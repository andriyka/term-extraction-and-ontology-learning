2012 19th International Symposium on Temporal Representation and Reasoning  A Metric Temporal Logic for Dealing with Zero-time Transitions Luca Ferrucci, Dino Mandrioli, Angelo Morzenti, Matteo Rossi Dipartimento di Elettronica e Informazione - Politecnico di Milano, 20133 Milano, Italy Email: {ferrucci,mandrioli,morzenti,rossi}@elet.polimi.it Abstract--Many industrial systems include components interacting with each other that evolve with possibly very different speeds.
To deal with this situation many formalisms adopt the abstraction of "zero-time transitions", which do not consume time.
These, however, have several drawbacks in terms of naturalness and logic consistency, as a system is modeled to be in different states at the same time.
We introduce a metric temporal logic, called X-TRIO, that uses non-standard analysis to elegantly deal with zero-time transitions in an abstract, descriptive way.
We study the decidability of the logic, and we introduce a decision procedure for a subset thereof.
XTRIO has been applied in companion works to the design and verification of industrial systems.
occurs in many practical cases, like in hardware devices where several gate-switches occur during a single clock period, or in heterogeneous control systems, where different components evolve at sharply different time granularities, say microseconds vs. seconds or minutes or even longer ones.
In such cases, the literature often proposes a sharp distinction between micro- and macro-steps.
Normally, only macro-steps are assumed to "consume time" -- often just one unit -- whereas micro-steps are considered as zerotime transitions.
Various operational formalisms, like Timed Petri nets or variants of the Statecharts notations adopt this assumption [3].
For such systems, however, the use of fixedduration next-time operator is inadequate.
In temporal logics that adopt a view of system state as a function of time such a notion of zero-time transition is however counterintuitive (when a zero-time micro-step is performed more than one state is associated with a single time instant), and may lead to logical contradiction.
Some temporal logics adopt instead a time structure where more than one system state may be associated with a single time instant [4] and therefore must provide distinct notations to refer to time and state change.
In these notations, the progress of time and state evolution are fully decoupled, which is rather unnatural in most practical cases.
In previous work [5], we proposed the adoption of NonStandard Analysis (NSA) to formalize micro-steps.
Intuitively, in NSA the domain of any variable is extended by introducing non-standard numbers, which, roughly speaking, include infinitesimal quantities: an infinitesimal number is strictly less than any positive standard one.
We exploited this idea by formalizing micro-steps in terms of transitions that take a non-null, infinitesimal time in the context of our metric temporal logic language TRIO.
In this paper, we develop the approach by defining a framework consisting of: a time domain T enriched with non-standard numbers; the TRIO temporal logic, providing a metric on time through the Dist(*, d) operator; a sequence s of instants in - the augmented version of - T , in which the modeled system changes state; a new next operator X to refer to the next system state, which occurs in a non-standard time instant in case of a micro-step, or in a standard one in case of an ordinary (macro-) step.
The overall framework is called X-TRIO: we provide its syntax and semantics, and prove that the logic is in  I. I NTRODUCTION In a traditional view of time-dependent systems the state is a function of time, i.e., the system is in exactly one state at each time instant.
Some (though not all) temporal logics also adopt this view: formulae refer to an (implicit) time instant, the (sub)formulae are evaluated with respect to the unique system state associated with it, and the logic's modal operators refer to other time instants and related states.
If the modeled system evolves by discrete computation steps then a correspondingly discrete underlying time structure is naturally adopted, and the next-time operator (and possibly, in addition, a previous-time operator) are provided, such as the X (respectively, Y) operators of Linear Temporal Logic.
The time domain, then consists of the set of the naturals or the integers ; the time taken by each computation step is uniform, and it corresponds to the adopted time unit, say, seconds or microseconds.
If a genuinely quantitative notion of time is adopted for modeling strict real-time features, or a need arises to characterize asynchronous behaviors, the underlying time domain may be dense or continuous, like the set of real numbers, and modal operators are provided such as Dist(*, d) of TRIO [1], or similar operators in MTL [2], to refer to the time point at a generic distance d from the current time.
Then, the next operator X, which adopts a fixed time displacement, becomes just an abbreviation for Dist(*, 1).
This assumption, however, becomes too simplistic if the various computational steps that move the system from one state to the next one take a variable amount of time to complete.
In some cases, the duration of some steps is orders of magnitude smaller than others so that, at some level of abstraction, it can be neglected entirely.
This situation  N  Z  1530-1311/12 $26.00 (c) 2012 IEEE DOI 10.1109/TIME.2012.22  81  general undecidable; we then define a decidable fragment that is expressive enough to model computing devices that are typically embedded in many industrial systems, such as Flexible Manufacturing Systems (FMS).
The decidability of this subset of X-TRIO is obtained through its encoding into the Propositional Linear Temporal Logic with Both future and past operators (PLTLB); from this encoding, we built a prototype verification tool using decision procedures based on bounded model-checking implemented in the Zot tool [6].
Two companion papers apply the X-TRIO language to formalize the semantics of the Stateflow notation used in many application fields, and to automatically analyze properties of critical system: [7] focuses on the modeling and analysis of single Stateflow components whereas [8] deals with the integration of several cooperating modules.
Notions of zero-time transitions appear very naturally when reasoning about computations of embedded systems.
For instance, in [9], while developing and analyzing a formal model of an aerospace satellite system, the authors repeatedly emphasize the need for "algorithmic detection of Zeno behavior".
An early approach in the field of temporal logics introduced a time structure suitable to support the notion of micro- and macro-steps [2].
Our approach, based on NSA, allows us to frame the problem in a general and elegant way, and provides means to equip the resulting logic with suitable verification mechanisms.
In the literature, other works have used NSA to provide a formal and rigorous semantics to timing features of various kinds of notations for system modeling: in [10] NSA is used to describe a hybrid system modeled in Simulink in presence of cascaded mode changes, while in [11] a complete system theory is defined, adopting a theoretical approach to investigate computability issues.
This paper is structured as follows.
Section II defines the syntax and semantics of X-TRIO.
Section III studies decidability issues, identifies a decidable fragment of the logic, and provides its encoding into PLTLB.
Section IV draws conclusions and hints at possible extensions of this work.
the current instant.
TRIO formulae can be interpreted both in discrete and dense time domains.
X-TRIO extends TRIO along two main lines.
First, the temporal domain T is augmented with infinitesimal numbers from the theory of non-standard analysis founded by A. Robinson [12], which has already been exploited in TRIO [5] to deal with time-critical systems.
Intuitively, for any numerical domain D, fi is infinitesimal in D if fi >= 0 and fi is smaller than any number in D>0 .
The original values of D are classified as standard and are characterized by predicate st, that is, x is standard iff st(x) holds.
D is augmented with infinitesimal numbers and all numbers resulting from adding and subtracting infinitesimal non-zero numbers to and from standard ones, respectively.
Predicate ns(x) denotes that x is non-standard.
For each x, st(x) holds if and only if ns(x) does not hold.
Notice that 0 is the only infinitesimal standard number and that non-standard numbers are of the form v +- fi, where st(v) holds, and fi is infinitesimal greater than 0.
NSA provides an axiomatization that allows one to apply all arithmetic operations and properties of traditional analysis in an intuitive way: for instance, the sum of two standard numbers is standard, the sum of two infinitesimal numbers is an infinitesimal and the sum of an infinitesimal with a standard number is a non-standard number.
The theory of NSA introduces, in addition to the notion of infinitesimal numbers and operations on them, the notion of infinite numbers (which are, intuitively, greater than any value in D), plus a rich set of results that make NSA an appealing framework for reasoning on both familiar and new objects.
In this paper we exploit some of the terminology and concepts of NSA to provide an elegant characterization of zero-time steps, but we do not make use of the full power of the theory; for example, we do not deal with infinite numbers (i.e., we have that ns(x) iff x = v +- fi, with st(v) and fi infinitesimal), as they are of no use when modeling zero-time steps.
We assume as the original time domain D either N or R>=0 and denote its extension with infinitesimal numbers as T .
T is a totally ordered set of numbers.
The second major novelty of X-TRIO is the introduction of the next operator X which is typical to describe the evolution of dynamical systems as a sequence of discrete steps.
Unlike the traditional use of the operator in a metric setting, however, the time distance between two consecutive states is not implicitly assumed as a time unit; on the contrary, it can be any standard or non-standard positive number.
Precisely, we introduce two different types of X operator, namely, Xst and Xns .
Intuitively, the formula Xst (ph) is true in the current instant iff ph is true in the next state entered by the system and this occurs at a time instant that is a standard number; conversely, formula Xns (ph) is true iff, in the next state, ph is true and the occurrence time is a non-standard number.
We will use these two operators to distinguish between two typical ways of  II.
T HE X-TRIO LOGIC In this section, we first introduce some necessary background, then we define the syntax and semantics of X-TRIO.
A. Syntax The original TRIO language [1] is a general-purpose specification language suitable for modeling real-time systems.
It is a temporal logic supporting a metric on time.
TRIO formulae are built out of the usual first-order connectives, operators, and quantifiers, and the single basic modal operator Dist: for any formula ph and term t indicating a time distance, formula Dist(ph, t) specifies that ph holds at a time instant whose distance is exactly t time units from  82  OPERATOR  DEFINITION  AlwF(ph) SomF(ph)  [?
]t(t >= 0 - Dist(ph, t)) [?
]t(t >= 0 [?]
Dist(ph, t)) [?
]t >= 0(Dist(ps, t) [?]
[?
]v(0 <= v < t - Dist(ph, v))) [?
]t >= 0(Dist(ps, -t) [?]
[?
]v(-t < v <= 0 - Dist(ph, v)))  Until(ph, ps) Since(ph, ps)  S, t  S, t  S, t  S, t  S, t  S, t  S, t  S, t   Table I X-TRIO DERIVED TEMPORAL OPERATORS .
S, t  S, t   modeling system evolution: Xst will formalize macro-steps i.e., transitions that "consume real, tangible time", whereas Xns will describe micro-steps, which are often formalized as zero-time transitions.
Yesterday operators Yst and Yns are introduced in a similar manner.
The syntax of X-TRIO is defined as follows: ph  :=  t  :=  N N N N  Table II S EMANTICS OF X-TRIO.
III.
D ECIDABILITY OF X-TRIO  p | !ph | ph1 [?]
ph2 | Dist(ph, k) | Xst (ph) | Xns (ph) | Yst (ph) | Yns (ph) | [?
]t.t ph | Dist(ph, t) | t = k | t < k | t1 [?]
t2 | !t  Let us consider the following syntactic fragment of XTRIO, which we name X-TRION : ph :=  In this paper, we restrict the set of atomic propositions AP to propositional variables p, and the set V of temporal terms to variables t and constants k. Temporal terms t take values in the time domain T and can appear only in closed formulae.
We leave first-order extensions of the logic to future work.
Symbols , [?
], [?
], -, [?
], etc.
are derived as usual.
We introduce the derived operators of X-TRIO as in TRIO; Table I shows those used in this paper.
p | !ph | ph1 [?]
ph2 | Dist(ph, 1) | Dist(ph, fi) | Dist(ph, -1) | Dist(ph, -fi) | Until(ph1 , ph2 ) | Since(ph1 , ph2 ) | Xst (ph) | Xns (ph) | Yst (ph) | Yns (ph)  As the name suggests, we interpret X-TRION formulae over the non-standard temporal domain .
In X-TRION , Dist(ph, 1 + fi) is an abbreviation for Dist(Dist(ph, fi) , 1); similarly for Dist(ph, 1 - fi).
The Until and Since operators are now primitive, and we have the following abbreviations: SomF(ph) = Until(, ph) and AlwF(ph) = !SomF(!ph).
Notice that, as the syntax of X-TRION does not allow variables, its temporal structures become triples of the form S =  T , b, s.
We also restrict the interpretation domain of the form v + kfi, where v, k [?]
to the numbers of and fi is an infinitesimal number.
Thus, standard numbers are identified by the coefficient k = 0.
We indicate this domain by + .
In addition, since by definition for all k [?]
, v + kfi < v + 1 - kfi, due to the restriction above we have v - kfi [?]
/ + for all k. Hence, for all ph, Dist(ph, -fi) is false in all standard instants t (i.e., such that st(t)).
Despite the restrictions introduced in X-TRION , however, the logic is undecidable, and the following holds.
N  B.
Semantics A model-theoretic semantics for X-TRIO is defined by following a fairly standard path on the basis of a temporal structure S =  T , b, n, s, where: (i) T is the time domain such that [?
]t [?]
T it is t >= 0.
(ii) b : T -- 2AP is an interpretation function that associates each instant of time t with the set of atomic propositions b(t) that are true in t. (iii) n : V -- T is an evaluation function that associates with each temporal term of the set V a value in T .
(iv) s = {si |i [?]
: si [?]
T [?]
s0 = 0 [?]
[?
]j [?]
(j < i = sj < si ) [?]
[?
]t [?]
T (si < t < si+1 = b(si ) = b(t))} is the distinguishing element of the X-TRIO temporal structure.
It is a (possibly infinite) sequence of time instants starting from the initial instant 0, called History.
Intuitively, it represents the discrete sequence of instants when the system changes state.
Thus, the X operator represents a step moving from si to si+1 .
Then, the satisfaction relation  of an X-TRIO formula ph by structure S =  T , b, n, s at a time instant t [?]
T is defined as in Table II.
A formula ph is satisfiable in a structure S =  T , b, n, s when S, 0  ph.
In the rest of this paper, we study some relevant properties of the X-TRIO logic, with focus on the case T = .
N  p iff p [?]
b(t) !ph iff S, t  ph ph1 [?]
ph2 iff S, t  ph1 and S, t  ph2 Dist(ph, k) iff t + n(k) [?]
T and S, t + n(k)  ph Dist(ph, d) iff t + n(d) [?]
T and S, t + n(d)  ph Xst (ph) iff there is i [?]
s.t.
si <= t < si+1 , st(si+1 ) and S, si+1  ph Xns (ph) iff there is i [?]
s.t.
si <= t < si+1 , ns(si+1 ) and S, si+1  ph Yst (ph) iff there is i [?]
s.t.
si-1 < t <= si , i > 0, st(si-1 ) and S, si-1  ph Yns (ph) iff there is i [?]
s.t.
si-1 < t <= si , i > 0, ns(si-1 ) and S, si-1  ph [?
]d.ph iff for all n  that differ from n at most for d, 	T , b, n  , s , t  ph  N  N N  N  N  N  Theorem 1.
The satisfiability problem of the X-TRION logic is undecidable.
Proof sketch.
: In classic fashion (see, e.g., [13]), we reduce the halting problem of a 2-counter machine to the satisfiability problem of X-TRION formulae, by defining a set of X-TRION formulae that formalize the increment and decrement of the 2 counters.
We associate one counter with the sequence of even standard numbers, and one with the sequence of odd standard  N  83  (v + 1) + (k + 1)fi, whose infinitesimal distance from v + 1 increases of fi w.r.t to the distance of v + kfi from v. This generality, however, is unnecessary for interesting classes of applications such as those tackled in [7], [8], for which we do not need the full expressive power of X-TRION .
In the next section, we investigate a sufficient condition that allows us to build a decision procedure for a subset of the logic that can be used in many relevant practical applications.
The study of other sufficient conditions is left for future work.
numbers, as detailed below.
We associate two propositional letters, E and O, with each standard instant of s so that when the current standard instant is even (resp., odd) then only E (resp., O) holds.
They do not hold in non-standard instants.
These constraints are represented by the following X-TRION formulae (we show the case of even instants): E= E=  Xst (O) [?]
Xns (Until(!O [?]
!E, Xst (O) [?]
!O [?]
!E)) Dist(O, 1)  A.
A decision procedure for X-TRIO  Given two consecutive standard instants sj and si in s (i.e., such that si = sj + 1), there is a finite (possibly empty) sequence s[j,i) of length i - (j + 1) of non-standard instants in s between them since s is discrete.
We introduce X-TRION formulae (not shown here for brevity) to partition s[j,i) into two subsequences such that, at each instant, either propositional letter A or propositional letter B) holds.
We use letters A and B to "mark" each instant in s[j,i) as shown in Figure 1.
The sequence of B's ends in the last non-standard instant of s[j,i) .
In this section, we show the decidability of a fragment of X-TRION by reducing its satisfiability problem to that of PLTLB.
The transformation is effective and has been implemented in the Zot satisfiability checker.
PLTLB extends classic LTL [14] with past operators; its syntax (as used in the rest of this paper) is the following: ph := p| !ph | ph1 [?]
ph2 | XL (ph) | YL (ph) | ph1 UL ph2 | ph1 SL ph2 We have also the usual abbreviations FL (ph) =  UL ph and GL (ph) = !FL (!ph).
The semantics of PLTLB is defined over discrete traces.
A trace is an infinite word p = p(0)p(1) .
.
.
over the finite alphabet S = 2AP , where each p(i) represents the set of atomic propositions that are true in i.
L denotes the satisfiability relation of PLTLB.
The definition of L is straightforward if one considers that, for any ph, YL (ph) is false at 0 [14].
As a first step to encode X-TRION into PLTLB, we restrict histories s according to the following constraints: 1) Either all standard natural numbers or a bounded interval thereof including 0 belong to s. 2) If si+1 is non-standard (ns(si+1 )), then si+1 -si = fi.
These constraints are not strictly necessary to obtain decidability, but they are not overly restrictive and they simplify the encoding for our purposes.
Notice also that, if si+1 is standard (st(si+1 )), then between si and si+1 there is an infinite sequence of nonstandard numbers si + fi, si + 2fi, .
.
.
such that, for all k [?]
N, b(si + kfi) = b(si ).
In order to reduce the satisfiability problem of X-TRION (which is in general undecidable) to that of PLTLB (which is decidable), we need to apply further restrictions to the former.
As mentioned above, the key to encoding a counting mechanism in X-TRION is to evaluate operator Dist(*, v + kfi) (with v >= 1) in non-standard instants.
This suggests, to obtain decidability, to make the evaluation of this operator meaningful only in standard instants.
For this, we introduce an X-TRION predicate, NowST, that evaluates to true only in standard instants.
Such a predicate corresponds to the following X-TRION formula:  O E O E A A A B B B B B A A B B A B t  t+e t+2e ...
Figure 1.  t+1  t+2  t+3  Part of trace representing counters.
We use the sequence of A and B to represent the two counters: the numbers of A's starting from standard numbers marked with E (resp.
O) represent the first (resp.
second) counter.
We encode the operations increase/decrease/check if 0, by manipulating the length of the sequence of A's.
For example, the counter associated with E increases its current value if the sequence of A's that starts at the next even standard instant is such that the last A of that sequence dists 2 + fi from the last A of the current sequence of A's.
This is encoded through the following X-TRION formula, reminding that all the naturals numbers belong to the temporal domain: E-  (A - Until(A, B [?]
Dist(A [?]
Xns (B) , 2)))[?]
(B - Dist(A [?]
Xns (B) , 2))  The other cases are omitted for brevity.
The counter is zero when the sequence of A's is empty.
In the case of the counter associated with even standard numbers we can encode this check with the formula E [?]
B.
Finally, at the initial instant of the sequence s, which is an even number, E holds and the corresponding counter value is 0 (i.e., E [?]
B holds at 0).
The halting of the formalized machine is expressed simply as reachability of a final state.
Hence, we conclude that the satisfiability problem of X-TRION is undecidable.
The counting mechanism can be simulated by X-TRION thanks to the Dist(*, 1 + fi) operator, which allows us to move from a non-standard instant v +kfi to the non-standard  NowST [?]
!Dist(, -fi)  (1)  In fact, Dist(, -fi) holds in t [?]
N+ iff t - fi [?]
/ which is true iff st(t).
Then, every occurrence of  N+ , 84  Dist(ph, v + kfi), with v >= 1, will be intended as an abbreviation for Dist(ph, v + kfi) [?]
NowST.
Hence, by convention Dist(ph, v + kfi) is false in all non-standard instants if v >= 1.
In addition, we introduce a further restriction that allows us to obtain a quite simple decision procedure for the logic, with a rather limited cost in expressiveness, as discussed below.
The restriction consists of imposing that the value of formulae is meaningful only in instants that are "covered" by the history s. In fact, by definition of s in Section II-B, there can be instants t [?]
T such that, for all i, si < t. In this case, s shows a classic "Zeno behavior" [3], where it accumulates at a finite instant, signaling a model that changes state infinitely often in a finite interval.
Then, by convention, we state that formulae that are evaluated after one such accumulation point are false.
This can be achieved by considering every subformula ps of an X-TRION formula ph as an abbreviation for ps [?]
SomF(Xst () [?]
Xns ()).
We have the following result.
there is an instant t such that the subformulae of ph have the same value in all t [?]
[t, si+1 ).
In addition, t is a number of non-standard instants that is equal to the maximum nesting depth d of Dist(*, -fi) operators far from si .
More precisely, given a formula ph, the nesting d(ph) of Dist(*, -fi) operators is defined as follows: d(p) = 0; d(ps1 [?]
ps2 ) = max(d(ps1 ), d(ps2 )), and similarly for the Until and Since operators; d(!ps) = d(ps) (similarly for Dist(ps, +-1) and for Dist(ps, fi)); finally, d(Dist(ps, -fi)) = 1 + d(ps).
Then, we have the following result.
Lemma 3.
Given an X-TRION formula ph and a structure S =   + , b, s, if st(si+1 ), then for any two instants j, k [?]
+ such that si + d(ph)fi < j < k < si+1 , S, j  ph iff S, k  ph.
N  Proof: First of all, we notice that it must be ns(j) and ns(k), as, by constraint 1, si >= si+1 - 1.
Then, the proof proceeds by induction on the structure of ph.
If ph = p [?]
AP , then p [?]
b(j) iff p [?]
b(k), as b(j) = b(k) by definition of s, hence the result.
If ph = !ps, S, j |= ph iff S, j |= ps, which holds iff S, k |= ps by inductive hypothesis, as d(ph) = d(ps), i.e., iff S, k |= ph.
The case for Dist(ps, fi) is similar.
If ph = ps1 [?]
ps2 , S, j |= ph iff both S, j |= ps1 and S, j |= ps2 , which, by inductive hypothesis, holds iff both S, k |= ps1 and S, k |= ps2 , as d(ph) >= d(ps1 ) and d(ph) >= d(ps2 ).
If ph = Dist(ps, 1), then both S, j  ph and S, k  ph, as Dist(ps, 1) is by convention false in non-standard instants.
Similarly when ph = Dist(ps, -1).
If ph = Until(ps1 , ps2 ), we have that S, k  ph iff there is a t >= k s.t.
S, t  ps2 , and for all k <= t < t it is S, t  ps1 .
By inductive hypothesis, since d(ph) >= d(ps1 ), for all t , t s.t.
j <= t < k <= t < si+1 , we have that S, t  ps1 iff S, t  ps1 .
Hence, S, t  ps1 holds for all k <= t < t iff also for all j <= t < t it is S, t  ps1 .
Then, S, k  ph iff S, j  ph.
The case ph = Since(ps1 , ps2 ) is similar.
If ph = Xst (ps), S, j  ph iff S, si+1  ps, as st(si+1 ).
We have also S, k  ph iff S, si+1  ps, hence the result.
If ph = Xns (ps), both S, j  ph and S, k  ph, as st(si+1 ).
If ph = Yst (ps), both S, j  ph and S, k  ph hold iff st(si ) and S, si  ps.
Similarly for the case ph = Yns (ps).
If ph = Dist(ps, -fi), S, j |= ph iff S, j - fi |= ps; since j - fi > si + (d(ph) - 1)fi and d(ph) = d(ps) + 1, then k - fi > j - fi > si + d(ps)fi hence, by inductive hypothesis, we have S, k - fi |= ps, i.e., S, k |= ph.
Notice that Lemma 3 does not hold if j = si + d(ph)fi.
For example, if j = s0 = 0, s1 = 1, and p [?]
b(s0 ), with d(ph) = 0, then Yst (p) holds in k = s0 + fi, but not in j.  Lemma 2.
Given an X-TRION formula ph in which all subformulae have the form ps [?]
SomF(Xst () [?]
Xns ()), and given two structures S1 =   + , b1 , s, S2 =   + , b2 , s (i.e., which have the same history s) such that, for all such that t < si , it is t [?]
+ for which there is i [?]
b1 (t) = b2 (t), then S1 , 0 |= ph iff S2 , 0 |= ph.
N  N  N  N  Proof sketch.
: We show a stronger result, from which Lemma 2 descends as corollary.
More precisely, we show that, given any t [?]
+ , S1 , t |= ph iff S2 , t |= ph.
First of all, we remark that, if for each t [?]
+ there is a si such that t < si , then for all t [?]
+ it is b1 (t) = b2 (t), hence the desired result.
In addition, notice that, in this case, condition SomF(Xst () [?]
Xns ()) is true for all t [?]
+ , so the value of ph does not depend on it.
In the rest of the proof, we consider the case in which there are instants t such that, for all i, si < t. The set of such instants can be shown to have a minimum, which we indicate with t, such that st(t).
Then, history s accumulates at t, and we separate two cases: t < t and t >= t. In the case t >= t, SomF(Xst () [?]
Xns ()) is false, hence for all ph both S1 , t |= ph and S2 , t |= ph.
Then, we only need to consider the case t < t. The rest of the proof is by induction on the structure of ph: consider a subformula ps of ph.
If ps = p, by hypothesis b1 (t) = b2 (t); hence the result.
If ps = Dist(z, 1), then S1 , t |= ps iff S1 , t + 1 |= z, hence, by inductive hypothesis, iff S2 , t + 1 |= z, and iff S2 , t |= ps.
All other cases are similar and are omitted for brevity.
As a consequence of Lemma 2, and also of the next lemma 3, given the restrictions introduced above, in order to determine whether an X-TRION formula is satisfiable we only need to focus on the sequence s, and we can disregard the instants following an accumulation point, if any.
In order to introduce our PLTLB-based decision procedure for X-TRION , we need a further intermediate result.
We show that, in each interval (si , si+1 ) such that st(si+1 ),  N  N  N  N  N  The basic idea of the encoding is, given an X-TRION formula ph, to build a corresponding PLTLB formula t (ph) such that each model S =   + , b, s of ph corresponds to a trace p that is a model of t (ph), where each t [?]
+ such that there is si > t is mapped onto an element p(rS (t)),  N  85  N  s  s0  s1  s2  s3  0  e  2e  3e  sp nsp nsp  ep  0  3  t (p) = p  s4  1  1+e ...    fp  sp  nsp  4  5  6  4e  ...  t (!ph) = !t (ph) t (ph1 [?]
ph2 ) = t (ph1 ) [?]
t (ph2 )  rS p  1  Figure 2.
2  t (Xns (ph)) = XL (nsp [?]
t (ph)) t (Xst (ph)) = XL ((ep [?]
fp ) UL (sp [?]
t (ph))) t (Yns (ph)) = YL ((ep [?]
fp ) SL (nsp [?]
t (ph))) t (Yst (ph)) = YL ((ep [?]
fp ) SL (sp [?]
t (ph)))  ...   An example of rS (with d(ph) = 1).
N  t (Dist(ph, 0)) = t (ph) t (Dist(ph, )) = (!fp [?]
XL (t (ph))) [?]
(fp [?]
t (ph)) t (Dist(ph, -)) = !sp [?]
((!fp [?]
YL (t (ph))) [?]
(fp [?]
t (ph)))  N  and b(t) = p(rS (t)), where rS : + - is monotonic.
Then, we represent the transition si -- si+1 through the PLTLB operator XL .
Constraints 1 and 2 guarantee that the difference between si+1 and si = v + kfi is either 1 - kfi or fi, depending on whether si+1 is standard or not.
The encoding "flattens" the history s over p: it represents each si through an element of p. Then, to separate the elements of p that represent standard instants from those that represent non-standard ones, we introduce a PLTLB propositional letter sp such that sp [?]
p(i) iff i in p corresponds to a standard number.
In addition, we need to introduce "filling" elements in p to represent the (infinite) non-standard instants between si and si+1 when st(si+1 ).
Lemma 3 suggests that the required number of these elements is finite, equal to d(ph) + 1; in fact, all non-standard instants such that si + d(ph) < t < si+1 are equivalent from the point of view of the truth of subformulae, hence they can be "condensed" in one single element.
We mark the first d(ph) elements of p following the one corresponding to si with proposition ep , and the element corresponding to all instants si + d(ph) < t < si+1 with fp .
Figure 2 depicts an example of history s, and its corresponding trace p. Then, trace p must obey the following PLTLB constraint, where nsp is an abbreviation for !sp [?]
!fp [?]
!ep : sp [?]
GL ((ep - !fp [?]
!sp ) [?]
(fp - !sp ) [?]
(sp - fifi   d(ph) k XL (ep )[?]
k=1 XL nsp UL d(ph)+1 XL (fp [?]
XL (sp )) [?]
XL (GL (ns p ))) [?]
(ep [?]
fp - p[?
]AP p - YL (p)))  t (Dist(ph, 1)) = sp [?]
XL (!sp UL (sp [?]
t (ph))) t (Dist(ph, -1)) = sp [?]
YL (!sp SL (sp [?]
t (ph))) t (Until(ph, ps)) = t (ph) UL t (ps) t (Since(ph, ps)) = t (ph) SL (fp [?]
t (ph) [?]
t (ps)) [?]
t (ph) SL (!fp [?]
t (ps)) Table III T RANSLATION SCHEMA t .
N  N N  Given a structure S =   + , b, s, for all t [?]
+ such that there is si > t, we define function rS : + - as follows(see Figure 2 for a graphical representation): (i) rS (0) = 0 (s0 = 0); (ii) if ns(t), and [?
]i s.t.
t = si (hence t = si-1 + fi), then rS (t) = rS (si-1 ) + 1; (iii) if ns(t), and [?
]i s.t.
si + d(ph)fi < t < si+1 (hence st(si+1 )), then rS (t) = rS (si ) + d(ph) + 1; (iv) if t > 0 and st(t) (hence there is i > 0 s.t.
t = si ), then rS (t) = rS (si-1 )+d(ph)+2; (v) if ns(t), and [?
]i s.t.
si < t <= si + d(ph)fi < si+1 , then there is k s.t.
t = si + kfi, and rS (t) = rS (si ) + k; Notice that rule (iii) is applied to all nonstandard instants in between si +d(ph)fi and si+1 , and it maps each of them onto a "filling" element in p. As a consequence, rule (iv) maps a standard instant onto rS (si-1 ) + d(ph) + 2, i.e., to the element in p that follows a "filling" one.
Then, if t < t , we have rS (t) <= rS (t ).
The following result holds.
(2)  N  Theorem 4.
Given an X-TRION formula ph, there is a structure S =   + , b, s such that S, 0  ph iff there exists a trace p such that p L t (ph) [?]
(2).
N  N  PLTLB formula (2) imposes, respectively, that (i) sp holds in p(0), (ii) ep , fp and sp are mutually exclusive, (iii) each element marked sp is followed either by an infinity of nsp elements or by a finite number of nsp elements, until there is a sequence of exactly d(ph) ep elements followed, in turn, by a fp element, which is in turn followed by a sp element, (iv) if ep or fp [?]
p(i + 1), then all propositions that hold in p(i + 1) also hold in p(i).
In other words, traces p have d(ph) one of the following two forms: sp (ns*p ep fp sp )o or * d(ph) * o sp (nsp ep fp sp ) (nsp ) .
Transformation t of Table III takes an X-TRION formula ph and produces an equisatisfiable PLTLB formula phL .
Proof: Suppose we have a structure S =   + , b, s.
The corresponding infinite word p is built from S as follows (where AP are the atomic propositions in ph): for each p [?]
AP and t [?]
+ such that there is si > t (hence rS (t) is defined), p [?]
b(t) iff p [?]
p(rS (t)).
In addition, sp [?]
p(rS (t)) iff st(t), fp [?]
p(rS (t)) iff there i s.t.
si + d(ph) < t < si+1 and st(si+1 ), and ep [?]
rS (t) iff si < t <= si + d(ph) < si+1 .
It can be shown that trace p built in this way satisfies formula (2).
Dually, if p is such that p L te (ph) [?]
(2), structure S =   + , b, s is obtained in the following way.
Given an l [?]
, / p(l) (i.e., l is not a "filling" element),  l0 .
.
.
lv  if ep , fp [?]
N  N  86  N  N  (where [?
]j [?]
[0, v), we have lj < lj+1 ) are all the elements of the infinite word p such that lv <= l and [?
]j [?]
[0, v] : sp [?]
p(lj ) (i.e., they are all the elements that correspond to standard instants in p preceding element l), and k = l - lv (i.e., k is the number of elements between p(l) and p(lv )), then sl = v + kfi.
This entails that, since sl is a standard number iff it is of the form v + 0fi, we have that st(sl ) iff sp [?]
p(l).
In addition, by (2), sp [?]
p(0), hence s0 = 0 as expected.
This defines the points of the history s of S, which in turn defines rS .
b is defined as follows: for each t such that there is si > t, for each p [?]
AP , p [?]
b(t) iff p [?]
p(rS (t)).
If, instead, there is no si > t, we can chose the value of b(t) arbitrarily, as, by Lemma 2, it does not affect the truth of ph in S; then, in this case we have p[?]
/ b(t) for all p [?]
AP .
We prove Theorem 4 by induction on the structure of formula ph.
First of all, by Lemma 2, if there is an accumulation point t, instants t >= t do not affect the satisfiability of ph, hence we need only analyze instants t < t. Then, we show that, for all t < t (where t = +[?]
if there is no accumulation point), it is S, t |= ps (where ps is a subformula of ph) iff p, rS (t)L t (ps).
If ps = p, then S, t |= p iff p [?]
b(t), which holds, by construction, iff p [?]
p(rS (t)), i.e.
iff p, rS (t)L p, and t (p) = p, hence the result.
The cases ps = !z and ps = ps1 [?]
ps2 are immediate.
If ps = Xns (z), S, t |= ps iff si <= t < si+1 , ns(si+1 ) and S, si+1 |= z; by inductive hypothesis this holds / iff p, rS (si+1 )L t (z), and by construction sp , fp , ep [?]
p(rS (si+1 )), hence p, rS (si+1 ) - 1L XL (t (z) [?]
nsp ), and by construction rS (t) + 1 = rS (si+1 ), since it must be t = si , because si+1 = si + fi.
If ps = Xst (z), S, t |= ps iff si <= t < si+1 , st(si+1 ) and S, si+1 |= z; by inductive hypothesis this holds iff p, rS (si+1 )L t (z), and by construction sp [?]
p(rS (si+1 )), hence p, rS (si+1 )L t (z) [?]
sp .
It is either si < t, or si = t. If si < t, fp [?]
p(rS (t)) or ep [?]
p(rS (t)) and rS (si+1 ) >= rS (t) + 1.
If si = t, fp , ep [?]
/ p(rS (t)), and rS (si+1 ) = rS (t) + d(ph) + 2.
In both cases for all rS (t) < l < rS (si+1 ) it is fp [?]
p(rS (t)) or ep [?]
p(rS (t)), hence p, rS (t)L XL ((fp [?]
ep ) UL (sp [?]
t (z))), i.e., p, rS (t)L t (ps).
The cases for the Yns and Yst operators are similar.
Dist(ps, 0) is equivalent to ps, hence this case is trivial.
If ps = Dist(z, fi), S, t |= ps iff S, t + fi |= z, which, by inductive hypothesis, holds iff p, rS (t + fi)L t (z).
We have two cases: si <= t <= d(ph) < si+1 and si + d(ph) < / rS (t), t < si+1 (hence st(si+1 )).
In the first case, fp [?]
rS (t + fi) = rS (t) + 1, hence p, rS (t)L !fp [?]
XL (t (z)).
In the second case, fp [?]
rS (t), and by Lemma 3 S, t + fi |= z iff S, t |= z, which in turn holds iff p, rS (t)L t (z), hence p, rS (t)L fp [?]
t (z).
All in all, p, rS (t)L !fp [?]
XL (!sp [?]
t (z)) [?]
fp [?]
t (z), i.e., p, rS (t)L t (ps).
The case ps = Dist(z, -fi) is similar to the previous  one, with the addition that S, t |= ps only if t - fi [?]
+ (i.e., ns(t)) which, by inductive hypothesis, holds iff sp [?]
/ p(rS (t)), i.e., p, rS (t)L !sp .
If ps = Dist(z, 1), S, t |= ps iff st(t), t + 1 < t, and S, t + 1 |= z.
It is st(t) iff sp [?]
p(rS (t)).
Also, t + 1 < t holds iff there is si > t + 1, i.e., iff rS (t + 1) is defined, and sp [?]
p(rS (t + 1)).
In addition, when rS (t + 1) is defined, S, t+1 |= z iff p, rS (t+1)L t (z), by inductive hypothesis.
As rS (t + 1) > rS (t), and there are no standard instants in between, then p, rS (t)L sp [?]
XL (!sp UL (sp [?]
t (z))), i.e., p, rS (t)L t (ps).
The case ps = Dist(z, -1) is similar.
If ps = Since(ps1 , ps2 ), then S, t |= ps iff there is 0 <= t <= t s.t.
S, t |= ps2 and for all t < t <= t it is S, t |= ps1 .
By inductive hypothesis we have p, rS (t )L t (ps2 ).
We have two cases: si <= t <= si + d(ph) < si+1 for some i, or si + d(ph) < t < si+1 .
In the former case, then for all t < t <= t it is also rS (t ) < rS (t ) <= rS (t), hence, by inductive hypothesis, for all rS (t ) < rS (t ) <= rS (t) it is p, rS (t )L t (ps1 ), hence p, rS (t)L t (ps1 ) SL t (ps2 ).
In the latter case, instead, there are some t < t < si+1 hence, by Lemma 3, S, t |= ps1 , and also rS (t ) = rS (t ) and fp [?]
p(rS (t )).
Then, by inductive hypothesis, we have p, rS (t )L t (ps2 ) and for all rS (t ) <= rS (t ) <= rS (t) it is p, rS (t )L t (ps1 ).
Then, p, rS (t)L t (ps1 ) SL (fp [?]
t (ps1 ) [?]
t (ps2 )).
Overall, p, rS (t)L t (ps1 ) SL t (ps2 )[?
]t (ps1 ) SL (fp [?]
t (ps1 )[?
]t (ps2 )), i.e., p, rS (t)L t (ps).
The case for the Until operator is similar.
Remark 5.
As mentioned above, Lemma 3 does not hold if we relax the condition on j and allow it to be j = si +d(ph).
However, if we allow si + d(ph) <= j < k < si+1 , the only cases where the proof fails are those for Yns , Yst , and Dist(*, 1) (when st(si ) and d(ph) = 0).
This suggests that, if ph does not include instances of operator Dist(*, -fi) (in which case d(ph) = 0, and, by constraint (2), no elements marked with ep appear in p), nor instances of the Yns and Yst operators, the encoding can be simplified.
In fact, in this case we can use the following modified encoding tf (we only show the cases that differ from t ): tf (Xns (ph)) = XL (tf (ph) [?]
!sp ) tf (Xst (ph)) = XL (sp [?]
tf (ph)) [?]
(fp [?]
XL (tf (ph))) tf (Dist(ph, fi)) = XL (!sp [?]
tf (ph)) [?]
(XL (sp ) [?]
tf (ph)) tf (Since(ph, ps)) = tf (ph) SL (XL (!sp ) [?]
tf (ps)) [?]
tf (ph) SL (XL (sp ) [?]
tf (ph) [?]
tf (ps)) Also, constraint (2) is replaced by the following formula:  sp [?
]GL  (sp - XL (fp [?]
!sp )) [?]
(f p - (YL (sp ) [?]
!sp [?]
XL (sp ))) [?]
(fp - p[?
]AP p - YL (p))  fi  As it happens with other logic formalisms, past operators allow users to obtain more succinct and intuitive formulae, paying a little price in terms of computational complexity.
87  Finally, from translation schema t and Theorem 4 we can prove the following.
say, module A must reach a stable state after a sequence of micro-steps always before module B does.
Acknowledgments.
: Work supported by the European Commission, Programme IDEAS-ERC, Project 227977SMScom.
We thank the anonymous reviewers for their comments.
Theorem 6.
The satisfiability problem of the fragment of X-TRION defined above is PSPACE-complete.
Proof: First of all, we remark that the satisfiability problem of PLTLB is PSPACE-complete [14].
Then, to show the PSPACE-hardness of the satisfiability problem for X-TRION we reduce the satisfiability problem of PLTLB to that of X-TRION .
To achieve this, given a PLTLB formula phL , we can build a corresponding X-TRION formula simply by applying the following transformation: UL - Until, SL - Since, XL - Dist(*, 1), YL - Dist(*, -1), and by including the constraint AlwF(!Xns ()).
To show the PSPACE-completeness, it is enough to note that, given an X-TRION formula ph, transformation t produces an equisatisfiable PLTLB formula phL , whose size is polynomial in the size of ph.
R EFERENCES [1] C. Ciapessoni, P. Mirandola, A. Coen-Porisini, D. Mandrioli, and A. Morzenti, "From formal models to formally-based methods: an industrial experience," ACM TOSEM, vol.
8, no.
1, pp.
79-113, 1999.
[2] R. Koymans, "Specifying real-time properties with metric temporal logic," Real-Time Systems, vol.
2, no.
4, pp.
255- 299, 1990.
[3] C. A. Furia, D. Mandrioli, A. Morzenti, and M. Rossi, "Modeling time in computing: a taxonomy and a comparative survey," ACM CSUR, vol.
42, no.
2, pp.
6:1-59, 2010.
IV.
C ONCLUSIONS AND F UTURE W ORK  [4] J. S. Ostroff, Temporal Logic for Real Time Sytems, ser.
Adv.
Soft.
Dev.
Series.
John Wiley & Sons, 1989.
We presented a novel approach to model and analyze systems evolving through discrete steps in a generic time domain, which can be either discrete or continuous; these steps may have quite different durations, up to the point that some are negligible w.r.t.
others.
The language supporting our approach, X-TRIO, extends the TRIO metric temporal logic with non-standard numbers and the next-state operator X.
It can be used to model many types of heterogeneous real-time systems, and to give formal semantics to many informal or semiformal notations widely adopted in the practice of industrial applications, as done for Stateflow and FMS [7], [8].
The approach could also be applied to other logic languages for real-time systems such as MTL [2].
In its full generality X-TRIO is undecidable.
In this context, however, we are motivated by the need to offer users fully automated "push-button" analysis tools.
We obtained such a goal by suitable restrictions in the syntax of the language and by encoding the resulting subset into the "kernel PLTLB" supported by the Zot tool (zot.googlecode.com).
Theorem 1 provides a basic hint on where the obstacles to achieve decidability abide, and it also suggests a few guidelines to find new sufficient conditions that lead to other, possibly more general, decidable versions of the basic language X-TRIO.
This is the direction of our ongoing research.
For instance, we are interested in macro- and micro-steps with time durations not fixed a priori.
In particular, the assumption that every micro-step takes exactly a constant infinitesimal value fi is adequate for applications such as those examined so far where the effects of many micro-steps become visible only at the beginning and end of macro-steps, but a finer view could become necessary when, e.g., synchronizing several components whose micro-steps have incommensurable durations but still have to guarantee some critical properties,  [5] A. Gargantini, D. Mandrioli, and A. Morzenti, "Dealing with zero-time transitions in axiom systems," Information and Computation, vol.
150, no.
2, pp.
119-131, 1999.
[6] M. Pradella, A. Morzenti, and P. San Pietro, "Refining real-time system specifications through bounded model- and satisfiability-checking," in Proc.
of ASE, 2008, pp.
119-127.
[7] L. Ferrucci, D. Mandrioli, A. Morzenti, and M. Rossi, "Nonnull infinitesimal micro-steps: a metric temporal logic approach," Online at http://arxiv.org/abs/1206.0911, 2012.
[8] ----, "Modular automated verification of flexible manufacturing systems with metric temporal logic and non-standard analysis," in Proc.
of FMICS, 2012, to appear.
[9] M.-A.
Esteve, J.-P. Katoen, V. Y. Nguyen, B. Postma, and Y. Yushtein, "Formal correctness, safety, dependability, and performance analysis of a satellite," in Proc.
of ICSE, 2012, pp.
1022-1031.
[10] A. Benveniste, T. Bourke, B. Caillaud, and M. Pouzet, "Nonstandard semantics of hybrid systems modelers," J. of Comp.
and Sys.
Sci., vol.
78, no.
3, pp.
877 - 910, 2012.
[11] S. Bliudze and D. Krob, "Modelling of complex systems: Systems as dataflow machines," F.
Inf., vol.
91, pp.
251-274, 2009.
[12] A. Robinson, Non-standard analysis.
Press, 1996.
Princeton University  [13] R. Alur and T. A. Henzinger, "A really temporal logic," Journal of the ACM, vol.
41, pp.
181 - 203, 1994.
[14] P. Schnoebelen, "The complexity of temporal logic model checking," in Adv.
in Modal Logic, 2002, pp.
393-436.
88