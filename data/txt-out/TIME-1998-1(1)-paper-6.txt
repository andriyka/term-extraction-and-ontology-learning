Linkoping Electronic Articles in Computer and Information Science Vol.
2(1997): nr 16  Tackling the Qualication Problem using Fluent Dependency Constraints: Preliminary Report Patrick Doherty  Department of Computer and Information Science Linkoping University S-58183 Linkoping, Sweden patdo@ida.liu.se  Jonas Kvarnstrom  Department of Computer and Information Science Linkoping University S-58183 Linkoping, Sweden jonkv@ida.liu.se  This work has been submitted for publication elsewhere, and if accepted, the current copyright may be transferred and the present version may be superseded by a revised one.
The WWW page at the URL provided below will contain up-to-date information about the current version and copyright status of the article.
Additional copyright information is found on the next page of this document.
Linkoping University Electronic Press Linkoping, Sweden http://www.ep.liu.se/ea/cis/1997/016/  Published on December 19, 1997 by Linkoping University Electronic Press 581 83 Linkoping, Sweden  Linkoping Electronic Articles in Computer and Information Science ISSN 1401-9841 Series editor: Erik Sandewall  c 1997  Patrick Doherty Jonas Kvarnstrom Typeset by the author using LATEX Formatted using etendu style  Recommended citation: <Author>.
<Title>.
Linkoping Electronic Articles in  Computer and Information Science, Vol.
2(1997): nr 16.
December 19, 1997.  http://www.ep.liu.se/ea/cis/1997/016/.
This URL will also contain a link to the author's home page.
The publishers will keep this article on-line on the Internet (or its possible replacement network in the future) for a period of 25 years from the date of publication, barring exceptional circumstances as described separately.
The on-line availability of the article implies a permanent permission for anyone to read the article on-line, to print out single copies of it, and to use it unchanged for any non-commercial research and educational purpose, including making copies for classroom use.
This permission can not be revoked by subsequent transfers of copyright.
All other uses of the article are conditional on the consent of the copyright owner.
The publication of the article on the date stated above included also the production of a limited number of copies on paper, which were archived in Swedish university libraries like all other written works published in Sweden.
The publisher has taken technical and administrative measures to assure that the on-line version of the article will be permanently accessible using the URL stated above, unchanged, and permanently equal to the archived printed copies at least until the expiration of the publication period.
For additional information about the Linkoping University Electronic Press and its procedures for publication and for assurance of document integrity, please refer to its WWW home page: http://www.ep.liu.se/ or by conventional mail to the address stated above.
Abstract  Recently, a great deal of progress has been made using nonmonotonic temporal logics to formalize reasoning about action and change.
In particular, much focus has been placed on the proper representation of non-deterministic actions and the indirect eects of actions.
One popular approach to representing the indirect eects of actions has been via the use of causal rules which in a more general sense can be viewed as uent dependency constraints.
Although uent dependency constraints have been used primarily under a loose causal interpretation, we show that when interpreted in a broader sense they provide a exible means for dealing with a number of other representational problems such as the qualication problem and the ramication constraints as qualication constraints problem, in addition to the standard ramication problem.
More importantly, the use of uent dependency constraints for dierent purposes does not involve additions to the base nonmonotonic temporal logic, TAL, used here, but simply the addition of several macro operators to an action language used to represent action scenarios or narratives.
The payo is that TAL has already been shown to oer a robust approach to representing action scenarios which permit incomplete specications of both state and the timing of actions, non-deterministic actions, actions with duration, concurrent actions, use of both boolean and non-boolean uents, and solutions to the frame and ramication problems for a wide class of action scenarios.
In addition, all circumscribed action scenarios in these classes and the more general class involving qualication considered in this paper can be shown to be reducible to the rst-order case.
Finally, a restricted entailment method for this new class of scenarios is fully implemented.
In the paper, we present a challenge example which incorporates all these features, propose a distinction between weak and strong qualication with a representation of both, and provide a visualization of the preferred entailments using a research tool VITAL for querying and visualizing action scenarios.
At the time of publication of this report, a similar shorter version lacking Appendices 3-6 had been submitted to TIME'98, The Fifth International Workshop on Temporal Representation and Reasoning.
This version also contains some minor corrections in addition to comments added in Appendix 1.
A longer paper is planned.
TIME'98 submission date: December 8, 1997.
1  1 Introduction In this paper, we provide a challenge in the form of a complex action scenario description, the Russian Airplane Hijack Scenario (RAH) which requires robust solutions to the frame, ramication and qualication problems.
We say robust because the scenario requires the representation of concurrent actions, incomplete specication of states, ramication with chaining, the use of nonboolean uents, ne-grained dependencies among objects in dierent uent value domains, actions with duration, ramication constraints as qualications to actions, two types of qualication, weak and strong, and the use of explicit time, in addition to other features.
Although some of these features have been reported in previous work, the approach to qualication is new, the use of a research tool VITAL [8], which provides an implementation and visualization of action scenarios is new, and the action scenario, to our knowledge, is one of the more challenging and complex scenarios proposed as a test example.
We will use Temporal Action Logic (TAL) to reason about action scenarios.
Temporal Action Logics (TAL) have their origin in the Features and Fluents framework proposed by Sandewall [11], where both a variety of logics of preferential entailment for reasoning about action and change and a framework for assessing the correctness of these and future logics were proposed.
One of the denitions of preferential entailment, PMON, was proposed by Sandewall and assessed correct for the K-IA class of action scenarios, a broad class of scenarios which dealt with nondeterministic actions, incomplete specication of state and the timing of actions, and observations at arbitrary states in a scenario.
PMON solved the frame problem for the K-IA class.
Later, Doherty [1, 2] translated and generalized PMON into an order-sorted rst-order logic with a circumscription axiom capturing the PMON denition of preferential entailment.
Recently, a number of additional extensions and generalizations have been added to the original PMON and the logics generated belong to what we call the TAL family.
Although the logics belong to the TAL family, each is essentially an incremental addition to the base logic PMON.
TAL-RC, proposed by Gustafsson and Doherty [6], provides a solution to the ramication problem for a broad, but as yet unassessed class of action scenarios.
The main idea is the addition of a specialization of uent dependency constraints which we called causal constraints.
The solution was based on the insight that the Occlude predicate used to solve the frame problem for PMON was all that was needed to dene causal rules which turn out to be very similar to action eect axioms.
The solution is also extremely ne-grained in the sense that one can easily encode dependencies between individual objects in the domain, work with both boolean and non-boolean uents and represent both Markovian and non-Markovian dependencies [5].
TAL-C, recently proposed by Gustafsson and Karlsson [7], uses uent dependency constraints as a basis for representing concurrent actions.
A number of phenomena related to action concurrency such as interference between one action's eects and another's execution, bounds on concurrency and conicting, synergistic, and cumulative eects of concurrent actions are studied.
In this paper, we will consider two problems: the qualication problem and the ramication constraints as qualication constraints problem [4, 9].
We call the logic used, TAL-Q, and note that it is an incremental extension of TAL-C, just as TAL-C is an incremental extension of TAL-RC.
In fact, the logical language and minimization policy is roughly the same for TAL-RC, TAL-C, and TAL-Q.
The novelty of the solution to these problems is in the combined use of uent dependency constraints and an additional idea introduced in TAL-C, durational uents.
The advantage of leaving the logic and minimization policy intact is that the new class of action scenarios representable in TAL-Q subsumes previous classes and any circumscribed scenario in TAL-Q is provably and automatically reducible to a compact rst-order theory eciently implemented in a research tool called VITAL [8].
VITAL is an on-line tool which permits both the visualization and querying of action scenarios.
The paper is structured as follows.
In Section 2, we briey describe TAL-Q.
We then provide a brief description of the surface language for action scenarios and their translation into an order-  2 sorted rst-order language with a circumscription axiom.
In Section 3, we describe a complex action scenario, the Russian Airplane Hijack Scenario (RAH), and provide a formal description in Appendix 1 which will be used throughout the paper.
In Section 4, we consider weak and strong qualication and provide a preliminary proposal for representing both types in TAL-Q.
Appendix 1 contains the RAH action scenario in the language L(SD) (described below) and Appendix 2-6 contain visualizations of the preferred entailments of the RAH scenario and various extensions to it.
The visualizations have been generated automatically from the VITAL tool.
Due to page limitations, we have to be very brief with our description of action scenario translation macros and the underlying logic, referring the reader to the following sources ([11, 1, 2, 6, 7, 8]).
2 TAL-Q: Temporal Action Logic with Qualication In this section, we introduce TAL-Q which will be used as a basis for a preliminary proposal for dealing with qualication of actions.
The basic approach we use for reasoning about action and change is as follows.
First, represent an action scenario in the surface language L(SD) which is a high-level language for representing observations, action types and action occurrences, dependency constraints, domain constraints, and timing constraints about actions and their duration.1 Second, translate L(SD) into the base language L(FL) which is an order-sorted rst-order language with four predicates Occlude(t; f ), Holds(t; f; v), Per(f ), and Dur(f; v), where t,f , and v are variables for timepoint, uent, and value expressions, respectively.
Holds expresses what value a uent has at each timepoint.
Occlude expresses that a uent at a timepoint is allowed to change value at that timepoint.
Each uent has to be characterized as either a durational uent, Dur(f; v), with default value v, or a persistent uent Per(f ), but not both.
The idea is that unless a durational uent is occluded at a timepoint, it will retain its default value, while a persistent uent at t + 1 retains whatever value it has at t unless it is occluded.
A linear discrete time structure is used in TAL-Q.
The minimization policy is based on the use of ltered preferential entailment [10] where action occurrences (occ-) and dependency constraints (dep-) are circumscribed with Occlude minimized and Holds xed.
The result is then ltered with two nochange axioms, the observations, and some foundational axioms such as unique names and temporal structure axioms.
Let ,obs , ,occ, ,dep, and ,acc denote the translations into L(FL) of the observation, occurrence, dependency and domain constraints in an action scenario, respectively.
In addition, let ,fnd denote the foundational axioms which include axioms for the time structure, unique names and the Dur=Per specication of uents.
The nochange axioms in ,ncg are  8t; f; v[Per(f ) !
(:Occlude(t + 1; f ) !
(Holds(t; f; v) $ Holds(t + 1; f; v)))]; which states that persistent uents that are not occluded at time t + 1 retain their value from t, and  8t; f; v[Dur(f; v) !
(:Occlude(t; f ) !
Holds(t; f; v))]; which states that durational uents have a default value of v, but when occluded can take on arbitrary values.
Since each uent is either durational or persistent, inertia of uent values or default behavior is dependent on the extension of Occlude which is minimized relative to ,dep and ,occ.
If  is an action scenario in L(SD), then Trans() is its translation into L(FL) which includes all of the sets of formulas ,x .
The following denition of preferential entailment applies: 1  Appendix 1 lists the RAH action scenario in language L(SD) which is described informally in Section 3.
3  Denition 1 The formula  is entailed by Trans() i ,fnd ^ ,acc ^ ,obs ^ ,ncg ^ Circso (,occ ^ ,dep ; Occlude) j=  Since there are only positive occurrences of the Occlude predicate in the circumscription context,  Circso (,,) is reducible to a logically equivalent rst-order formula.
The translation from L(SD) to L(FL) is straightforward and the reader is referred to [3, 7] for details concerning translation and the logic used.
We simply translate one of each type of statement in the scenario in Appendix 1 to provide some understanding, but rst we discuss the macro operators CT , R, I , and X .
The CT operator stands for becomes true.
For example, its use in dependency constraint cc3, CT ([t] loc(airplane) = ^ loc3), would be translated as follows: Holds(t; loc(airplane); loc3) ^ 8u[t = u + 1 !
:Holds(u; loc(airplane); loc3)]  Translations of the next operators are shown after they are discussed.
The R operator stands for uent reassignment and where an interval is used, occludes the uent in the interval and gives it a new value at the last timepoint.
For example the action occurrence occ3 uses the R operator as follows: R([4] loc(dimiter) =^ oce).
Here, because of the use of a single timepoint, it is only changing at 4.
The I operator stands for exceptional assignment and is often used in combination with durational uents.
It states that a uent will have a particular value which holds throughout the interval or at the timepoint.
For example, the dependency constraint cc1 contains the following: I ([t] 8airplane[:poss board(person; airplane)]);  which states that the default value for the durational uent poss board does not apply and the uent is false at t. The X operator stands for occlude assignment.
Its purpose is simply to allow a uent's value to vary at a timepoint or interval.
For example, the dependency constraint cc2 contains the following: X ([t] 8airplane[:poss board(person; airplane)]);  which states that poss board may be true or false at t. The observation statement obs2, the action occurrence statement occ3 which uses the R operator, the dependency statement cc1 which uses the I operator and the dependency statement cc2 which uses the X operator are translated into L(FL) as follows: obs2 Holds(0; loc(erik); home2) ^ Holds(0; loc(comb2); home2) ^ :Holds(0; drunk(erik); true) occ3 Holds(2; loc(dimiter); home3) !
Holds(4; loc(dimiter); oce) ^ Occlude(4; loc(dimiter)) cc1 8t; person[Holds(t; inpocket(person; gun); true) !
8airplane[:Holds(t; poss board(person; airplane); true) ^ Occlude(t; poss board(person; airplane))]] cc2 8t; person[Holds(t; drunk(person); true) !
Occlude(t; poss board(person; airplane))]  3 The Russian Airplane Hijack Scenario In this section, we will use the methodology of representative examples as a means of considering and proposing a preliminary solution to the qualication and ramication as qualication problems.
The proposal, while conveyed via a specic action scenario, can easily be presented in a more generic, but less intuitive manner.
We leave that for a longer paper.
We will use a new  4 action scenario, the Russian Airplane Hijack scenario, as a representative example.2 The scenario is described informally below and the formal action scenario can be found in Appendix 1.
A Russian businessman, Vladimir, travels a lot and is concerned about both his hair and safety.
Consequently, when traveling, he places both a comb and a gun in his pocket.
A Bulgarian businessman, Dimiter, is less concerned about his hair, but when traveling by air, has a tendency to drink large amounts of vodka before boarding a ight to subdue his fear of ying.
A Swedish businessman, Erik, travels a lot, likes combing his hair, but is generally law abiding.
Now, one ramication of putting an object in your pocket is that it will follow with you as you travel from location to location.
Generally, when boarding a plane, the only preconditions are that you are at the gate and you have a ticket.
One possible qualication to the boarding action is if you arrive at the gate in a suciently inebriated condition, as will be the case for Dimiter.
A ramication that may in some cases play a dual role as a qualication to the boarding action is if you try to board a plane with a gun in your pocket, which may be the case for Vladimir.
Now, Vladimir, Erik and Dimiter, start from home, stop by the oce, go to the airport, and try to board ight SAS609 to Stockholm.
Both Erik and Vladimir put combs in their pockets at home, Vladimir picks up a gun at the oce, while Dimiter is already drunk at home.
Who will successfully board the plane?
What are their nal locations?
What is in their pockets after attempting to board the plane and after the plane has arrived at its destination?
If the scenario is encoded properly and our intuitions about the frame, ramication and qualication problems are correct then we should be able to entail the following from the scenario in Appendix 1: 1.
Erik will board the plane with comb2 in his pocket and eventually board the plane successfully ending up at his destination.
2.
Vladimir will get as far as the airport with a gun and comb1 in his pocket.
He will be unable to board the plane.
3.
Dimiter will get as far as the airport and may or may not have boarded the plane.
He may or may not have comb3 in his pocket.
A weaker form of qualication (use of the X operator) is used here.
For example, if he is observed to be on the plane then he successfully slipped by security and there is no inconsistency.
If he is observed not to be on the plane, then the action failed and there is also no inconsistency.
4.
An indirect eect of ying is that the person ends up at the same location as the airplane.
In addition, because items in pockets follow the person, a transitive eect results where the items in the pocket are at the same location as the plane.
Consequently, erik and comb2 end up at run609b, the nal destination of ight sas609.
In fact, we do entail this and more.
The facts true in all preferred models for this scenario can be viewed in Appendix 2.3  4 Representing the Qualication Problem in TAL-Q In comparison with the frame and ramication problems, the qualication problem is still one of the least understood and with few satisfactory solutions.
This is most probably due to the fact that there are many dierent types of qualication problem, or reasons for qualifying an action description.
The main problem is that in general, it is computationally, ontologically and epistemologically unfeasible to represent complete specications of all the preconditions to actions which would include all possible qualications.
In this section, we will propose a default-based 2 This scenario is an elaboration and concretization of a sketch for a scenario proposed by Vladimir Lifschitz in recent on-line discussions in the European Transactions on Articial Intelligence (ETAI/ENAI).
3 red and green stand for false and true values for boolean uents, gray stands for true or false, while black after gray stands for \do not know the value, but will take the value gray" ends up being.
\2" means 2 possible values.
They are not shown in the diagram due to lack of space.
The diagram is automatically generated using the VITAL tool.
You should have a colored copy of Appendix 2.
5 solution within the TAL-Q framework that has a number of novelties.
We can express both strong and weak forms of qualication, the representation is ecient, and one can model ramication constraints as qualications in a number of ways.
We consider both forms of qualication using the RAH scenario from Appendix 1 to describe the approach.
Boarding an airplane might have a number of dierent qualications, for example, being drunk or carrying a gun in your pocket.
In other contexts, these facts may be perfectly natural.
The diculty, especially when such facts are inferred indirectly as ramications, is in providing a exible enough representation to allow the facts to play dual roles as either ramications, or ramications that may qualify an action.
One ramication of traveling or boarding a plane, is that everything in my pocket travels with me, including guns and combs.
So if I have a gun in my pocket before boarding a plane, one ramication of the boarding action is that the gun is on the plane.
Now, one could argue that having a gun in my pocket plays the role of a qualication to the boarding action and the action should fail.
On the other hand, it is perfectly possible that one could slip by with a gun if it is made of a special type of plastic.
So, how do we know that an action has been qualied?
Well, after the action is executed, we may observe the results of the action's eects.
For example, if vladimir is observed to be on the plane even though he has a gun, then he has slipped by and the action was possible after all.
If we observe that he isn't on the plane, then possession of the gun actually qualied the action.
This weaker form of qualication which we call weak qualication can also be represented.
Let's start with strong qualication.
A qualied action contains a uent enabling the action in its precondition with the same number of arguments as its associated action type.
For example, the boarding action contains a uent poss board(person; airplane): acs4 [t1 ; t2] board(person; airplane) !
[t1 ] poss board(person; airplane)^loc(person) =^ airport !
R([t2 ] loc(person) = ^ value(t2 ; loc(airplane)) ^ onplane(airplane; person)) Note that the uent poss board is a durational uent Dur(poss board) with default value true which means it can only take on another value (false) at a timepoint if it is occluded at that timepoint for some reason.
Such reasons are described as dependency constraints: cc1 8t[8person[[t] inpocket(person; gun) !
I ([t] 8airplane[:poss board(person; airplane)])]] This dependency constraint together with the assertion that poss board is durational implies that as long as a person has a gun in his pocket, poss board will be false for that person on all airplanes.
So far, this is similar to a standard default solution to the qualication problem, not unlike other solutions, but with some subtle dierences.
For example, it permits more control of the enabling precondition, even allowing it to change during the execution of an action.
Strong qualication has its uses, but is not fully adequate for other types of qualication.
A visualization of the preferred entailments for the scenario which is listed in Appendix 1, is provided in Appendix 2.4 Instead of the above, let's consider the use of a weak qualication.
Using the current example, the idea here is that inpocket(person, gun) should not be an absolute qualication, it should make it less likely that the person can successfully board the plane, but that would depend on additional information derived from other domain and dependency constraints.
We rst relax the previous dependency cc1 by replacing it with cc1.1 where the I operator is replaced with the X operator.
cc1.1 8t[8person[[t] inpocket(person; gun) !
X ([t] 8airplane[:poss board(person; airplane)])]] This change would generate two preferred models for people with guns.
In one, they successfully board the plane with a gun, in the other they do not.
In the RAH scenario, this would then be the case for vladimir, but erik's and dimiter's situation would remain unchanged.
We can not infer poss board(vladimir; sas609) or its negation from timepoint 7 to innity, where 7 is the end of the action where vladimir places a gun in his pocket.
In the case with cc1, we could infer the negation 4 Note that the scenario in Appendix 1 shows the use of strong qualication (guns) for vladimir and weak qualication (drunk) for dimiter described next.
6 from 7 to innity.
A visualization of the preferred entailments for the scenario which is listed in Appendix 1, but with cc1 replaced with cc1.1, is provided in Appendix 3.
Now one of the advantages of this approach is its naturalness.
Given a scenario, we can check whether action occurrences are successful or not by adding observations to the scenario after the action occurrence.
Adding obs5 [13] onplane(sas609; vladimir) to the scenario would allow us to infer that he did in fact board the plane and poss board(vladimir; sas609) was in fact true.
He would then end up at his destination.
A visualization of the preferred entailments for the scenario which is listed in Appendix 1, but with cc1 replaced with cc1.1 and with obs5 added, is provided in Appendix 4.
If instead we added obs6 [13] :onplane(sas609; vladimir), then we could infer that he was unable to board the plane and he did not end up at his destination.
A visualization of the preferred entailments for the scenario which is listed in Appendix 1, but with cc1 replaced with cc1.1 and with obs6 added, is provided in Appendix 5.
We are now very close to one solution to the problem of ramications as qualication constraints.
Observations are similar to domain constraints with the exception that observations generally assert facts about one timepoint while domain constraints (acc) assert facts generally true about one or more timepoints.
Now the idea is simply that domain constraints, or other dependency constraints for that matter, when used in ramication chains may implicitly qualify actions.
For example, let's extend our scenario (using cc1.1) with the domain constraint that it is absolutely forbidden for guns to be on planes, acc3 8t[8airplane[[t] :(loc(gun) =^ loc(airplane))]]: The location of the gun is a ramication of traveling from place to place.
We have not changed cc1.1, but in combination with the constraints we can infer from the scenario that vladimir was unable to board the plane, not simply due to the fact that he had a gun in his pocket, but due to that and some additional domain constraints of a more generic nature that sometimes function as ramication constraints and in this case as qualication constraints.
A visualization of the preferred entailments for the scenario which is listed in Appendix 1, but with cc1 replaced with cc1.1 and acc3 added, is provided in Appendix 6.
In conclusion, there is currently some basic understanding of the qualication problem, but we believe the techniques proposed here provide a reasonable basis for dealing with more sophisticated types of qualication than those found in the literature.
We also demonstrated how our research tool VITAL [8] can be used to generate the six appendices describing the RAH scenario and visualization of preferred entailments.
Acknowledgments This research is supported in part by the Knut and Alice Wallenberg Foundation, the Swedish Research Council for Engineering Sciences and the ECSEL graduate studies program.
References [1] P. Doherty.
Reasoning about Action and Change Using Occlusion.
In: Proceedings of the 11th European Conference on Articial Intelligence, 1994, 401-405.
[2] P. Doherty, W. Lukaszewicz.
Circumscribing Features and Fluents.
In: Proceedings of the 1st International Conference on Temporal Logic, Lecture Notes on Articial Intelligence, vol.
827, Springer-Verlag, 1994, 82-100.
7 [3] P. Doherty.
PMON+: A Fluent Logic for Action and Change, Formal Specication, Version 1.0.
Department of Computer and Information Science, Linkoping University.
Technical report LITH-IDA-96-33.
1996. http://www.ida.liu.se/publications/techrep/96/tr96.html [4] M. Ginsburg, D. E. Smith.
Reasoning about Action II: the Qualication Problem, Articial Intelligence J., 35, 1988, 311-342.
[5] E Giunchiglia and V. Lifschitz.
Dependent uents.
In Proc.
of the 14th Int'l Conf.
on Articial Intelligence, 1995.
[6] J. Gustafsson, P. Doherty.
Embracing Occlusion in Specifying the Indirect Eects of Actions.
In: Proceedings of the 5th International Conference on Principles of Knowledge Representation and Reasoning, Morgan Kaufmann Publishers, San Francisko, 1996, 87-98.
[7] J. Gustafsson, L. Karlsson.
Reasoning about Actions in a Multi-agent Environment.
Linkoping Electronic Articles in Computer and Information Science, 1997. http://www.ep.liu.se/ea/cis/1997/014.
Also submitted for journal publication.
[8] J. Kvarnstrom, P. Doherty.
VITAL: A Research Tool for Visualizing and Querying Action Scenarios in TAL.
http://anton.ida.liu.se/vital/vital.html.
[9] F. Lin, R. Reiter.
State Constraints Revisited, Journal of Logic and Computation, special issue on actions and processes, 4, 1994, 655-678.
[10] E. Sandewall.
Filter Preferential Entailment for the Logic of Action and Change.
In: Proc.
of the 11th Int'l Joint Conf.
on Articial Intelligence, (IJCAI-89), Morgan Kaufmann Publishers, 1989.
[11] E. Sandewall.
Features and Fluents.
A Systematic Approach to the Representation of Knowledge about Dynamical Systems.
Volume 1.
Oxford University Press, 1994.
8  Appendix1 DOMAIN SPECIFICATION  domain thing = {gun, comb1, comb2, comb3, vladimir, dimiter, erik, sas609} domain location = {home1, home2, home3, office, airport, run609, run609b, air} domain runway = location [run609, run609b] domain airplane = thing [sas609] domain person = thing [vladimir - erik] domain pthing = thing [gun, comb1 - comb3] domain pocket = {pocket1, pocket2, pocket3} feature loc(thing): location showname feature inpocket(person,pthing): boolean durational poss_board = true feature poss_board(person,airplane): boolean feature drunk(person): boolean feature onplane(airplane,person): boolean action put(person, pthing, pocket) action travel(person, location, location) action fly(airplane, runway, runway) action board(person, airplane)  THE NARRATIVE: OBSERVATIONS, ACTION OCCURRENCES AND TIMING obs1 [0] loc(vladimir) =^ home1 ^ loc(gun) =^ oce ^ loc(comb1) =^ home1 ^ :drunk(vladimir) obs2 [0] loc(erik) =^ home2 ^ loc(comb2) =^ home2 ^ :drunk(erik) obs3 [0] loc(dimiter) =^ home3 ^ loc(comb3) =^ home3 ^ drunk(dimiter) obs4 [0] loc(sas609) =^ run609 occ1 [1; 2] put(vladimir; comb1; pocket1) occ2 [1; 2] put(erik; comb2; pocket2) occ3 [2; 4] travel(dimiter; home3; oce) occ4 [3; 5] travel(vladimir; home1; oce) occ5 [4; 6] travel(erik; home2; oce) occ6 [6; 7] put(vladimir; gun; pocket1) occ7 [5; 7] travel(dimiter; oce; airport) occ8 [7; 9] travel(erik; oce; airport) occ9 [8; 10] travel(vladimir; oce; airport) occ10 [9; 10] board(dimiter; sas609) occ11 [10; 11] board(vladimir; sas609) occ12 [11; 12] board(erik; sas609) occ13 [13; 16] y(sas609; run609; run609b) ACTION TYPES acs1 [t1 ; t2] y(airplane; runway1; runway2) !
[t1 ] loc(airplane) =^ runway1 !
I ((t1 ; t2 ) loc(airplane) = ^ air) ^ R([t2 ] loc(airplane) =^ runway2) acs2 [t1 ; t2] put(person; pthing; pocket) !
[t1] loc(person) =^ loc(pthing) !
R((t1 ; t2 ] inpocket(person; pthing)) acs3 [t1 ; t2] travel(person; loc1; loc2) !
[t1 ] loc(person) =^ loc1 !
R([t2] loc(person) =^ loc2) acs4 [t1 ; t2] board(person; airplane) !
[t1 ] poss board(person; airplane) ^ loc(person) =^ airport !
R([t2 ] loc(person) =^ value(t2 ; loc(airplane)) ^ onplane(airplane; person))  DOMAIN CONSTRAINTS //A pthing cannot be in two pockets at the same time.
acc1 8t[8pthing1[8person1[8person2[:(person1 = person2) ^ [t] inpocket(person1; pthing1) !
[t] :inpocket(person2; pthing1)]]]]  9 //A person cannot be on board two airplanes at the same time.
acc2 8t[8person1[8airplane1[8airplane2[:(airplane1 = airplane2) ^ [t] onplane(airplane1; person1) !
[t] :onplane(airplane2; person1)]]]] DEPENDENCY CONSTRAINTS //A person who has a gun cannot board any airplane.
cc1 8t[8person[[t] inpocket(person; gun) !
I ([t] 8airplane[:poss board(person; airplane)])]] //A person who is drunk may not be able to board an airplane.
cc2 8t[8person[[t] drunk(person) !
X ([t] 8airplane[:poss board(person; airplane)])]] //When an airplane moves, persons on board the airplane also move.
cc3 8t[8airplane[8person[8loc3[[t] onplane(airplane; person) ^ CT ([t] loc(airplane) = ^ loc3) !
R([t] loc(person) =^ value(t; loc(airplane)))]]]] //When persons move, things in their pockets also move.
cc4 8t[8person[8pthing[8loc3[[t] inpocket(person; pthing) ^ CT ([t] loc(person) = ^ loc3) !
R([t] loc(pthing) =^ value(t; loc(person)))]]]]  Value  Value  Value  Value  poss_board(dimiter, sas609):  poss_board(erik, sas609):  poss_board(vladimir, sas609):  Value  onplane(sas609, vladimir):  Value  Value  loc(erik):  onplane(sas609, erik):  Value  loc(dimiter):  onplane(sas609, dimiter):  Value  loc(comb3):  Value  Value  loc(comb2):  loc(vladimir):  Value  loc(comb1):  Value  Value  inpocket(vladimir, gun):  Value  Value  inpocket(vladimir, comb3):  loc(gun):  Value  inpocket(vladimir, comb2):  loc(sas609):  Value  Value  Value  inpocket(erik, comb3):  inpocket(vladimir, comb1):  Value  inpocket(erik, comb2):  inpocket(erik, gun):  Value  Value  inpocket(dimiter, comb3):  Value  Value  inpocket(dimiter, comb2):  inpocket(erik, comb1):  Value  inpocket(dimiter, comb1):  inpocket(dimiter, gun):  Value  Value  drunk(erik):  drunk(vladimir):  Value  drunk(dimiter):  home1  run609  office  home2  home3  home3  home2  home1  1  home1  run609  office  home2  home3  home3  home2  home1  2  home1  run609  office  home2  home3  home3  home2  home1  3  office  run609  office  home2  office  *2*  home2  office  5  *2*  office  office  7  office  run609  office  office  *2*  *2*  12  *2*  *3*  *2*  *3*  office  run609  office  14  15  16  .
.
.
run609  *2*  *3*  run609  air  *2*  *3*  air  air  *2*  *3*  air  *2*  *3*  run609b run609b  *2*  *3*  run609b run609b  run609  run609  run609  run609  air  air  run609b run609b  board(erik,sas609) board(vladimir,sas609)  fly(sas609,run609,run609b)  office airport airport airport airport airport airport airport airport  run609  travel(erik,office,airport)  travel(dimiter,office,airport)  13  office airport airport airport airport airport airport airport airport  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  *2*  *3*  put(vladimir,gun,pocket1) board(dimiter,sas609)  travel(vladimir,home1,office)  11  travel(vladimir,office,airport)  office  run609  office  office  10  office airport airport airport airport airport airport airport airport  9  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  office  8  office airport airport airport  *2*  office  office  6  travel(erik,home2,office)  home1  run609  office  home2  office  *2*  home2  home1  4  travel(dimiter,home3,office)  put(erik,comb2,pocket2)  put(vladimir,comb1,pocket1)  home1  run609  office  home2  home3  home3  home2  home1  0  10  Appendix2  Value  Value  Value  loc(comb3):  loc(dimiter):  loc(erik):  Value  Value  Value  Value  poss_board(dimiter, sas609):  poss_board(erik, sas609):  poss_board(vladimir, sas609):  Value  onplane(sas609, erik):  onplane(sas609, vladimir):  Value  Value  loc(vladimir):  onplane(sas609, dimiter):  Value  Value  loc(comb2):  Value  Value  loc(comb1):  loc(gun):  Value  inpocket(vladimir, gun):  loc(sas609):  home3  Value  inpocket(vladimir, comb3):  home1  run609  office  home2  home3  home3  home2  home1  1  home1  run609  office  home2  home3  home3  home2  home1  2  home1  run609  office  home2  home3  home3  home2  home1  3  office  run609  office  home2  office  *2*  home2  office  5  *2*  office  office  7  office  run609  office  office  *2*  *2*  *2*  12  *2*  *3*  *2*  *3*  office  run609  office  run609  office airport  run609  office airport  *2*  run609  *2*  travel(dimiter,office,airport)  board(erik,sas609) board(vladimir,sas609)  travel(erik,office,airport)  *2*  run609  *2*  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  *2*  *3*  put(vladimir,gun,pocket1) board(dimiter,sas609)  travel(vladimir,home1,office)  *2*  11  travel(vladimir,office,airport)  office  run609  office  office  10  office airport  9  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  office  8  office airport airport airport  *2*  office  office  6  travel(erik,home2,office)  home1  run609  office  home2  office  *2*  home2  home1  4  travel(dimiter,home3,office)  put(erik,comb2,pocket2)  put(vladimir,comb1,pocket1)  home1  run609  office  home2  home3  home2  Value  inpocket(vladimir, comb2):  home1  Value  Value  Value  inpocket(erik, comb3):  inpocket(vladimir, comb1):  Value  inpocket(erik, comb2):  0  inpocket(erik, gun):  Value  Value  inpocket(dimiter, comb3):  Value  Value  inpocket(dimiter, comb2):  inpocket(erik, comb1):  Value  inpocket(dimiter, comb1):  inpocket(dimiter, gun):  Value  Value  drunk(erik):  drunk(vladimir):  Value  drunk(dimiter):  *2*  air  *2*  air  *2*  *3*  air  *2*  14  *2*  air  *2*  air  *2*  *3*  air  *2*  15  *2*  .
.
.
*2*  *3*  *2*  *2*  *2*  run609b run609b  *2*  run609b run609b  *2*  *3*  run609b run609b  *2*  16  fly(sas609,run609,run609b)  *2*  run609  *2*  run609  *2*  *3*  run609  *2*  13  11  Appendix3  Value  Value  Value  Value  poss_board(dimiter, sas609):  poss_board(erik, sas609):  poss_board(vladimir, sas609):  Value  onplane(sas609, vladimir):  onplane(sas609, erik):  Value  loc(erik):  Value  Value  loc(dimiter):  onplane(sas609, dimiter):  Value  loc(comb3):  Value  Value  loc(comb2):  loc(vladimir):  Value  loc(comb1):  Value  Value  inpocket(vladimir, gun):  Value  Value  inpocket(vladimir, comb3):  loc(gun):  Value  inpocket(vladimir, comb2):  loc(sas609):  Value  Value  Value  inpocket(erik, comb3):  inpocket(vladimir, comb1):  Value  inpocket(erik, comb2):  inpocket(erik, gun):  Value  Value  inpocket(dimiter, comb3):  Value  Value  inpocket(dimiter, comb2):  inpocket(erik, comb1):  Value  inpocket(dimiter, comb1):  inpocket(dimiter, gun):  Value  Value  drunk(erik):  drunk(vladimir):  Value  drunk(dimiter):  home1  run609  office  home2  home3  home3  home2  home1  1  home1  run609  office  home2  home3  home3  home2  home1  2  home1  run609  office  home2  home3  home3  home2  home1  3  office  run609  office  home2  office  *2*  home2  office  5  *2*  office  office  7  office  run609  office  office  *2*  *2*  run609  12  *2*  *3*  *2*  *3*  office  run609  office  run609  run609  o f f i c e a i r p o r t run609  run609  o f f i c e a i r p o r t run609  travel(dimiter,office,airport)  board(erik,sas609) board(vladimir,sas609)  travel(erik,office,airport)  run609  run609  run609  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  *2*  *3*  put(vladimir,gun,pocket1) board(dimiter,sas609)  travel(vladimir,home1,office)  11  travel(vladimir,office,airport)  office  run609  office  office  10  o f f i c e a i r p o r t run609  9  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  office  8  office airport airport airport  *2*  office  office  6  travel(erik,home2,office)  home1  run609  office  home2  office  *2*  home2  home1  4  travel(dimiter,home3,office)  put(erik,comb2,pocket2)  put(vladimir,comb1,pocket1)  home1  run609  office  home2  home3  home3  home2  home1  0  air  air  air  air  *2*  *3*  air  air  14  air  air  air  air  *2*  *3*  air  air  15  .
.
.
*2*  *3*  run609b run609b  run609b run609b  run609b run609b  run609b run609b  *2*  *3*  run609b run609b  run609b run609b  16  fly(sas609,run609,run609b)  run609  run609  run609  run609  *2*  *3*  run609  run609  13  12  Appendix4  Value  Value  Value  Value  poss_board(dimiter, sas609):  poss_board(erik, sas609):  poss_board(vladimir, sas609):  Value  onplane(sas609, vladimir):  Value  Value  loc(erik):  onplane(sas609, erik):  Value  loc(dimiter):  onplane(sas609, dimiter):  Value  loc(comb3):  Value  Value  loc(comb2):  loc(vladimir):  Value  loc(comb1):  Value  Value  inpocket(vladimir, gun):  Value  Value  inpocket(vladimir, comb3):  loc(gun):  Value  inpocket(vladimir, comb2):  loc(sas609):  Value  Value  Value  inpocket(erik, comb3):  inpocket(vladimir, comb1):  Value  inpocket(erik, comb2):  inpocket(erik, gun):  Value  Value  inpocket(dimiter, comb3):  Value  Value  inpocket(dimiter, comb2):  inpocket(erik, comb1):  Value  inpocket(dimiter, comb1):  inpocket(dimiter, gun):  Value  Value  drunk(erik):  drunk(vladimir):  Value  drunk(dimiter):  home1  run609  office  home2  home3  home3  home2  home1  1  home1  run609  office  home2  home3  home3  home2  home1  2  home1  run609  office  home2  home3  home3  home2  home1  3  office  run609  office  home2  office  *2*  home2  office  5  *2*  office  office  7  office  run609  office  office  *2*  *2*  12  *2*  *3*  *2*  *3*  office  run609  office  14  15  16  .
.
.
run609  *2*  *3*  run609  air  *2*  *3*  air  air  *2*  *3*  air  *2*  *3*  run609b run609b  *2*  *3*  run609b run609b  run609  run609  run609  run609  air  air  run609b run609b  board(erik,sas609) board(vladimir,sas609)  fly(sas609,run609,run609b)  office airport airport airport airport airport airport airport airport  run609  travel(erik,office,airport)  travel(dimiter,office,airport)  13  office airport airport airport airport airport airport airport airport  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  *2*  *3*  put(vladimir,gun,pocket1) board(dimiter,sas609)  travel(vladimir,home1,office)  11  travel(vladimir,office,airport)  office  run609  office  office  10  office airport airport airport airport airport airport airport airport  9  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  office  8  office airport airport airport  *2*  office  office  6  travel(erik,home2,office)  home1  run609  office  home2  office  *2*  home2  home1  4  travel(dimiter,home3,office)  put(erik,comb2,pocket2)  put(vladimir,comb1,pocket1)  home1  run609  office  home2  home3  home3  home2  home1  0  13  Appendix5  Value  Value  Value  Value  poss_board(dimiter, sas609):  poss_board(erik, sas609):  poss_board(vladimir, sas609):  Value  onplane(sas609, vladimir):  Value  Value  loc(erik):  onplane(sas609, erik):  Value  loc(dimiter):  onplane(sas609, dimiter):  Value  loc(comb3):  Value  Value  loc(comb2):  loc(vladimir):  Value  loc(comb1):  Value  Value  inpocket(vladimir, gun):  Value  Value  inpocket(vladimir, comb3):  loc(gun):  Value  inpocket(vladimir, comb2):  loc(sas609):  Value  Value  Value  inpocket(erik, comb3):  inpocket(vladimir, comb1):  Value  inpocket(erik, comb2):  inpocket(erik, gun):  Value  Value  inpocket(dimiter, comb3):  Value  Value  inpocket(dimiter, comb2):  inpocket(erik, comb1):  Value  inpocket(dimiter, comb1):  inpocket(dimiter, gun):  Value  Value  drunk(erik):  drunk(vladimir):  Value  drunk(dimiter):  home1  run609  office  home2  home3  home3  home2  home1  1  home1  run609  office  home2  home3  home3  home2  home1  2  home1  run609  office  home2  home3  home3  home2  home1  3  office  run609  office  home2  office  *2*  home2  office  5  *2*  office  office  7  office  run609  office  office  *2*  *2*  12  *2*  *3*  *2*  *3*  office  run609  office  14  15  16  .
.
.
run609  *2*  *3*  run609  air  *2*  *3*  air  air  *2*  *3*  air  *2*  *3*  run609b run609b  *2*  *3*  run609b run609b  run609  run609  run609  run609  air  air  run609b run609b  board(erik,sas609) board(vladimir,sas609)  fly(sas609,run609,run609b)  office airport airport airport airport airport airport airport airport  run609  travel(erik,office,airport)  travel(dimiter,office,airport)  13  office airport airport airport airport airport airport airport airport  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  *2*  *3*  put(vladimir,gun,pocket1) board(dimiter,sas609)  travel(vladimir,home1,office)  11  travel(vladimir,office,airport)  office  run609  office  office  10  office airport airport airport airport airport airport airport airport  9  o f f i c e a i r p o r t a i r p o r t a i r p o r t run609  office  8  office airport airport airport  *2*  office  office  6  travel(erik,home2,office)  home1  run609  office  home2  office  *2*  home2  home1  4  travel(dimiter,home3,office)  put(erik,comb2,pocket2)  put(vladimir,comb1,pocket1)  home1  run609  office  home2  home3  home3  home2  home1  0  14  Appendix6