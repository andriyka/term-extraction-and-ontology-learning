Temporal Tableau Queries Jef Wijsen and Alexis Bl&s Universitk de Mons-Hainaut, Belgium T ~ J ( S )S N A M E  Abstract  Blake  CITY Athens  FROM 1  TO 7  FROM  TO  1  7  The tableau construct plays a very important role in relational database theory.
It is shown how this construct can be extendedfor tuple-timestamped relations.
The expressive power of temporal tableau queries is compared with that of a temporal algebra.
A temporal extension of the Homomorphism Theorem is given.
X I ( U [ ~ , ~ I ( K I , ~ ( ~ ) )SNAME )  1.
Introduction  Blake  Several algebras for temporal relational databases have been published since the early eighties [3, 71.
In more recent years, there has been a growing interest inpractical languages for temporal databases.
This has led to a number of temporal extensions of SQL [6,8, 111.
The theoretical foundations of these temporal query languages-including is-sues like expressiveness, complexity, computability, genericity, and optimization-have not been systematically explored.
Some intriguing theoretical questions are raised by the following example that initially aroused our interest in this field; the example also illustrates some of the notations used later on.
Consider the following temporal relation inspired by [2]: S  SNAME ~  STATUS  Blake  Athens  Smith  Smith  Paris 20  London  The natural numbers are used to denote time.
The first tuple means that supplier Blake lived in Athens with status 10 at time instants 1,2, and 3.
Consider the query: Give the names of suppliers who stayed within the same city throughout the entire time period [:3,6].
To answer this query, we first perform a temporal projection on SNAME and C I T Y .
We use an unnamed algebra perspective and denote SNAME and CITY as columns 1 and 3 respectively.
0-7695-1107-4/01 $10.00 0 2001 IEEE  136  temporal SQL extension, addresses the first question by a construct called "restructuring," which is stated to be "one of the most powerful constructs of TSQLT [lo, p. 1331.
Loosely speaking, restructuring allows a pre-projection in thefrom clause, nested within the outer projection of the select clause.
However, a temporal algebra query may contain more than two projections none of which can be removed by rewriting; an example is r1( q , 4( n , 2(C[2,3]( r 1 , 2 , 3 (I))) 1) where I contains at least four non-temporal attributes.
Consequently, restructuring alone is generally insufficient and more powerful constructs are needed, in particular the ability to nest queries in thefrom clause.
The second question is at the center of this paper, whose main contributionis the introduction of temporal tableau query.
This new construct is introducedin intimate relationship with a "kemel" temporal algebra called SPCt"e-kernel, in the sense that it is difficult to imagine a full-fledged temporal algebra that cannot express all SPCtlmequeries.
We first introduce SPCtlme, and then we introduce temporal tableau queries that can express an important class of SPCtImequeries, called rooted spCtlmequeries.
Section 2 takes off with a note on coalescing.
Temporal relations are defined in Section 3.
The SPCtlmealgebra is introducedin Section 4, and the subclass of rooted SPC time queries in Section 5.
Sections 6 and 7 introduce temporal tableau queries and their composition.
SPCtlmequeries and temporal tableau queries are compared for expressiveness in Section 8.
In particular, we develop an effective method for translatingrooted SPC time queries into temporal tableau queries.
Section 9 introduces a temporal generalization of the famous Homomorphism Theorem [l, p. 1171, and illustrates how it may be applied for optimization of temporal queries.
Finally, Section 10 lists some open problems.
Sound: if (IC, 1) E coalesce(1) and m E N such that le 5 m 5 1, then I contains a pair ( i ,j ) such that i 5 m 5  2.
A note on coalescing  h&".
b,q1 A  Coalescing is a well-known concept in temporal databases, and was already illustrated in Section 1.
It is not our aim to contribute here to the ongoing debate whether coalescing is beneficial or harmful; rather we want to shed some light on the expressive power needed for coalescing.
The query coalesce defined next captures the essence of this operator.
It works on sets of intervals, i.e., temporal relations of arity 0 according to Definition 3 introduced later; the extension to temporal relations of higher arity is straightforward.
Supremum.
I f p 5 q and r  j.
The query coalesce is expressible in the SPCUD algebra (= the SPCU-algebra [l, p. 621 extended with Difference) extended with selections of the form ai<j ( Q ) ,equipped with the natural semantics.
An SQL version has appeared in [10, p. 1051.
The following result is not hard to prove but nevertheless important.
9  Theorem 1 The query coalesce is not expressible in the SPCU algebra extended with selections of the form %<j(Q).
Consequently, any temporal algebra that incorporates coalescing, as the algebra proposed in Section 4 does, allows certain queries that are outside the scope of the SPCU algebra.
This suggests that certain theoretical questions may not be easy.
3.
Temporal relation We assume a discrete linear order to represent time.
In all examples throughoutthis paper, natural numbers are used to denote time points.
Definition2 We assume a discrete, linearly ordered set (IP,<) of time points.
We define for each p, q E IP the interval b,q ] := { z E P I p z < q } .
The set of all intervals is denoted 1.
Two intervals are unijiable if their set union is again an interval.
<  Theorem 2 The set satisfying:  E, ordered by set inclusion, is a lattice  [ T , SI  = b,q1 n [ T , SI.
5 s then [p, q ] V [ T , s] = [pi s] U  [ T , ql.
Intervals of Ti are used to timestamp tuples; the timestamping attributeis denoted T. A temporal relation is a coalesced set of temporal tuples with non-empty timestamps.
For example, the temporal relations I, J both of arity 2 (T does not add to the arity):  Definition 1 Let Ns := { ( i ,j ) I i , j E N and i 5 j } .
Let I be a finite subset of N5.The output of the query coalesce on input I, denoted coalesce(I),is a minimal (w,r.t.
cardinality) subset of Ns satisfying:  We write (a, b , [l,31) E J because the temporal tuple (a, b , [l,31) is "contained" in the first tuple of J ; the containment relationship between these two tuples is written (a, b, [1,311 5 ( a , b , [0 , 91).
The relationship E between  Complete: if ( i ,j ) E I then coalesce(1) contains a pair ( k ,1) with k 5 i and j 5 1, and  137  4.3.
Teinporal cross product  a temporal tuple and a temporal relation is extended in a natural way to a relationship 5 among temporal relations.
In the above example, I C J.  Definition3 We assume a countably infinite set dom of constants.
A (temporal) tuple of arity n (n 2 0) is an element of domn x 1.If t is a tuple of arity n, then the ith coordinateoft(i E (1, ..., n})isdenotedt(i),a~~dthe(n+l)~~ coordinate is denoted t (T).
Two tuples t and s of the same arity (say n) are value-equal, denoted t =: s, iff t(i) = s ( i ) foreachi E {1,..., n}.
Wewritet 5 s i f f t =: s a n d t(T) Lett be a temporal tuple and T, S sets of temporal tuples, all of the same arity.
We write t E Tiff either t ( T ) = {} or t 3 s for some s E T. We write T S iff t E S for every tuplet E T. A (temporal)relation of arity n (n 2 0) is a set I of temporal tuples of arity n such that for each t , s E I :  cW.
2. i f t ( T ) ands(T) areunifiableandt x s thent = s.  4.
A simple temporal algebra  Dehitioin 7 For every n E N,we assume the existence of denumeraibly many relation variables R, RI, R:!, .
.
.
of arity n. SF'CtImequeries and their associated arities are recursively defined as follows:  Base.
Every relationvariable of arity n is an SPCtImequery of arity n.  &I and Q:!
are SPCtlmequeries of arities n1 and respectively, then Q1 x Q:!
is an SPCtlmequery of arity n1 n:!.
722  +  We write Q ( R 1 , .. .
, Rn), where R1,.
.
.
, R, are distinct relation variables, to indicate that Q is a query containing the relation variables RI, .
.
.
, R,.
The semantics of & ( R I.,.
.
, Rn)is relative to an interpretation function that maps each R, to a temporal relation of the same arity as R, (i E { 1, .
.
.
, n}).
These semantics is defined in the natural manner (not elaborated here).
In the remainder of this paper, we only (considerSPCtimequeries Q ( R )involving a single relation variable.
Let &I (R), Q:!
(R) be queries of the same arity.
We write Q1 &:!
iff Q1 (I)C & Z (I)for each temporal relation I of the same arity as R. &I and Q:!
are equivalent, denoted &I 5 &2, iff &I L &Z and Q:!
C &I.
An SPCtImequery Q (R) is unsatisfiable iff &(I) = { } for each temporal relation I of the same arity as R.  Definition4 Let I be a temporal relation of arity n, and i , j E (1,..., n } , a E d o m , a n d p , q E P w i t h p s q .
:= {t E I  spctime  Join.
If  4.1.
Temporal selection  Ui=j(I)  4.4.
Project.
If Q is an SPCtlme query of arity n and j1,.. .,jmE (1,. .
., n } , then rJ1,,3n(&) is an SPC?
"~query of arity m ( m 2 0).
We introduce a basic temporal extension of the SPC algebra; an example was already given in Section l. A selection of the form (I)retrieves each tuple of I whose timestamp includes the interval [p, q ] .
A projection automatically performs coalescing on the result.
Joining two tuples - involves concatenating the values for the non-temporal attributes and taking the intersection of the timestamps.
These temporal operators are common; see for example [9].The temporal algebra SPCtlmewill be used later on for studying the expressive power of temporal tableau queries.
0  +  Select.
If Q is an SPCtlme query of arity n, and i , j E (1,.. .
, n } ,a E d o m , andp,q E IF withp 5 q , then (Q), and ~ [ p , ~ l ( Qare ) SPCtimequeries of arity n.  1. t ( T ) # {),and  -  Definition6 Let I, J be temporal relations I x J := of arities n and m respectively.
{(t(l),.
.
.
,t(n>, s(l),. '
., s(m),t(T)n s ( T ) ) I t E I a n d s J~a n d t ( T ) n s ( T ) # (}}.Itcanbeverifiedthat I x J is a. temporal relation of arity n m.  I t ( i )= t ( j ) } ,  Unsatisfiability arises if two constants are required to be equal, a:s in a l = a ( u l = b ( ~ ) )spctlme .
queries are monotonic:  4.2.
Temporal projection Definition5 Let I be a temporal relation of arity n, and j l , j z , .
.
.
, j , E (1, .
.
.
, n } ( m 2 0).
r J 1 ,,Jm (I)is the smallest (w.r.t.
C)temporal relation J of arity m satisfying for every t E I, ( t ( j l ) ,.
.
.
, t ( j m ) ,t(T)) E J .
Theorem 3 Let &(R)be an SPCtImequery, and I , J temporal rejutionsof the same arity as R. I f I E J then Q (I)  Q(J)*  138  Q (R) is called rooted iff (1) it is satisfiable and (2) for each subquery of Q of the form 7r;( 9'),there is a non-empty, ubiquitous interval for Q'; otherwise &(R)is unrooted.
Importantly, as argued in Section 1, we cannot push the selection through the projection in the SPCtimequery nb,q~(7r;(Q)).Nor can we push the cross product through the selections in the SPCtImequery U [ P , ~(Q1) I x a[,,,](Qz).
As a consequence, the normal form for SPC algebra expressions [l, p. 551 does not apply to SPCtImequeries.
Example 1 Each query Q(R) without projection is rooted.
~1(a[1,41(R)) is rooted, but 0[1,4](rl(R))is not.
5.
Rooted SPCtimequeries The tableau construct is very important in relational database theory.
It can be used, among others, for query optimization based on the Homomolphism Theorem [l].
It is interesting to ask whether this construct can be extended to the temporal domain.
Loosely speaking, a tableau query consists of a relation T, called the tableau of the query, followed by a tuple U, called the summary.
The tableau T and the summary U can contain constants as well as variables.
Intuitively, the tableau T lists the tuples that are both sufficient and necessary to include the summary tuple U in the answer to the query.
The formalism of tableau query does not carry over immediately to the temporal domain.
One problem is with projection and the involved coalescing.
Consider the SPCtIme query nl(Q(R)) where the arity of Q is 2.
Let I be a relation of the same arity as R. What tuples should be in &(I) in order to include the tuple U = (z, [p, q]) with p 5 q in the answer 7rl(Q(I))?According to the definition of projection, U E 7r1 (Q(I))if and only if Q (I)contains a number k > 0 of tuples (IC, Yl, [pl, q11), .
.
., ( 2 ,Y k , bk,Q k l ) such that [io, q ] 2 [ioj , e].The problem arising is that the number k is not fixed.
This suggests that the classical notion of tableau needs to be adapted to accommodate a variable number of tuples.
Interestingly, there are situations where the use of the projection operator does not lead to this kind of difficulty.
Assume in the previous example n[r,s](Q'(R))-Clearly, t E u[r,sl(Q'(I)) imQ(R) plies t(T) _> [ T , Then it is correct to conclude that, in order to have U = (x,[p, q ] ) E r ~ ( o [ r , s ] ( Q ' ( I ) ) ) , it is sufficient and necessary to have two tuples The outer ( 2 ,Y I , [i., (2, Y Z , [ T , q ] ) E g[r,s](&'(I))* projection in 7r1(cr[,,,] (Q'(I))) will coalesce these two tuples into a single tuple (2, [io.
q] V [ T , SI) (cf.
Theorem 2).
Hence, the number k reduces to 2 as a result of the fact that every tuple of C [ ~ , ~ I ( Q ' must ( I ) ) necessarily include [ T , This observation leads to the subclass of "rooted" queries defined next.
SI.
SI)]  SI.
Definition 8 An interval b,q] is called ubiquitous for an Spctime query Q (R) iff for every temporal relation I of the same arity as R, t E &(I) implies t(T) 2 [p, q ] .
There exist unrooted SPCtlmequeries that are equivalent to rooted ones.
Obviously, the unrooted query 7 r 1 , ~ , ,"(R), where R is of arity n, is equivalent to the rooted query R. It is slightly harder to verify that the unrooted query 7r1,2, ,n(n[1,4~(R) x R), whereRisofarityn,isequivalent to the rooted query a[l,4](R).
6.
Temporal tableau query The notion of temporal tableau is defined exactly as was the notion of temporal relation, except that both variables and constants may occur.
Importantly, only two temporal variables are introduced, and their usage is syntactically restricted: f (from) can only occur as the left coordinate of an interval, and t (to) only as the right coordinate.
No interval can contain non-temporal variables.
The summary tuple t in a temporal tableau query (T,t ) must satisfy t (T) = [f , t].
The semantics of temporal tableau queries is a natural extension of non-temporal tableau query semantics [ l , p. 431.
Definition 9 We assume a set var of non-temporal variables.
We assume two temporal variables f and t not in var.
An f-t-valuation is a mapping p from { f , t} to P such that p ( f ) 5 p ( t ) extended to be the identityon var U dom.
We define:  V := {[x,y] I IC E P U { f } andy E IPU {t}} .
A tableau tuple of arity n (n 2 0) is an element of (var U dom)" x V. If t is a tableau tuple of arity n, then the ith coordinateoft (i E { 1, .
.
.
, n}) is denoted t ( i ) ,and the ( n 1) coordinate is denoted t (T).
A (temporal) tableau of arity n (n 2 0) is a set of tableau tuples of arity n. A (temporal) tableau query is a pair (T,t ) where T is a temporal tableau and t is a tableau tuple such that t(T) = [f,t] and each variable in t also occurs in T; moreover, (TIt ) should satisfy the following safety requirement: for every f-t-valuation p , for every non-temporal variable IC occuning in t , there must be a tableau tuple s E T such that IC occurs in s and p(s(T))# {}.
Let T = (T,t ) be a temporal tableau query and I a temporal relation of the same arity as T. An embedding of tem- .
poral tableau T into I is a valuation v for the variables occurring in T such that:  +  v(z) E doni if x is a variable in var, 0  139  v(f), v ( t ) E Pand v(f)  5 v ( t ) ,and  0  v(T) I, where it is understood that v is extended to be the identity on constants.
composition of temporal tableau queries, which generalizes the composition of typed tableaux [ l , p. 2261.
We assume that the reader is familiar with the composition of typed tableaux; the composition of temporal tableau queries is slightly miore complicated, as illustrated next.
Let T and U be the temporal tableau queries:  The Output Of On input denoted ' ( I ) , is the tempora1 relation of the Same aritY as satisfying: E r(l) iff there exists an embedding v of T into I such that v(t) = s. ' 9  Example 2 Consider the temporal tableau query r = (T,t ) and the temporal relation I:  p;:I  Considerthe valuationv = { ( x , b ) , ( f , 6 ) , ( t , 7 ) } .
Then v ( T )is the following set of tuples:  Y2  If,tl  We want to construct the temporal tableau query r 0 U corresponding to the composition of r followed by U .
F'roceeding along, the lines of typed tableaux, one looks for a substitution mapping t to s 1, and another one mapping t to s2.
The difficulty is that there is no substitution that maps t to S;I for such substitution to exist, we must have w 1 = a and y1 = y2.
Likewise, the existence of a substitutionthat maps t to s2, requires w2 = a and w1 = y3.
From w1 = a and w1 = y3, it follows y3 = a.
Applying these equalities to U, we obtain a new tableau query U':  Since v(T) C I, v(t) = (6, [6,7]) E r(1).
It can be verified that T is equivalent to the SPCtlme query n2 (U[1,4] (U1= a  Y3  (RI1).
Example 3 The following table T = (T,t ) falsifies the safety requirement of Definition 9 and hence is not a valid temporal tableau query:  Now there exist substitutions from; to si,and from t to si.
Consider an embedding v with v ( f ) = 4 and v ( t ) = 5.
Then v(T) I for every temporal relation I of arity 1, inSimilar to safety in the redependent of the value of .(.).
lational calculus, the safety requirement in Definition 9 ensures that query answers are finite and depend on the content of the input temporal relation.
Definition 10 Let r = (T,t) and U = (S,s) be two temporal tableau queries, where t and S are both of arity n. Let  S = {Sl, .
.
.
, s,}.
A unifier fort apd D is a substitution0 defined as follows.
Compute z,the equivalence relation on var Udomu { f , t } defined as the reflexive, transitive closure of:  Note that v ( T )may not be a temporal relation, as no coalescing is required.
It can be easily verified that t E r(I)and s 5 t imply s E r(I).
Temporal tableau queries are monotonic:  1. s,(g) E a if t ( j ) = a for some constant a, for each i E { l , .
.
.
, m } a n d j E (1,.. .
, n } ; 2.
Theorem 4 Let T = (T,t ) be a temporal tableau query, J and I , J temporal relations of the same arityas T .
ZfI then r ( I ) & r ( J ) .
E s z ( k )i f t ( j ) = t ( k ) , foreach i E (1,.. .
, m} andj,k E ( 1 , .. .
, n } .
S,(J)  The unifier o f t and U does not exist if two distinct constants are in the same equivalence class.
Otherwise their unifier is the substitution 6 such that:  7.
Composition of temporal tableau queries  1. if z In Section 8 we will develop an approach that inductively constructs temporal tableau queries correspondingto subexpressionsof an SPCtlmequery.
The construction uses  a for some constant a, 6(2) = a ;  2. otherwise Q(x) = d,where 2' is the smallest (under a fixed ordering on var) such that 2 E d .
140  Definition 11 Let T = (T,t ) and U = (S,s) be two temporal tableau queries, where t and S are of the same arity.
Let S = {SI, .
.
.
, sm}.
Assume 0 is a unifier fort and a;if no such unifier exists, the composition is undefined.
For each i E { 1,.. .
, m } ,let 0i be a substitutionthat maps t to 0 ( s i ) and maps each other variable of T to a new, distinct variable not used elsewhere in the construction.
Then:  3. t ~ b ( ~ i = j ( := Q )tab(&). )
1  ... i - 1  i  i s 1 ...  12  T  .
>21 .
.
.
4.  t a b ( ~ i = .
( Q := ) ) tab(&)*  m  TOb:=(U0i(T),0(s)) i=l  ,  ... i-1  i  i+l  21  ...  xi-1  a  Xi+l  21  ...  2i-1  a  2i+l  1  where it is understood that 0 is extended to be the identity on constants.
.
.
.
12 T .
.
.
xn [f,t] .
.
.
.
E n [f,t]  4  Example 4 For T and U as introduced at the beginning of this section:  (U)  ...  xj,  ...  xj,  xj,  ...  xj,  .
..  where [p, q] is ubiquitousfor Q (typicallythe maximal ubiquitousinterval).
More precisely, the arity of w is m; u ( j i ) = v(ji) = w ( i ) foreachi E {1,2, .
.
.
, m},andallconstants are pairwise distinct otherwise.
Composition is well-defined  Proposition 1 Let T = (T,t ) and U = (S, s ) be two temporal tableau queries, where t and S are of the same arity.
Let I be a temporal relation of the same arity as T .
If.
0 U is dejned then 7 0 o(1) = a ( r ( 1 ) )otherwise ; a ( r ( 1 ) )= {}.
6.
Q = Q1 x QZ ; assume Q1 andQ2 are ofaritynl and n2 respectively.
Let tab(Q1) = ( T I ( , X I , .. .
, x n l ,[ f ,t])) and tab(Q2) = (Tz,(yl,.. .
, ynz, [f,t])).
Assume without loss of generality that T I and Tz have no variables in common except for f and t. Then tab(&) := (TI U Tz,(21, .
.
.
, xnl, YI .
.
.
, YnZ , [f,tl)).
8.
Temporal tableaux of rooted queries  Example5 Let R be of arity 1.
Tl(U[1,4](R) x U[2,3](R))* Since  We give an inductive definition that translates a rooted Spctime query into a temporal tableau query.
The crux lies in the translation of temporal selection ~ [ p ,(.
)~ ]and projection, where the introductionof two tuples is needed.
Definition12 For each rooted SPCtime query Q ( R ) , tab(&) is recursively defined as follows.
Assume Q ( R )is of arity n in what follows.
1. tab(R1 :=  -1  , where R is a re-  Y lation variable of &ty  h t l (21) Ef,tI ( w )  R.  2.
141  Let Q  =  Since [a,31 is ubiquitousfor u[l,41(R) x ~[2,3](R),  Example 6 Consider the temporal tableau queries r and U as follow!
;:  The main result of this paper can now be stated.
Theorem5 For each rooted SPCtlme query Q ( R ) , t a b ( Q ) Q.
For the non-temporal domain, it is well-known that satisfiable SPC queries and tableau queries are equivalent.
For the temporal domain, the expressive powers of satisfiable SPCt"e and temporal tableau queries do not coincide.
Then 0 = { ( U , z ) , (w,z ) } is a homomorphism of U to r under every f-t-valuation.
To see this, recall that [f,41 U [l,t] _> [l,41 (Theorem 2).
Hence, r E (T.On the other hand, the identity is a homomorphism of T to U under every f-t-valuation.
It follows r E U , Recall from Example 5 that U = t a b ( n l ( ~ [ ~ , 4 ] (xRq2,3l(R))), ) where R is arelaR)).
tion variable of arity 1.
Moreover, T = t ~ b ( a [ ~ , ~ ] ( By Theorem 5, it follows that T I (up,41(R) x r p 3 ]( R ) )can be equivalently rewritten (or "optimized") as u [,41~(R).
10.
Discussion Recall the questions asked in Section 1.
Can the construct of tableau query be generalized for temporal relations?
We have shown that two temporal variables (f and t ) are sufficient to express all rooted SPCtlmequeries.
Does the absence of the normal form in the temporal algebra hinder the "temporalizing" of tableau queries?
Somewhat surprisingly, even though a rooted SPCtlmequery can contain multiple nested projections none of which can be removed, its equivalent temporal tableau query needs no nesting.
Every projection leads to two tuples being inserted in the inductive constructionof Section 8, implying that the size of the equivalent tableau query is exponential in the number of projections of the original SPCtlmequery.
Our study revealed a number of open questions:  Theorem 6 There exists a satisJiableSPCtlmequery Q(R) that is equivalent to no temporal tableau query.
Theorem 7 There exists a temporal tableau query that is equivalent to no SPCtImequery.
9.
The Homomorphism Theorem We give a temporal variant of the famous Homomorphism Theorem and illustrate how it can be used for temporal query optimization.
Definition 13 Let B = ( T ,t ) and U = ( S ,s ) be two temporal tableau queries such that T and S have the same arity, as well as t and s. A homomorphism from U to r under f t-valuation p is a substitutione such that O(p(S)) 5 p ( T ) and O M S ) ) = 4 t ) .
Find a syntactic characterization of rooted queries (if it exists).
Characterize the class of all SPCtlmequeries that are equivalent to temporal tableau queries.
Is every SPCt"" query in that class equivalent to a rooted SPCt'mequery?
Theorem 8 Let r = ( T ,t ) and U = (S,s ) be two temporal tableau queries such that T and S have the same arity, as well as t and s. Then r C U i f f o r every f-t-valuation p, there exists a homomorphismfrom U to T under p.  Extend the construct of temporal tableau query so that it can also express all unrooted queries (cf.
Theorem 6).
This seems to imply tableaux that can accommodate a variable number of tuples.
Extend the SPCt'"" algebra so that it can express all temporal tableau queries (cf.
Theorem 7).
In the following example, Theorem 8 is used for temporal query optimization.
142  4.
Find procedures to (1) determine whether a given tableau query is equivalent to some SPCtlmequery, and (2) build the equivalent SPCtlmequery if it exists.
[4] P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz.
Constraint query languages.Joumal of Computerand System Sciences, 51(1):26-52, 1995.
[5] A. Klug.
On conjunctive queries containing inequalities.
Joumal of the ACM, 35(1):146-160, 1988.
[6] N.A.
Lorentzos and Y. G. Mitsopoulos.
SQL Extensions for Interval Data.
IEEE Transactionson Knowledge and Data EnRineerinR,9(3):480-499, 1997.
[7] L. E. McKenzie, Jr. and R. T. Snodgrass.
Evaluation of relational algebras incorporating the time dimension in databases.
ACM Computing Surveys,23(4):501-543,1991.
[8] R. T. Snodgrass, editor.
The TSQL2 Temporal Query Language.
Kluwer Academic Publishers, 1995.
[9] R. T. Snodgrass.
Overview of Temporal Databases.
In C. Zaniolo,S .
Ceri, C. Faloutsos,R.
Snodgrass,V.
S .
Subrahmanian, and R. Zicari, editors,Advanced Database Systems, chapter 5, pages99-126.
Morgan Kaufmann, San Francisco, 1997.
[lo] R. T. Snodgrass.
TSQL2.
In C. Zaniolo, S .
Ceri, C. FaloutSOS, R. Snodgrass, V. S .
Subrahmanian, and R. Zicari, editors, AdvancedDatabaseSystems, chapter 6, pages 127-147.
Morgan Kaufmann, San Francisco, 1997.
[ l l ] D. Toman.
Point-Based Temporal Extensions of SQL and Their Efficient Implementation.
In 0.
Etzion, S .
Jajodia, and S .
Sripada, editors, TemporalDatabases: Researchand Practice, volume 1399 of Lecture Notes in Computer Science, pages 21 1-237.
Springer-Verlag, 1998.
5.
Given two temporal tableau queries c and  T, find an algorithm to decide whether there exists a homomorphism from n to T under every f -t -valuation.
We conclude with a number of open-ended considerations that deserve future attention.
Timestamping in temporal tableau queries is effectuated by intervals.
An alternative approach would be to use point based timestamping extended with inequality constraints for representing intervals.
In [5] and [4], the extension of tableau queries with inequality comparisons is studied in a general setting that does not focus on time.
Interestingly,for general inequality comparisons, query containment does not imply the existence of a homomorphism.
Note that Theorem 8 does not quite express the "homomorphism property" for temporal tableau queries, as our construct of homomorphism is still relative to the concept o f f -t-valuation.
We used discrete time and closed intervals.
The extension to dense time requires the introduction of open intervals.
For example, consider the temporal tableau query T = (T,t) and the temporal relation I:  I 2  [fl  tl  *I  When temporal variables range over the real numbers, the answer r ( I )should be {(b,]5,9])}, showinga half-openinterval.
We only considered a single temporal dimension, representing valid time.
The extension with transaction time seems straightforward for queries that do not compare valid time with transaction time.
An interesting problem is to extend the current framework for queries where valid and transaction time are not independent.
Finally, it is interesting to ask whether temporal tableaux can serve as a unifyingframework for studying temporal dependencies, in the same way as classical tableaux provide a unified understanding of most non-temporal dependencies raised in the literature.
References Foundations of [l] S .
Abiteboul, R. Hull, and V. Vianu.
Databases.
Addison-Wesley, 1995.
[2] C. Date.
An Introduction to Database Systems.
AddisonWesley, seventh edition, 2000.
[3] D. Dey, T. M. Barron, and V. C. Storey.
A complete temporal relational algebra.
VLDB Joumal: Very Large Data Bases, 5(3): 167-1 80,1996.
143