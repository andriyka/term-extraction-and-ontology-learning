Fixing the Semantics for Dynamic Controllability and Providing a More Practical Characterization of Dynamic Execution Strategies Luke Hunsberger Vassar College Poughkeepsie, NY 12604-0444 USA hunsberg@cs.vassar.edu  Abstract Morris, Muscettola and Vidal (MMV) presented an algorithm for checking the dynamic controllability (DC) of temporal networks in which certain temporal durations are beyond the control of the planning agent.
Their DC-checking algorithm is based on rules for inferring new constraints based on the real-time context within which execution decisions must be made.
This paper presents a counter-example to demonstrate that some of the inference rules are, in fact, not sound.
The paper fixes the problem by strengthening the definition of dynamic execution strategies to correctly capture the central prohibition against advance knowledge of future events.
The new definition enables MMV's soundness proof to go through with minimal changes.
It then uses the stronger definition to derive an equivalent, alternative characterization of dynamic execution strategies that highlights the real-time execution decisions that a planning agent must make.
The procedural strategy used by MMV in their completeness proof is shown to satisfy the stronger definition, thus ensuring that the DC-checking algorithm is also complete with respect to the stronger definition.
As a result, the paper puts MMV's DC-checking algorithm on a more solid theoretical foundation, while also providing a more practical characterization of dynamic execution strategies.
1.
Introduction Dechter et al.
[1] introduced Simple Temporal Networks (STNs), a practical formalism for representing and managing time-points and temporal constraints.
Vidal and Ghallab [8] argued that certain processes are only initiated by a planning agent, but their durations are beyond the agent's control.
They augmented STNs to include contingent constraints and defined the controllability of such networks.
Vidal and Fargier [6, 7], and later Vidal [5], presented more concise definitions of networks with contingent  constraints--called Simple Temporal Networks with Uncertainty (STNUs)--and three kinds of controllability: weak, strong and dynamic.
Of these, dynamic controllability has the most practical use.
Loosely speaking, a network is dynamically controllable (DC) if there exists a dynamic execution strategy (DES) that an agent can use to execute the time-points under its control that will guarantee the consistency of the network no matter how the contingent durations turn out.
Crucially, a DES is not allowed to depend on advance knowledge of future events.
In particular, real-time execution decisions cannot depend on the values of contingent durations that have not yet completed.
Morris, Muscettola and Vidal [3]--henceforth MMV-- further refined the semantics of dynamic controllability and presented a pseudo-polynomial-time algorithm for checking the dynamic controllability of arbitrary STNUs.
Their proof of the soundness of their DC-checking algorithm is based on rules for inferring new constraints that reflect the real-time context within which execution decisions must be made.
Their completeness proof demonstrates that any network accepted by the algorithm has a viable DES.
Later, Morris and Muscettola [4] presented a more concise, O(n5 )-time DC-checking algorithm, and Morris [2] presented an even faster, O(n4 )-time algorithm.1 The correctness of the later algorithms is based on the MMV semantics and the correctness of the MMV algorithm; thus, this paper focuses on the MMV semantics and algorithm.
1.1.
This paper This paper begins by presenting a counter-example to the soundness of MMV's DC-checking algorithm.
The problem is two-fold.
First, MMV's definition of a DES--and hence of dynamic controllability--does not adequately capture the prohibition against advance knowledge of future events that lies at the heart of our pre-theoretic notion of dynamic controllability.
Second, MMV's soundness proof relies on a 1n  is the number of time-points in the network.
are as in an STN, and C [?]
E is a subset of the edges: the contingent links.
(The rest of the edges are called requirement links.)
For each contingent link, e [?]
C, the bounds are assumed to satisfy 0 < l(e) < u(e) < [?].
If e is a contingent link from A to C, then C is called a contingent time-point, and A is called the activation time-point for C. In this paper, contingent links are indicated as follows:  property of DESs that is not entailed by their definition.
The paper fixes the problem by augmenting MMV's definition of DES to include a stronger property that correctly captures the above-mentioned prohibition.
It then proves that MMV's soundness proof, with minimal changes, goes through using the new definitions.
No changes to the DCchecking algorithm are required; it is sound with respect to the new definitions.
Finally, the paper uses the new definition of dynamic execution strategies to derive a more practical, alternative characterization of such strategies.
The new characterization is based directly on the kinds of real-time execution decisions that a planning agent must make.
Each real-time decision has one of two forms.
They can be glossed as "wait until something happens" or "if nothing happens before time t , then execute the time-points in the set kh".
Such strategies can be derived using the sorts of incremental computations that are reflected in the procedural strategy used by MMV in their completeness proof.
This paper demonstrates that their procedural strategy satisfies the new definition of a dynamic execution strategy, thereby ensuring that the existing DC-checking algorithm is also complete with respect to the new definition of dynamic controllability.
Although some of the elements of the alternative characterization of strategies developed in this paper bear some similarity to notions defined by Vidal and Fargier [6, 7], they are quite distinct.
In addition, the strategies based on real-time execution decisions are novel, their properties are rigorously analyzed, and they are proven to be equivalent to the (revised) MMV definitions.
[l(e), u(e)] A  C  Let N c [?]
N denote the set of contingent time-points and N x = N - N c - {Z} the set of executable time-points.
To execute a time-point means to fix its value to the current time.
The planning agent directly controls the execution of only the executable time-points.
Nature is presumed to control the duration of each contingent link.
A contingent time-point, C, is said to be activated if its activation time-point, A, has been executed.
Situations and Projections.
Let N be an STNU whose contingent links are e1 , .
.
.
, eq and whose corresponding labels are [x1 , y1 ], .
.
.
, [xq , yq ].
The space of situations for N is the cross-product, N = [x1 , y1 ] x .
.
.
x [xq , yq ].
Each o [?]
N is called a situation.
Each situation specifies durations for all of the contingent links in N .
For a situation, o = (o1 , o2 , .
.
.
, oq ), the projection, No , is the STN (not STNU) derived from N by replacing each contingent link, ei , with a requirement link labeled by [oi , oi ], thereby fixing its duration to the value oi .
1.2.
Summary of MMV's approach  Schedules.
Given an STNU, N = hN, E, l, u, Ci, a schedule is a mapping T : N - R (i.e., a complete set of variable assignments for all of the time-points in N ).
For convenience, the shorthand Tt is used instead of T (t) to denote the time at which t is executed according to the schedule T .
The set of schedules for N is denoted by TN .
A schedule T is consistent with N (resp., a projection No ) if the assignments in T satisfy all of the constraints in N (resp., No ).
Henceforth, we restrict attention to schedules in which TAi < TCi for each contingent link, Ai Ci .
This section summarizes the definitions used by MMV, but also draws from Vidal [5] and Vidal and Fargier [7].
Simple Temporal Network (STN).
An STN is a 4-tuple, hN, E, l, ui, where N is a finite set of nodes (or timepoints), E is a set of directed edges, and l : E - R[?]{-[?]}
and u : E - R [?]
{[?]}
are functions that map edges to lower and upper bounds, respectively.
An edge, e [?]
E, from the time-point X to the time-point Y, represents the constraint, Y - X [?]
[l(e), u(e)], indicated as follows:  Pre-histories.
Given a schedule T for an STNU N , and a time-point x [?]
N , the pre-history of x with respect to T is:  [l(e), u(e)] X  Y  T<x = {(Ci , TCi - TAi ) : Ai Ci [?]
C, TCi < Tx } Thus, T<x specifies the durations of all contingent links that execute before x according to the schedule T .
The edges are also called links.
One of the time-points, called the zero time-point (or Z), is fixed at the value 0.
All other time-points are constrained to occur after Z.
Execution Strategies.
An execution strategy for an STNU N is a mapping, S : N - TN , from situations to schedules.2 S is called viable if for each situation o [?]
N ,  Simple Temporal Network with Uncertainty (STNU).
An STNU is a 5-tuple, hN, E, l, u, Ci, where N, E, l and u 2  [10, 20]  [10, 20]  C  A  (a)  C - B <= 15, should C happen to execute after time 15.
But executing B sometime after 0 risks violating the constraint, C - B >= 10, should C happen to execute at time 10.
For N !
, the DC-checking algorithm infers the (impossible) constraint, C - B [?]
[5, 0], and thus rejects N !
.
But the strategy, S !
, defined below, is a viable DES for N !
.
C  A B  [2, 15]  B  (b)  [-4, 7]  Figure 1.
Sample triangular networks C0  [10, 20]  [2, 3]  C  For any situation, o, if ZC <= 15 in o, let [S !
(o)]B = 0; otherwise, let [S !
(o)]B = 5.
[10, 15]  S !
clearly violates the important prohibition against decisions that depend on advance knowledge of future events.
In particular, the execution time for B, which must be chosen before C executes, depends on the execution time of C. However, this strategy is viable, since all of the schedules it generates are consistent with the corresponding projections.
Furthermore, it is a DES.
To see this, notice that the pre-history for any schedule that assigns B the value 0 is necessarily empty, but the pre-history for any schedule that assigns B the value 5 necessarily contains information about C0 --since ZC0 is constrained to occur within [2, 3].
Thus, any schedules having the same pre-histories for B assign the same value to B, which is what the DES definition requires.
Thus, according to MMV's definition, N !
is DC, although the DC-checking algorithm rejects it.
Thus, N !
contradicts the soundness of the DC-checking algorithm.
This counter-example employs what should be an irrelevant contingent time-point, C0 , to take advantage of a loophole in the DES definition.
The presence of C0 causes the different sets of schedules to have different pre-histories for B, thereby escaping the main DES requirement.
In so doing, the execution time of B is allowed to depend on advance knowledge of the future execution of C. In view of this contradiction, MMV's proof of the soundness of the DC-checking algorithm must have an error.
In particular, their proof depends on the following claim:3  B  Z  Figure 2.
A counter-example, N !
the schedule S(o) is consistent with the projection No .
S is called a dynamic execution strategy (DES) for N if [S(o 0 )]<x = [S(o 00 )]<x  ==  [S(o 0 )]x = [S(o 00 )]x  for all situations, o 0 , o 00 , and executable time-points, x.
Thus, if two schedules generated by a DES have identical pre-histories for x, they must assign the same value to x.
Dynamic Controllability.
An STNU, N , is dynamically controllable (DC) if there exists a viable DES for N .
The DC-Checking Algorithm.
MMV's DC-checking algorithm infers constraints that any viable DES must satisfy.
Some of the constraints are ternary constraints, called waits.
For example, the networks in Fig.
1 each contain a contingent link, AC, and a requirement link, BC.
For (a), the DC-checking algorithm infers the constraint, B-A [?]
[5, 8].
For (b) it infers a wait: while C is unexecuted, B must wait until at least 13 units after A (i.e., B - A >= 13).
The algorithm also propagates waits.
MMV prove that the rules for generating and propagating waits are sound (i.e., the resulting waits must be satisfied by any viable DES).
They also prove that any STNU accepted by the algorithm has a viable DES (i.e., that the algorithm complete).
2  Let S be a DES, o a situation, t 6= C a time-point, and AC a contingent link where C 6[?]
[S(o)]<t .
Let o 0 be a situation that differs from o only in its value for the duration of AC--but such that C 6[?]
[S(o 0 )]<t .
Then [S(o 0 )]t = [S(o)]t .
Counter-example  Although this property holds in the case of triangular networks, it does not hold for N !
.
In particular, S !
is a DES, o = (2, 10) is a situation (i.e., C0 = 2, C = 10), [S !
(o)]B = 0, and C 6[?]
[S !
(o)]<B = [?].
However, o 0 = (2, 20) is a situation that differs only in the value it assigns to C, C 6[?]
[S !
(o 0 )]<B = {(C0 , 2)}, and yet [S !
(o 0 )]B = 5 6= 0 = [S !
(o)]B .
The STNU, N !
, shown in Fig.
2, contains two contingent links--ZC0 and ZC--and one requirement link: BC.
Since Z is fixed at 0, the duration of ZC is the same as the value of C; and the duration of ZC0 equals the value of C0 .
N !
does not satisfy our intuitive notion of dynamic controllability since there is no safe time to execute B.
For example, executing B at time 0 risks violating the constraint,  3 In  MMV's discussion of the Precede case: "Since C is not in T<B or T<A , TB cannot depend on AC.
Therefore TA and TB are unchanged if the projection is mutated to a projection p0 where AC equals y."
A similar assumption is made in their Lemma 1, which covers propagation of waits.
2 MMV define strategies as mappings from projections to schedules, not  situations to schedules.
However, since situations correspond one-to-one to projections, this difference is purely superficial.
3  3.
Closing the loophole  of generality, let Ci be a contingent time-point such that [S(o 0 )]Ci = k0 , but [S(o 00 )]Ci > k0 .
Let Ai be the activation time-point for Ci .
Then [S(o 0 )]Ai < [S(o 0 )]Ci = k0 implies that [S(o 0 )]Ai = [S(o 00 )]Ai , by the choice of k0 .
The problem with the DES definition is that it compares pre-histories relative to time-point variables.
The revised DES definition, given below, instead compares pre-histories relative to fixed times, k [?]
R. To facilitate comparison, the revised definitions for DES and DC are marked by asterisks.
Lemma 2.
If S is a DES* for N , then it is a DES for N .
Proof 2.
Suppose [S(o 0 )]<x = [S(o 00 )]<x for some o 0 and o 00 , and executable x.
Let k0 , Ai and Ci be as in Lemma 1.4 Since S(o 0 ) and S(o 00 ) agree about Ai , but not Ci , it follows that Ci 6[?]
[S(o 0 )]<x = [S(o 00 )]<x .
Thus, Ci occurs at or after x in both S(o 0 ) and S(o 00 ).
Thus, x occurs before k0 in both.
Thus, [S(o 0 )]x = [S(o 00 )]x .
Pre-histories relative to a number k. Given an STNU N , a schedule T , and some k [?]
R, then T <k denotes the pre-history of T relative to k, which specifies the durations of the contingent links in N that finish before k in T : T <k = {(Ci , TCi - TAi ) : Ai Ci [?]
C, TCi < k}  Lemma 3.
Suppose [S(o 0 )]<k = [S(o 00 )]<k for a DES* S, and some k, o 0 and o 00 .
Then for all time-points t, if [S(o 0 )]t < k or [S(o 00 )]t < k, then [S(o 0 )]t = [S(o 00 )]t .
Furthermore, for all executable time-points x, if [S(o 0 )]x <= k or [S(o 00 )]x <= k, then [S(o 0 )]x = [S(o 00 )]x .
Thus, if S(o 0 ) and S(o 00 ) have the same pre-histories relative to k, then they must agree about the execution times of all time-points before k, and all executable time-points at k.  Dynamic Execution Strategy* .
A strategy, S, is called a dynamic execution strategy* (DES* ) if for any situations, o 0 , o 00 [?]
N , and executable time-point x in N : if [S(o 0 )]x = k and [S(o 0 )]<k = [S(o 00 )]<k , then [S(o 00 )]x = k. In other words, if the strategy S in the situation o 0 assigns the value k to the executable time-point x, then S must also assign k to x for any other situation o 00 whose pre-history relative to k matches that of o 0 .
Proof 3.
Let k0 , Ai and Ci be as in Lemma 1.
By choice of k0 , S(o 0 ) and S(o 00 ) agree about all executions before k0 .
If k0 < k, then Ci executes before k in S(o 0 ) or S(o 00 ).
But then Ci [?]
[S(o 0 )]<k = [S(o 00 )]<k , which implies [S(o 0 )]Ci = [S(o 00 )]Ci , contradicting the choice of Ci .
Thus, k <= k0 , and S(o 0 ) and S(o 00 ) agree about all timepoints executing before k. Finally, suppose [S(o 0 )]x = k or [S(o 00 )]x = k for some executable x.
If k < k0 , then [S(o 0 )]x = [S(o 00 )]x by the choice of k0 ; if k = k0 , then [S(o 0 )]x = [S(o 00 )]x by Lemma 1.
Dynamic Controllability* .
An STNU is called dynamically controllable* (DC* ) if there is a viable DES* for it.
Although the strategy, S !
, is a DES for the network, N !
, it is not a DES* .
To see this, first note that [S !
(o)]<0 = [?]
for all situations o, since no contingent time-point can execute before 0.
Next, note that for some o 0 , [S !
(o 0 )]B = 0.
Thus, for S !
to be a DES* would require [S !
(o)]B = 0 for all situations o.
However, for some o 00 , [S !
(o 00 )]B = 5.
In general, being a DES* requires a strategy to make the same decisions about executable time-points in the same real-time contexts.
As will be shown subsequently, the existing DC-checking algorithm is both sound and complete with respect to the new DES* and DC* definitions.
Lemma 4 shows that the DES* definition correctly captures the prohibition against advance knowledge of future events, which is the property on which MMV based their soundness proof for their DC-checking algorithm.
Lemma 1.
Let S be a DES* , and o 0 and o 00 situations such that S(o 0 ) 6= S(o 00 ).
Let k0 [?]
R be the first time at which S(o 0 ) and S(o 00 ) differ.
Then S(o 0 ) and S(o 00 ) agree about which executable time-points execute at k0 ; however, for some contingent link, Ai Ci , one of S(o 0 ) and S(o 00 ) says Ci executes at k0 , while the other says Ci executes after k0 .
In any case, [S(o 0 )]Ai = [S(o 00 )]Ai < k0 .
Lemma 4.
Let S be a DES* , o a situation, t 6= C a timepoint, and AC a contingent link such that C 6[?]
[S(o)]<t .
If o 0 is the same as o, except that the duration of AC is changed, and C 6[?]
[S(o 0 )]<t , then [S(o 0 )]t = [S(o)]t .
Proof 4.
Let k0 , Ai and Ci be as in Lemma 1.
Thus, S(o) and S(o 0 ) disagree about the duration of Ai Ci .
Thus, AC must be the link Ai Ci .
Without loss of generality, suppose [S(o)]C = k0 and [S(o 0 )]C > k0 .
Since C 6[?]
[S(o)]<t , C must occur at or after t in S(o) (i.e., [S(o)]t <= k0 ).
If t is executable, or if t is contingent with [S(o)]t < k0 , then  Proof 1.
By construction, [S(o 0 )]<k0 = [S(o 00 )]<k0 which, given that S is a DES* , implies that S(o 0 ) and S(o 00 ) agree about the executable time-points that execute at k0 .
Thus, S(o 0 ) and S(o 00 ) can only disagree about the execution of contingent time-points at k0 .
Without loss  4 Proofs  4  of Lemmas 2, 3, 4 and 8 ignore trivial case, S(o 0 ) = S(o 00 ).
[S(o)]t = [S(o 0 )]t by Lemma 1.
If t is contingent with [S(o)]t = k0 , then S(o) and S(o 0 ) must agree about the execution of t's activation time-point.
Furthermore, since t 6= C, S(o) and S(o 0 ) must agree about the duration of the contingent link ending in t. Thus, [S(o)]t = [S(o 0 )]t .
T (t), is also used for partial schedules.
For convenience, T may be viewed as a set of elements of the form, (t, Tt ).
Let u(T ) = max{Tt : t [?]
Dom(T )} denote the maximum execution (MaxEx) time of time-points appearing in T .
If t 6[?]
Dom(T ), then t is unexecuted in T .
The set of time-points that are unexecuted in T is denoted by U (T ).
Similarly, U x (T ), U c (T ) and U a (T ) respectively denote the sets of executable, contingent and activated time-points that are unexecuted in T .
Note that U a (T ) [?]
U c (T ), since only contingent time-points can be activated.
Corollary 4.1.
MMV's DC-checking algorithm is sound with respect to the definitions of DES* and DC* .
4.
Alternative Characterization of a DES*  Respect.
Let T be a (possibly partial) schedule* for an STNU N .
Let o = (o1 , .
.
.
, oq ) [?]
N .
T respects o if for each contingent link, Ai Ci , one of the following holds:  Defining strategies as mappings from (complete) situations to (complete) schedules obscures the real-time features of typical execution scenarios.
For example, an agent typically becomes aware of the unfolding situation only incrementally, over time.
As more contingent durations complete, the space of possible situations contracts.
In addition, when making real-time execution decisions, an agent knows the execution times of only those time-points that have already executed.
Finally, the DES* definition obscures the kinds of execution decisions an agent can make.
This section introduces partial schedules to represent not only the contexts within which an agent must make realtime execution decisions, but also the outcomes of those decisions.
A partial schedule specifies the execution times of some, but not all of the time-points.
However, since partial schedules represent what has actually happened so far, it is important to restrict attention to partial schedules that respect (i.e., are consistent with) at least one situation.
Two kinds of real-time execution decisions (RTEDs) are defined: WAIT and (t, kh).
These can be glossed as: "Wait until some contingent duration completes" or "If nothing happens before t , then execute the (executable) time-points in kh."
The outcome of an RTED depends on the situation, and is represented by a partial schedule that specifies the execution of one or more additional time-points.
The outcome of a WAIT decision involves the execution of only contingent time-points; the outcome of a (t, kh) decision can involve the execution of contingent or executable time-points.
An RTED-based strategy is defined as a mapping from partial schedules to real-time execution decisions.
This section proves that RTED-based strategies correspond one-toone to DES* s. In addition, an RTED-based strategy is used to verify that MMV's DC-checking algorithm is complete with respect to the new DES* and DC* definitions.
(1) neither Ai nor Ci appear in T ; (2) only Ai appears in T , and TAi + oi > u(T ); or (3) both Ai and Ci appear in T , and TAi + oi = TCi .
For each T , the set of situations respected by T is denoted by (T ).
T is called respectful if it respects at least one situation in N (i.e., if (T ) 6= [?]).
If T is both respectful and partial, it is called a respectful, partial schedule (RPS).
A strategy S is respectful if for each o, S(o) respects o.5 The WAIT Decision.
Let T be some RPS for N such that U a (T ) is non-empty (i.e., there is at least one contingent time-point that is activated, but not yet executed in T ).
Then WAIT is an allowable RTED for T .
The Outcome of a WAIT Decision.
If U a (T ) 6= [?]
and o [?]
(T ) is a situation respected by T , then the time at which the next contingent time-point will execute (according to T and o) is defined by: tnc(T , o) = min{TAi + oi : Ci [?]
U a (T )} Since U a (T ) 6= [?
], tnc(T , o) is well defined; and since T respects o, tnc(T , o) > u(T ).
Next, let kha (T, o) [?]
U a (T ) denote the non-empty set of activated contingent time-points that, according to T and o, will execute next, at the time tnc(T , o): kha (T, o) = {Ci [?]
U a (T ) : TAi + oi = tnc(T , o)} Then O(T, o, WAIT) denotes the outcome of the WAIT decision for T in the situation o, which is defined to be: T [?]
{(Ci , tnc(T , o)) : Ci [?]
kha (T , o)} Note that O(T, o, WAIT) is a schedule* that augments T to include all of the contingent time-points that execute at the time, tnc(T , o).
Thus, the MaxEx time for this outcome is tnc(T , o).
In addition, T [?]
O(T, o, WAIT).
Schedules* .
Given an STNU, N = hN, E, l, u, Ci, a schedule* is a (possibly partial) mapping T : N - R. Let Dom(T ) [?]
N denote the domain of T .
If Dom(T ) = N , then T is a (complete) schedule as previously defined; otherwise, T is a partial schedule.
If t [?]
Dom(T ), then t is said to appear in T .
The shorthand notation, Tt instead of  5 A viable strategy is necessarily respectful since S(o) being consistent with No requires S(o) to respect all durations in o; however, a respectful strategy need not be viable, since it need not satisfy all constraints in N .
5  A (t, kh) Decision.
Let T be some RPS for N such that U x (T ) is non-empty (i.e., at least one executable time-point is unexecuted in T ).
If t > u(T ) and kh is a non-empty subset of U x (T ), then (t, kh) is an allowable RTED for T .
Lemma 6.
Let R be an RTEDS, and o some situation.
Then R and o determine a unique sequence of schedules* , T 0 = {(Z, 0)} [?]
T 1 [?]
T 2 [?]
.
.
.
[?]
T a where for each i < a, T i is partial and respects o, T i+1 = O(T i , o, R(T i )), and u(T i ) < u(T i+1 ); and where T a is a complete schedule that respects o.
The Outcome of a (t, kh) Decision.
Let o [?]
(T ) be a situation respected by T .
Then O(T, o, (t, kh)) denotes the outcome of the decision, (t, kh), for T in the situation o.
The outcome depends on the relationship between the numbers tnc(T , o) and t .
For simplicity, let t c = tnc(T , o), and let kha = kha (T, o).
(If U a (T ) = [?
], let t c = [?].)
If t c < t , the outcome involves the execution of only the (contingent) time-points in kha ; if t < t c , the outcome involves the execution of only the (executable) time-points in kh; if t c = t , the outcome involves the execution of the time-points in both kha and kh.
In particular, O(T, o, (t, kh)) is defined by:  if t c < t  T [?]
{(C, t c ) : C [?]
kha }, T [?]
{(x, t ) : x [?]
kh}, if t < t c  T [?]
{(C, t c ) : C [?]
kha } [?]
{(x, t ) : x [?]
kh}, if t c = t  Proof 6.
Given some T i and o, the outcome T i+1 = O(T i , o, R(T i )) deterministically augments T i to include the execution of at least one more time-point.
Thus, the sequence is unique and terminates in a complete schedule, T a .
Furthermore, u(T i ) < u(T i+1 ).
Finally, since T 0 respects all situations, including o, Lemma 5 inductively ensures that each T i , including T a , respects o. Lemma 7.
Any DES* S and situation o together determine a unique sequence of schedules* , s0 = {(Z, 0)} [?]
s1 [?]
s2 [?]
.
.
.
[?]
sb = S(o) where u(s0 ) < u(s1 ) < .
.
.
< u(sb ), and for each i < b, the time-points that appear in si+1 - si are all executed at the time u(si+1 ).
This sequence of schedules* is henceforth called the signature sequence of schedules* for S(o).
If S(o) respects o, then each si respects o.
Note that the MaxEx time of the outcome is min{t c , t }.
In addition, T [?]
O(T, o, (t, kh)).
Lemma 5.
If T is a partial schedule that respects the situation o, and d is an RTED that is allowed for T , then the outcome O = O(T, o, d) also respects o.
Proof 7.
The schedule S(o) involves |N | execution events, some of which may occur simultaneously.
Let 0 = t0 < .
.
.
< tb be the distinct times of those events, where b <= |N |.
For each i, let si+1 = si [?]
{(t, [S(o)]t ) : [S(o)]t = ti+1 }.
Then u(si ) = ti for each i <= b.
If S(o) respects o, then it satisfies condition (3) of respect for each contingent link, implying that each si [?]
S(o) respects o.
Proof 5.
Let Ai Ci be some contingent link.
Case 1: Neither Ai nor Ci appear in T .
Thus, Ci 6[?]
U a (T ) and Ci is unexecuted in O.
If Ai is still unexecuted in O, then condition (1) of the definition of respect is satisfied; otherwise, condition (2) is satisfied, since oi > 0.
Case 2: Ai appears in T , but not Ci (i.e., Ci [?]
U a (T )).
Suppose Ci [?]
kha (T, o).
If d is the WAIT decision or d = (t, khc ) and tnc(T , o) <= t , then Ci is executed in O and condition (3) in the definition of respect is satisfied, since TAi + oi = tnc(T , o).
Otherwise, Ci is not executed in O and condition (2) is satisfied, since t < tnc(T , o).
On the other hand, if Ci 6[?]
kha (T, o), then Ci will not execute until after tnc(T , o).
Thus, Ci is not executed in O and condition (2) is satisfied.
Case 3: Ai Ci is finished and respected by T .
Thus, Ai Ci is finished and respected by the outcome, O [?]
T .
Reachable schedules.
Let S be a respectful DES* and o a situation.
Let s0 [?]
.
.
.
[?]
sb be the signature sequence of schedules for S(o).
Each si is called reachable by S(o).
R(S(o)) = {si : i < b} denotes the S set of reachable partial schedules for S(o).
R(S) = o[?]
R(S, o) denotes the set of reachable partial schedules for the strategy S. By Lemma 7, each s [?]
R(S) respects at least one situation.
Lemma 8.
Let S be a respectful DES* .
If T is reachable by S(o 0 ), and T respects o 00 , then T is reachable by S(o 00 ).
Proof 8.
Let {si0 } and {si00 } be the signature sequences of schedules* for S(o 0 ) and S(o 00 ), respectively.
Let j be the smallest index for which sj0 6= sj00 .
Since T is reachable by S(o 0 ), T = si0 for some i.
Case 1: T = si0 for some i < j.
But then T = si00 and, hence, is reachable by S(o 00 ).
RTED-based Strategy (RTEDS).
An RTED-based strategy for an STNU, N , is a mapping, R, from respectful partial schedules to real-time execution decisions.
Thus, if T is a partial schedule that respects at least one situation, then R(T ) is a real-time execution decision for T .
6  Case 2: T = si0 for some i >= j.
Thus, sj0 [?]
T .
Since T respects o 00 , so does sj0 .
And sj00 respects o 00 by Lemma 7, since S is respectful.
Let u = min{u(sj0 ), u(sj00 )}.
By construction, u is the first time at which sj0 and sj00 differ.
Thus, [S(o 0 )]<u = [sj0 ]<u = [sj00 ]<u = [S(o 00 )]<u .
Since S is a DES* , this implies that S(o 0 ) and S(o 00 ) agree about which executable time-points execute at u.
But since both sj0 and sj00 respect o 00 , they cannot disagree about the execution times for any contingent time-points at u.
Thus, sj0 = sj00 , which contradicts the choice of j.
Proof A.
Let S be a respectful DES* .
Define a mapping R from RPSs to RTEDs, as follows.
First, if T is reachable for S (i.e., T [?]
R(S)): * If x (T ) = [?
], then let R(T ) = WAIT.
* If x (T ) 6= [?
], then let R(T ) = (t x , kh), where t x is the time of the next execution event for any o [?]
x (T ), and kh is the set of executable time-points that execute at the time t x in any such o.
The uniqueness of t x and kh is guaranteed by Lemma 9; thus, R(T ) is well-defined for T [?]
R(S).
For any other respectful partial schedule, T , if U a (T ) is non-empty, let R(T ) = WAIT; otherwise, let R(T ) = (u(T ) + 1, {x}), where x is some time-point in U x (T ).
Finally, for any situation o, let s0 [?]
.
.
.
[?]
sb = S(o) be the signature sequence of schedules* for S(o); and let T 0 [?]
.
.
.
[?]
T a be the unique sequence of outcomes determined by R and o.
It suffices to show that a = b and T i = si for each i--and hence that T a = sb = S(o).
Base Case: s0 = {(Z, 0)} = T 0 .
Recursive Case: si = T i for some i < a.
Then T i is reachable for S, and [T i ]t = [S(o)]t for all t [?]
Dom(T i ).
Thus, for any Cj [?]
U a (T i ), TAi j + oj = [S(o)]Aj + oj = [S(o)]Cj .
If x (T i ) = [?
], then R(T i ) = WAIT and o [?]
c (T i ), which implies that U a (T i ) 6= [?].
Thus, tnc(T i , o) = min{[S (o)]Cj : Cj [?]
U a (T i )} equals t c , the time of the next contingent execution event in S(o), and kha (T i , o) is the set of contingent time-points executing at that time in S(o).
Thus, the outcome, T i+1 , equals si+1 .
However, if x (T i ) 6= [?
], then R(T i ) = (t x , kh).
If o [?]
x (T i ), then the outcome includes the execution of the time-points in kh.
Otherwise, o [?]
c (T i ), and t c < t x implies that the outcome involves the execution of contingent time-points as in the WAIT case.
In either case, the outcome agrees with S(o), implying that T i+1 = si+1 .
Corollary 8.1.
Let T [?]
R(S) be a reachable partial schedule for a respectful DES* S. For any o 0 , o 00 [?]
(T ), T is reachable for S(o 0 ) and S(o 00 ).
Thus, the signature sequences for S(o 0 ) and S(o 00 ) are the same up to T , and hence for each t [?]
Dom(T ), [S(o 0 )]t = Tt = [S(o 00 )]t .
The sets c (T ) and x (T ).
For each T [?]
R(S), let c (T ) denote the set of situations, o [?]
(T ), such that the next execution event in S(o) after u(T ) involves only contingent time-points; and let x (T ) denote the set of situations, o [?]
(T ), such that the next execution event in S(o) after u(T ) involves at least one executable time-point.
Note that (T ) = c (T ) [?]
x (T ).
Lemma 9.
Suppose T [?]
R(S) for a respectful DES* S. If o 0 , o 00 [?]
x (T ), then the time of the next execution event after u(T ) is the same for S(o 0 ) and S(o 00 ).
Call that time t x .
Also, the sets of executable time-points that execute at t x in S(o 0 ) and S(o 00 ) are the same.
Finally, if o c [?]
c (T ), then the time, t c , of the next contingent execution after u(T ) according to S(o c ) is less than t x .
Proof 9.
Let t 0 and t 00 be the times of the next execution events after u(T ) in the schedules S(o 0 ) and S(o 00 ), respectively.
Suppose t 0 <= t 00 .
By Corollary 8.1, S(o 0 ) and S(o 00 ) are the same up to the time u(T ).
Thus, by construc0 0 tion, [S(o 0 )]<t = [S(o 00 )]<t .
Thus, by Lemma 3, S(o 0 ) and S(o 00 ) must agree on all executable time-points that execute at t 0 , which implies that t 0 = t 00 .
Let t x = t 0 = t 00 .
x x Suppose t c >= t x .
Then [S(o 0 )]<t = [S(o c )]<t 0 c which, by Lemma 3, implies that S(o ) and S(o ) must agree on all executable time-points that execute at or before time t x , contradicting the choice of o c [?]
c (T ).
Theorem B.
Each RTEDS is a respectful DES* .
Proof B.
Let R be any RTED-based strategy for N .
Given any o, define SR (o) to be the terminal schedule in the unique sequence of outcomes determined by R and o which, by Lemma 6, is guaranteed to respect o.
Let o 0 , o 00 be a pair of situations for which the DES* property fails.
Let k be the earliest time of such a failure.
Thus, for some executable x, k = [SR (o 0 )]x and [SR (o 0 )]<k = [SR (o 00 )]<k , but [SR (o 00 )]x 6= k. Let {T1j } and {T2j } be the sequences of outcomes determined by following R in the situations o 0 and o 00 , respectively.
Let T1i+1 and T2i+1 be the first pair of outcomes in these sequences that differ.
Thus, T1i = T2i .
Hence, the governing decision at step i was the same: R(T1i ) = R(T2i ).
Theorem A.
Let S be a respectful DES* for N .
Then there exists an RTED-based strategy, R, that is equivalent to S in the sense that for each situation o [?]
N , the signature sequence of schedules* for S(o) is identical to the unique sequence of outcomes determined by R and o.
7  Let T = {(Z, 0)} be the initial partial schedule.
If U (T ) = [?
], then DONE!
If U x (T ) = [?
], let d(T ) = WAIT.
Go to Step 4.
For each x [?]
U x (T ), let [m(x), M (x)] be the current time-window for x in N .
If every contingent link, Ai Ci , for which x has a wait, w(Ai , Ci , x), is activated in T , let W (x) = max{TAi + w(Ai , Ci , x) : Ci [?]
U a (T )}; otherwise, let W (x) = [?].
Let floor (x ) = max{m(x ), W (x )} and go(x ) = min{floor (x ), M (x )}.
Let d(T ) = (t x , kh), where t x = min{go(x ) : x [?]
U x (T )} and kh = {x [?]
U x (T ) : t x = go(x )}.
4.
If d(T ) = WAIT, then wait until some contingent time-point executes.
Otherwise, d(T ) = (t x , kh).
If nothing happens before time t x , then execute the time-points in kh; otherwise, observe the contingent time-points executed at some t c < t x .
5.
Update T to include the execution events from Step 4.
Update N to include the corresponding constraints.
Go to Step 1.
0.
1.
2.
3.
required.)
floor (x ) is the earliest time x can be executed without violating its lower bound, m(x), or any of its relevant waits.
go(x ) is the same except that it enforces the constraint that x not violate its upper bound, M (x).
(MMV, in effect, prove that a conflict between floor (x ) and M (x) is not possible for an STNU accepted by their algorithm.)
In Step 4, the agent waits to see what the outcome of the decision d(T ) will be.
In Step 5, the agent updates T and N to reflect that outcome, before returning to Step 1.
Eventually, the procedure terminates when all of the timepoints have been executed.
For any situation, o, the procedure in Fig.
3 leads the agent through the characteristic sequence of outcomes described in Lemma 6.
Thus, it determines an RTED-based strategy which, by Theorem A, is necessarily a DES* .
Therefore, the strategy generated by MMV's procedure is necessarily a DES* .
Thus, their proof that that strategy is viable ensures that their DC-checking algorithm is complete with respect to the definitions of DES* and DC* .
Figure 3.
MMV's strategy as an RTEDS Let u = min{u(T1i ), u(T2i )}.
Note that u is the earliest time at which SR (o 0 ) and SR (o 00 ) differ.
Case 1: u < k. Then the DES* property holds at u and [SR (o 0 )]<u = [SR (o 00 )]<u implies, by Lemma 3, that SR (o 0 ) and SR (o 00 ) agree about all executable time-points at u, and all time-points before u.
But then [SR (o 0 )]<k = [SR (o 00 )]<k implies that SR (o 0 ) and SR (o 00 ) agree on all contingent time-points at u, too, contradicting choice of u.
Case 2: k <= u.
Then SR (o 0 ) and SR (o 00 ) agree about all time-points before k. Since x is executed at k in SR (o 0 ), the decision R(T1i ) = R(T2i ) must have been (k, kh) for some kh containing x.
But then T2i+1 must be an outcome at time k, which implies that x [?]
kh is also executed in T2i+1 at time k, contradicting that [SR (o 00 )]x 6= k.  5.
Conclusions This paper fixed a technical flaw in MMV's semantics for dynamic controllability.
It presented an alternative characterization of strategies based on real-time decisions and showed that MMV's existing DC-checking algorithm is sound and complete with respect to the revised semantics.
References [1] R. Dechter, I. Meiri, and J. Pearl.
Temporal constraint networks.
Artificial Intelligence, 49:61-95, 1991.
[2] P. Morris.
A structural characterization of temporal dynamic controllability.
In Principles and Practice of Constraint Programming (CP 2006), volume 4204 of Lecture Notes in Computer Science, pages 375-389.
Springer, 2006.
[3] P. Morris, N. Muscettola, and T. Vidal.
Dynamic control of plans with temporal uncertainty.
In 17th Int'l.
Joint Conf.
on Artificial Intelligence (IJCAI-01), pages 494-499, 2001.
[4] P. H. Morris and N. Muscettola.
Temporal dynamic controllability revisited.
In 20th National Conference on Artificial Intelligence (AAAI-2005), pages 1193-1198, 2005.
[5] T. Vidal.
A unified dynamic approach for dealing with temporal uncertainty and conditional planning.
In Fifth International Conference on Artificial Intelligence Planning Systems (AIPS-2000), pages 395-402, 2000.
[6] T. Vidal and H. Fargier.
Contingent durations in temporal csps: from consistency to controllabilities.
In Proceedings of the TIME-97 Workshop, 1997.
[7] T. Vidal and H. Fargier.
Handling contingency in temporal constraint networks: from consistency to controllabilities.
Journal of Experimental and Theoretical Artificial Intelligence, 11(1):23-45, 1999.
[8] T. Vidal and M. Ghallab.
Temporal constraints in planning: Free or not free?
In CONSTRAINT '95 Workshop, 1995.
RTED-based Version of MMV's Verification Strategy.
To prove that any STNU accepted by their DC-checking algorithm is dynamically controllable, MMV presented not a mapping from situations to schedules, but a procedure for incrementally generating a single schedule in response to the unfolding situation.
Space limitations preclude duplicating that procedure here.
Instead, Fig.
3 presents an equivalent procedure for generating real-time execution decisions.
Although the computations are equivalent, they are structured around partial schedules and RTEDs.
The procedure in Fig.
3 starts with an initial partial schedule, T = {(Z, 0)}.
It then computes an RTED, d(T ), in Step 2 or Step 3, as follows.
If all executable time-points have already been executed, then d(T ) = WAIT (Step 2).
Otherwise, d(T ) = (t x , kh) based on the values for t x and kh computed in Step 3.
These values are based on the current time-windows for the as-yet-unexecuted executable timepoints, which can be computed using an all-pairs, shortestpath algorithm.
(No generation or propagation of waits is 8