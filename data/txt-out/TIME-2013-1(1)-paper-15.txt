2013 20th International Symposium on Temporal Representation and Reasoning  Complexity of Model Checking over General Linear Time Tim French, John Mc Cabe-Dansted and Mark Reynolds School of Computer Science and Software Engineering The University of Western Australia 35 Stirling Highway, Crawley WA 6009 Perth, Australia.
Email: {tim.french,john.mccabe-dansted,mark.reynolds}@uwa.edu.au with discrete points.
If a sentence of natural language or some strange formalism can determine the behaviour of a signal over a linear order, we can check it.
Our second generalisation is more important.
Timed automata are tremendously useful mathematical objects for veridZcation and design tasks [4], [5] but there are many properties exhibited in the real continuous world that do not seem amenable to easy modelling by their fundamental discrete step by step action.
To name just a few consider the following: the approach of Achilles to Zenoas Tortoise [6]; a fractal signal [7] (see Figure 1); the indZnitesimal chattering of a sliding controller [8] (like a perfect ABS braking system); or mathematically dedZned hypothetical signals like one true at precisely the irrational real numbers.
An automaton allowing a cycle of shorter and shorter durations may give an indication of the possibility of some Zeno type behaviour but it does not allow specidZcation of what happens after the accumulation point.
Furthermore, even developers of more conventional automatalike machines have to sometimes consider the behaviour of their system with an environment that is less well-behaved and they would benedZt from being able to describe a wide range of environmental possibilities.
In this paper, we allow structures exhibiting any dedZnable boolean signals.
A simple and long-established propositional temporal language adequate for our situation is L(U, S), the propositional temporal language using Kampas Until and Since connectives [9].
We interpret L(U, S) over general linear dZows and call the logic US/L.
If we restrict semantics to just the real numbers then the logic is sometimes called RTLaroughly Metric Temporal Logic [10], [11] without the metrics.
Recent work [12] addressed the problem of synthesis of linear models of US/L formulasadZnding an algorithm to describe a linear model of any given satisdZable formula.
This required a formal language for outputting details of models.
To do this, the paper presented a compositional language for model expressions, building upon pioneering work by [13], [14], [15], [16].
An abstract syntax with a few basic composition operators allows an expression to specify how to iteratively build an arbitrarily complex linear structure from simple singleton point structures.
This language is expressively adequate, as any satisdZable formula of US/L has a model representable in this language [12].
AbstractaTemporal logics over general linear time allow us to capture continuous properties in applications such as distributed systems, natural language, message passing and A.I.
modelling of human reasoning.
Linear time structures, however, can exhibit a wide range of behaviours that are hard to reason with, or even describe dZnitely.
Recently, a formal language of Model Expressions has been proposed to allow the convenient dZnite description of an adequately representative range of these generally indZnite structures.
Given a model described in this Model Expression language and a temporal logic formula, a model checking algorithm decides whether the formula is satisdZed at some time in the model.
Tools based on such algorithms would support a wide variety of tasks such as veridZcation and counterexample investigation.
A previous paper gave an exponential space algorithm for the problem of model checking Until/Since temporal formulas over linear time Model Expressions.
Here we prove that the problem is actually PSPACE-complete.
We present a new PSPACE algorithm and we show PSPACE-hardness by a reduction from quantidZed boolean formulas.
Keywords-Model Checking; Complexity; General Linear Flows; Dense Time; Logic  I. I NTRODUCTION Since [1] dZrst made the radical suggestion that a model with a continuous dZow of time might be better for handling concurrent systems than traditional discrete temporal logics, there has been steadily increasing development of appropriate non-discrete formalisms, techniques, tools and their foundations.
The important quality assurance task of veridZcation of a system, formalised as model-checking, has developed from simple checking of a Kripke structure against an LTL formula in discrete time [2] to checking all traces of a timed automata in continuous time against temporal metric constraints [3].
Here we also consider model checking of temporal properties in not necessarily discrete time models but we generalise the problem in several important but related ways.
We consider any underlying linear models of time and we do not assume that the structure to achecka has been generated by the action of some dZnite mechanism moving from discrete state to discrete state.
So time may be the non-negative reals or the natural numbers but it may instead be the rationals or the integers or some dZnite sequence of continuous intervals interspersed The work was partially supported by the Australian Research Council.
1530-1311/13 $26.00 AS 2013 IEEE 1550-1311/13 DOI 10.1109/TIME.2013.21  107 95    fi     	     fi   dZnite duplications of submodels.
By contrast [12] focussed on expressively complete dZnite representations of indZnite/dense structures, for which dZnite duplication is not required, so the formalism has only operators for indZnite repeats of submodels.
Thus the actual model-checking algorithms end up being quite different.
In section 2 we dedZne the logic US/L and in section 3, we dedZne model expressions.
Section 4 contains our PSPACEhardness result and section 5 presents the new PSPACE model checking algorithm.
    fi     	       Fig.
1.
An example of a fractal signal  II.
T HE LOGIC In this section, we introduce the logic US/L.
We dZrst dedZne the temporal language L(U, S) of Until and Since.
Then US/L is just the logic of L(U, S) over the class of all structures with a linear dZow of time.
L(U, S) is a propositional language and we work with a dZxed countable set L of atomic propositions (or atoms).
A frame (T, <), or dZow of time, is any irredZexive linear order.
Structures T = (T, <, h) will have a frame (T, <) and a valuation h for the atoms, i.e.
for each atom p a L, h(p) a T .
The well-formed formulas of L(U, S) are generated from the atomic propositions by the 2-place connectives U and S (both used in a predZx manner) along with the boolean connectives AZ and aSS.
That is, we dedZne the set of formulas recursively to contain the atoms and for formulas Ia and I,, we include AZIa, Ia aSS I,, U (Ia, I,) and S(Ia, I,).
Formulas are evaluated at points in structures T = (T, <, h).
We write T, x |= Ia when Ia is true at point x a T .
This is dedZned inductively as follows.
Suppose that we have dedZned the truth of formulas Ia and I,, at all points of T. Then for all points x: T, x |= p iff x a h(p), for p atomic; T, x |= AZIa iff T, x |= Ia; T, x |= Ia aSS I, iff both T, x |= Ia and T, x |= I,; T, x |= U (Ia, I,) iff there is y > x in T such that T, y |= Ia and for all z a T such that x < z < y we have T, z |= I,; and T, x |= S(Ia, I,) iff there is y < x in T such that T, y |= Ia and for all z a T such that y < z < x we have T, z |= I,.
Along with standard logical abbreviations Iaa"I, = AZ(IaaSSI,), Ia a I, = AZIa a" I,, and Ia a I, = (Ia a I,) aSS (I, a Ia), we use the following temporal abbreviations in illustrating the logic: F Ia = U (Ia, ), aalpha will be true (sometime in the future)a GIa = AZF (AZIa), aalpha will always hold (in the future)a; and their past time versions P and H.  Having dZnite representations for structures also opens the possibility for an algorithm for model checking formulas against those representations.
Such a general linear time model checking algorithm was presented for this problem in [17].
The algorithm had complexity exponential in time and space.
Let us consider a example such as the fractal signals of, e.g., [7].
Figure 1 shows a simplidZed hypothetical fractal signal where all spikes are upwards.
Let p hold during periods of increasing signal, q describe a decreasing one, and r represent a constant signal.
Assume that these propositions also hold at the start and ends of the appropriate intervals.
Using the new notation of [12] can then represent the pattern of increments and decrements in this signal with the Model Expression r + {r, p} + p + {p, q} + q + {q, r} + r.
Useful properties of this signal can be specidZed in L(U, S).
For example, we can reach a region of increment directly from a constant region so r aSS U (p, r a" p) is satisdZed within the model.
However, we cannot reach a region of decrement from a region of increment, so r aSSU (q, r a" q) is not satisdZed within the model.
Checking such claims is the work of a modelchecking algorithm.
In this paper, we will show that model checking US/L formulas against (general linear time) Model Expressions is actually PSPACE-Complete.
We show PSPACE-hardness by a reduction from the satisdZability problem for quantidZed boolean formula.
This hardness result is quite robust in the sense that it only needs a fraction of the operators available, and removing more operators results in a problem in P. We then show that the problem is in PSPACE by giving a polynomial space model checking algorithm.
This is essentially an improved variant of the [17] algorithm.
However, we do not want to claim that the new algorithm would be better for practical use.
For this reason we have not implemented the algorithm although an implementation of the original algorithm is available [18].
There are some similarities between the model checking task here and the task of model checking LTL formulas against acompressed pathsa as described in [19].
In fact, we have been able to follow a similar approach to theirs for our proof of PSPACE-hardness.
Like model expressions, the compressed path formalism allows concise expressions of structures (but there only dZnite discrete ones) via duplication of submodels.
However, the compressed paths of [19] were intended to represent dZnite discrete paths efdZciently and thus only allowed  III.
B UILDING S TRUCTURES As in [12], we dedZne a notation which allows the description of temporal structures.
Each expression tells us how to build a structure out of simple basic structures via four ways of putting structures together to form larger ones.
The general idea is simple.
Using singleton structuresa the dZow of time is one pointawe build up to more complex  108 96  structures by the iterative application of any of the operations.
There are four operations available: 1) concatenation of two structures, consisting of one followed by the other; 2) D repeats of some structure laid end to end towards the past; 3) D repeats laid end to end towards the future; 4) and making a densely thorough shufdZe of copies from a dZnite set of structures.
These operations are well-known from the study of linear orders (see e.g.
[14]).
Model Expressions are an abstract syntax to dedZne models using the following set of primitive operators based on the four operations: a a a a I ::= a | It | I + J | I | I | I0 , AV AV AV , In   are important for modelling US/L formulas.
Every satisdZable US/L formula D has an ME I such that a structure T that corresponds to I will satisfy D, yet MEs are minimal in that excluding any operator (except It) will render them unable to represent models for some US/L formulas.
We will give an illustration of the non-trivial operations a a below.
The lead operation, I = J has D submodels, each corresponding to J , and each preceding the last, as illustrated in Figure 2.
The trail operator is the mirror image of lead, whereby a a I = J has D structures, each corresponding to J and each proceeding the earlier structures.
The shufdZe operator is harder to represent with a diagram.
The model expression I = I1 , .
.
.
In  corresponds to a dense, thorough mixture of intervals corresponding to I1 , .
.
.
, In , without endpoints.
We dedZne the shufdZe operation using the rationals, Q as they are a convenient order with the required properties.
The dedZnition of model expressions is not deterministic, as the construct for the shufdZe I1 , AV AV AV , In  does not specify how the structures corresponding to I1 , AV AV AV , In are mapped to Q.
This is inconsequential, and as long as the mapping is dense for each i from 1 to n, the resulting structures will be models of the same formulas [12].
where a a IL = 2L so the letter indicates the atoms true at a point.
We refer to these operators, respectively, as a letter, the empty order, concatenation, lead, trail, and shufdZe.
DedZnition 1.
[Correspondence] A model expression I corresponds to a structure as follows: aV It is the empty sequence and corresponds to the (pseudo) frame1 (a, <, h) where < and h are empty relations.
aV a corresponds to any single point structure ({x}, <, h) where < is the empty relation and h(p) = {x} if and only if p a a. aV I +J corresponds to a structure (T, <, h) if and only if T is the disjoint union of two sets U and V where au a U , av a V , u < v and I corresponds to (U, <U , hU ) and J corresponds to (V, <V , hV ).
The symbols <U , hU refer to the restriction of the relations < and h to apply only to elements of U .
a a aV I corresponds to the structure (T, <, h) if and only if T is the disjoint union of sets {Ui |i a D} where for all i, for all u a Ui , for all v a Ui+1 , v < u, and I corresponds to (Ui , <Ui , hUi ).
a a aV I corresponds to the structure (T, <, h) if and only if T is the disjoint union of sets {Ui |i a D} where for all i, for all u a Ui , for all v a Ui+1 , u < v, and I corresponds to (Ui , <Ui , hUi ).
aV I0 , AV AV AV , In  corresponds to the structure (T, <, h) if and only if T is the disjoint union of sets {Ui |i a Q} where 1) for all i a Q, (Ui , <Ui , hUi ) corresponds to some Ij for j a$?
n, 2) for every j a$?
n, for every a = b a Q, there is some k in the open interval (a, b) where Ij corresponds to (Uk , <Uk , hUk ), 3) for every a < b a Q, for all u a Ua , for all v a Ub , u < v.  IV.
H ARDNESS R ESULT DedZnition 2.
We dedZne the USME-checking problem as follows: given an ME I and formula D, determine whether there exists a structure T = (T, <, h) corresponding to I and point x a T such that T, x  D. The reduction we will use to prove PSPACE-hardness will be from satisdZability of prenex QBF formulas.
We now provide a dedZnition of these formulas.
DedZnition 3.
A prenex QBF is a formula of the form arn arna1 AV AV AV ar2 ar1 D where n is even and D is a Boolean formula using only atoms in the set {r1 , .
.
.
, rn }.
A subformula of a prenex QBF formula is a QBF formula.
For QBF formulas Ia, I, and atom r we let Ia [r/I,] be the formula obtained from Ia by replacing each occurrence of the atom r with I,.
For any Boolean formula D and atom r, arD is equivalent to D [r/] aSS D [r/aL] and arD is equivalent to AZarAZD and hence D [r/] a" D [r/aL].
We see that a prenex QBF is equivalent to a boolean formula with all atoms replaced with  or aL.
As such, a prenex QBF is equivalent to a theorem of Propositional Calculus iff it is satisdZable.
We say that a prenex QBF evaluates to true iff it is equivalent to a theorem (or equivalently, if it is satisdZable).
The reduction from QBF satisdZability solving to model checking compressed paths [19] makes use of efdZcient replication of identical submodels.
In our reduction to MEs we will use the a a operator to replicate submodels; however, this gives us less dZexibility.
Whereas [19] distinguished between duplicated submodels by following one with an fn atom and the other with a tn atom we instead use the Until operator to  To allow more elegant phrasing we take aI corresponds to Ta to be equivalent to aT corresponds to Ia.
The MEs 1 Of course, the empty pseudo-frame is not counted as a frame and we do not allow empty structures.
109 97  J  ...
Fig.
2.
IaA e  e  I  I  e  e  I1  I1  J  J  a a The lead operation, where I = J  e  e  I  I  e  e  I2  I2  e ... e  e ... e  I  I  e  e  In  In  .. .
e  e  I  I  e  e  .. .
Fig.
3.
The shufdZe operation, where I = I1 , AV AV AV , In fi  dedZne a formula Iai to distinguish the last instance from the dZrst.
Using this trick we now dedZne a reduction from testing the satisdZability of QBF formula to ME-checking as follows:  will now show that this reduction is correct and thus the MEchecking problem is PSPACE-hard.
It can be convenient to treat formulas as atoms, so we provide the dedZnitions:  DedZnition 4.
For the rest of this section we let J0 = a and aaaaaaaaa let Ji = {pi } + Jia1 + {qi } for each positive i, let Iai = AZ (qi a" U (pi , AZqi )), dZx a positive even integer n, let Dq = arn arna1 AV AV AV ar2 ar1 D be some prenex QBF formula on the set of atoms r1 , .
.
.
, rn , and let D be the formula that results when each ri is replaced by Iai in the Boolean formula D. We let D0 = D and in general let Di = U (qi , pi a Dia1 ) for positive odd i and let Di = AZ (U (qi , AZ (pi aSS Dia1 ))) for positive even i.
We reduce the problem aIs the QBF formula Dq satisdZablea to checking the L(U, S) formula pstart a Dn against the ME {pstart } + Jn .
DedZnition 5.
Say T = (T, <, h) is a structure, then T with an L(U, S) formula Ia added as an atom is TIa = (T, <, h ) interpreted over the set of atoms LaS{Ia} where h (p) = h (p) for all p a L and for each point x a T we have x a h (Ia) iff T, x  Ia.
Where I is an ME we let I Ia be the ME that results when Ia is added to every letter of I (not just letters at which Ia would be satisdZed).
Given a set I" = {Ia1 , .
.
.
, Iam } of L(U, S) formulas and an ME I we dedZne I I" to be the result I Ia1 AVAVAVIa1 of replacing each letter a in I with a aS I".
a a Note that if any structure corresponds to I then it must also a a correspond to I + I [20].
Using this we can easily prove the next lemma inductively.
The truth of Iai at qi points is unimportant to the correctness of the reduction and so we could have dedZned Iai as being just AZU (pi , AZqi ); however, ensuring Iai is not true at the same time as qi makes the formal statement and proof of Lemma 6 below simpler.
The intuition behind our choice of Di is that Iaj will be true throughout the last (prior to {qi }) submodel corresponding to {pi } + Ji+1 , but false throughout the previous such submodels.
Thus U (qi , pi a Dia1 ) means afor points satisfying pi , including points where Iai is false and points where Iai is true, it is the case that Dia1 a, and so is used as our translation of ari .
Likewise the intuition behind AZ (U (qi , AZ (pi aSS Dia1 ))) is that it requires Dia1 at one of the points satisfying pi , and we can choose from one of these points that satisfy Iai or the point which satisdZes AZIai .
We  Lemma 6.
For each i we let Ti = (T, <, h) be a structure corresponding to Ji .
The structure TIa1 AVAVAVIai with each Iai added as an atom corresponds to Ji where J  is dedZned recursively: J0 = a and for each positive i we let Ji = aaaaaaaa aa Iai + {qi }.
{pi } + J  ia1 + {pi , Iai } + J  ia1 Proof: The lemma is trivially true for i = 0.
Say that  the lemma is correct up to i a 1, that is Jia1 corresponds aaaaaaaaa Ia1 AVAVAVIaia1 to Tia1 .
By dedZnition {pi } + Jia1 + {qi } and the aaaaaaaaa equivalent ME {pi } + Jia1 + {pi } + Jia1 + {qi } correspond aaaaaaaaaa Ia AVAVAVIa to Ti .
We see that Ti 1 ia1 corresponds to {pi } + J  ia1 +  110 98  {pi } + J  ia1 + {qi }.
Recall that Iai = AZ (qi a" U (pi , AZqi )).
At the dZnal point qi is true so Iai is false.
The atom pi does not occur within J  ia1 so U (pi , AZqi ) must be false throughout the J  ia1 immediately preceding {qi }; hence Iai is true there.
As we have dedZned Until to be strict, U (pi , AZqi ) is also false at the last occurrence of pi .
The atom qi does aaaaaaaaaa not occur within {pi } + J  ia1 so we see that U (pi , AZqi ) is Ia AVAVAVIa Ia true when followed by pi .
Hence Ti 1 ia1 i corresponds to a a a a a a a a a a Iai Ji = {pi } + J  ia1 + {pi , Iai } + J  ia1 + {qi }.
By induction the lemma holds for all non-negative integers i.
From Lemma 6 we see that for any subset S a [1, n] there exists a point x a T such that for all i a [1, n] we have T, x  Iai iff i a S. This is enough to give us NP-hardness.
We see that a USME-checker returns atruea, when given D and In as input, precisely when D is satisdZable.
As we have a polynomial time reduction from Boolean satisdZability solving, an NP-hard problem [21], we know the USME-checking problem is NPhard; however, the goal is to prove PSPACE-hardness and so we need a reduction from a PSPACE-hard problem.
Boolean satisdZability with alternating quantidZers is PSPACE-complete (see for example [22]).
SatisdZability of QuantidZed Boolean Formulas (QBF) is trivially reducible to satisdZability of QBF in prenex normal form, so we will only consider prenex QBF and QBF that are subformulas of a prenex QBF.
I"aSIa  I" + J  ia1 i + {qi }.
We see that for each x a hU (pi ) either {pi , Iai } aS I" or {pi } aS I" corresponds to T{x} .
We see that where {pi } aS I" corresponds to T{x} , x is immediately prior to an interval of I" points V such that TV corresponds to J  ia1 .
As i is a minimal counter example i a 1 does not provide a counter example.
Thus T, x  Dia1 iff DSia1 evaluates to true.
Likewise if {pi , Iai } aS I" corresponds to T{x} we see that T, x  Dia1 iff DSaSi ia1 evaluates to true.
We now further divide the case of i > 0 into odd and even cases.
Suppose i is odd.
Then Di = U (qi , pi a Dia1 ) and Di = ari Dia1 .
We see that T, z  Di is true precisely if for all x a hU (pi ) we have T, x  Dia1 .
From the previous paragraph we see that for the dZnal x a hU (pi ) we have T, x  Dia1 iff DSaSi ia1 evaluates to true, and for the other x a hU (pi ) we have T, x  Dia1 iff DSia1 evaluates to true.
Thus T, z  Dia1 S precisely if DSaSi ia1 and Dia1 both evaluate to true; or in other S S words Di = (arDia1 ) is true.
By contradiction, i is even.
As i is even, Di = AZ (U (qi , AZ (pi aSS Dia1 ))) and Di = ari Dia1 .
We see that T, z  Di is true precisely if for some x a hU (pi ) we have T, x  Dia1 .
There is such an x S iff either DSaSi ia1 or Dia1 evaluate to true; or in other words S DSi = (ari Dia1 ) is true.
We have now shown that the minimal counter example i cannot be zero, a positive odd number or a positive even number.
By contradiction, no counterexample exists.
This lemma demonstrates that our reduction from QBF is correct, and gives us the following theorem:  DedZnition 7.
Given a QBF formula I, and set S a {1, .
.
.
, n}, we let I, S be the formula that results when each free variable / S. Let rj in I, is replaced with  if j a S and aL if j a D0 = D, for each positive odd i let Di = ari Dia1 and for each positive even i let Di = ari Dia1 .
Theorem 9.
The USME-Checking problem is PSPACE-hard.
Note that the Dn dedZned above is the same as the prenex QBF Dq = arn arna1 AV AV AV ar2 ar1 D. The following lemma then demonstrates the existence of a reduction from satisdZability solving of QBF.
Note that a more traditional dedZnition of the model checking problem would only require us to determine whether the formula is a satisdZed at a particular point.
Note that this dedZnition would still be PSPACE-hard as we are only interested in the truth of Dn at the dZrst point of the reduction.
Also note that Dn does not use the Since operator so limiting formulas to those of L (U ) (or L (S), as the Since operator is essentially just a mirror image of the until operator) would still leave a PSPACE-hard model-checking problem.
In the next section we outline a polynomial space implementation for USME-checking, showing that the USME-checking problem is PSPACE-complete.
Note also that we used the qi atoms to assist in reasoning about the correctness of the reduction.
We do not claim that this reduction is in any sense minimal.
Consider, for example, a smaller reduction similar to above but where aaaaaaaaaaa J0 = {p1 }, for each positive i we have Ji = {pi+1 } + Jia1 , Iai = U (pi , AZpi+1 ) and we model check the formula Dn against the model Jn .
Note that this PSPACE-hardness result only requires MEs with a a and + (not shufdZes or a a) and does not require the Since operator in the formula.
Equivalently we could use a and + in the ME and exclude Until from the formula.
a Thus this result is quite robust to restrictions of the ME  Lemma 8.
Let T = (T, <, h) be a structure corresponding to Jn .
Let T = (T, <, h ) = TIa1 AVAVAVIan .
Let i a {0, .
.
.
, n}, let S = {s1 , .
.
.
, sm } be a subset of {i + 1, .
.
.
, n}, let I" = {Ias1 , .
.
.
, Iasm }.
Finally, let U be an interval of points I" in T such that J  i corresponds to TU and z be a point immediately prior to U .
Then DSi evaluates to true precisely if T, z  Di .
Proof: Assume that i is the smallest i that provides a counterexample to this lemma.
We see that if i = 0 then there is one point x a U and that TU corresponds to a.
We see that for each j we have x a h (Iaj ) iff j a S, and further for a point z immediately prior to x, we have x a h (Iaj ) aa T, x  Iaj aa T, z  Iaj .
Each atom rj in DSi = DS0 = DS has been substituted for  / S (and or aL, for  if j a S (and T, z  Iaj ) or aL if j a T, z  AZIaj ).
Thus T, z  D0 iff DS evaluates to true.
Now consider i > 0.
Recall that TU corresponds to aaaaaaaaaaaI"aa I" J  i = {pi } aS I" + J  ia1 + {pi , Iai }aS  111 99  next section terminating in polynomial time.
and/or formula.
An obvious question is whether we can get a result that is even stronger.
We now consider some obvious stronger restrictions, and show that all of these restrictions lead to a problem in P. Given that we consider a number of restrictions, and that a full discussion of their precise complexity would require reference to the implementation in [17], we do not consider each restriction in detail, for example we will not discuss whether the restriction is P-hard.
Note that, in practice, the unrestricted ME-checking problem is fairly easy.
For example, the implementation in [17] performs well on randomly generated problems and uses an amount of time linear in the size of the model.
We have seen that we only need either lead or trail to give PSPACE-hardness.
The original decision procedure [17] worked by expanding the ME to add formulas as atomic propositions.
Adding each formula was polynomial but interactions between Until and a a (likewise S and a a) could roughly triple the size of the ME after adding a formula leading to exponential growth of the ME.
No other interactions led to growth in the size of the ME.
Thus the size of the dZnal ME is the same as the input ME if we exclude both lead and trail, and so we see the following proposition is true.
V. A P OLYNOMIAL S PACE I MPLEMENTATION In this section we outline how to model check a formula D against an ME I using only a polynomial amount of space.
We now dedZne presatisfaction.
Intuitively T = (T, <, h) presatisdZes U (Ia, I,) means U (Ia, I,) would be true at a point immediately prior to all points in T .
DedZnition 13.
We say that a structure T = (T, <, h) presatisdZes U (Ia, I,) iff there exists a y a T such that T, y  Ia and for each x a T we have x < y a T, x  I,.
Postsatisfaction is similar but is the mirror image, so informally T = (T, <, h) postsatisdZes S (Ia, I,) means S (Ia, I,) would be true at a point immediately after all points in T .
As with [17], we iterate over the formulas from smallest to largest; however, we do not actually modify the ME to add atoms.
The algorithm in [17] pushed down formulas as atoms into an ME I so the result only depended on I and the formulas of the form U (Ia, I,) that were presatisdZed after the interval that corresponding to I and the formulas of the form S (Ia, I,) that were postsatisdZed before the interval; in this formulation we store the set I" of such formulas instead of extending I with new atoms.
Proposition 10.
If we exclude both lead and trail from MEs (or both until and since from formulas) the ME-checking problem becomes polynomial  DedZnition 14.
Let S be the set of formulas of the form S (Ia, I,) and U be the set of formulas of the form U (Ia, I,).
Let D1 , .
.
.
, Dn be an enumeration of subformulas of the dZxed formula D and negations of strict subformulas of D such that for any i, j a [1, n] if Di is a subformula of Dj then i a$?
j.
We let Da$?j be the set {D1 , .
.
.
, Dj }, and let dedZne equivalence up to j on sets of formulas S and T as follows S aa$?j T iff S aS Da$?j = T aS Da$?j .
If we exclude a+a from MEs we can see by induction that Until and Since formulas are true either everywhere or nowhere, and so adding formulas as atoms would not grow the size of the ME.
It is easy to see the following proposition must be true.
Proposition 11.
If we exclude a+a from MEs, the USMEchecking problem becomes polynomial.
Theorem 12.
Model-checking a formula D in the fragment L (F, P ) of L (U, S) against an ME I is in P.  Below we dedZne a recursive function A.
Informally, A (I, IS, D) = (I, I") is intended to represent the statement: if we have an interval TV that corresponds to I, IS is the set of formulas in U presatisdZed immediately after V in T and formulas in S postsatisdZed immediately before V in T then it must be the case that the set of formulas satisdZed within TV is I and the set formulas in U presatisdZed immediately before V in T and formulas in S postsatisdZed immediately after V in T is I".
The formula D indicates that we are only interested in whether D a I and so we can limit ourselves to subformulas of D and their negations.
The algorithm works by generating increasing accurate approximations to (I, I") that are accurate up to some subformula Dj .
Proof: We see that as time advances an F formula can become false, but can never become true.
Thus we can choose an ordering F I,1 , .
.
.
, F I,n of the n F -subformulas of D such that for all i, j with i a$?
j we have F I,j a F I,i true throughout I.
This means that the set of formulas presatisdZed at some point is one of the n + 1 values a,{F I,1 }, .
.
.
, {F I,1 , .
.
.
, F I,n }.
We can likewise order the m H-formulas.
This means that the set of pre and post-satisdZed formulas takes one of (n + 1) (m + 1) values, and will result in the implementation described in the  DedZnition 15.
Let K be an ME, and IS be a set of formulae.
We dedZne A (K, IS, D) to be the pair of sets of formulas (I, I") as follows.
We consider various possible forms of K. The dZrst case we consider is a letter.
In the following construction we build increasingly accurate approximations of (I, I"): for each j we have Ij aa$?j I and I"j aa$?j I".
Case 0.
K = It.
Since K corresponds to the empty pseudo frame it cannot satisfy any formula so we let I = a, likewise  Our original PSPACE hardness result relied only on a+a and one of lead or trail.
We have now considered excluding both those operators.
In each case the model checking problem became polynomial.
Note that our PSPACE-hardness result only required one of Until and Since, and if we exclude both, the USME-checking problem becomes polynomial.
An obvious question is whether we can get a hardness result using only temporal connectives such as F , (and its dual G) or its past time equivalent H. We will now outline why we cannot do so.
112 100  will not be presatisdZed.
Clearly U (Ia, I,) is presatisdZed if I, is found everywhere in K and Ia occurs in K or we append a structure to T that presatisdZes U (Ia, I,).
aV I"0 = a, I0 = a aV for each i : a If Di is of the form U (Ia, I,) or S (Ia, I,) then a If AZI, a / Iia1 aSS (Ia a Iia1 a" Di a IS) then I"i = I"ia1 aS {Di } a else I"i = I"ia1 \ {Di }.
a for every integer j a [0, m] we let: fi  Iji , I"ji = A (Ij , (I"i aS S) aS (I"i aS U) , Di )  it cannot affect pre or postsatisfaction so I" = IS.
Case 1.
K is a letter: aV I0 = a, I"0 = a aV for each i: a We let Ii be a set such that Ii \{Di } = Iia1 \{Di } / and: if Di is of the form AZIa then Di a Ii iff Ia a Iia1 ; if Di is of the form Ia aSS I, then Di a Ii iff Ia a Iia1 aSS I, a Iia1 ; if Di is an atom then Di a Ii iff Di a K; if Di a U aS S then Di a Ii iff D a IS.
a Di a I" iff Di is of the form U (Ia, I,) or S (Ia, I,) and either Ia a Ii or (I, a Ii ) aSS (Di a IS).
a We let I be the minimal expansion of In such that for each Di , we have Di a I iff Di a In and AZDi a I iff Di a / In .
We add the negations into I so that when we have an ME with multiple letters we can express aIa occurs everywherea as AZIa a / I.
Case 2.
K = I + J : The construction for + is similar.
However, we dZrst build approximations for the subMEs I and J .
To understand the following construction note that the formulas postsatisdZed following J are the same as those following I +J , that is ISaSU.
Likewise the formulas presatisdZed prior to I are the same as those presatisdZed prior to I + J , that is (IS aS S).
We iteratively call A using approximations to I IS.
This works because each time we calculate I"J i (or I"i ) the approximation we pass is correct up to Di and A is structured such that some later formula Dj for j > i cannot affect whether Di is included in the input.
To see that the approximation is correct up to Di take forexample the case where Di a S and / U. note that I"Iia1 aS S = I"Ii aS S as Di a J I aV let I"0 = I"0 = a, aV for each i : a If Di a / U aS S then let:      J J Ii , I"i = A J , (IS aS U) aS I"Iia1 aS S , Di  I I     Ii , I"i = A I, (IS aS S) aS I"J ia1 aS U , Di  aV   a Ii = 0a$?ja$?m Iji I = In , I" = I" n .
a a The original model checking procedure from [17] unwinds I a a into something of the form I0 + I1 + AV AV AV + Im .
The intuition behind integer j below is that it indexes Ij in this expansion.
We handle a a as an expansion of + so its dedZnition below mostly follows the approach for I + J .
However, note that a a has a limit point on the left, and so at the left hand the since operator behaves similarly to the shufdZe.
a a Case 4.
K = I : aV let m be the number of instances of U in D. 0 m aV let I"0 = I"0 = a, aV for each i : a let I"m+1 = IS aS U. i / S then let I"a1 = I"0ia1 and for each j a a If Di a i [0, m] from m down to 0 let: a If Di a S is of the form S (Ia, I,) then   a If AZI, a / I0ia1 aSS Ia a I0ia1 a" Di a IS then I"a1 = i 0 = I" \ {D }.
I"0ia1 aS {Di } else I"a1 i ia1 i  fi a for each j from 0 up to m let Iji , I"ji =   fi  fi fi j+1 aS S aS I" aS U , D A I, I"ja1 i i ia1  0   j aV I= I , I" = I" aS U aS (I"m n n aS S) 0a$?ja$?m n a a Case 5.
K = I : Broadly similar to above, but the mirror image.
For example, the intuition behind integer j is now that a a it indexes Ij of an expansion Im + AV AV AV + I1 + I0 .
aV let m be the number of instances of S in D. 0 m aV let I"0 = I"0 = a, aV for each i : a let I"m+1 = IS aS S. i / U then let I"a1 = I"0ia1 and a If Di a i fi for each j a [0, m] from m down to 0 let Iji , I"ji =   fi  fi fi j+1 aS U aS I" aS S , D A I, I"ja1 i ia1 i a If Di a U then   a If AZI, a / I0ia1 aSS Ia a I0ia1 a" Di a IS then I"a1 = i = I" \ {D }.
I"ia1 aS {Di } else I"a1 ia1 i i  fi a for each j from 0 up to m let Iji , I"ji =   fi  fi fi j+1 aS U aS I" aS S , D A J , I"ja1 i i ia1  a If Di a U then let:      J J I , I" = A J , (IS aS U) aS I"Iia1 aS S , Di  i I iI     J  Ii , I"i = A I, (IS aS S) aS I"i aS U , Di a If Di a S then let:      I I Ii , I"i = A I, (IS aS S) aS I"J ia1 aS U , Di      J J Ii , I"i = A J , (IS aS U) aS I"Ii aS S , Di I I J J I = IIn aS IJ n; I" = I"n ;I" = I"n ; aS S I" = I"In aS U aS I"J n Case 3.
K = I0 , .
.
.
, Im : Note that a shufdZe is a dense mixture and so the fragment of a structure T corresponding K that whatever occurs before (or after) a substructure corresponding to Ii corresponds to K itself.
When determining whether U (Ia, I,) is presatisdZed before a structure corresponding to K, we see that if I, is not true throughout K then we see that, since K represents a dense mixture, even the smallest predZx of the structure corresponding to K will have AZI, and so U (Ia, I,) aV  113 101     I = 0a$?ja$?m Ijn , I" = I"0n aS S aS (I"m n aS U) Note that we could eliminate the case where K = It, as the algebraic equivalences in [20] could be used to reduce the input ME I to an equivalent ME without It occurring (or the trivial ME that contains only It, for which the model checking problem is trivial as it has no points and thus cannot satisfy any formula).
Kripke structures primarily results from these disjunctions while in the model checking MEs the difdZculty comes from the operators a a and a a used to represent Zeno properties, and is related to the difdZculty with compressed paths.
It is interesting that the complexity of model-checking in this context matches that of synthesis and satisdZability.
Synthesis [12] and satisdZability [16] checking L(U, S) are also PSPACE-complete over the reals, and over general linear time as well [23].
aV  DedZnition 16.
The aPolynomial Space Model Checking Procedurea is as follows: given an ME I and formula D we return atruea iff D a I where (I, I") = A (I, IS, D).
R EFERENCES [1] H. Barringer, R. Kuiper, and A. Pnueli, aA really abstract concurrent model and its temporal logic,a in Proceedings of 13th ACM Symposium on Principles of Programming Languages, 1986, pp.
173 a 183.
[2] A. Sistla and E. Clarke, aComplexity of propositional linear temporal logics,a J. ACM, vol.
32, pp.
733a749, 1985.
[3] P. Bouyer, N. Markey, J. Ouaknine, and J. Worrell, aOn expressiveness and complexity in real-time model checking,a in Proc.
of the 35th Intl.
Colloq.
on Automata, Languages and Programming, Part II, ser.
ICALP a08.
Berlin, Heidelberg: Springer-Verlag, 2008, pp.
124a135.
[4] R. Alur, C. Courcoubetis, and D. L. Dill, aModel-checking for real-time systems,a in LICS.
IEEE Computer Society, 1990, pp.
414a425.
[5] R. Alur and D. Dill, aAutomata for modeling real-time systems,a in Automata, Languages and Programming, ser.
LNCS, M. Paterson, Ed.
Springer Berlin / Heidelberg, 1990, vol.
443, pp.
322a335.
[6] N. Huggett, aZenosE paradoxes,a in The Stanford Encyclopedia of Philosophy, winter 2010 ed., E. N. Zalta, Ed., 2010.
[7] G. W. Wornell and A. V. Oppenheim, aEstimation of fractal signals from noisy measurements using wavelets,a Signal Processing, IEEE Transactions on, vol.
40, no.
3, pp.
611a623, 1992.
[8] P. J. Mosterman, aHybrid dynamic systems: mode transition behavior in hybrid dynamic systems,a in Winter Simulation Conference, S. E. Chick et al Eds.
ACM, 2003, pp.
623a631.
[9] H. Kamp, aTense logic and the theory of linear order,a Ph.D. dissertation, University of California, Los Angeles, 1968.
[10] R. Koymans, aSpecifying real-time properties with metric temporal logic,a Real-time systems, vol.
2, no.
4, pp.
255a299, 1990.
[11] J. Ouaknine and J. Worrell, aSome recent results in metric temporal logic,a in Formal Modeling and Analysis of Timed Systems.
Springer, 2008, pp.
1a13.
[12] T. French, J. C. Mc Cabe-Dansted, and M. Reynolds, aSynthesis for temporal logic over the reals,a in Advances in Modal Logic, T. Bolander, T. BrauEner, S. Ghilardi, and L. S. Moss, Eds.
College Publications, 2012, pp.
217a238.
[13] H. LaEuchli and J. Leonard, aOn the elementary theory of linear order,a Fundamenta Mathematicae, vol.
59, pp.
109a116, 1966.
[14] J. P. Burgess and Y. Gurevich, aThe decision problem for linear temporal logic,a Notre Dame J.
Formal Logic, vol.
26, no.
2, pp.
115a128, 1985.
[15] M. Reynolds, aContinuous temporal models,a in Australian Joint Conference on ArtidZcial Intelligence, ser.
Lecture Notes in Computer Science, M. Stumptner et al, Eds., vol.
2256.
Springer, 2001, pp.
414a425.
[16] aa, aThe complexity of the temporal logic over the reals,a Annals of Pure and Applied Logic, vol.
161, no.
8, pp.
1063a1096, 2010.
[17] T. French, J. Mc Cabe-Dansted, and M. Reynolds, aModel checking general linear temporal logic,a 2013, accepted to appear in TABLEAU.
[18] J. C. Mc Cabe-Dansted, aModel checker for general linear time (online applet and data),a 2012, http://www.csse.uwa.edu.au/azmark/research/ Online/mechecker.html.
[19] N. Markey and P. Schnoebelen, aModel checking a path,a in CONCUR 2003-concurrency theory.
Springer, 2003, pp.
251a265.
[20] T. French, J. Mc Cabe-Dansted, and M. Reynolds, aAn algebraic system for linear orders,a 2013, accepted to appear in TIME 2013.
[21] S. A. Cook, aThe complexity of theorem-proving procedures,a in Proceedings of the third annual ACM symposium on Theory of computing, ser.
STOC a71.
New York, NY, USA: ACM, 1971, pp.
151a158.
[22] L. J. Stockmeyer and A. R. Meyer, aWord problems requiring exponential time(preliminary report),a in Proceedings of the dZfth annual ACM symposium on Theory of computing, ser.
STOC a73.
New York, NY, USA: ACM, 1973, pp.
1a9.
[23] M. Reynolds, aThe complexity of temporal logics over linear time,a Journal of Studies in Logic, vol.
3, pp.
19a50, 2010.
As this model checker is a reformulation of the modelchecker in [17], the proof of correctness is similar.
We now show that the USME-checking problem is in PSPACE.
Theorem 17.
 We can solve the model checking problem in fi 2 O |I| |D| space.
Proof: Consider an obvious implementation of A as a recursive function.
We can discard ISi and I"i after ISi+1 and I"i+1 have been computed.
Each set of formulas can be stored as an array of bits of length n, with the ith bit representing whether Di is in the set and so the amount of space required to store an array of formulas is |D|.
We see that we only need to store a number of such arrays of order |I| per recursion, and the recursion depth is at most |I|.
Hence we can solve 2 the model checking problem in space of order |I| |D|.
VI.
C ONCLUSION In this paper we have shown that the model checking problem for US/L formulas over Model Expressions is PSPACEComplete.
We presented a simple recursive procedure which, unlike [17], does not construct an ME or store interim MEs and thus only requires polynomial space with regard to the total length of input |I| + |D|.
We have also proven a hardness result by a reduction from QBF satisdZability solving, giving us PSPACE-completeness.
Interestingly, it is known that the USME-checking problem is polynomial if either the length of the input formula or input model is dZxed [17] (but clearly not if neither are dZxed, unless P=PSPACE).
Our PSPACE-hardness result is quite robust in the sense that it depends only upon +, a a, U and the classical operators; removing further operators will result in a polynomial problem.
Despite their semantic complexity, shufdZes do not contribute to the computational complexity of the problem.
The complexity is quite similar to that of LTL which is also PSPACE-complete for model checking against both Kripke structures [2] and compressed paths [19].
Note that while LTL is simpler than US/L, the Kripke models allow the LTL model checker to non-deterministically pick loops through the Kripke structure, an issue that the USME (and compressed path) checker does not need to handle.
Also, MEs do not have disjunctions, and so MEs represent just one possible trace of a system, whereas the traditional model checking problem of LTL has the models represent systems which can have many possible traces.
The difdZculty in model checking LTL against  114 102