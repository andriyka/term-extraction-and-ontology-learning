A Resolution Method for CTL Branching-Time Temporal Logic Alexander Bolotov and Michael Fisher Department of Computing Manchester Metropolitan University Manchester M1 5GD, UK.
{A.Bolotov,M.Fisher}@doc.mmu.ac.uk  Abstract  time temporal logics [l].
Here, the underlying model of time is of a choice of possibilities branching into the future.
Such branching-time temporal logics have been developed and applied to the specification of concurrent and distributed systems [2].
It has been observed that most correctness properties of concurrent programs (that do not deal with fairness) can be expressed in a branching-time logic called Computation Tree Logic (CTL), first proposed in [l].
There are several extensions of CTL of which CTL* is commonly considered as a full branching-time logic [9].
However, the core logics we concentrate on, are CTL and its extension Extended CTL (ECTL) [SI, which incorporates simple fairness constraints.
It has been shown that CTL and ECTL can be respectively extended to CTL' and ECTL+, where boolean combinations of temporal modalities are allowed.
Here, CTI+ is of equivalent expressive power to CTL [6], however, ECTL+ is strictly more expressive than ECTL.
Much of the research into the verification of concurrent and distributed systems has centred around the modelchecking technique utilising CTL.
Here the satisfiability of a CTL formula is checked with respect to a model derived from a finite-state program [2], [8].
Due to the success of this approach, together with a lack of direct applications of proof in branching-time temporal logics, relatively little research has been carried out on efficient decision procedures for such logics.
The work that has been produced has mainly been concerned with basic tableau and automata methods for these logics [6].
However, in recent years several applications of branching-time temporal logics requiring improved proof methods have been developed, most notably the specification and verification of multi-agent systems [14].
This has led to the requirement for more refined, and potentially more efficient, proof methods.
For linear discrete temporal logics we have developed a proof method based upon clausal temporal resolution [ 101.
Due to its simple, yet flexible, formulation, this approach has been shown to be particularly amenable to efficient implementation [4].
It is based upon a normal form that can  In this paper we extend our clausal resolution method for linear temporal logics to a branching-time framework.
The branching-time temporal logics considered are Computation Tree Logic (CTL), often regarded as the simplest useful logic of this class, and Extended CTL (ECTL), which is CTL extended with fairness operators.
The key elements of the resolution method, namely the normal form, the concept of step resolution and a novel temporal resolution rule, are introduced and just@ed with respect to both these logics.
A completeness argument is provided, together with an example of the use of the temporal resolution method.
Finally, we consider future work, in particular extension of the method yet furthel; to CTL*, and implementation of the approach by utilising techniques developedfor linear-time temporal resolution.
1 Introduction Temporal logic, which was originally developed as a logical framework in which to describe tense in natural languages [ 131, is now recognized as an essential tool for reasoning about programs.
The sequence of states of a program's execution can be considered as a sequence of moments, or states, within a temporal logic.
Thus, proofs about the correctness of programs correspond to proofs within an appropriate temporal logic [SI.A particular area in which temporal logics have been extensively used is in the specification and verification of properties of concurrent and distributed systems [ 121.
The power of the temporal language allows the representation of a variety of complex properties relating to these systems, such as liveness, deadlock and invariance.
As the applications that require concurrent and distributed solutions have become more refined, so the corresponding logical tools have been extended.
In representing the behaviour of concurrent systems, the ability to refer to a range of possible execution paths is seen as important.
Thus, there is a need for methods incorporating branching-  0-8186-7937-9/97 $10.00 0 1997 IEEE  20  potentially represent a range of temporal logics, utilising a variety of model structures [I 11.
We here consider the extension of this approach to CTL and ECTL.
The key elements of the method, namely the normal form, the concept of srep resolution and the form of temporal resolution rule, are introduced and justified with respect to both logics.
We first briefly outline the syntax and semantics of CTL ( $ 2 ) .
This is a rich temporal language, consisting of the future-time temporal modalities representing "always", "sometimes", "next", "until" and "unless".
As our resolution approach is clausal, we next introduce a normal form used for CTL formulae ($3).
A CTL formula in normal form is given as a set of formulae of a special structure, where all temporal operators, except "next" and "sometime", have been removed.
Such sets can express all information contained in the original formula.
If this information concems a loop, i.e., a situation where some proposition Q must occur at all future moments, and if Q is also constrained to be false at some point in the future, then the temporal resolution rule can be applied.
The range of resolution and simplification rules used are described in $4 as are simple examples and correctness arguments.
In $5, we extend the approach to ECTL, while, in SS6, we provide concluding remarks and discuss future work.
Finally, in Appendix A, we provide a complete axiomatic system for CTL which is used as part of the completeness proof in $4.
All atomic propositions, true, false and start are in WFFCTL.
If A and B are in WFFCTL, then so are A A B, -A, A V B, A B, A B.
+  If A and B are in WFFCTL, then O A , O A , OA, A U B and A W B are all path formulae.
If P is a path formula then A P and E P are both in WFFCTL.
Each CTL formula has a structure where any temporal operator can only be followed by a path operator or a classical operator, while any path operator can only be followed by a temporal operator.
As a result CTL is weaker than lineartime temporal logic in its expressive capabilities within a path, but is more expressive in that it can quantify over paths themselves.
As an example of its restricted nature, note that no formula describing the property where both OA and OB are satisfied on the same specific path can be constructed using CTL syntax.
(Note that there are a variety of natural extensions of CTL, culminating in CTL", of which some intermediate extensions such as Extended CTL - see 55 -are often useful.)
2.2 Semantics for CTL  2 Computation Tree Logic (CTL)  Observe that CTL has the following features that are important for our analysis:  2.1 Syntax of CTL We define the language of Computational Tree Logic (CTL) using the following symbols.
0  atomic propositions: p , q , r , .. .
,Pl,ql,rl,.
.
.
>pn,qn,rn,.. .
0  classical operators:  0  classically defined constants true, false  0  0  A,  1,  Each state can have an infinite number of successors, but should have at least one.
Each state belongs to some path (a sequence of states with finite past and infinite future).
+,=, V,  No merging of paths is allowed -a path, once started from another one, has no more common states with any other path.
new constant start, meaning 'at the beginning of time'  For the detailed description of CTL's theoretical properties, subsystems and extensions see [5].
A formula of CTL is interpreted in a model structure M = (S, R, L ) ,where  temporal operators: - 'always in the future' - 'at some time in the future' 0 - 'at the next moment in time' U - 'until' W - 'unless'  0  e  S is a set of states,  R c S x S is a binary relation over S such that for all i there exists a j such that (si,s j ) E R (as each path is isomorphic to the Natural Numbers, we will abbreviate this relation by '5')and  branching-time path operators:  A - 'on all future paths starting here' E - 'on some future path starting here'  L is an interpretation for all atomic propositional sym-  The set of well-jiormed formulae of CTL, WFFCTL, is defined as follows.
bols at each state.
21  In Figure 1 we define a relation 'I=', (slightly changing the similar definition in [ 5 ] )which evaluates well-formed CTL formulae at a particular state sa in a particular model M .
Notation  SNF in linear-time temporal logics [l 11.
Rather than repeating that algorithm, we will describe the elements that are new, being required for the manipulation of branchingtime formulae.
As in the linear-time case, the basic idea behind the normal form is to identify the core operators and generate formulae relevant to either the first state in a model, or to all subsequent states in a model.
The transformation procedure again uses fixpoint unwinding and subformula renaming in order to reduce an arbitrary formula to SNF,.
A formula in SNF, is of the form  1.
Any logical constant witk 'e' on top means a metalanguage expression, i.e.
3 and mean respectively metalanguage 'some path' and 'implies' (to differentiate them from their language analogues.
+  2.
An infinite path, x,, (0 5. i ) , is a sequence si,si+l, si+2,.
.
.
such that V j ( ( s j , sj+l) E R).
x,, is a path originating from start .
A O A(P,  * F,)  a  where each P, is a present-time formula and each Fais a present or future-time formula.
3.
A state exists that is the root of the structure's tree.
We term this SO and it satisfies + 3 j ( ( s j , SO) E R ) .
k  start  j  V pj  (an initial rule)  j=1 1  A  v EO v j=1 k  Cta  +  i= 1 1  A ai + i=l 1  Aai  *  A 0  Pj  (aglobalA0-rule)  &(ind)  (aglobalEO-rule)  j=1 k  AOy  (a global AO-rule)  EOy(ind)  (a global EO-rule)  i=l 1  A ai + i=l  Figure 2 -SNF, Definition Each of the "Pi+ Fi" (called rules) is furtherrestricted as in Figure 2 , where each ai, P j or y is a literal, true or false and (ind) is some index, possibly empty.
The intuition behind this formulation is that each of the global rules represents a constraint upon the future behaviour of the formula, given the current conjunction of literals, while the initial rules provide the initial conditions; the ' A 0 ' and 'EO' rules constrain successor states while the 'AO' and 'EO' constrain sequences of states over a longer period.
All the other operators are subsumed within this represenoperator is represented by tation.
For example, the 'A 0' a (possibly infinite) sequence of ' A O ' operations (see "removal of A U" below).
Figure 1 - CTL Semantics Definition 1 [Satisfiability] A well-formed CTL formula, B, is satisfiable if, and only if, 2 M .
( M ,so) B.  I=  Definition 2 [Validity] A well-formed CTL formula, B , is valid is and only if, it is satisfied in every possible model, i.e.
V M .
( M , s o ) B.
+  3 Normal Form for CTL As the proof method we use is clausal, we require both the definition of a normal form for CTL formulae and an algorithm for generating the normal form from arbitrary CTL formulae.
To retain soundness, this algorithm must preserve satisfiability of the formulae.
In developing the normal form, called Separated Normal Form for CTL (SNFJ, we utilise many of the mechanisms already developed for  3.1 Indices An existential path quantifier plays a crucial role in CTL.
In some cases we might have a formula EB derived from a formula EA and we want to be sure that both A and B hold on the same path.
We incorporate indices to express this situation.
Thus, E A ( i ) means that A holds on some  22  path labelled as (i).
As we will see, indices are important in the process of transformation to the normal form and in resolution where, for example, there is a need to merge formulae labelled with identical indices.
Indices appear in any rule with a conclusion containing a E. In such cases both this premiss and conclusion(s) with E are labelled with an identical index.
We also require that all rules applied retain indices.
Note that we omit indices where they are empty.
Removal of A W :  * A(FWG)  =  EOF E(FUG)  =  ~ < .
~ A A o < p[.GV(FAAO[) v[.FAEO[ pJ.GV(FAEOJ)  Now we present a rule to rewrite into SNFc formulae of the type Q + P with Q and P as pure classical formulae:  Given such equivalences we can develop our transformation rules.
These are based on the general rules for representation of fixpoints for the basic modalities, for example  We also have to enrich the set of rules used for the transformation to the normal form in classical logic by the following (we term this set of transformation rules 'TRAW):  P+AOF  +  { Px  + +  F A X  FAX  Removal of A U :  P  +-A(FUG) +  Removal of E U :  ( P+Gv(FA~)  ( P+Gv(FAx)  }  As in the case of linear-time SNF, we can show that this transformation process preserves sutisjiubility.
AO(FAX) =$  + +  {  Removal of E 0:  P  -+  E+ AiF P i G W (1FA 1 G ) -+ PTGU ( i F A 7G) + Q + false Q + EOP(I) Q + E O ( P A R)(i) + Q + EOR(i) 'P' abbreviates either path and 'T' any temporal operator.
1AF iEF P i ( F U G) P i ( F WG) Q + PT(fa1se)  where x is a new proposition symbol [I I].
The specific rules for the removal of non-core modalities are given below.
Note that formulae produced may still not be in the correct form and some further (generally classical) manipulation may be required.
Removal of A 0 :  V  Recall that any application of a rule which contains E in its conclusion requires labelling E formulae in this conclusion and in its premiss with an identical index '?.
Thus, in particular, in the case of the removal of EU now we are sure that OG will occur on the same path where F U G occurred.
We also require renaming for any formula with nested basic CTL modalities.
An example of renaming is given below with x as a new variable:  We now consider how an arbitrary CTL formula can be transformed into SNF,.
(Again, we will not provide transformations that occur within the analogous translation for linear-time logics [l I],) The first transformation towards SNF, is the introduction of the basic rule structure.
Thus, given an arbitrary CTL formula, C, we can preserve satisfiability to give A n ( s t a r t + C).
Further transformations presented below are based upon fixpoint characterizations of the basic CTL modalities [5]:  AOF  z  Removal of E W :  3.2 Rules toward SNF,  A(FUG)  G V( F A X ) { P ++ AO(G (FAX))  4 The Temporal Resolution Method Once the translation to SNF, has been carried out, then all temporal statements within CTL are represented as sets of such rules.
In order to achieve a refutation, we can apply two types of resolution rule: step resolution (SRES) and temporal resolution (TRES).
I  4.1 Step Resolution  I  Step (classical) resolution [IO] can be used between formulae that refer to the same moment in time (here, 1 is a literal and (i) is an index):  23  SKES 1 TRES 4  SRES 2  Here, the resolvent includes a W formula since there might be a case where there is a path xs, on which P occurs but 0 1 F is already outstanding.
4.3 Loops in CTL  SRES 3  While the idea of temporal resolution is to resolve forand '0' operators, the actual promulae containing cedure is more complex since in a number of difficult cases ' 0' formuIa can be presented in a given set of formulae The following set of rules represents the containing '0'.
idea of a simple example of such a loop:  'a'  SRES 4  F F Note that we again use indices in the second and third step resolution rules.
This will be useful, in particular, in allowing merging formulae labelled with identical indices (see 54.4).
+  +  AOG AOF  +  This actually gives the so-called A n - l o o p : F A O A O G , and thus could be resolved with, for example,  H  +.
E V ~ G .
Thus, temporal resolution involves collecting together a set of formulae containing the '0' operator that together imply the appropriate ' 0' formula.
In particular cases, some of the formulae needed in order to construct a loop can be missed, but can be derived from the normal form representation.
Thus, we require the removal of any '0' operator as a part of the transformation process into the normal form.
In the case of linear-time temporal logic, the crucial part of this resolution method i s this process of searching for suitable sets of 0-formulae.
In particular, a variety of algorithms have been developed and analysed for the implementation of this element of the method [IO, 3, 41.
While we do not consider the implementation of the resolution method here, we expect that several of the successful algorithms from the linear-time case can be utilised within this framework (see also $6).
4.2 Temporal Resolution Once step resolution has been applied, the temporal resolution rule can be invoked.
The basic idea here is to resolve a formula containing a OF constraint together with another containing a 0 - F constraint.
It is important to note that both of these must occur on the same path.
Thus, we have four kinds of possible combinations of O F and 0 4 ' prefixed by A or E, taking into account even the case of P j E a F and Q =i- E&F, where the same path considered in both formulae.
This generates four temporal resolution rules.
Note that in the formulation of these rules we use the expressions P .j A O A U F and P + EOE [3F as abbreviations for SNF, rules which represent these loops (see $4.3).
TRES 1  4.4 Transferral and Merging Rules As in the linear-time temporal resolution method, a transformation is available for transferring constraints, derived from local contradictions, to other states.
Thus, having P 3 false we transform it as a pure classical formula using the rule mentioned in 53.2.
Searching for a loop might require merging formulae.
This is presented by the following rule:  TRES 2  TRES 3  24  where 'P' represents either path quantifier.
We even allow merging of two existential formulae with identical labels, as these identical labels indicate the same path:  {  B.
Each axiom has a resolution-based refutation.
$$I\  }-+{PAQ+EO(CAD)(~)}  4.5 Termination  EOp  The step and temporal resolution rules are repeatedly applied.
If we reach a stage where no new resolvents are generated, then the procedure terminates.
If any of the following SNFc rules are generated during the temporal resolution procedure, the original set of rules is unsatisfiable: 1. start +-false 2. true =+-false  4.6  As an example, we present one part of the resolution proof for Ax5 (from the axiomatic system presented in Appendix A) by assuming its negation and deriving a contradiction.
(This will, at the same time, serve as an example of the temporal resolution procedure in action.)
The part of axiom Ax5 considered is  * 1AO-p  The refutation is given below, including the transformation (steps 1 to 9) of the negated formulae into the normal form.
1. start + bp A AUT^ input 1, TRAN 2. start + E a p (i) 1, TRAN 3. start +- A O l p 2, E O Removal 4. start j p A z 2, E O Removal (i) ) 5. x ~ E O ~ A X 4, TRAN 6 .
start + p 4, TRAN 7. start + x 5, TRAN 8. z + EOp (i) 5, TRAN 9.
2 E O x (i) 3,8 - 9, TRES3 10. start + A-x W l p 10, A W Removal 11. start +- 7p V (12A y) 12.
Y + A 0 (1Pv (-z A Y)) 10, A W Removal 6 , l l SRES4 13. start =+- ( - 2 A y ) 13, TRAN 14. start =+ -x 7,14 SRES 4 15. start + false  Correctness  Due to lack of space we will not provide full proofs here, but merely present a sketch of the proof of completeness and state the soundness and termination theorems.
+  Theorem 1 [Soundness] If application of the resolution procedure to a well-formed formula, A, generates a contradiction, then A is unsatisfiable (in the given semantics for the logic CTL).
Theorem 2 [Termination] The resolution procedure terminates when applied to any well-formed formula.
Theorem 3 [Completeness] If a well-formed formula, A, is unsatisfiable, then the resolution procedure will generate a contradiction when applied to A .
Here "TRAW'and "SRES' are abbreviations for transformation and step resolution rules, respectively.
Steps 4,5, 11 and 12 represent the removal of E 0 and A W operators.
Note that the rules 8 - 9 represent the loop z + EOE u p and hence can be resolved with the eventuality of the rule 3; this is represented by the TRES3 operation at step 10.
The proof terminates since it reached start =+- false.
It is not very difficult to develop resolution proofs for the rest of the axioms, thus establishing statement B.  Completeness of our resolution system can be established by the following reasoning.
We will show that for any theorem A of the axiomatic formulation of the logic CTL (see Appendix A) its negation -A has a resolution refutation.
As this resolution formulation of CTL is sound (Theorem 1 above) and the axiomatic formulation of CTL is complete (established in [ 5 ] ) in relation to the same semantics, we are led to the completeness of the resolution system.
Thus, for completeness we now have to show that our resolution formulation of CTL has at least the deductive power of the complete axiomatic system.
Lemma 1 For any theorem, A , of the axiomatic formulation of the logic CTL its negation T A has a resolution refutation.
INDUCTION CASE: Lemma I is valid for the proof of the length i, 1 5 i < n, i.e.
for any a, Fi has a resolution proof.
Now we must show that  I. Lemma I is also valid for the proof of the length n. Considering the formula F,, the following two cases can be indicated:  The proof below actually provides a constructive method for transforming any axiomatic proof into a refutation.
Proof We establish this fact by induction on the length n of the proof of A in the axiomatic system.
Let F l , ...,F, be a sequence of formulae within such a proof.
1.1.
F, is an axiom.
1.2.
F, is a conclusion of generalization or modusponens inference rules.
In the case 1.1 the proof of the Lemma is identical to the base case of induction, B.
Now consider the two subcases  BASECASE: n = 1, meaning that Fl = A is an axiom.
Thus, we must show  25  Recall that it has been shown that CTL+ is equivalent to its base logic CTL, ECTL is strictly more expressive than both CTL [7] and ECTL+ and that the most powerful branching-time system of this class is CTL" (which allows all possible combinations of modalities) [9].
of 1.2.
1.2.1 Generalization (see Appendix A) F, = A 0B where A 0B is a conclusion of generalisation.
Given as a premice the fact that B is valid (induction hypothesis), we will resolve this with the anchored negation of A 0B:  0. start + 7 A O B 1. start + E & B ( ~ ) 2. start + B 3. true + A O B 4. start + E(fa1se W ' B ) ( i ) 5. start + TB 6. start +false  5.1 Extended CTL In this section, we consider ECTL and the application of our resolution procedure to this extended logic.
Throughout, we will only describe the differences between the CTL procedure and the ECTL one.
We begin by examining the syntactic and semantic extensions of ECTL.
We introduce two new temporal operators, namely  given 0 , TRAN inductionhypothesis inductionhypothesis 1 , 3 TRES2 4, Removal of E W 2,5 SRES 4  0"  0"  1.2.2 Modus ponens (see Appendix A) Here we will use the fact (which can be easily proved for our resolution systems) that for any formula F , F has a refutation if A U F has.
Thus, we have to show that 1 A O B , together with induction hypothesis for the premises of the modusponens, lead to a contradiction.
This will prove (according to the statement above) the same result for the conclusion B of modus ponens itself.
Now anchoring T A0B to start, we commence with  start + TA 0B start + E+B(~) start + A start + T A V B true + A O A 5. true + A 0 ( T AV B ) 6. true + A O B 7. start + E(fa1se W l B ) ( i ) 8. start j - I B 9. start + B 10. start + false 0.
1.
2.
3.
4.
-  'almost always in the future' 'infinitely often in the future'  and extend the notion of well-formed formulae given in $2 to include  5 .
If A is in WFFECTL, then " A path formulae.
and +"A are both  The semantics of these two operators is as follows.
given 0 , TRAN inductionhypothesis inductionhypothesis inductionhypothesis inductionhypothesis 4 , 5 SRES 1 1,6 TRES2 7, Removal of E W 2,3 SRES 4 8 , 9 SRES 4  This concludes the outline proof of completeness.
5 Extensions of CTL  (M,xsi)  k +"A  iff  (M,xsi)  k  iff  O"A  b s , ~ r , i (.
i 5 j ) 3 ( M , s j ) k 0.4 2 s j E xsi.
( i S j ) h ( M , s j ) k CIA  Now, to incorporate ECTL formulae in our resolution procedure it turns out that we need only translate the relevant operator pairs into SNF,, using the following transformations.
+ EO"F(i) -+ P +A O ~ F + P + EO'F(i) + P + AO"F + P  + x , x + EO(x A F ) } ( i ) { P + X , x + AO(XA F ) } { P + EOy, y + E O F } ( i ) { P + AOy, y + A O F } {P  Thus, SNFc is expressive enough to serve as a normal form for both CTL and ECTL.
The proof of completeness for ECTL is consequently very similar, the only difference being that we must now show that the transformation of WFFECTL to the normal form preserves satisfiability.
There are known extensions of CTL which can be generated from CTL by weakening its syntactic restrictions.
Allowing Boolean combinations of temporal operators, but retaining CTL restrictions on path operators, gives us the CTLf system.
Thus, a formula E(OA V U T A )is a formula of CTL+ but not of CTL.
Another way to extend CTL is to introduce the meaning "infinitely often" and U", meaning "almost always", operators while retaining all the syntactic restrictions of CTL.
This provides the Extended CTL (ECTL) system [SI, which allows the representation of fairness properties.
ECTL can be also enriched to by allowing boolean combinations of linear modalities, which gives a system called ECTL+.
6 Conclusions  ow,  We have described an extension of the clausal resolution method developed for linear-time temporal logics to a branching-time framework.
This will form the basis of future work into both the efficient implementation of this approach, where we expect to utilise techniques developed for implementing linear-time temporal resolution, and further extension towards the logic CTL*, which allows arbitrary combinations of path and temporal operators.
During  26  this future work, we expect not only to refine both the normal form and the resolution rules, but also to provide further insight into the relationship between branching-time temporal logics by studying the formulae that they correspond to within the normal form.
M. Fisher.
A Resolution Method for Temporal Logic.
In Proceedings of the Twelfth International Joint Conference on Artijicial Intelligence (IJCAI), Sydney, Australia, 1991.
M. Fisher.
A Normal Form for First-Order Temporal Formulae.
In Proceedings of Eleventh International Conference on Automated Deduction (CADE), 1992.
Acknowledgements Both authors would like to thank Clare Dixon for her comments and suggestions on this work.
A. Pnueli.
The Temporal Logic of Programs.
In Proceedings of the Eighteenth Symposium on the Foundations of Computer Science, Providence, USA, November 1977.
References E. M. Clarke and E. A. Emerson.
Design and Synthesis of Synchronisation Skeletons Using Branching Time Temporal Logic.
Proceedings of the Workshop on Logic of Programs, Lecture Notes in Computer Science, 13152-71,1981.
A.
Prior.
Past, Present and Future.
Oxford University Press, 1967.
A. S. Rao and M. P. Georgeff.
Modeling Agents within a BDI-Architecture.
In International Conference on Principles of Knowledge Representation and Reasoning (KR), April 1991.
E. M. Clarke, E. A. Emerson, and A. P. Sistla.
Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications.
ACM Transactions on Programming Languages and Systems, 8(2):244-263,1986.
Axiomatic System The following set of axioms and rules of deduction represent a complete deductive system in relation to the semantics of the logic CTL.
Here we follow [5].
C. Dixon.
Strategies for Temporal Resolution.
PhD thesis, Department of Computer Science, University of Manchester, Manchester M13 9PL, U.K., 1995.
Axioms for CTL Ax1 .
All axioms of propositional calculus Ax2.
EOp z E(true U q )  C. Dixon.
Search Strategies for Resolution in Temporal Logics.
In Proceedings of the Thirteenth International Conference on Automated Deduction, 1996.
Ax3.
A m p E 1 E o - p Ax4.
AOp  E. A. Emerson.
Temporal and Modal Logic.
In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 996-1072.
Elsevier, 1990.
A(true Up)  Ax5.
E u p E 1AV7p Ax6.
E O (p V q )  = (EOp V EOq)  Ax7.
AOp f 1 E O i p E. A. Emerson and J. Y. Halpern.
Decision Procedures and Expressiveness in the Temporal Logic of Branching Time.
In Proceedings of the Fourteenth ACM Symposium on the Theory of Computing (STOC),pages 169-180,1982.
Ax8.
E(PUd Ax9.
A(pUq)  E. A. Emerson and J. Y. Halpern.
"Sometimes" and "Not Never" Revisited: On Branching Versus Linear TimeTemporalLogic.
ACMJournal, 33(1):151-178, January 1986.
E. A. Emerson and C-L. Lei.
Modalities for Model Checking: Branching Time Logic strikes back.
Technical Report TR-85-21, Department of Computer Sciences, University of Texas at Austin, 1985.
(PAEOE(PUq))) ( q V (p A AOA(pUq)))  f (qv  AxlO.
AOtrue AEOtrue  Axll.
A O ( r 3 ( i q AEOr)) 3  Ax12.
A O ( T 3 (-q A E O ~ )3) (T 3 TAOq)  Ax13.
A O ( r I> (Yq A AOr)) 3  (T  Ax14.
A O ( r I> ( i q A AOr)) 3  (T 3  Ax15.
A O ( p 3 q ) 3 (EOp 3 EOq)  (T 3  YACpUq))  3 lE(pUq))  TEOq)  Rules of Inference for CTL For any theorems A and A B,  *  E. A. Emerson and A. P. Sistla.
Deciding full branching time logic.
Information and Control, 61, 1984.
27  R1.
A , A > B k B  modus ponens  R2.
B  generalization  AOB