2012 19th International Symposium on Temporal Representation and Reasoning  An optimal tableau system for the logic of temporal neighborhood over the reals Angelo Montanari Department of Mathematics and Computer Science University of Udine, Udine, Italy angelo.montanari@uniud.it  border between decidability and undecidability cutting right across the core of that family.
A prominent role in the family of ITLs is played by Propositional Neighborhood Logic (PNL).
It features two modalities a"d'aS and a"d'aS that make it possible to access intervals adjacent to the right (future) and to the left (past) of the reference one, respectively.
Representation theorems and complete axiomatic systems for PNL with respect to various classes of interval neighborhood frames have been given by Goranko et al.
in [13].
Expressiveness issues have been addressed in [6], [14].
Decidability and complexity of the satisdZability problem for PNL have been studied by Bresolin et al.
in [6], where PNL decidability with respect to the classes of all linearly-ordered domains, well-ordered domains, and dZnite linearly-ordered domains, and the linear order of a has been proved via a reduction to the satisdZability problem for the two-variable fragment of dZrst-order logic for binary relational structures over ordered domains [15].
Additional decidability results for PNL over the classes of dense, discrete, and dZnite linear orders, as well as over the linear orders of a$?
and a have been obtained in [7], [8].
In all the considered (classes of) linear orders, the satisdZability problem for PNL turns out to be NEXPTIME-complete.
Optimal tableau systems for PNL over various classes of linear orders, including a, a$?, and a, have been developed in [7], [8], [10].
The only missing piece of information is that about PNL over a. PNL is expressive enough to distinguish between satisdZability over different classes of linear orders.
In [8], Bresolin et al.
have shown that PNL can separate the class of discrete (resp., dense) linear orders from that of all linear orders.
Additional separation results for specidZc linear orders have been given in [14], where Della Monica et al.
have proved that PNL is able to separate a$?
from a (easy) and a from a (difdZcult).
As for the latter, they have shown that if a PNL-formula is satisdZable over a, then it is satisdZable over a as well, but the converse does not hold.
In most separation results, the past modality a"d'aS plays an essential role.
As an example, the future fragment of PNL, featuring the modality a"d'aS only, is not able to distinguishing between a and a.
The relationships between a$?
and a and between a and a are, however, quite different.
In [14], the authors give a log-space reduction from the satisdZability problem for PNL over a$?
to that over a, that is, the satisdZability problem  AbstractaThe propositional logic of temporal neighborhood (PNL) features two modalities that make it possible to access intervals adjacent to the right and to the left of the current one.
PNL has been extensively studied in the last years.
In particular, decidability and complexity of its satisdZability problem have been systematically investigated, and optimal decision procedures have been developed, for various (classes of) linear orders, including a, a$?, and a.
The only missing piece is that for a.
It is possible to show that PNL is expressive enough to separate a and a.
Unfortunately, there is no way to reduce the satisdZability problem for PNL over a to that over a.
In this paper, we dZrst prove the NEXPTIME-completeness of the satisdZability problem for PNL over a, and then we devise an optimal tableau system for it.
Keywords-Interval Temporal Logics; Real Numbers; Decidability; Complexity; Tableaux Methods.
I NTRODUCTION Interval temporal logics (ITLs) are a family of modal logics for reasoning about relational interval structures over linear orders, which are well suited for a number of applications [1] The 13 binary ordering relations between two intervals on a linear order form the set of the so-called Allenas interval relations [2].
Halpern and Shohamas modal logic of time intervals (HS) features a distinct unary modality for each Allenas relation and it is interpreted over frames where intervals are primitive entities [3].
While formulas of point-based temporal logics are evaluated at time points, formulas of ITLs are evaluated at time intervals.
This results in a substantially higher expressive power and computational complexity of ITLs as compared to point-based ones.
Hence, it does not come as a surprise that, while decidability is a common feature of point-based temporal logics, undecidability dominates among HS and its fragments [3], [4], [5].
For a long time, such a situation has discouraged further theoretical investigations on ITLs and prevented people from systematically using them in practical applications.
This bleak picture started lightening up in the last few years when various non-trivial decidable ITLs have been identidZed [6], [7], [8], [9], [10], [11], [12].
(Un)decidability of an ITL depends on two main factors: (i) the set of its modalities, and (ii) the class of interval models (the linear order) over which it is interpreted.
Gradually, it became evident that the tradeoff between expressiveness and computational feasibility in ITLs is rather subtle and sometimes unpredictable, with the 1530-1311/12 $26.00 AS 2012 IEEE DOI 10.1109/TIME.2012.18  Pietro Sala Department of Pharmacology University of Verona, Verona, Italy pietro.sala@univr.it  39  ...  d, d  d d d d, a"d'aSd, a"d'aSa"d'aSd  a 2 d d d ... ...  d, a"d'aSd, a"d'aSa"d'aSd  AZd, AZd, a"d'aSd, a"d'aSd Figure 1.
A model for the PNL-formula d over a.  for PNL over a$?
has been reduced to that for a suitable class of PNL formulas over a.
Unfortunately, there is no way to reduce the satisdZability problem for PNL over a to that over a.
To dedZne such a reduction, we should be able to provide a characterization of the class of a-models corresponding to a-models in PNL, and we are not (a simple game-theoretic argument can be used to prove it).
In this paper, we address the satisdZability problem for PNL over a.
First, we dedZne syntax and semantics of PNL, and we briedZy discuss separability of a and a in PNL.
Then, we introduce the key notion of fuldZlling labeled interval structure.
Next, we give a model-theoretic proof of the decidability of PNL over a.
Finally, an optimal tableau system for PNL over a is developed.
a  M, [dd , dd ] aS d1 a" d2 (resp., AZd) iff M, [dd , dd ] aS d1 or M, [dd , dd ] aS d2 (resp., M, [dd , dd ] aaS d);  a  M, [dd , dd ] aS a"d'aSd iff add a dV such that dd > dd and M, [dd , dd ] aS d; M, [dd , dd ] aS a"d'aSd iff add a dV such that dd < dd and M, [dd , dd ] aS d.  a  We say that (i) d is satisdZable if there exist M and [dd , dd ] such that M, [dd , dd ] aS d and (ii) d is valid, denoted aL= d, if it is true on every interval in every interval model.
We do not impose any constraint on the valuation function, thus placing ourselves in the most general (and difdZcult) interval setting.
As an example, given an interval [dd , dd ], it may happen that d a d ([dd , dd ]) and d aa d ([da,d , da,d ]) for all [da,d , da,d ] a [dd , dd ].
As already pointed pointed out, PNL is expressive enough to separate different classes of linear orders as well as specidZc ones.
Here, we focus our attention on a and a.
On the one hand, it holds that, for any PNL-formula d, if d is satisdZable over a, then it is also satisdZable over a [14].
Roughly speaking, given an a-model M = a"d(a), d aS for d, a a-model Ma, = a"d(a), d a, aS for it can be obtained by dedZning a suitable (strictly monotonic) mapping from a to a that mimicks the original valuation d over a by a valuation d a, over a.
The key observation is that it is always possible to replace every d a a a a by a suitable da, a a without affecting the truth value of a PNL (sub)formula.
On the other hand, the opposite implication does not hold: there exist PNL-formulas which are satisdZable over a, but not over a [14].
Let d be the PNL-formula: d aSS a"d'aSa"d'aSd aSS [ds]((d a a"d'aSd) aSS (d a a"d'aSd) aSS (d a [d']([d']d aSS [d'][d']d)) aSS (d a [d']([d']d aSS [d'][d']d)) aSS AZ(d aSS d) aSS (AZd aSS AZd a a"d'aSd aSS a"d'aSd)), where [ds] is the (PNL-dedZnable) universal modality.
d is satisdZable over a, but not over a.
A a-model M = a"d(a), d aS for d can be a built by taking a dZctitious point d a a a a, say, d = 2, and by forcing d to be true over all (and only) the intervals of rational numbers [dd , dd ] to the left of d and d to be true over all (and only) the intervals of rational numbers [dd , dd ] to the right of d. It can be easily checked that M satisdZes d. A graphical account of M is given in Figure 1.
The unsatisdZability of d over a can be proved by a reductio ad absurdum.
Intuitively, d forces the existence of an indZnite descending sequence of intervals where d holds and of an indZnite ascending ones where d holds such that both the indZmum of (the endpoints of) the dZrst sequence and the supremum of (the endpoints of) the second one exist and must coincide (Dedekind-completeness of a is exploited  T HE LOGIC OF TEMPORAL NEIGHBORHOOD In this section, we introduce syntax and semantics of PNL, and we provide a formula that separates a and a in PNL.
Let dV be a set of points and dt = a"dV, <aS be a linear order on it.
An interval on dt is a pair [dd , dd ], with dd , dd a dV and dd < dd (strict semantics)1 .
The set of all intervals over dt (interval structure) is denoted by d(dt).
For every [dd , dd ], [da,d , da,d ] a d(dt), we say that [da,d , da,d ] is a right (resp., left) neighbor of [dd , dd ] iff dd = da,d (resp., da,d = dd ).
The vocabulary of PNL consists of a set ddT of proposition letters, the logical connectives AZ and a", and the modalities a"d'aS and a"d'aS.
The other connectives and the logical constants a$?
(true) and aL (false) are dedZned as usual.
Moreover, [d'] and [d'] stand for the duals AZa"d'aSAZ and AZa"d'aSAZ of a"d'aS and a"d'aS, respectively.
Formulae of PNL, denoted by d, d, .
.
., are recursively dedZned by the grammar: d ::= d aL AZd aL da"d aL a"d'aSd aL a"d'aSd.
We denote by aLdaL the length of d (number of symbols in d).
A formula of the form a"d'aSd, AZa"d'aSd, a"d'aSd, or AZa"d'aSd is called a temporal formula.
An interval model for a PNL formula d is a pair M = a"d(dt), d aS, where d : d(dt) aa 2ddT is a valuation function assigning to every interval the set of proposition letters true over it.
Given an interval model M = a"d(dt), d aS and an interval [dd , dd ] a d(dt), the semantics of PNL is dedZned recursively by the satisdZability relation aS as follows: a  ...  for d a ddT, M, [dd , dd ] aS d iff d a d ([dd , dd ]);  1 As an alternative, one may assume a non-strict semantics which admits point intervals, that is, intervals of the form [dd , dd ].
All results in the paper can be adapted to the case in which non-strict semantics is assumed.
40  here).
Let d be such a point.
It is possible to show that there is no way to consistently dedZne the truth value of d and d over intervals with d as their left endpoint (d excludes the existence of an interval where both d and d hold).
The unsatisdZability of d over a can be interpreted as a plus of a-models: structural properties of a exclude pathological models like the above-described a-model satisfying d. Hence, a-models can be viewed as the most appropriate models for practical applications where density is an essential ingredient of the temporal domain.
d a a([dd , dd ]) and (ii) for each a"d'aSd a TF(d) and every [dd , dd ] a d(dt), if a"d'aSd a a([dd , dd ]), then there exists dd < dd such that d a a([dd , dd ]).
The next theorem proves that for any PNL-formula d and any linearly-ordered domain dt, the satisdZability of d is equivalent to the existence of a fuldZlling LIS with an interval labeled by d. Theorem 1.
A PNL-formula d is satisdZable over a linearlyordered domain dt iff there exists a fuldZlling LIS L = a"d(dt), aaS such that d a a([dd , dd ]) for some [dd , dd ] a d(dt).
The left-to-right implication is straightforward; the opposite one is proved by induction on the structure of d [8].
The statement of the theorem is parametric in dt: it holds whatever linearly-ordered domain we take as dt.
From now on, we say that a fuldZlling LIS L = a"d(dt), aaS satisdZes d iff there exists [dd , dd ] a d(dt) such that d a a([dd , dd ]).
To reason about LISs, we associate with each point the set of its temporal requests.
Given L = a"d(dt), aaS and dd a dV, the set of future temporal requests of dd is REQL d (dd ) = {a"d'aSd a TF(d) : add a dV(a"d'aSd a a([dd , dd ]))} aS {[d']d a TF(d) : add a dV([d']d a a([dd , dd ]))}.
Past temporal requests are dedZned in a similar way.
The set of temporal L requests of dd is REQL (dd ) = REQL d (dd ) aS REQd (dd ).
Given a PNL-formula d and a LIS L, we dedZne REQL = {d a REQd aL d = REQL (d) for some d a dV} and, for each d a dV, ds dVdAdVddL (d) = {d a REQL aL d = REQL (da, ) for some da, > d} and d dd dAL (d) = {d a REQL aL d = REQL (da, ) for some da, < d}.
The general notion of fuldZlling LIS can be applied to a single point as follows.
Given L = a"d(dt), aaS, dd a dV, and a"d'aSd a REQL d (dd ), we say that a"d'aSd is fuldZlled for dd in L if d a a([dd , dd ]) for some dd > dd in dV.
The same for a"d'aSd a REQL d (dd ).
We say that dd is fuldZlled in L if all L a"d'aSd a REQL d (dd ) and a"d'aSd a REQd (dd ) are fuldZlled for dd in L. We also need to count the number of occurrences of d a REQd in a (portion of a) LIS.
Given L = a"d(dt), aaS, dVa, a dV, and d a REQd , we say that d occurs d times in dVa, if there exist exactly d distinct points dd1 , .
.
.
, ddd a dVa, such that REQL (ddd ) = d, for each 1 a$?
d a$?
d. In particular, given L = a"d(dt), aaS, dVa, a dV, and dd a dVa, , we say that REQL (dd ) (resp., dd ) is unique in dVa, if for every dd a dVa, , with dd a= dd , REQL (dd ) a= REQL (dd ).
F ULFILLING LABELED INTERVAL STRUCTURES We introduce some basic notions and results.
In particular, we show that the satisdZability of a PNL formula over a linearly-ordered domain dt can be reduced to the existence of a suitable labeling of the interval structure d(dt).
Let d be a PNL-formula to be checked for satisdZability.
The closure CL(d) of d is the set of all sub-formulas of d and of their negations (we identify AZAZd with d, AZa"d'aSd with [d']AZd, and AZa"d'aSd with [d']AZd).
Among the formulas in CL(d), a special role is played by the set of temporal formulas TF(d) = {a"d'aSd, [d']d, a"d'aSd, [d']d a CL(d)}.
By induction on the structure of d, one can prove that, for every formula d, aL CL(d)aL a$?
2aaLdaL, and aL TF(d)aL a$?
2a(aLdaLa 1).
A maximal set of requests for d is a set d a TF(d) such that (i) for each a"d'aSd a TF(d), a"d'aSd a d iff [d']AZd aa d, and (ii) for each a"d'aSd a TF(d), a"d'aSd a d iff [d']AZd aa d. We denote by REQd the set of all maximal sets of requests.
aL TF(d)aL aL REQd aL is equal to 2 2 .
We dedZne a d-atom (atom for short) as a set d' a CL(d) such that (i) for each d a CL(d), d a d' iff AZd aa d', and (ii) for each d1 a" d2 a CL(d), d1 a" d2 a d' iff d1 a d' or d2 a d'.
Let dd be the set of all atoms.
It holds that aLdd aL a$?
2aLdaL .
We connect atoms by a binary relation dzdd such that for each pair of atoms d'1 , d'2 a dd , d'1 dzdd d'2 iff (i) for each [d']d a CL(d), if [d']d a d'1 , then d a d'2 , and (ii) for each [d']d a CL(d), if [d']d a d'2 , then d a d'1 .
We now introduce a suitable labeling of interval structures based on atoms that will play an important role in the following proofs.
We dedZne a d-labeled interval structure (LIS) as a pair L = a"d(dt), aaS, where d(dt) is an interval structure and a : d(dt) a dd is a labeling function such that, for every pair of neighboring intervals [dd , dd ], [dd , dd ] a d(dt), a([dd , dd ]) dzdd a([dd , dd ]).
If we interpret a as a valuation function, LISs can be viewed as candidate models for d: truth of formulas devoid of temporal operators follows from the dedZnition of atom, and universal temporal conditions, imposed by [d'] and [d'] operators, are forced by the relation dzdd .
To turn a LIS into a model for d, we must also guarantee the satisfaction of existential temporal conditions, imposed by a"d'aS and a"d'aS operators.
To this end, we introduce the notion of fuldZlling LIS.
A LIS L = a"d(dt), aaS is fuldZlling iff (i) for each a"d'aSd a TF(d) and every [dd , dd ] a d(dt), if a"d'aSd a a([dd , dd ]), then there exists dd > dd such that  D ECIDABILITY OF PNL OVER a We now show that the satisdZability problem for PNL over a is decidable (NEXPTIME-complete).
DedZnition 1.
Let d be a PNL formula, d' be an atom, and d1 , d2 a REQd .
The triple a"d1 , d', d2 aS is an interval-tuple iff (i) for each [d']d a d1 , d a d'; (ii) for each [d']d a d2 , d a d'; (iii) for each a"d'aSd a TF(d), a"d'aSd a d' iff a"d'aSd a d2 ; (iv) for each a"d'aSd a TF(d), a"d'aSd a d' iff a"d'aSd a d1 ; (v) for each d a d', if a"d'aSd a TF(d), then a"d'aSd a d1 ; and (vi) for each d a d', if a"d'aSd a TF(d), then a"d'aSd a d2 .
41  Interval-tuples act as the basic building blocks in the construction of a (pseudo-)model for a PNL formula.
4) 5)  Proposition 1.
Let L = a"d(a), aaS be a LIS for a PNL formula d. For every dd , dd a a, the triple a"REQL (dd ), a([dd , dd ]), REQL (dd )aS is an interval-tuple.
6)  Given a LIS L, we identify the interval-tuples that occur in L, and, among them, those which are fuldZlled in L. DedZnition 2.
Let L be a LIS and a"d, d', da, aS be an intervaltuple.
We say that a"d, d', da, aS occurs in L if there exists [dd , dd ] a d(a) such that a([dd , dd ]) = d', REQL (dd ) = d, and REQL (dd ) = da, .
If a"d, d', da, aS occurs in L and there exists [dd , dd ] such that a([dd , dd ]) = d', REQL (dd ) = d, REQL (dd ) = da, , and both dd and dd are fuldZlled in L, then we say that a"d, d', da, aS is fuldZlled in L (via [dd , dd ]).
7)  such that REQL (d) = d; each point d a dVaa is fuldZlled in L; for all d, da, a dVaa , with d < da, , there exists da,a, a dV such that d < da,a, < da, ; for each d a dV such that ainf (d) = {d1 , ..., dd } (a= a), ainf (d) a ds dVdAdVddL (d) and, for each 1 a$?
d a$?
d, there is da, such that REQL (da, ) = dd and ds dVdAdVddL (da, ) = ds dVdAdVddL (d); if aaa = {d1 , ..., dd }, then for each 1 a$?
d a$?
d, there is da, such that REQL (da, ) = dd and ds dVdAdVddL (da, ) = ddddd(REQL ); the symmetric condition for asup (d) and a+a .
Even though all interval-tuples are fuldZlled in an a-pseudomodel L for d, L is not necessarily fuldZlling, since there can be multiple occurrences of the same interval-tuple associated with different intervals.
Thus, to turn L into a fuldZlling LIS (for d) some additional effort is needed.
The next dedZnition introduces an important ingredient of such a process.
We show now how to reduce the problem of checking the existence of a fuldZlling LIS for d to that of checking the existence of a dZnite pseudo-model of bounded size for it.
DedZnition 6.
Let d be a PNL formula, L = a"d(dt), aaS be a LIS, and d a dV be a fuldZlled point in L. We say that: d a a set d,dd a dV is a future essential set for d if (i) for each a"d'aSd a REQL (d), there is da, a d,ddd such that d a a([d, da, ]) (fuldZlling condition) and (ii) for each da, a d,ddd there is a"d'aSd a REQL (d) such that, for each da,a, a d,ddd a {da, }, AZd a a([d, da,a, ]) (minimality); d a a set d,dd a dV is a past essential set for d if it satisdZes the symmetric fuldZlling and minimality conditions.
DedZnition 3.
Let L = a"d(dt), aaS be a LIS, with dt being (a restriction of) a.
A function aaddd : REQL a dV aS {aa} (resp., aad dVd : REQL a dV aS {+a}) is an indZmum (resp., supremum) region function if, for each d a REQL , aaddd (d) = d, with d a= aa (resp., aad dVd (d) = d, with d a= +a), implies REQL (da, ) a= d for every da, a dV, with da, < d (resp., da, > d).
DedZnition 4.
Let L = a"d(dt), aaS be a LIS, with dt being (a restriction of) a, aaddd (resp., aad dVd ) be an indZmum (resp., supremum) region function, and d a dV.
The set of sets of requests that aaddd (resp., aad dVd ) accumulates on d is ainf (d) = {d a REQL aL aaddd (d) = d aSS d a= REQL (d)} (resp., asup (d) = {d a REQL aL aad dVd (d) = d aSS d a= REQL (d)}).
We put aaa = {d a REQL aL aaddd (d) = aa} (resp., a+a = {d a REQL aL aad dVd (d) = +a}).
From DedZnition 6, it follows that for each da, a d,ddd (resp., da, a d,ddd ), there exists at least one formula d that belongs to a([d, da, ]) (resp., a([da, , d]) only, while we cannot exclude the existence of formulas d that belong to the labeling of more than one interval [d, da, ] (resp., [da, , d]), with da, a d,ddd (resp., da, a d,ddd ).
Lemma 1.
Let d be a PNL formula and L = a"d(a), aaS be a fuldZlling LIS that satisdZes it.
Then, there exists an a-pseudo-model La =) a"a"d(dt), aaS, aaddd , aad dVd aS for d with ( 2aaLdaL +3a2aLdaL a2 a (2 a aLdaL + 1) + 2 a aLdaL a 23aaLdaL+1 .
aLdVaL a$?
2 2  Let dtaa = {d1 < ... < dd } be the restriction of dt to the elements which are asupremaa or aindZmaa of some d a REQL , i.e., dtaa = a"(ddddd(aaddd )aSddddd(aad dVd ))aSdV, <aS.
For each 1 a$?
d a$?
d a 1 and d a REQL , d occurs in region d if there is dd < d < dd+1 such that REQL (d) = d, and d occurs in region 0 (resp., d) if there is d < d1 (resp., d > dd ) such that REQL (d) = d. Given a PNL formula d, an a-pseudomodel for d is dedZned as follows.
Lemma 2.
Let d be a PNL formula and La = a"a"d(dt), aaS, aaddd , aad dVd aS be an a-pseudo-model for it.
Then, there exists a fuldZlling LIS L over a that satisdZes d. Proof: First, we build a fuldZlling LIS over a satisfying d; then, we turn it into a fuldZlling LIS over a satisfying d. Building a fuldZlling LIS La, over a.
The fuldZlling LIS La, = a"d(a), aa aS is obtained as the alimita of an indZnite sequence of a-pseudo-models L0 (= La ), L1 , L2 , .... We show how to transform Ld into Ld+1 , for every d aL 0, by a 3-step process.
We make use of an auxiliary queue to collect points to be checked for fuldZllment.
Formally, for any d aL 0, let dd be the queue of all points d a dVd that must be checked for fuldZllment.
d0 consists of all and only those d a dV such that d is not fuldZlled in La .
DedZnition 5.
Let d be a PNL formula, L = a"d(dt), aaS be a dZnite LIS for d, aaddd and aad dVd be respectively an indZmum and a supremum region function, and dtaa = {d1 < ... < dd } be the above-dedZned suborder of dt.
The triple a"L, aaddd , aad dVd aS is an a-pseudo-model for d if it satisdZes the following conditions: 1) there exists [d, da, ] a d(dt) such that d a a([d, da, ]); 2) each interval-tuple that occurs in L is fuldZlled; 3) for each 0 a$?
d a$?
d and each d a REQL that occurs in region d, there exists a fuldZlled point d in region d  42  / dVaa .
It can be easily between d, da, belongs to dVaa .
Let d a shown that d = REQLd+1 (d) is not unique (the proof is by contradiction), and thus there is d a dVd+1 , with d a= d (assume d < d), such that REQLd+1 (d) = d. We add a new E point dE to dVd+1 , with d < dE < da, , and we force REQLd+1 (d) to be equal to d. To this end, for each da,a, a dVd+1 , if da,a, < E = ad+1 ([da,a, , d]), otherwise (da,a, > d, we put ad+1 ([da,a, , d]) a,a, E we put ad+1 ([d, E d ]) = ad+1 ([d, da,a, ]).
Moreover, we put d), E = ad+1 ([d, d]).
The case in which d a dVaa and ad+1 ([d, d]) / dVaa is symmetric.
da, a First, we observe that the above construction introduces indZnitely many new points, but it does not remove any point.
The choice of a queue to manage points which are not fuldZlled guarantees that their defects are sooner or later dZxed.
We show now that the fuldZlling LIS La, for d we were looking for is the limit of this indZnite construction.
Let La d be equal to Ld devoid of the labeling of all intervals consisting of a (non-unique) point in dd and a unique point in dVd a dd .
We dedZne La, as the indZnite union aSdaL0 La d .
It trivially holds that dVd a dVd+1 , for every d aL 0.
To prove a that aa d a ad+1 , for every d aL 0, we observe that: (i) the set of unique points never changes, that is, the set of unique points in dV0 is equal to that in dVd , for every d aL 0, (ii) the labeling of intervals whose endpoints are both non-unique (resp., unique) never changes, that is, it is dZxed once and for all, and (iii) for each pair of points d, da, a dVd add such that d is non-unique and da, is unique, if d < da, (resp., da, < d), then ad ([d, da, ]) = ad ([d, da, ]) (resp., ad ([da, , d]) = ad ([da, , d])) for all d aL d, that is, the labeling of [d, da, ] (resp., [da, , d]) may possibly change when the non-unique point is removed from the queue, but then it remains unchanged forever (nonunique points which are fuldZlled from the beginning never change atheir labelinga).
Finally, to prove that all points are fuldZlled in aSdaL0 La d , it sufdZces to observe that: (i) all unique points are fuldZlled in the restriction of L0 to dV0 a d0 (and thus in La 0 ), and (ii) for every d aL 0, all points in dVd a dd are fuldZlled in La d and the dZrst element of dd may be not a fuldZlled in Ld (and thus in La d ), but it is fuldZlled in Ld+1 .
Every point is indeed either directly inserted into dVd a dd or added to dd (and thus it becomes the dZrst element of dd for some d > d) for some d aL 0.
To conclude, it sufdZces to observe that, by condition 1 of DedZnition 5, d a a([d, da, ]) for some [d, da, ] a d(dt), and such a condition is preserved by the construction (from a given iteration on, the interval over which d holds does not change anymore).
Hence, La, is a fuldZlling LIS for d over a (it can be easily shown that dVa, is isomorphic to a).
Step 1.
First, we observe that dd aS dVaa = a, as points in dVaa are already fuldZlled in La (condition 4 of DedZnition 5) and, as we will see, points which are fuldZlled in Ld remain fuldZlled in Ld+1 .
If dd is empty, then we directly move to step 2.
Otherwise, we build Ld+1 as follows.
Let d be the element at the head of dd .
If d is fuldZlled, we remove it from dd and put Ld+1 = Ld (every point is not fuldZlled when added to the queue, but subsequent expansions of the domain can make it fuldZlled before the time at which it will be taken into consideration).
Otherwise, there exist a a"d'aSor a a"d'aS-formula in dd,dLd (d) which are not fuldZlled.
Let us consider the former case.
By condition 3 of DedZnition 5, there exists da, (in the same region as d) such that REQLd (da, ) = REQLd (d) and da, is fuldZlled.
We distinguish two cases, namely, da, > d and da, < d, and we show how to make d fuldZlling in both of them (details in the Appendix).
The case of a a"d'aS-formula in REQLd (d) is symmetric.
Since d is fuldZlled in the resulting structure Ld+1 , it can be safely removed from the queue.
As the insertion of new points does not affect the properties of aainf and aasup , we keep them unchanged during the whole construction.
It can be easily shown that Ld+1 is an a-pseudo-model for d. Step 2.
This step acts on the a-pseudo-model generated by step 1 to guarantee that, in the alimita LIS La, , for each d a ddddd(aaddd ) (resp., ddddd(aad dVd )) and each d a addd (d) a, (resp., ad dVd (d)), REQL (da, ) a= d, for every da, < d (resp., da, > d), and for every d > 0, there is d a, < da, < d + d (resp., d a d < da, < d) such that REQL (da, ) = d. For each d a ddddd(aaddd ), let addd (d) = {d1 , ..., dd } (if addd (d) = a, the property trivially holds) and let d be the immediate successor of d in (the current value of) dtd+1 (we refer to the output of Step 1).
We add d new points d < dE1 < .. < dEd < d to dVd+1 , at positions d+(dad)/(d+ 1), .., d + d a (d a d)/(d + 1), and we force REQLd+1 (dEd ) to be equal to dd , for 1 a$?
d a$?
d. By condition 6 of DedZnition 5, for each 1 a$?
d a$?
d, there is da,d a dVd+1 such that REQLd+1 (da,d ) = dd and FutureLd+1 (da,d ) = FutureLd+1 (d), and thus addd (d) a FutureLd+1 (da,d ).
Then, for each d < d < d, there is da,a,d > da,d such that REQLd+1 (da,a,d ) = dd .
We put a, ad+1 ([dEd , dEd ]) = ad+1 ([da,d , da,a,d ]).
Moreover, for every d aL d, a, there is da,a, > da,d such that REQLd+1 (da,a, ) = REQLd+1 (d ).
a, We put ad+1 ([dEd , d ]) = ad+1 ([da,d , da,a, ]).
Finally, by dedZnition a, of aaddd , da,d > d, and thus, for every d a$?
d, we put a, a, ad+1 ([d , dEd ]) = ad+1 ([d , da,d ]).
For each d a aaa , we proceed in the same way, the only difference being that new points are inserted to the left of the least element of dVd+1 .
A completely symmetric set of operations must be peformed for each d a ddddd(aad dVd ) and d a ad dVd (d), and for a+a .
Step 3.
This step forces the alimita LIS La, to be dense by simply adding a point in between any pair of consecutive points.
Let d, da, be a pair of consecutive points in dVd+1 (we refer to the output of Step 2).
Since Ld+1 is an a-pseudomodel for d, by condition 5 of DedZnition 5, at most one  Turning La, into a fuldZlling LIS L over a.
The fuldZlling LIS L = a"d(a), aa aS for d can be obtained from La, as follows.
First, we put aa ([d, da, ]) = aa ([d, da, ]) for every d, da, a a.
Next, we dedZne a function aaa : a a a a REQd such that for every dd a a a a, aaa (dd ) = d, for some d such that aainf (d) < dd < aasup (d) (the existence of  43  d is guaranteed by the construction of La, , which forces all sets of requests to accumulate on rational points - set dVaa ).
For every dd a a a a, we force REQL (dd ) to be equal to aaa (dd ).
By construction, there exists a pair of rational points d < dd < da, such that REQL (d) = REQL (dd ) = REQL (da, ) (= R).
Then, for every d a a, we put (i) aa ([d, dd ]) = aa ([d, d]) if d < d, (ii) aa ([d, dd ]) = aa ([d, da, ]) if d < d < dd , (iii) aa ([dd , d]) = aa ([d, d]) if dd < d < da, , and (iv) aa ([dd , d]) = aa ([da, , d]) if d > da, .
Moreover, we put aa ([d, dd ]) = aa ([dd , da, ]) = aa ([d, da, ]).
From (d) and (ddL), it immediately follows that dd is fuldZlled.
To complete the construction, we must dedZne the labeling of intervals [dd , da,d ] for da,d a a a a (intervals of the form [da,d , dd ], with da,d a a a a, are taken into consideration in the labeling of da,d ).
By dedZnition of aaa , there exist d, da, a a, with d < dd and da,d < da, , such that REQa (d) = REQa (dd ) and REQa (da, ) = REQa (da,d ).
We put aa ([dd , da,d ]) = aa ([d, da, ]).
It is easy to check that L is a fuldZlling LIS for d over a.  a"[d0 , d1 ], d'd aS, where dtdl = {d0 < d1 } and d a d'd .
Given d a dVdl and a"d'aSd a REQdl (d) (resp., a"d'aSd a REQdl (d)), a"d'aSd (resp., a"d'aSd) is fuldZlled in dl for d if there is a node da, a dl labeled by a"[d, da, ], d'da, aS (resp., a"[da, , d], d'da, aS) such that d a d'da, .
Given d a dVdl , d is fuldZlled in dl if each a"d'aSd (resp., a"d'aSd) in REQdl (d) is fuldZlled in dl for d. Let dZ be a tableau and dl be a branch of dZ , with dtdl = {d0 < .. < dd }.
We denote by dl a d (resp., dl a d1 aL..aLda ) the expansion of dl with an immediate successor node d (resp., a immediate successor nodes d1 , .., da ).
To possibly expand dl, we apply one of the following expansion rules: a"d'aS-rule.
If there are dd a dVdl and a"d'aSd a REQdl (dd ) such that a"d'aSd is not fuldZlled in dl for dd , we proceed as follows.
If there is not an interval-tuple a"REQdl (dd ), d'd , daS, with d a d'd , we close dl.
If for every interval-tuple dl (d) is dedZned a"REQdl (dd ), d'd , daS, with d a d'd , aasup dl a, a, and aasup (d) = d for some d a$?
dd , we close dl as well.
Otherwise, let a"REQdl (dd ), d'd , daS be the selected intervaltuple.
Two cases must be considered:  Theorem 2.
The satisdZability problem for PNL over a is decidable.
dl dl 1) aasup (d) = +a or aasup (d) is not dedZned.
We choose a new point d and we expand dl with a = d a d + 1 immediate successor nodes d1 , .
.
.
, da such that, for each 1 a$?
d < a, dtdladd = dtdl aS {dd+da1 < d < dd+d } (for d = a, we add d > dd to the linear order), dd = a"[dd , d], d'd aS, with d a d'd , REQdladd (d) = d, and REQdladd (da, ) = REQdl (da, ) for each da, a dVdl ;  The thesis follows from Lemma 1, Lemma 2, and Theorem 1.
Theorem 2 allows us to reduce the problem of checking whether a PNL formula d is satisdZable to that of checking the existence of an a-pseudo-model for it of bounded size (the bound is given by Lemma 1).
A NEXPTIME decision procedure for such a problem can be easily developed.
NEXPTIME-hardness can be proved as in [10].
dl 2) there exists a > 0 such that aasup (d) = dd+a .
We choose a new point d and we expand dl with a immediate successor nodes d1 , .
.
.
, da such that, for each 1 a$?
d a$?
a, dtdladd = dtdl aS {dd+da1 < d < dd+d } dd = a"[dd , d], d'd aS, with d a d'd , REQdladd (d) = d, and REQdladd (da, ) = REQdl (da, ) for each da, a dVdl .
A TABLEAU SYSTEM FOR PNL OVER a In this section, we develop a tableau-based decision procedure for PNL over a.
First, we give the rules of the tableau system; then, we describe expansion strategies and blocking conditions; dZnally, we state termination, soundness, and completeness.
Optimality easily follows.
Let us introduce basic notation and dedZnitions.
A tableau for a PNL formula d is a special decorated tree dZ .
We associate a dZnite linear order dtdl = a"dVdl , <aS and a request function REQdl : dVdl a REQd with each branch dl of dZ .
We dedZne an accumulation constraint as a triple a"d, ddddddAddd, daS, where d a REQd , ddddddAddd a {sup , inf }, and d a dVdl aS {aa, +a}.
Each node d in dl is labeled either by a pair a"[dd , dd ], d'd aS, when a"REQdl (dd ), d'd , REQdl (dd )aS is an interval-tuple (expansion nodes), or by an accumulation constraint (accumulation nodes).
Accumudl dl and aasup as lation nodes in dl dedZne two functions aainf dl follows: for each d a ddddd(REQdl ), aainf (d) = d (resp., dl aasup (d) = d) iff the accumulation node a"d, inf , daS (resp., a"d, sup , daS) belongs to dl (during the construction of dl, dl dl and aasup are partial functions on ddddd(REQdl )).
aainf dl dl Likewise, we dedZne adl inf , dVaa dl , Future , and Past .
The initial tableau for d consists of a single expansion node (and thus of a single branch dl) labeled by the pair  a"d'aS-rule.
Symmetric to the a"d'aS-rule.
Fill-in rule.
If there are dd , dd a dVdl , with dd < dd , such that no node in dl is decorated with [dd , dd ] and there is an interval-tuple a"REQdl (dd ), d', REQdl (dd )aS, then we expand dl with a node d = a"[dd , dd ], d'aS.
If such an interval-tuple does not exist, we close dl.
Dense rule.
If there are two consecutive points dd , dd+1 a dVdl , with dd , dd+1 a dVaa dl , we proceed as follows.
If there is not an interval-tuple a"REQdl (dd ), d', daS for some d a REQd and d' a dd , we close dl.
If for each interval-tuple dl (d) = da, for some da, aL dd+1 or a"REQdl (dd ), d', daS, aainf dl a, aasup (d) = d for some da, a$?
dd , we close dl.
Otherwise, let a"REQdl (dd ), d', daS be the selected interval-tuple.
We choose a new point d and we expand dl with a node d, labeled by a"[dd , d], d'aS, such that dtdlad = dtdl aS {dd < d < dd+1 }, REQdlad (d) = d, and REQdlad (da, ) = REQdl (da, ) for every da, a dV dl .
dl Inf-rule.
Let d a ddddd(REQdl ) be such that aainf is undedZned, dd be the least point in dVdl with REQdl (dd ) = d, and d be a set of requests.
We expand dl with a = 2d + 3  44  accumulation nodes d0 , .., daa1 , where d0 = a"d, inf , aaaS and, for each 0 a$?
d a$?
d, d2d+2 = a"d, inf , dd aS and d2d+1 = a"d, inf , daS, where dda1 < d < dd (d < d0 for d = 0) is a new point.
Moreover, for 0 a$?
d a$?
d, REQdlad2d+2 (da, ) = REQdl (da, ) for each da, a dVdl , and REQdlad2d+1 (d) = d, dtdlad2d+1 = dtdl aS {dda1 < d < dd } ({d < d0 } for d = 0), and REQdlad2d+1 (da, ) = REQdl (da, ) for each da, a dVdl .
dl is Sup-rule.
Let d a ddddd(REQdl ) be such that aasup undedZned, dd be the greatest point in dVdl with REQdl (dd ) = d, and d be a set of requests.
We expand dl with a = 2da2d+3 accumulation nodes d0 , .., daa1 , where d2da2d+2 = a"d, sup , +aaS and, for each 0 a$?
d a$?
d a d, d2d = a"d, sup , dd+d aS and d2d+1 = a"d, sup , daS, where dd+d < d < dd+d+1 (dd < d for d = d a d) is a new point.
Moreover, for 0 a$?
d a$?
d, REQdlad2d (da, ) = REQdl (da, ) for each da, a dVdl , and REQdlad2d+1 (d) = d, dtdlad2d+1 = dtdl aS {dd+d < d < dd+d+1 } ({dd < d} for d = d a d), and REQdlad2d+1 (da, ) = REQdl (da, ) for each da, a dVdl .
Inf-chain rule.
Let d a dVdl be such that adl inf (d) = {d1 , .
.
.
, dd } (a= a) and 1 a$?
d a$?
d be such that for each da, a dVdl , with REQdl (da, ) = dd , Futuredl (da, ) a= Futuredl (d).
If there is not an interval-tuple of the form a"REQdl (d), d', dd aS, for some d', we close dl.
Otherwise, let a"REQdl (d), d', dd aS be such an interval-tuple and d be the immediate successor of d in dtdl .
We choose a new point da, and we expand dl with a node d = a"[d, da, ], d'aS such that REQdlad (da, ) = dd , dtdlad = dtdl aS {d < da, < d}, and REQdlad (da,a, ) = REQdl (da,a, ) for each da,a, a dVdl .
Sup-chain rule.
Symmetric to the inf-chain rule.
We start from an initial tableau for d and we apply the expansion rules to all the non-blocked and non-closed branches dl.
The expansion strategy is dedZned as follows: 1) 2) 3) 4) 5) 6) 7) 8)  apply the inf-rule until it generates no new node in dl; apply the sup-rule until it generates no new node in dl; apply the Fill-in rule until it generates no new node in dl; if there exist an active point d a dVdl and a"d'aSd a REQdl (d) such that a"d'aSd is not fuldZlled in dl for d, then apply the a"d'aS-rule on d, and then go back to step 1; if there exist an active point d a dVdl and a"d'aSd a REQdl (d) such that a"d'aSd is not fuldZlled in dl for d, then apply the a"d'aS-rule on d, and then go back to step 1; apply the inf-chain rule until it generates no new node in dl; apply the sup-chain rule until it generates no new node in dl; apply the Dense rule until it generates no new node in dl.
A tableau dZ for d is dZnal iff each branch dl of dZ is closed or blocked.
Theorem 3 (Termination).
Let dZ be a dZnal tableau for a PNL formula dl) be a branch of dZ .
It holds that ( 2aLdaL d and 2 +3a2aLdaL a2 a (2aLdaL + 1) + 2 a aLdaL a 23aaLdaL+1 ) a aLdlaL a$?
( 2 ( 2aLdaL ) aLdaL a2 a (2aLdaL + 1) + 2 a aLdaL a 23aaLdaL+1 a 1)/2.
( 2 +3a2 2 Theorem 4 (Soundness and completeness).
Let d be a PNL formula.
If dZ is a dZnal tableau for d that features one blocked branch, then d is satisdZable over a and, conversely, if d is satisdZable over a, then there exists a dZnal tableau for d with at least one blocked branch.
R EFERENCES [1] V. Goranko, A. Montanari, and G. Sciavicco, aA road map of interval temporal logics and duration calculi,a Journal of Applied Non-Classical Logics, vol.
14, no.
1a2, pp.
9a54, 2004.
The application of any of the above rules results in the replacement of the branch dl with one or more new branches, each one featuring a new node d. However, while the dZllin rule decorates such a node with a new interval whose endpoints already belong to dVdl , the other rules add a new point which becomes the left or right endpoint of the interval associated with the new node.
We say that d a dVdl is active iff one of the following three conditions occurs: (i) there is a node d in dl, with d = a"d, a, daS for some d a REQd and a a {ddd, d dVd}; (ii) there is a node d in dl, with d = a"[da, , da,a, ], d'aS, such that either da, = a, a,a, d or da,a, = d, and for each expansion node da, = a"[d , d ], d'a, aS, a, a,a, which is an ancestor of d in dl, a"REQdl (d ), d'a, , REQdl (d )aS a, a,a, a, a= a"REQdl (d ), d', REQdl (d )aS; (iii) for each point d , with dl dl (REQdl (d)) < da, < aasup (REQdl (d)), inserted in dVdl aainf dl a, dl before d, REQ (d ) a= REQ (d).
Let dl be a non-closed branch.
We say that dl is complete if for each dd , dd a dVdl , with dd < dd , there is a node d in dl labeled by d = a"[dd , dd ], d'aS, for some d'.
It can be easily shown that if dl is complete, then the pair a"d(dtdl ), adl aS such that, for each [dd , dd ] a d(dtdl ), adl ([dd , dd ]) = d' iff there is a node d in dl labeled by a"[dd , dd ], d'aS is a LIS.
We say that dl is blocked if dl is complete and for each active point d a dl, d is fuldZlled in dl.
[2] J. Allen, aMaintaining knowledge about temporal intervals,a Communications of the ACM, vol.
26, no.
11, pp.
832a843, 1983.
[3] J. Halpern and Y. Shoham, aA propositional modal logic of time intervals,a Journal of the ACM, vol.
38, no.
4, pp.
935a 962, 1991.
[4] D. Bresolin, D. Della Monica, V. Goranko, A. Montanari, and G. Sciavicco, aThe dark side of Interval Temporal Logic: sharpening the undecidability border,a in Proc.
of the 18th TIME.
IEEE, 2011, pp.
131a138.
[5] K. Lodaya, aSharpening the undecidability of interval temporal logic,a in Proc.
of the 6th ASIAN, ser.
LNCS, vol.
1961.
Springer, 2000, pp.
290a298.
[6] D. Bresolin, V. Goranko, A. Montanari, and G. Sciavicco, aPropositional interval neighborhood logics: Expressiveness, decidability, and undecidable extensions,a Annals of Pure and Applied Logic, vol.
161, no.
3, pp.
289a304, 2009.
[7] D. Bresolin, A. Montanari, and P. Sala, aAn optimal tableaubased decision algorithm for Propositional Neighborhood Logic,a in Proc.
of the 24th STACS, ser.
LNCS, vol.
4393.
Springer, 2007, pp.
549a560.
45  E = ad ([da,a, , dd ]) (if da,a, < d) E as follows: we put ad+1 ([da,a, , d]) a,a, E d ]) = ad ([dd , da,a, ]) (if da,a, > d) E for each da,a, , and ad+1 ([d, with da,a, a= d, da,a, a= da, , and da,a, a= dd ; moreover, we put E = ad ([da, , dd ]) and ad+1 ([da, , d]) E = ad ([d, dd ]).
ad+1 ([d, d]) E the request that da, In such a way, d satisdZes over [d, d] satisdZes over [da, , dd ].
Moreover, dE satisdZes the same past E (resp., [da, , d]) E requests that dd satisdZes: dE satisdZes over [d, d] a, the request that dd satisdZes over [d , dd ] (resp., [d, dd ]) and it satisdZes the remaining past requests over intervals that start at the same points where the intervals over which dd satisdZes E = them start.
Finally, if d > dd , we put ad+1 ([dd , d]) E ad ([dd , d]); ad+1 ([dd , d]) = ad ([d, dd ]) otherwise.
The labeling remains unchanged for all the remaining pairs dd , dd t, that is, ad+1 ([dd , dd ]) = ad ([dd , dd ]).
Now, by dedZnition of ad+1 , if dd is fuldZlled (in Ld ), then dE is fuldZlled (in Ld+1 ), while if dd is not fuldZlled (in Ld ), being dE fuldZlled or not (in E If dE is Ld+1 ) depends on the labeling of the interval [dd , d].
not fuldZlled (in Ld+1 ), we insert it into dd+1 .
The case (ddd) is completely symmetric, and thus its description is omitted.
Case 2.
Every da, > d such that REQLd (da, ) = REQLd (d) (if any) is not fuldZlled.
By condition 3 of DedZnition 5, there is da, < d such that (i) REQLd (da, ) = REQLd (d), (ii) da, is / dVaa (da, belongs fuldZlled, (iii) for each da, a$?
da,a, a$?
d, da,a, a to the same region as d), and (iv) for each da, < da,a, < d, if REQLd (da,a, ) = REQLd (d), then da,a, is not fuldZlled (da, is the greatest fuldZlling point with the same requests as d).
We dZrst prove that PastLd (da, ) = PastLd (d).
The proof is by reductio ad absurdum.
Suppose that there is da, < da,a, < d such that / PastLd (da, ).
Since Ld is an a-pseudo-model, REQLd (da,a, ) a a, by condition 2 of DedZnition 5 there are d, d a dVd such that a"REQLd (da,a, ), ad ([da,a, , d]), REQLd (d)aS is fuldZlled in Ld a, a, via [d, d ].
By dedZnition, both d and d are fuldZlled; morea, over, REQLd (d) = REQLd (da,a, ), REQLd (d ) = REQLd (d), a, a,a, and ad ([d, d ]) = ad ([d , d]); dZnally, since REQLd (da,a, ) a, a / PastLd (da, ), da, < d < d .
However, since by condia, tion (iv) d is the greatest fuldZlled element in dVd with a, REQLd (da, ) = REQLd (d), d cannot be greater than da, Ld a, (contradiction).
Hence, Past (d ) = PastLd (d).
Now, let a, d,ddd = {d1 , .., dd }.
For d = 1, .., d, we proceed as follows.
If dd is unique, then dd > d, since PastLd (da, ) = PastLd (d), and thus Case 1a applies.
If dd is not unique and dd > d, Case 1b applies.
If dd is not unique and da, < dd < d, we insert a new point dE immediately after d and we force E to be equal to REQLd (dd ).
For each da,a, , REQLd+1 (d) E we put ad+1 ([da,a, , d]) E = with da,a, < dd (resp., da,a, > d), a,a, a,a, a,a, E ad ([d , dd ]) (resp., ad+1 ([d, d ]) = ad ([dd , d ])).
Since PastLd (da, ) = PastLd (d), for each dd a$?
da,a, < d, there is da,a,a, < da, such that REQLd (da,a,a, ) = REQLd (da,a, ), and E = ad ([da,a,a, , dd ]).
Finally, we put thus we put ad+1 ([da,a, , d]) a, E ad+1 ([d, d]) = ad ([d , dd ]).
As in case 1, if dE is not fuldZlled, we insert it into dd+1 .
[8] D. Bresolin, A. Montanari, P. Sala, and G. Sciavicco, aOptimal tableau systems for propositional neighborhood logic over all, dense, and discrete linear orders,a in Proc.
of the 20th TABLEAUX, ser.
LNAI, vol.
6793.
Springer, 2011, pp.
73a87.
[9] aa, aWhatas decidable about Halpern and Shohamas interval logic?
The maximal fragment ABBL,a in Proc.
of the 26th LICS.
IEEE Computer Society, 2011, pp.
387a396.
[10] D. Bresolin, A. Montanari, and G. Sciavicco, aAn optimal decision procedure for Right Propositional Neighborhood Logic,a Journal of Automated Reasoning, vol.
38, no.
1-3, pp.
173a199, 2007.
[11] A. Montanari, G. Puppis, and P. Sala, aA decidable spatial logic with cone-shaped cardinal directions,a in Proc.
of the 18th CSL, ser.
LNCS, vol.
5771.
Springer, 2009, pp.
394a 408.
[12] aa, aMaximal decidable fragments of Halpern and Shohamas modal logic of intervals,a in Proc.
of the 37th ICALP - Part II, ser.
LNCS, vol.
6199, 2010, pp.
345a356.
[13] V. Goranko, A. Montanari, and G. Sciavicco, aPropositional interval neighborhood temporal logics,a Journal of Universal Computer Science, vol.
9, no.
9, pp.
1137a1167, 2003.
[14] D. Della Monica, A. Montanari, and P. Sala, aThe importance of the past in interval temporal logics: the case of Propositional Neighborhood Logic,a in Festschrift of Marek Sergot, ser.
LNAI.
Springer, 2012, vol.
7360, pp.
79a102.
[15] M. Otto, aTwo variable dZrst-order logic over ordered domains,a Journal of Symbolic Logic, vol.
66, no.
2, pp.
685a 702, 2001.
A PPENDIX Proof of Lemma 2 (step 1).
Case 1.
There exists da, > d such that REQLd (da, ) = a, REQLd (d) and da, is fuldZlled.
Let d,ddd = {d1 , ..., dd }.
For d = 1, ..., d, we proceed as follows: Case 1.a.
If dd is unique, then we put ad+1 ([d, dd ]) = ad ([da, , dd ]).
Such a replacement does not introduce new defects for dd .
By contradiction, suppose that there is a formula a"d'aSd a dd,dLd (dd ) that is fuldZlled in Ld by [d, dd ] only.
Since by condition 2 of DedZnition 5 a"dd,dLd (d), ad ([d, dd ]), REQLd (dd )aS is fuldZlled in Ld , there is [da,a, , da,a,a, ] such that a"dd,dLd (d), ad ([d, dd ]), REQLd (dd )aS is fuldZlled in Ld via [da,a, , da,a,a, ].
Since dd is unique, da,a,a, = dd .
However, since d is not fuldZlled in Ld , da,a, a= d. Hence, [da,a, , dd ], with da,a, a= d, fuldZlls a"d'aSd, thus contradicting the hypothesis that changing the labeling of [d, dd ] causes a defect for dd .
Case 1.b.
If dd is not unique, then there is d a= dd such that REQLd (d) = REQLd (dd ).
Three cases are possible: (i) dd a= aainf (REQLd (dd )) and dd a= aasup (REQLd (dd )), (ii) dd = aainf (REQLd (dd )), and (iii) dd = aasup (REQLd (dd )) (since dd is not unique, aainf (REQLd (dd )) a= aasup (REQLd (dd ))).
In cases (i) and (ii), we insert a new point dE immediately afE to be equal to REQLd (dd ) ter dd and we force REQLd+1 (d)  46