University of Westminster Eprints WestminsterResearch http://eprints.wmin.ac.uk http://www.wmin.ac.uk/westminsterresearch A clausal resolution method for branching-time logic ECTL.
Alexander Bolotov Artie Basukoski Harrow School of Computer Science  Copyright AS [2004] IEEE.
Reprinted 11th International Symposium on Temporal Representation and Reasoning: (TIME 2004), Tatihou, Normandie, France, 1-3 July 2004, pp.
140-147.
This material is posted here with permission of the IEEE.
Such permission of the IEEE does not in any way imply IEEE endorsement of any of the University of Westminster's products or services.
Internal or personal use of this material is permitted.
However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution must be obtained from the IEEE by writing to pubs-permissions@ieee.org.
By choosing to view this document, you agree to all provisions of the copyright laws protecting it.
digitalof archive at the University Westminster The WestminsterResearch Eprints service at theonline University Westminster aims to of make the research aims toofmake the research output of University available to a wider output the University available to the a wider audience.
Copyright andaudience.
Moral Rights Copyright and Rights remain with the authors and/or copyright owners.
remain with theMoral authors and/or copyright owners.
one copy for for non-commercial private Users are are permitted permittedtotodownload downloadand/or and/orprint print one copy non-commercial private study or research.
Further distribution and any use of material from within this or research.
Further distribution and any use of material from within this archive for profit-making enterprises or for commercial gain is strictly forbidden.
Whilst further distribution distribution ofofspecific specificmaterials materialsfrom fromwithin within this archive is forbidden, this archive is forbidden, you may mayfreely freely distribute the of URL of the University of Westminster Eprints distribute the URL WestminsterResearch.
(http://eprints.wmin.ac.uk).
(http://www.wmin.ac.uk/westminsterresearch).
In case of abuse or copyright appearing without permission e-mail wattsn@wmin.ac.uk.
A Clausal Resolution Method for Branching-Time Logic ECTL Alexander Bolotov and Artie Basukoski Harrow School of Computer Science, University of Westminster, HA1 3TP, UK A.Bolotov,A.Basukoski@wmin.ac.uk Abstract We expand the applicability of the clausal resolution technique to the branching-time temporal logic ECTL .
ECTL is strictly more expressive than the basic computation tree logic CTL and its extension, ECTL, as it allows Boolean combinations of fairness and single temporal operators.
We show that any ECTL formula can be translated to a normal form the structure of which was initially dedZned for CTL and then applied to ECTL.
This enables us to apply to ECTL a resolution technique dedZned over the set of clauses.
Our correctness argument also bridges the gap in the correctness proof for ECTL: we show that the transformation procedure for ECTL preserves unsatisdZability.
1.
Introduction CTL type branching-time temporal logics play a signidZcant role in potential applications such as specidZcation and veridZcation of concurrent and distributed systems [7].
Two combinations of future time temporal operators  (asome(aalwaysa), are useful in expressing fairness timea) and [6]:  ( is true along the path of the computation except possibly some dZnite initial interval of it) and  ( is true along the computation path at indZnitely many moments of time).
The logic ECTL (Extended CTL [9]) was dedZned to enable the use of these simple fairness constraints.
The logic ECTL further extends the expressiveness of ECTL by allowing Boolean combinations of elementary temporal operators and ECTL fairness constraints (but not permitting nesting of temporal operators or fairness constraints).
In [2] a clausal resolution method has been developed for the logic ECTL.
The introduction of the corresponding technique to cope with fairness constraints enabled the translation of an ECTL formula into the normal form, to which we apply a clausal resolution technique initially dedZned for the logic CTL.
In this paper we present the translation to the normal form for any ECTL formula.
Similarly to ECTL, as a normal form we utilise  the Separated Normal Form developed for CTL formulae, called SNF .
This enables us to apply the resolution technique dedZned over SNF  as the refutation technique for ECTL formulae.
The main contribution of this paper is the formulation of the technique to translate ECTL formulae into SNF  and a proof of its correctness.
The latter also bridges the gap in the correctness proof for ECTL: we show that the transformation procedure for ECTL preserves unsatisdZability.
The structure of the paper is as follows.
In 2 we outline the syntax and semantics of ECTL and those properties that are important for our analysis.
In 3 we review SNF .
Next, in 4, we describe the main stages of the algorithm to translate an ECTL formula into SNF  , give details of rules invoked in this algorithm and provide the example transformation.
The core of this paper, the proof of the correctness of this transformation technique, is given in 5.
Further, in 6 we outline the temporal resolution method dedZned over SNF  and apply it to a set of SNF  clauses (previously obtained in 4.3).
Finally, in 7, we draw conclusions and discuss future work.
2.
Syntax and Semantics of ECTL In the language of ECTL we extend the language of linear-time temporal logic, which uses future time (al(next time),  (until) and  ways),  (sometime), (unless), by path quantidZers A (on all future paths) and E (on some future path).
In the syntax of ECTL , similar to CTL and ECTL, we distinguish state ( ) and path ( ) formulae, such that well formed formulae are state formulae.
These are inductively dedZned below (where  is a formula of classical propositional logic)          fi         A E  fi                            Examples of ECTL formulae that are not expressible in fi  fi, E  a weaker logic ECTL, are A  fi.
These formulae express the Boolean combination  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE  of fairness properties or temporal operators in the scope of a path quantidZer.
We interpret a well-formed ECTL formula in a tree   , where is a set of like model structure states,  is a binary relation over , and  is an interpretation function mapping atomic propositional symbols to truth values at each state.
A path, fi , over , is a sequence of states           such that for all  ,      .
A path fi Az is called a fullpath.
Given a path fi and a state  fi   	   we term a dZnite subsequence    fi           of fi a predZx of a path fi and an indZnite sub-sequence             of fi a sufdZx of a path fi abbreviated   fi   .
satisdZes the folWe assume that an ECTL model lowing conditions: (i) There is a designated state,   , a root of a structure (i.e.
for all       ); (ii) Every state belongs to some fullpath and should have a successor state; (iii) Tree structures are of at most countable branching; (iv) Every path is isomorphic to  .
When trees are considered as models for distributed systems, paths through a tree are viewed as computations.
The requirements for ECTL models we are interested in would be sufdZx, fusion and limit closures [6].
Below, we dedZne a relation a a, which evaluates wellomitformed ECTL formulae at a state  in a model ting standard cases for Booleans.
   fi                    Aiff iff    fi    fi      fifi   E iffiff      fi    fi      iff  fi  	     fi        fi   	     fi    iff     fi        fi    iffiff     fi fi  	    fi       fi       fi  		     fi        fi      iff   fi      fi       DedZnition 1 An ECTL formula  is satisdZable if, and such that        .
only if, there exists a model Formula  is valid if, and only if, every model satisdZes it.
       	         fi    fifi      	  fi	                        	        fi	        As an example let us consider an ECTL formula A          (1)  which will be served in our example of the transformation towards SNFfi in 4.3.
It is straightforward from the semantics, that this formula is unsatisdZable: take an arbitrary   can not be fullpath, say , and show that satisdZed along  as in the linear-time logic.
2.1.
Some useful features of ECTL Here we summarize those features of ECTL that are important in our analysis and, thus, will affect both the translation of ECTL formulae to the normal form and the clausal resolution method.
In the rest of the paper, let T abbreviate any unary and T  any binary temporal operator and P either of path quantidZers.
Any formula of the type PT or PT  is called a basic CTL modality.
Proposition 1 [Negation Normal Form correctness] Given an ECTL formula  and its Negation Normal Form fiAV ,    iff   fiAV  [6].
        Given a CTL formula  , we will abbreviate the expression aa state subformula   with a path quantidZer as its main operatora by P-embedded subformula of  .
Now for an ECTL formula  , we dedZne a notion of the degree of nesting of its path quantidZers, denoted   , as follows.
DedZnition 2 (Degree of path quantidZer nesting)                   T  T  , and  ,  are purely classical if  formulae then      T    T   ; if         T  T  and    ,     then      T   and               T        ; if  P and     then  P    	.
Emerson and Sistla [10] showed that for any CTL AL (hence ECTL ) formula  with      ,  can be transformed into  Az by a continuous renaming of the Pembedded state subformulae such that   Az   .
For example, given  A E    E E  we can obtain fi A  E  A  E   A  E   A                         Proposition 2 (Correctness of the procedure Red) For    if, and only if, there any ECTL formula  , Az such that Az  exists a model  , where   is introduced in DedZnition 2 [10].
Recall that the logic CTL extends CTL by allowing Boolean combinations of temporal operators (but not any nesting of them).
Yet, it is still as expressive as CTL [8].
Hence we can transform any ECTL formula which is also a formula of CTL into an equivalent CTL formula.
Here we give some of the equivalences used for such reduction, referring the reader to the menand tioned paper for other cases which involve the operation.
(In the formulae below  and  are purely classical expressions.)
Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE          fi     P    P   P     P    P    P   P     P    E      E  E A     A A  (2)  Like ECTL, ECTL allows limited nesting of temporal operators to express fairness constraints.
For some of them, and E cases, the validity of the folnamely, for A lowing equivalences which we will use in our transformation procedure can be easily shown:   A  E  A A  E E   (3)  Applying procedure NNF fi and standard classical logic transformations, we can obtain for any ECTL formula  (that has the degree of path quantidZers nesting 1) its aspeciala Disjunctive or Conjunctive Normal Form, abbreviated as 	   E   and   A  .
DedZnition 3 (DNFE and CNFA for ECTL formulae)  , Let us call formulae of the type T   ,  T  ,  (where  and  are purely classical) as elementary formulae.
Now, a formula in 	   E is of the type E         and a formula in    A is of the type A      , where each       is an elementary formula.
For example, the following formula (which we used in   is in   A .
The proof of the following proposition can be established immediately from the semantics of ECTL .
fi2 as an unsatisdZability example) A  Proposition 3 (Correctness of the DNF E and CNFA ) For any ECTL formula  that has the degree of path quantidZers nesting 1, there exist its 	  E   and   A   such that  is satisdZable if, and only if, 	   E   and   A   are satisdZable respectively.
Similar to ECTL, a class of basic ECTL modalities consists of basic CTL modalities, enriched by the fairness constraints, P and P .
Our translation to SNF fi and temporal resolution rules are essentially based upon the dZxpoint characterizations of basic CTL modalities (see [5]).
Next we observe some results on interpreting ECTL over canonical models, noting that these results cover all CTL-type logics, including CTL .
DedZnition 4 (Branching degree and branching factor) The number of immediate successors of a state  in a tree structure is called a branching degree of .
Given a set         , of the branching degrees of the states of a tree structure, the maximal     is called a branching factor of this tree structure.
As we have already mentioned, we assume that underlying ECTL tree models are of at most countable branching.
However, following ([6]), trees with arbitrary, even uncountable, branching, aas far as our branching temporal logics are concerned, are indistinguishable from trees with dZnite, even bounded, branchinga.
DedZnition 5 (Labelled tree) Given a tree 	     , where   is a set of nodes and  is a set of edges, and a dZnite alphabet, fi, a fi     tree is a structure 	   where  is a mapping      fi, which assigns for each state, element of   , some label, element of fi.
In fi2 we introduced the notion of satisdZability and validity of ECTL formulae in relation to    .
Now, following [12], we call such a structure a tree interpretation.
Next we recall a notion of a  -ary tree canonical model which plays a fundamental role in our correctness argument.
For these purposes, again following [12], we will look at tree interpretations as tree generators: the root of the tree is understood as an empty string, , and the whole tree is seen as a result of unwinding of the root applying the suc  cessor function            , where      and     is a set of successors of a state .
DedZnition 6 (Tree canonical interpretation) Let      be a  -ary indZnite tree such that   denotes the set      , of branching degrees of the states  in 	 and             .
Now, given an al fi , a  -ary tree canonical interpretaphabet fi   tion for an ECTL formula  is of the form  , where       such that       fi.
 In a canonical interpretation        the set of states, the initial state and the successor relation are all dZxed, hence, a...they reduce to a function       fi , that is to a labelled tree over the alphabet   fi ...a ([12]).
We will refer to this tree as a canonical model.
Proposition 4 given below collects the results given in [12] (Lemma 3.5).
Proposition 4 (Existence of a canonical model) If an ECTL formula  with  E-quantidZers has a model, then it has an  	 -ary canonical model.
These results were essentially used in the formulation of the transformation rule for the ECTL fairness constraint A [2].
In this paper we will further extend their applicability in the transformation procedure for ECTL .
3.
Normal Form for ECTL  As a normal form for ECTL , similarly to ECTL, we utilise a clausal normal form, dedZned for the logic CTL, SNFfi , which was developed in [1, 4].
All formulae of SNFfi of the type   E  or   E  (see below), where  is a purely classical expression, are labelled with some index.
Indices are used to preserve  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE  a specidZc path context during the translation.
The language for indices is based on the set of terms    fi      fi      where  fi     denote constants.
A designated type of indices in SNF  are indices of the type 	  which represents a limit closure of 	 .
Thus, Efi  means that fi holds on some path labelled as  , for some  .
The alphabet for SNF  language is obtained from ECTL by omitting the fi and  operators, adding classically dedZned constants  and fi and a new operator,   (aat the initial moment of timea) dedZned as       iff  .
DedZnition 7 (Separated Normal Form SNF 	  ) SNF  is a set of formulae A fi   	  where each of the clauses   	 is further restricted as below, each        fi ,    or  is a literal,  or fi and 	  	  is some index.
         fi    A      fi    E     fi    A   fi  fi  fi  E    fi   fi fi  an initial clause  	      fi    an A step clause  fi    a E step clause an A sometime clause        fi    a E sometime clause  We obtain the SNF  semantics from the semantics of ECTL ( 2) by preserving only items for state formulae.
4.
Transformation of ECTL formulae into SNF    In this section we will dZrst describe the algorithm to transform ECTL  formulae into SNF  , some of its rules, and, dZnally, give an example transformation.
4.1.
Algorithm to transform ECTL formulae into SNF    As SNF  is a part of the resolution technique, to check validity of an ECTL  formula , we dZrst negate the latter and translate  into its Negation Normal Form, deriving  NNF  .
We introduce the transformation procedure  fi	 fi fi  applied to  , where  and 	 are described respectively by the steps 1-2 and 3-10 below.
(1) Anchor  to   and apply the initial renaming rule obtaining A         A     , where   is a new proposition.
(2) Apply equations (3) and procedure  (see DedZnition 2) to  .
Thus, we derive a set of constraints of the following structure A        fi      where         is a proposition,   is either a purely classical formula or if  contains a path quantidZer then the degree of nesting of path quantidZers in   is 1.
Let us call a formula  in pre-clause form if  fi  i.e.
it is of the form     where  is a literal, conjunction of literals, or   ,  is a purely classical formula or any of 	  P  PA" T Az  PTA"      PT P T  PTA"      T  (for some    ) and  A"    are purely classical formulae.
(3) For every pre-clause     : (3.1) If   is an ECTL formula but not a CTL  formula then do the following: (3.1.1) obtain its  	 E   or   	A   and apply equivalences 2-(e) or 2-(f) respectively.
(3.1.2) apply equivalences (3).
(3.1.3) apply procedure  .
(3.2) If   contains Boolean combinations of temporal operators but does not contain any fairness constraint then (as it is a CTL formula) apply the procedure to transform CTL into CTL (see section 2.1).
(4) At this stage, renaming state subformulae (which are expressed by basic CTL modalities) on the right hand-sides of the constraints derived at step 3 we obtain the structure required for a pre-clause.
(5) For every pre-clause     , by continuous renaming of the embedded classical subformulae by auxiliary propositions together with some classical transformations we obtain the following conditions.
- If  contains a basic CTL modality then - If  PT and PT is not P then  is a literal, else  is a purely classical formula.
- If  E  or  A  then  is a literal, - If  PA" T	 Az  then A" and Az are literals.
- If  E        	  or  A       , where each        and       is a temporal operator or a fairness constraint applied to classical formulae (but not literals) we obtain the structure where they apply to literals.
modality (6) Label each pre-clause containing the E by an unique index 	    	  and any other pre-clause containing the E quantidZer by an unique index 	    	 .
Let LIST IND be a list of all indices introduced during this labelling.
and A .
(7) Transform pre-clauses with E (8) Transform pre-clauses containing E         	  or A        (of the structure obtained at step 5).
(9) Remove all unwanted basic CTL modalities.
(10) Derive the desired form of SNF  clauses.
At this dZnal stage we transform pre-clauses     , where  is either P  or a purely classical formula: for every preclause   P  , we obtain the structure where P ap-  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE  plies either to a literal or to disjunction of literals.
This can be achieved, again, by renaming of the embedded classical subformulae, applying rules used to obtain conjunctive normal form (CNF), and distributing P over conjunction, together with some classical transformations.
Further, for ev , we apery remaining purely classical pre-clause ply a number of procedures including those that are used in classical logic in transforming formulae to CNF, some simplidZcations and the introduction of a temporal context.
4.2.
Transformation rules towards SNF    Indices.
Recall that at step 6 of the transformation procedure, we introduce labelling of the SNF  pre-clauses containing the E quantidZer.
The justidZcation of this labelling is based upon dZxpoint characterization of basic CTL modalities and was explained in [1, 2] except for the new specidZc ECTL formulae in fi E form.
The latter can be explained simply based upon the SNF  semantics.
Rules to remove basic CTL modalities.
Here we give those removal rules that will be used in our examples of the transformation to SNF  ( 4.3) and refutation ( 6).
In the formulation of the rules given below  is a new proposition:    Removal of E      E    E      Removal of E          	    	 fi    E 	 fi    E                case.
  A E E                                       A"  E E         A         A"     A     Managing embedded boolean combinations of path subformulae in ECTL .
Recall that on step 8 of the transformation procedure we must further reduce formulae of the      and A     fi .
The correform E  sponding rules are given below where   is fi  if the  are not , and  otherwise and   is the number of indices in LIST IND.
   E  A          fi fi      fi fi   case.
E E       E           Az  case.
  fi    fi fi   fi    fi fi   A E     fi    fi fi   fi    fi fi A"  E      A E       Az      fi fi   fi   Finally, from the rest of the rules previously dedZned for CTL/ECTL, we use the following.
Temporising       A E E  Distributivity of E    Managing embedded path subformulae in ECTL .
We incorporate rules to rename purely path formulae embedded in ECTL  fairness constraints from [2].
Let  and the number of indices in LIST IND be     let       fi be the constants occurLIST IND ring in these indices.
If for some index  we do not have   LIST IND then we upgrade LIST IND by   (in the formulation below   is the number of indices in LIST IND and         are new propositions).
          Renaming: the A               E E E      The dZrst stage of the transformation procedure  outlined above, the procedure  , is taken from the translation of ECTL formulae to SNF  [2].
Here we describe novel techniques to cope with Boolean combinations of temporal operators dedZned in addition to the rules of the procedure fi , introduced for ECTL [2].
We also recall some of those rules that will be used in our example given in 4.3.
For the full set of rules preserved from the CTL the reader is referred to [1, 4].
In the presentation below we omit the outer aA a connective that surrounds the conjunction of pre-clauses and, for convenience, consider a set of pre-clauses rather than the and  will abbreviate purely conjunction.
Expressions classical formulae.
case.
Renaming: the E    	 fi A 	 fi 	   fi    E E E                     In the rule for E , given that the premise of the rule is labelled by   , we preserve this label for both conclusions, thus, assuring that they refer to the same path.
    4.3.
Example Transformation As an example we translate into SNF  the formula: E  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE  	 fi    (4)  To check if (4) is valid negate it and apply procedure NNF  E    A   which was considered as an example of an unsatisdZable formula in 2.
From the translation algorithm, we derive steps 0a2, where  is a new proposition.
  fi      fiA fi  fiA        fi fi   	      	      We proceed with formula 2, where the right hand side of the implication is already in fi  A  .
Thus, we apply equation (2)-(f) to distribute the A over conjunction in 2, obtaining 3, and then simplify the latter deriving 4 and 5.
Next, we simplify formula 4 applying (3-(a)) to get 6.
The structure of the latter enables us to apply procedure 	 deducing 7 and 8 and introducing a new variable   .
  fi A A         fi A  	   fi A  	 	  fi A A         fi A   	 fi     fi A 	 fi  Applying the renaming rule (A case) to 5 we derive formula 9 and label it with a new index fi   (since LIST IND is empty).
Applying equation (3-(b)) to 9 we get fiE E fi   which is further reduced by procedure 	 to 10 and 11, where  is a new variable.
Apply A removal rule to 7 and E removal rule 11, where fi and fi are new variables.
 fi E       fi  fi E       fifi  fi E      fi  fi    fi   fi   fi A fi fi fi A    fi    fi   fi A fi  fi  fi fifi fi   fi E fi fi fi E  fi   fifi fi   fi E Next simplifying and temporising formulae 12 and 14 we obtain 16-19 and 20-23 respectively.
Finally, we distribute in 13 and 15.
A and E over   fi	  fi   fi  fi    fi        	     fi fi fi fi fi fi fi fi  fi  fi fi fi fi fi    fi fi   fi fi      fi A     A   fi     fi A   A   fi  A   A fi E  E fi   fi      fi    fi    fi    fi    fi    fi    fi     fi     fi  E fi  fi  fi  E  fi  The normal form of the given ECTL  formula A  is represented by clauses 1, 8, 10, 16a27.
  5.
Correctness of the Transformation of ECTL formulae into SNF    Here we provide the correctness argument for our transformation procedure.
A signidZcant part of this argument is either similar to the corresponding proofs given in [1, 2] for CTL and ECTL or extend these proofs for new cases of ECTL formulae.
Therefore, we will only state such claims referring the reader to [1, 2] while we sketch here proofs for new techniques used for ECTL  transformations.
Note also that in our previous paper ([2]) we have not established the proof for the claim analogous to Lemma 3 (see below).
Therefore, providing our argument in this paper, we not only show the desired correctness of the transformation procedure for ECTL  but also bridge this gap for ECTL.
Theorem 1 An ECTL formula, , is satisdZable if, and only if,   is satisdZable.
To establish the correctness of this theorem we dZrst show that an ECTL formula  is satisdZable, if and only if fi  is satisdZable (Lemma 1).
At the next stage we prove that the transformation procedure   preserves satisdZability (Lemma 2).
Finally, (Lemma 3), we show that given an ECTL formula  and its normal form, SNF  (), if SNF () is satisdZable then  is satisdZable.
Lemma 1 An ECTL formula, , is satisdZable if, and only if, fi  is satisdZable.
Since fi is taken from the translation of ECTL formulae to SNF , the proof of Lemma 1 follows from the correctness argument for ECTL ([2]).
Lemma 2 Given an SNF formula , if  fi  is satisdZable then so is  fi .
Here we must show that the new techniques used in our transformation procedure preserve satisdZability.
This includes the correctness argument for   E and fi A and also for the cases of Boolean combinations of temporal operators, E fi        case and A fi        case.
Corresponding proofs are established straightforwardly from the SNF  semantics, taking into account the meaning of indices and Proposition 4 ([12]).
Lemma 3 Given an ECTL  formula , if SNF  is satisdZable then so is .
From Lemma 1 it follows that given an ECTL  formula ,  is satisdZable if, and only if,  fi  is satisdZable.
Thus, for the proof of Lemma 3 we must show that the following proposition takes place: PROOF :  Proposition 5 Given an ECTL  formula , if  fi  is satisdZable then so is fi .
Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE  Here we sketch the proof for the new core technique introduced in our transformation procedure.
We will show  A         and havthat given  A ing generated  A  E                   A  E                 (where at least one of  fi  fi fi fi  has a form of or ), if  is satisdZable then  is satisdZable.
  Consider a model  which satisdZes .
We have   	    	  .
Following [12], we know that if a formula with 	 path quantidZers has a model, then it has an 	 fi aary canonical model.
We will now construct this canonical model   and show that every state in the model also satisdZes .
The construction proceeds by dZrst selecting a path, say  , from  which satisdZes one of the fi  fi fi fi 	 clauses.
This will be a basis path to construct a canonical model, which is also referred to as the aleftmosta path of the canonical model in [12].
Due to the labelling of the states of this path, each of them satisdZes  E             .
Then inductively construct each of the 	 additional paths (corresponding to 	  quantidZers) from each state along  .
Again, we label the states of these paths based on the original interpretations from M such that each of them also satisdZes  E             (for some fi).
We then proceed in the same way to take each state of the newly constructed paths and generate the 	 additional paths from each of them to derive the completed canonical model.
PROOF :           A"     Az  Figure 1.
 A' fi  A"  A"    Al  A"  A"   Az 	 fi aary Canonical Model for .
Our ultimate task is to show that for any state in the canonical model   which satisdZes , every path emanating from it satisdZes        .
This will ensure that  A         is satisdZed at every state of  , and, therefore, it is satisdZed in the root of   .
Consider an arbitrarily chosen path  fi of  and a state     , see Figure 1.
By the construction of   , every one of the 	 paths emanating from   satisdZes        .
What is left is to show that  fi    (which corresponds to the 	 fi  path emanating from   ) also satisdZes        .
The latter follows from the labelling of the states of the path  fi which is taken from one of the paths of  that satisdZes one of the        .
6.
The Temporal Resolution Method In order to achieve a refutation, we apply two types of resolution rules already dedZned in [1, 4]: step resolution (SRES) and temporal resolution (TRES).
The SRES rules are used between formulae which refer to the same initial moment of time or same next moment along some or all paths.
The basic idea of invoking temporal resolution is to resolve a set of formulae characterizing a loop in , i.e.
a set of SNFfi clauses indicating a situation when  occurs at all future moments along every (an A-loop in ) or some path (a E-loop in ) from a particular point in an ECTL  model, together with the clause containing  [3].
Here we present those step (SRES 1 and SRES 2) and temporal resolution (TRES 2 and TRES 4) rules which are used in the example refutation.
(For a detailed description of the resolution technique dedZned over SNF fi see [1, 4].)
SRES 1        SRES 2        TRES 2 A A    E       E       A      A     	   A     TRES 4 E        E E  E                         In the rules above  is a literal and the dZrst premises in the TRES rules abbreviate the A and E loops in  respectively (given that is satisdZed).
Correctness of the transformation of ECTL  formulae into SNFfi (5) together with the termination and correctness of the resolution method dedZned over SNF fi (shown in [1, 4]) enables us to apply the latter as the refutation method for ECTL  .
Example Refutation.
We apply the resolution method to the set of SNFfi clauses obtained in section 4.3 for 	 .
We commence the ECTL formula A the resolution proof presenting at steps 1 a 13 only those clauses that are involved in the resolution refutation in the following order: initial clauses, step clauses and, dZnally, any sometime clauses.
      A    A           E            E            A              E     	 fi  A   fi  A           We apply step resolution rules between 1 and 2, and 1 and 3.
No more SRES rules are applicable.
Formula 12 is an eventuality clause, and therefore, we are looking for a loop in  Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE  (see [3] for the formulation of the loop searching procedure).
The desired loop, E E   (given that condition  is satisdZed) can be found considering clauses 10 and 11.
Thus, we apply the TRES 4 rule to resolve this loop and clause 12, obtaining 16.
Next we remove E  from 16 deriving a purely classical formula 17 ( is a new variable).
Simplify the latter, apply temporising, obtaining, in particular, 19 and 20, and then a series of SRES rules to newly generated clauses.
    fi fi      fi fifi     E      fi fi  TRES 4 	     fi 	 fi E  fi   	  E    fi 	  fi E  fi        	fi 	 fi 	   fi  A       	fi 	 fi 	        fi fi       fi  fi  fi    fi fi     A       fi fi  fi    A    	fi fi  fi    A  fi fi  fi Now, as no more SRES rules are applicable, we are looking for a loop in  which can be found considering formulae 9 and 26: A A  given that condition   is satisdZed.
Thus, we can apply TRES 2 to resolve this loop and 13 deriving 27.
Then we remove E  from the latter (on step 28, where   is a new variable, we use only one of its conclusions).
Applying simplidZcation and temporising to 28 we obtain 29.
The desired terminating clause     is deduced by applying SRES 1 to steps 1, 15 and 23.
	    fi         E         fi               fi fi fi    	 E  fi   	 fi 	  fi fi fi   7.
Conclusions and Future Work We have described the extension of the clausal resolution method to the useful branching-time logic ECTL  .
Here we have followed our general idea to expand the applicability of the clausal resolution technique originally developed for linear-time temporal logic [11], and further extended to branching-time temporal logics CTL and ECTL [4, 1, 2].
This extension enables us to invoke a variety of well-developed methods and redZnements used in the resolution framework for classical logic.
The algorithm to search for loops needed for temporal resolution has been introduced in [3].
With the proof that SNF fi can be served as the normal form for ECTL  , the algorithm becomes fully functional for the latter.
Another contribution of this paper is completing the proof of the correctness of the transformation procedure in ECTL formulated in [2]: we have  now shown that if the set of clauses generated for an ECTL formula is satisdZable then the original formula is satisdZable.
Our results have brought us one step closer to the dZnal stage of our long-term project - to dedZne a clausal resolution method for CTL .
Among other obvious tasks are to redZne the presented method and to analyse its complexity which would enable the development of the corresponding prototype systems.
References [1] A. Bolotov.
Clausal Resolution for Branching-Time Temporal Logic.
PhD thesis, Department of Computing and Mathematics, The Manchester Metropolitan University, 2000.
[2] A. Bolotov.
Clausal resolution for extended computation tree logic ECTL.
In Proceedings of the Time-2003/International Conference on Temporal Logic 2003, pages 107a117, Cairns, July 2003.
IEEE.
[3] A. Bolotov and C. Dixon.
Resolution for Branching Time Temporal Logics: Applying the Temporal Resolution Rule.
In Proceedings of the 7th International Conference on Temporal Representation and Reasoning (TIME2000), pages 163a172, Cape Breton, Nova Scotia, Canada, 2000.
IEEE Computer Society.
[4] A. Bolotov and M. Fisher.
A Clausal Resolution Method for CTL Branching Time Temporal Logic.
Journal of Experimental and Theoretical ArtidZcial Intelligence., 11:77a 93, 1999.
[5] J. BraddZeld.
and C. Stirling.
Modal logics and mu-calculi.
In J. Bergstra, A. Ponse, and S. Smolka, editors, Handbook of Process Algebra, pages 293a330.
Elsevier, North-Holland, 2001.
[6] E. A. Emerson.
Temporal and Modal Logic.
In J. van Leeuwen, editor, Handbook of Theoretical Computer Science: Volume B, Formal Models and Semantics., pages 996a 1072.
Elsevier, 1990.
[7] E. A. Emerson.
Automated reasoning about reactive systems.
In Logics for Concurrency: Structures Versus Automata, Proc.
of International Workshop, volume 1043 of Lecture Notes in Computer Science, pages 41a101.
Springer, 1996.
[8] E. A. Emerson and J. Y. Halpern.
Decision procedures and expressiveness in the temporal logic of branching time.
In JCSS 30(1), pages 1a24, 1985.
[9] E. A. Emerson and J. Y. Halpern.
aSometimesa and aNot nevera revisited: On branching versus linear time temporal logic.
JACM, 33(1):151a178, 1986.
[10] E. A. Emerson and A. P. Sistla.
Deciding full branching time logic.
In Proceedings of STOC 1984, pages 14a24, 1984.
[11] M. Fisher.
A Resolution Method for Temporal Logic.
In Proc.
of the XII International Joint Conference on ArtidZcial Intelligence (IJCAI), pages 99a104, 1991.
[12] P. Wolper.
On the relation of programs and computations to models of temporal logic.
In L. Bolc and A. SzaLas, editors, Time and Logic, a computational approach, chapter 3, pages 131a178.
UCL Press Limited, 1995.
Proceedings of the 11th International Symposium on Temporal Representation and Reasoning (TIMEa04) 1530-1311/04 $20.00 AS 2004 IEEE