A uniform algebraic characterization of temporal functional dependencies* C. Combi+ , A. Montanari* , R. Rossato+ Dipartimento di Informatica, Universita degli Studi di Verona, Italy {combi,rossato}@sci.univr.it * Dipartimento di Matematica e Informatica, Universita degli Studi di Udine, Italy montana@dimi.uniud.it +  Abstract  data [1, 10, 11, 14, 15, 16, 17].
A few of them make it possible to express temporal constraints at different levels of time granularity [1, 16].
Some TFDs have been used during database design to generalize the conventional normalform-based decomposition of relational schemes to the temporal setting, others have been used to express database (temporal) integrity constraints.
In the following, we will focus our attention on this latter use.
Unfortunately, the lack of a common notation makes it difficult to compare, to integrate, and to possibly extend the various proposals.
In the database literature, different types of temporal functional dependencies (TFDs) have been proposed to constrain the temporal evolution of information.
Unfortunately, the lack of a common notation makes it difficult to compare, to integrate, and to possibly extend the various proposals.
In this paper, we outline a unifying algebraic framework for TFDs.
We first introduce the proposed approach, then we use it to give a uniform account of existing TFDs, and finally we show that it allows one to easily express new meaningful TFDs.
In this paper, we outline an algebraic approach that allows us to give a uniform account of existing TFDs.
It is well-known that (atemporal) FDs can be turned into containment equations whose satisfaction can be checked by testing suitable relational algebra expressions for emptiness [12].
In the following, we show that the simplest TFDs can be directly expressed in terms of atemporal FDs.
This is not the case, however, with the most complex TFDs.
To cope with them, we need an auxiliary procedure which generates a set of atemporal relations (the so-called snapshot relations, snapshots for short) on which atemporal FDs must be checked.
We show that a uniform solution can be obtained by reducing the satisfaction problem for TFDs to the problem of establishing whether the evaluation of suitable relational algebra expressions over the temporal database returns the empty set.
As a matter of fact, the most difficult cases are those of TFDs involving different time granularities.
1 Introduction Data dependencies provide a semantic specification of the meaningful instances of a given database/relation scheme.
Functional dependencies (FDs) are a specific class of data dependencies which play an important role in the logical design of relational databases [12].
Formally, given a relation scheme R(Z), a functional dependency FD over R(Z) is an expression of the form X - Y , with X, Y [?]
Z, which is satisfied by a relation r [?]
R(Z) if and only if for every t, t [?]
r, if t[X] = t [X], then t[Y ] = t [Y ].
FDs have been developed in the context of databases devoid of any temporal dimension of data, and thus they provide no direct support to the management of temporal constraints.
Temporal databases allow one to describe the temporal evolution of information by associating one or more temporal dimensions with the stored data [7].
Temporal functional dependencies (TFDs) have been used in temporal databases to constrain the temporal relationships among  The paper is organized as follows.
In Section 2, we briefly survey the different classes of existing TFDs.
In Section 3, we introduce a clinical application to be used to exemplify the proposed solution.
Next, in Section 4 we outline our algebraic approach, and we apply it to the various classes of TFDs.
In Section 5, we show that new meaningful TFDs can be easily expressed in the algebraic framework.
Section 6 summarizes the achieved results, and it briefly discusses further research directions.
* This work has been partially supported by contributions from the Italian Ministry of University and Research (MIUR) under the programs COFIN-PRIN "Constraint-based verification of reactive systems" and "Intelligent analysis of hemodialysis data for the improvement of care processes".
1  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  2 An overview of existing TFDs  Y are sets of attributes.
A TFD X G Y is satisfied by a valid time relation r at time i if and only if the FD X - Y is satisfied by ri [?]
ri+1 , .
.
.
, rmaxT ime .
Dynamic functional dependencies (DFDs) are of the form X N Y, where X and Y are sets of attributes.
A DFD X N Y is satisfied by a valid time relation r at time i, if and only if the FD X - Y is satisfied by ri [?]
ri+1 (by rmaxT ime if i = maxTime).
TFDs involving multiple time granularities.
A time granularity partitions the temporal domain T in various groups of indivisible elements, called granules, where each group corresponds to a distinct time unit.
In temporal databases, granularity systems have been exploited to specify temporal constraints about differently-grained elements of standard calendars, such as the Gregorian one, as well as elements of user-defined calendars, that is, finite sets of time granularities.
A time granularity G is a function from an index set IG to the powerset of the temporal domain (T ) such that for any pair of granules G(i) and G(j), with i = j, (i) G(i) [?]
G(j) = [?]
and (ii) if i < j, then for all t [?]
G(i) and t [?]
G(j) t < t .
Moreover, the subset of IG that maps indices to nonempty granules forms an initial segment of IG .
Various relations can be defined between pairs of granularities, such as, for instance, grouping, refinement, and partition [1].
In [1] Bettini et al.
define the notion of temporal functional dependency (TFD) with multiple time granularities.
A time granularity is defined as a mapping u from the index set N, whose elements are called time points, to the powerset (R) of the absolute temporal domain R. A temporal module scheme is a pair (R, G), where R is a relation scheme and G is a time granularity.
A temporal module is a triple (R, G, ph), where (R, G) is a temporal module scheme and ph is a function, called a time windowing function, that associates a set of tuples with any granule G(i)/time point i (the set of tuples valid at i).
TFDs are of the form X -G Y , and they properly extend atemporal FDs.
By definition, a temporal module (R, G, ph) satisfies a TFD X -G Y , with G coarser than G, if and only if whenever two tuples, that hold on time granules in G covered by the same granule in G , agree on X, they must also agree on Y .
On the basis of such TFDs, they propose a temporal normalization theory together with suitable algorithms for normal-formbased decomposition.
In [16] Wijsen introduces a notion of temporal functional dependency (TFD) for temporal databases extended with time granularity which is quite similar to Bettini et al.
's one [1].
The distinctive concepts of the underlying temporal model are those of temporal relation and object identity.
The temporal domain is assumed to be (isomorphic to) N and its elements are called time points.
A time granularity is defined as a suitable binary relation on N, called temporal relation.
Furthermore, the relational model is extended with the notion of object identity, which is preserved through up-  TFDs devoid of time granularities.
In [14] Vianu represents a temporal relation as a temporal sequence of snapshots.
A new snapshot is obtained from the current one by a global update, which affects some, possibly all, its tuples simultaneously.
According to Vianu's view, each snapshot can be interpreted as a set of objects, each one denoted by a distinct tuple, which preserve their identity through updates.
He distinguishes two classes of data dependencies, respectively called static and dynamic dependencies.
Static dependencies are standard (atemporal) FDs that must be satisfied by any single snapshot, while dynamic dependencies express conditions on the evolution of the database, that is, on the sequence of snapshots.
In [11] Jensen et al.
propose a bitemporal data model that associates a bitemporal element (v, t) with each tuple, where v and t are the values of the two basic temporal dimensions of valid time and transaction time, respectively [7].
The valid time of a fact is the time when the fact is true in the modeled reality, while the transaction time is the time when the fact is current in the database and it can be retrieved.
The scheme of a bitemporal relation is obtained by adding a special temporal attribute to the set of traditional attributes which temporally qualifies a tuple by means of a bitemporal element.
In fact, we can view a bitemporal element as a set of pairs of values associated with the valid and transaction time attributes (and thus bitemporal relations can be expressed in 1NF).
FDs are extended to temporal relations as follows.
Given a bitemporal relation scheme R(Z) and two sets of non-temporal attributes X, Y [?]
Z, a relation r [?]
R(Z) satisfies a temporal functional dependency X -T Y if all snapshots of r satisfy the atemporal FD X - Y (it is thus similar to static dependency introduced by Vianu [14]).
In a subsequent paper [10], Jensen and Snodgrass introduce a set of notions to be used to express temporal aspects of a scheme, and they show how to use them in database design.
In particular, they define suitable notions of temporal key and temporal normal form.
Finally, in [15] Wijsen proposes a data model extended with valid time, where time is represented as a discrete and bounded set of time points TIME = {0, 1, 2, .
.
.
, maxTime}.
The valid time of a tuple is expressed by means of a special attribute VT whose value is the set of time points at which the tuple is true in the reality.
Given a valid time relation r, a snapshot ri of r at time i, with i [?]
N, is the set of valid tuples of r at time i, devoid of their temporal component.
A snapshot functional dependency (FD) X - Y is satisfied by a valid time relation r at time i if and only if it is satisfied by ri .
Keys and normal forms are defined in term of FDs in the standard way.
Besides FDs, Wijsen introduces two classes of temporal dependencies.
Temporal functional dependencies (TFDs) are of the form X G Y, where X and 2  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  dates, and with the ability of dealing with complex objects, that is, objects that may have other objects as components (this is obtained by making it possible to associate with each object attribute either an atomic value or a pointer to another object).
procedure that generates all the required relations.
Next, we show that the problem of checking whether a temporal database satisfies a given (set of) TFD(s) can be always reduced to the problem of establishing whether the evaluation of a suitable relational algebra query over the temporal database returns the empty relation.
3 A clinical application  P-Id p1 p1 p1 p1 p1 p1 p1 ... p1 p1 p1 p1 ...
In this section we briefly introduce a real-world example taken from clinical medicine, namely, chemotherapies for oncological patients, that we shall later use to exemplify the solution we propose.
As a general rule, oncological patients undergo several chemotherapy cycles, and each cycle typically includes the administration of several drugs.
The temporal schedule of drug administrations within each cycle is usually predefined and the same cycle can be repeated several times.
Let us consider, for instance, the following chemotherapy recommendation for Hoadkin's disease [9]: "The ChlVPP regimen consists of chlorambucil (6 mg/m2 /day) on days 1 through 14, vinblastine (6 mg/m2 ) on days 1 and 8, procarbazine (100 mg/m2 /day) on days 1 through 14, and prednisone (40 mg/day) on days 1 through 14.
Patients treated with this regimen receive six cycles repeated every 28 days."
This therapy plan implicitly introduces some time granularities, which define the time scheduling for the assumption of the prescribed drugs.
They are graphically depicted in Figure 1, where we use the shorthands ChlVPP, Chl, V, Pc, and Pd for ChlVPP regimen, chlorambucil, vinblastine, procarbazine, and prednisone, respectively.
Let T P atient be a temporal relation that stores information about the patients who underwent ChlVPP chemotherapies, and let P atient be its atemporal component with scheme P atient(P -Id, Chemo, BG, Drug, Qty), where P-Id is the patient identifier, Chemo is the type of therapy, BG is the blood group of the patient, and Drug and Qty are respectively the name of the assumed drug and its quantity.
Let the valid time V T of each tuple be the time of the specific drug assumption, expressed as the number of days from the beginning of the therapy.
The temporal relation T P atient pairs information about patients with the time of their drug assumption.
The scheme of T P atient is obtained by adding the temporal attribute VT to the set of attributes of the scheme P atient, that is, att(T P atient) = att(P atient) [?]
{V T }.
Chemo ChlVPP ChlVPP ChlVPP ChlVPP ChlVPP ChlVPP ChlVPP ... ChlVPP ChlVPP ChlVPP ChlVPP ...  BG 0+ 0+ 0+ 0+ 0+ 0+ 0+ ... 0+ 0+ 0+ 0+ ...  Drug Chlo Vinb Proc Pred Chlo Proc Pred ... Chlo Vinb Proc Pred ...  Qty 6 6 100 40 6 100 40 ... 6 6 100 40 ...  VT 1 1 1 1 2 2 2 ... 8 8 8 8 ...  Table 1.
A T P atient instance that records data about the first cycle of treatment for p1 .
To clarify the proposed solution, we will make use of some examples of TFDs over T P atient.
Table 1 shows a T P atient instance that stores data about the first cycle of chemotherapy for patient (with identifier) p1 .
The attribute V T encodes the valid time in term of days from the beginning of the therapy.
As an example, the first four tuples store information about the assumption of the drugs Chlo, Vinb, Proc, and Pred on the first day of the cycle (VT=1).
They can be retrieved by executing the following query: pP -Id,Chemo,BG,Drug,Qty (sV T =1 (T P atient)) In general, the snapshot ri , at time i, contains all and only the tuples of a temporal relation T r valid at time i over its atemporal attributes Z, that is, ri = pZ (sV T =i (T r)).
4.1  Vianu's dynamic dependencies  In [14] Vianu proposes a simple extension to the relational model aimed at capturing the temporal evolution of a database.
It views a temporal database as a temporal sequence of database instances (states).
Updates, insertions, and deletions force the transition from one state to the next one.
More precisely, a temporal database is defined as a sequence of consecutive database instances and a sequence of "update mappings" that link pairs of consecutive instances  4 An algebraic approach for TFDs In this section, we first show how TFDs can be brought back to (atemporal) FDs over atemporal relations, obtained by means of suitable algebraic operations.
As a matter of fact, for some TFDs it is necessary to provide an external 3  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  ChlVPP(1)  ChlVPP(2)  ChlVPP(6) Time  Time Day(1) Chl(1) Pc(1) Pd(1) V(1)  Day(2) Chl(2) Pc(2) Pd(2)  ..... ..... ..... .....  Day(8) Chl(8) Pc(8) Pd(8) V(2)  ..... ..... ..... .....  Day(28)  Day(14) Chl(14) Pc(14) Pd(14)  Figure 1.
Granularities involved in the chemotherapy treatment.
attributes a1 , .
.
.
, ak have been replaced by the attributes b1 , .
.
.
, bk :  (old/new instances).
A tuple is viewed as (a representation of) an object.
Since a tuple and its updated version denote the same object, every tuple preserves its identity through updates.
This is guaranteed by the update mappings ui : for every tuple x belonging to the instance Ii , ui (x) is the updated version of x belonging to Ii+1 .
Conditions on the temporal evolution of objects are expressed by means of dynamic dependencies.
According to Vianu's notation, we will denote the old [?]
rb1 ...bk |a1 ...ak (ri+1 ) By a natural join on l, we can merge the two snapshot re~ lations ri and ri+1 into an atemporal relation rVi,i+1 , whose tuples collect the values of the original temporal relation immediately before and immediately after the update:  [?]
~  and the new value of an attribute A by A and A, respectively.
Furthermore, to preserve the identity of tuples through updates, Vianu extends the scheme of a relation by adding a special attribute l (a placeholder for object identifiers), whose value allows one to link a tuple and its updated version.
Given a temporal relation T r, we denote by T r * the relation obtained by adding the attribute l to the scheme of T r (cf.
Table 2):  rVi,i+1 = ri 1 ri+1 ~  Let Y be the result of the renaming of the attributes in [?]
att(T r* ) = {l} [?]
att(T r) Dynamic dependencies relate every relation instance (snapshot) to its successor.
More precisely, a dynamic de[?]
[?]
[?]
[?]
[?]
by Ai (resp.
Xi ).
We have that X -Y , with X [?]
Y = [?
], is satisfied by T r * if and only if the query sY1 =Y3 (Q 1(X=X2 [?]
V T =V T2 ) S),  where  p{l}[?
]Z (sV T =i (T r* )) and let  [?]
dependency X -Y can indeed be encoded by means of the following relational algebra query.
Hereafter, for i >= 1, let T ri* be the temporal relation obtained from T r * by replacing every attribute A (resp.
set of attributes X) of T r *  pendency X -Y imposes to tuples that feature the same values for the attributes X at time i to feature the same values for the attributes Y at time i + 1.
We now show that the problem of checking whether a dynamic dependency is satisfied by a given temporal relation can be reduced to that of checking whether a functional dependency over a suitable atemporal relation is satisfied.
Such an atemporal relation is obtained by joining the snapshot at time i with the snapshot at time i + 1, once the attributes of the latter have been properly renamed.
Let ri be the snapshot of T r * at time i returned by the query:  ~ ri+1  [?]
Y .
We have that the dynamic dependency X -Y is satisfied by the temporal relation T r * if and only if the functional ~ dependency X -Y is satisfied by the relations rVi,i+1 for every time point i.
Note that we need an external procedure to generate, for every time point i, the relation rVi,i+1 to test.
Such a procedure is not necessary anymore if we directly work on the given temporal relation.
The dynamic  1  Q  [?]
S  [?]
T r* 1(l=l1 [?]
V T +1=V T1 ) T r1*  T r*2 1(l2 =l3 [?]
V T2 +1=V T3 ) T r3* ,  returns the empty set.
be the snapshot of T r * at time i + 1, where the  1 To  simplify the structure of queries, we use the shorthand +1.
4  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  The join operation merges tuples which feature the same values for the attributes X and X1 , which concern the evolution of the same object, that is, have the same values for l and l1 , and are valid on two successive time points.
More complex join operations are needed when we need to consider the same attribute(s) before and after the update, as shown by the following example.
where ~  and Cond  BG 0+ 0+ 0+ 0+ 0+ 0+ 0+ ... 0+ 0+ 0+ 0+ ...  Drug Chlo Vinb Proc Pred Chlo Proc Pred ... Chlo Vinb Proc Pred ...  Qty 6 6 100 40 6 100 40 ... 6 6 100 40 ...
[?]
[?]
[?]
of Chemo, Drug -- Drug can be brought back to the problem of establishing whether the query sDrug1 =Drug3 (Q 1Cond S), where  VT 1 1 1 1 2 2 2 ... 8 8 8 8 ...  T P atient* 1(l=l1 [?]
V T +1=V T1 ) T P atient*1  Q  -  S  -  T P atient*2 1(l2 =l3 [?]
V T2 +1=V T3 ) T P atient*3  Cond  [?]
Chemo = Chemo2 [?]
Drug = Drug2 [?]
V T = V T2 ,  returns the empty set.
Note that, in this case, the query must take into account the fact that the intersection of the attributes in the premise and those in the consequence of the dependency is not empty.
4.2  Jensen, Snodgrass, and Soo's TFDs  In [11] Jensen, Snodgrass, and Soo address the problem of expressing (temporal) functional dependencies on data provided with both valid and transaction time dimensions.
A bitemporal instance of the relation Patient that stores data about the first cycle of the therapy is given in Table 3.
We assume the transaction time of the tuples to be equal to now to indicate that they are current in the database.
Furthermore, we assume a point-based point of view according to which the bitemporal elements (t, v), associated with each tuple, are represented by means of two different temporal attributes (TT and VT, respectively).
Jensen et al.
define the satisfaction of TFDs in terms of the satisfaction of the corresponding atemporal FDs: a TFD X -T Y is satisfied by a bitemporal relation r B if and only if every atemporal instance of r B satisfies the FD X - Y .
The point-based representation of a bitemporal relation T r B makes it possible to reduce the satisfaction of X -T Y over T r B to the satisfaction of X - Y over the following relations ri,j :  Table 2.
A T P atient* instance that stores data about the first cycle of treatment for p1 .
Consider the following condition on the relation T P atient* : "each new drug is determined uniquely on the basis of the current type of chemotherapy and the assumed drug".
According to Vianu's notation, this condition can [?]
N P Id, N Chemo, N BG, N Drug, N Qty|  As already pointed out, we need an external procedure to generate, for i = 1, .
.
.
, 28, the relation rVi,i+1 and to check the satisfaction of the given functional dependency on it.
As an alternative, the problem of checking the satisfaction  A T P atient* instance is reported in Table 2.
Its first tuple (oid1, p1, ChlVPP, 0+, Chlo, 6, 1) states that the patient (with identifier) p1 assumed the drug chlorambucil on the first day.
The special attribute l plays the role of tupleidentifier.
The values oid1, oid2, oid3, and oid4 for the attribute l identify the tuples associated with the assumption of the drugs Chlo, Vinb, Proc, and Pred, respectively.
Chemo ChlVPP ChlVPP ChlVPP ChlVPP ChlVPP ChlVPP ChlVPP ... ChlVPP ChlVPP ChlVPP ChlVPP ...
[?]
P Id, Chemo, BG, Drug, Qty  P atient* (l, P Id, Chemo, BG, Drug, Qty).
P-Id p1 p1 p1 p1 p1 p1 p1 ... p1 p1 p1 p1 ...  = rCond (ri+1 )  ri+1  Example.
Let us extend the scheme of the temporal relation T P atient with the special attribute l. Let P atient* be the resulting temporal relation.
We have that att(T P atient* ) = att(P atient* ) [?]
{V T }, where the atemporal scheme of P atient* is:  l oid1 oid2 oid3 oid4 oid1 oid3 oid4 ... oid1 oid2 oid3 oid4 ...  = p{l}[?
]Z (sV T =i (T P atient* ))  ri  [?]
be expressed by the temporal dependency: Chemo, Drug [?]
-- Drug.
We have that the temporal relation T P atient* satisfies the given dynamic dependency if and only if, for every i, the atemporal dependency Chemo, Drug - N Drug is satisfied by the atemporal relation: ~  rVi,i+1 = ri  ri+1  ri,j = pZ (s(T T =j[?
]V T =i) (T rB )) 5  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  P-Id p1 p1 p1 p1  Chemo ChlVPP ChlVPP ChlVPP ChlVPP  BG 0+ 0+ 0+ 0+  Drug Chlo Vinb Proc Pred  Qty 6 6 100 40  T {(now,1),(now,2),(now,3), .
.
.
, (now,14)} {(now,1),(now,8)} {(now,1),(now,2),(now,3), .
.
.
, (now,14)} {(now,1),(now,2),(now,3), .
.
.
, (now,14)}  Table 3.
A T Patient bitemporal instance.
dependency X - Y is satisfied by ri [?
]ri+1 .
.
.[?
]rmaxT ime .
It is satisfied by a temporal relation T r if and only if it is satisfied by T r at every time j [?]
TIME.
We reduce the satisfaction of a TFD XGY over the relation T r at time i to the satisfaction of the FD X - Y over the following relation r>=i :  For all i, j, the relation ri,j consists of the set of tuples current at time j (T T = j) which are valid at time i (V T = i).
Thus, to check the satisfaction of the TFD X -T Y on T rB , we need to generate, for all i, j, the relation ri,j and to check whether it satisfies the FD X - Y .
The use of such an auxiliary procedure can be avoided as follows.
We can reduce the problem of checking the given TFD to the equivalent problem of establishing whether the following query returns the empty set:  r>=i = pZ (sV T >=i (T r)) The relation r>=i contains the valid tuples of T r from time i to time maxTime.
To check the satisfaction of a TFD XGY over a temporal relation T r, we have to check the satisfaction of XGY at each time j [?]
TIME.
To this end, it suffices to check the satisfaction of the FD X - Y on the relation r>=1 = pZ (sV T >=1 (T r)) = pZ (T r) (according to Table 1, the first time point is numbered by 1).
Equivalently, we can reduce the problem of checking the satisfaction of a TFD XGY over the temporal relation T r to the problem of establishing whether the following query returns the empty set:  sY =Y1 (T rB 1(X=X1 [?]
V T =V T1 [?]
T T =T T1 ) T r1 B ) The join operation merges the tuples which are valid at the same time and current at the same time, which feature the same values for the attributes X and X1 .
Example.
The TFDs proposed by Jensen et al.
can be used to express the following constraint: "at one time, a patient can undergo only one chemotherapy" (P -Id -T Chemo).
The FD P -Id - Chemo must be checked on all the snapshots of the relation T P atientB , that is, for each valid time point i and each transaction time point j of a tuple, we must show that the relation  sY =Y1 (T r 1X=X1 T r1 )  satisfies the FD.
Once more, the problem of checking the satisfaction of P -Id - Chemo on T P atientB can be alternatively brought back to the problem of checking whether the following query returns the empty set:  Example.
Let us consider the following condition on the relation T P atient: "every patient has a value of the blood group which remains unchanged all over the time".
This dependency can be expressed in Wijsen's notation as {P -Id}G{BG}.
The relation T P atient satisfies {P -Id}G{BG} if (and only if) the dependency P -Id - BG is satisfied by  sChemo=Chemo1 (T P atientB 1Cond T P atientB 1 ),  r>=1 = pZ (sV T >=1 (T P atient)) = pZ (T P atient)  ri,j = pZ (sT T =j [?]
V T =i (T P atientB ))  where  Alternatively, checking the satisfaction of {P -Id}G{BG} over T P atient can be brought back to checking whether the following query returns the empty set:  Cond [?]
(P -Id = P -Id1 [?]
V T = V T1 [?]
T T = T T1 )  4.3  Wijsen's TFDs  sBG=BG1 (T P atient 1P -Id=P -Id1 T P atient1 ) According to Wijsen's definition [15], the dynamic functional dependency XNY is satisfied at time i if the functional dependency X - Y is satisfied by ri [?]
ri+1 .
A dynamic functional dependency is satisfied by a temporal relation T r if and only if it is satisfied by T r at every time j [?]
TIME.
The satisfaction of Wijsen's temporal functional dependencies and dynamic functional dependencies are expressed in terms of satisfaction of functional dependencies on a specific set of snapshots [15].
According to Wijsen's definition [15], a temporal functional dependency XGY is satisfied by a temporal relation T r at time i if the functional 6  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  X - Y is satisfied, for each i [?]
N such that G (i) = [?
], by the following relation:  We reduce the satisfaction of XNY over the temporal relation T r at time i, with i < maxT ime, to the satisfaction of X - Y over the following relation ri,i+1 :  r[si ,ei ] = pZ (s(V T >=si [?
]V T <=ei ) (T r))  ri,i+1 = pZ (sV T =i [?]
V T =i+1 (T r))  where Z is the set of atemporal attributes and si and ei are the granules of G(i) delimiting the temporal granule G (i), that is, G (i) = [si , ei ] at granularity G2 .
The relation r[si ,ei ] consists of the tuples of T r, defined on the set of atemporal attributes Z, valid at some time point belonging to the i-th granule of G .
In such a case, it is necessary to check the satisfaction of X - Y in all the relations r[si ,ei ] associated with the non-empty granules of G .
As an alternative, the constraint expressed by a temporal functional dependency X -G Y can be described by means of a suitable relational algebra query.
Let GranG = (GS , GE ) be a relation whose tuples represent the starting point (GS ) and the ending point (GE ) of the granules of the (finite3 ) granularity G at the granularity G used for the relation T r. The TFD X -G Y is satisfied on T r if and only if the following query returns the empty set:  If i = maxT ime, the dependency has to be checked on the relation pZ (sV T =maxT ime (T )).
To check the satisfaction of XNY on T r, we have to check the satisfaction of X - Y on each relation rj,j+1 , with j [?]
TIME.
To this end, we need an external procedure to generate, for all j, the relation rj,j+1 and to check whether it satisfies the functional dependency.
Again, the use of the external procedure can be avoided by checking whether the following query, whose join condition constrains the tuples to merge to be valid on two consecutive time points, returns the empty set: sY =Y1 (T r 1(X=X1 [?]
(V T +1=V T1 [?
]V T =V T1 )) T r1 ) Example.
Let us consider the following temporal dependency over the relation T P atient: "every patient assuming the same drug in two consecutive time points cannot change the type of chemotherapy in these points".
According to Wijsen's notation, this dependency can be expressed as {P -Id, Drug}N{Chemo}.
It is satisfied by the temporal relation T P atient at time i, if the dependency P -Id, Drug - Chemo is satisfied by the following relation ri,i+1 :  sY =Y1 ((T r 1X=X1 T r1 ) 1Cond GranG ) where Cond  If we want to check whether the relation T P atient satisfies the given dependency, we must generate the relation ri,i+1 , for every i = 1, .
.
.
, 28, and check the satisfaction of P -Id, Drug - Chemo on it.
As an alternative, the problem of checking the satisfaction of {P -Id, Drug}N{Chemo} over T P atient can be brought back to the problem of checking whether the following query returns the empty set:  r[si ,ei ] = pZ (s(V T >=si [?]
V T <=ei ) (T P atient)) As an example, with respect to the T Patient instance of Table 1, the time granules si and ei (at the bottom granularity of days), delimiting the temporal interval related to the first cycle of treatment, are 1 and 28.
Thus, the relation r[1,28] contains all the tuples which are valid during the first granule of the ChlVPP granularity.
Alternatively, the problem of checking the satisfaction of P -Id, Drug -ChlV P P Qty over T Patient can be brought back to that of checking whether the following query returns the empty set:  sChemo=Chemo1 (T P atient 1Cond T P atient1 ) where [?]
P -Id = P -Id1 [?]
Drug = Drug1 [?]
V T + 1 = V T1  4.4  G S <= V T <= G E [?]
GS <= V T 1 <= G E  Example.
Let us consider the following temporal constraint over the relation T Patient: "a patient cannot assume different quantities of the same drug within a therapy cycle".
In Bettini, Jajodia, and Wang's formalism, it can be expressed by the TFD P -Id, Drug -ChlV P P Qty.
This dependency is satisfied by the relation T Patient if P -Id, Drug - Qty is satisfied, for each i [?]
N such that ChlVPP(i) = [?
], by the relation r[si ,ei ] obtained from the following relational algebra expression:  ri,i+1 = pZ (sV T =i [?]
V T =i+1 (T P atient))  Cond  [?]
Bettini, Jajodia, and Wang's TFDs  sQty=Qty1 (Q 1Cond GranChlV P P ) 2 For sake of simplicity, we restrict ourselves to granularities without gap inside.
3 To deal with the general case of possibly infinite granularities, we can assume that the relation GranG is suitably instantiated by an external procedure with regard to the relation to join with.
Bettini, Jajodia, and Wang TFD is a statement of the form X -G Y , where G is a temporal granularity [1].
Such a TFD is satisfied by a temporal instance T r of a temporal module (R, G, ph) if the functional dependency 7  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  where Q  -  T P atient 1P -Id=P -Id1 T P atient1  Cond  [?]
G S <= V T <= G E [?]
GS <= V T 1 <= G E  proposed dependency we would need a set of TFDs with multiple granularities.
As an example, the proposed constraint can be expressed by a set of 5 TFDs in the formalism of Bettini et al.
[1].
Each one of the 5 TFDs is of the form P -Id, Drug -Gi Qty, where i ranges from 1 to 5.
The 5 granularities are defined as having granules of size 5 days and are such that each granule Gi+1 (j) starts one day after the starting of the granule Gi (j).
As a further example, let us consider the following constraint: "the quantities of a prescribed drug must be repeated for any chemotherapy every seven days".
In this case, TFDs with multiple granularities cannot help us, because we are constraining corresponding tuples of different groups of seven days (i.e., granules).
Such a dependency can be expressed as Chemo, Drug -27 Qty, and its satisfaction can be imposed by constraining the following query to return the empty set:  The TFDs with granularities proposed by Wijsen in [16] can be dealt with in a similar way.
5 Defining new TFDs Besides providing a uniform description of the TFDs proposed in the literature, the proposed algebraic approach allows us to easily characterize further TFDs, which, at the best of our knowledge, have not been previously considered.
As an example, let us consider the following constraint: "the quantity of a prescribed drug for a given patient cannot be changed from one administration to the following one, if the two administrations happen within 5 days".
Such a condition can be expressed by the dependency P -Id, Drug -5 Qty, whose satisfaction can be imposed by constraining the following query to return the empty set:  s(Qty=Qty1 [?
]V T -V T1 =7) (Q - pW (Q 1Cond S)) where W  [?]
(att(T P atient) [?]
att(T P atient1 ))  Q  -  T P atient 1Chemo=Chemo1 [?
]Drug=Drug1  S  -  T P atient2 1Chemo2 =Chemo3 [?
]Drug2 =Drug3  s(Qty=Qty1 [?
]V T -V T1 <=5) (Q - pW (Q 1Cond S))  T P atient1  where [?]
(att(T P atient) [?]
att(T P atient1 ))  Q  -  S  -  T P atient 1P -Id=P -Id1 [?
]Drug=Drug1 T P atient1 T P atient2 1P -Id2 =P -Id3 [?
]Drug2 =Drug3 T P atient3  W  T P atient3  and Cond  [?]
Chemo = Chemo2 [?]
Drug = Drug2 [?]
V T = V T 2 [?]
V T1 > V T 3  and Cond  [?]
P -Id = P -Id2 [?]
Drug = Drug2 [?]
V T = V T 2 [?]
V T1 > V T 3  6 Conclusions  The query allows one to correlate the tuples related to consecutive assumptions of the same drug for the same patient (difference and join operations).
The select condition checks whether two consecutive assumptions happen within 5 days (V T - V T1 <= 5) and have different quantities for the associated drug (Qty = Qty1 ).
If this is the case, then the temporal dependency P -Id, Drug -5 Qty is not satisfied.
This constraint represents a temporal functional dependency which cannot be expressed by the proposed TFDs.
On the one hand, those devoid of granularities deal either only with tuples valid on consecutive time points or separately on tuples valid at each time point or globally on all the tuples valid at every time point.
On the other hand, TFDs with multiple granularities consider sets of tuples according to a global time partition, not related to the distance between two consecutive tuples.
As a matter of fact, to express the  In this paper, we have shown that the problem of checking the satisfaction of TFDs can be reduced to the problem of establishing whether the evaluation of suitable relational algebra expressions returns the empty set.
This approach allows us to manage in a uniform way the different TFDs proposed in the literature and to express new meaningful TFDs.
We are currently working on the problem of establishing the complexity of checking for emptiness the resulting relational algebra expressions on a given database.
It is wellknown that the data complexity of relational algebra queries is in LOGSPACE with respect to the database size [12].
Efficient ad-hoc algorithms can be studied for the class of algebraic expressions needed to express relevant TFDs.
Besides the model-checking problem we addressed in this paper, a more general issue is to verify whether there 8  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  exists a database satisfying a given expression (satisfiability checking).
The general problem of checking temporal constraints has been extensively studied in the literature [2, 3, 4, 13] both for first-order temporal logic (FOTL) and for two-sorted classical first-order logic.
In particular, in [13] Lipeck and Saake identify a restricted class of FOTL formulae, often called biquantified formulae, which includes formulae with only future temporal operators and admits only a restricted form of quantification defined as follows.
Quantifiers can be either external (not in the scope of any temporal connective) or internal (no temporal connectives in their scope).
In the considered class of formulae, all external quantifiers are universal.
In [2] Chomicki analyzes the problem of checking temporal logic constraints on the basis of the notion of satisfaction constraints on finite histories.
The considered class of logical formulae, which allow one to capture a significant set of temporal integrity constraints, is the class of the safety formulae [3] (intuitively, a safety formula says that "nothing bad ever happens").
A violation of a safety formula can be detected as a violation of its satisfaction in some finite history of the database; for these reasons, this class of formulae are particularly suitable for checking constraints.
The notion of potential constraint satisfaction [4] describes the fact that an integrity constraint is potentially satisfied at instant t if the finite history of the database (i.e.
the sequence of instances up to the current one) can be extended to an infinite history that satisfies it.
In [3] Chomicki and Niwinski prove that the problem of potential constraint satisfaction for biquantified safety formulae, with no internal quantifiers, is decidable in exponential time.
We are exploring the possibility of automatically translating our relational algebra expressions into biquantified formulae.
By a preliminary analysis of TFDs, we have been able to prove that some of them can be easily expressed by a biquantified formula.
As an example, Wijsen's DFDs of the form XNY can be expressed by the biquantified FOTL formula [?
]X, Y, Y1 ((r(X, Y ) [?]
r(X, Y1 )) - Y = Y1 ), where  is the temporal operator "next" [5].
Finally, we would like to compare the expressiveness of the proposed (algebraic) approach with that of the logical framework for TFDs outlined in [8], based on an extension of the notion of labeled linear time structure for time granularity introduced in [6].
[3] J. Chomicki and D. Niwinski.
On the feasibility of checking temporal integrity constraints.
Journal of Computer and System Sciences, 51(3):523-535, 1995.
[4] J. Chomicki and G. Saake.
Logics for Databases and Information Systems.
Kluwer Academic Publishers, 1998.
[5] J. Chomicki and D. Toman.
Temporal logic in information systems.
In Logics for Databases and Information Systems [4], pages 31-70.
[6] C. Combi, M. Franceschet, and A. Peron.
Representing and reasoning about temporal granularities.
Journal of Logic and Computation, 14(1):51-77, 2004.
[7] C. Combi and A. Montanari.
Data models with multiple temporal dimensions: completing the picture.
In Proc.
of the 13th Conference on Advanced Information Systems Engineering, volume 2068 of LNCS, pages 187-202, 2001.
[8] C. Combi and R. Rossato.
Temporal functional dependencies with multiple granularities: a logic based approach.
In Proc.
of the 15th Conference on Database and Expert System Applications, volume 3180 of LNCS, pages 864-873, 2004.
[9] C.D.
Weekes et al.
Hodgkin's disease in the elderly: Improved treatment outcome with a doxorubicin-containing regimen.
Journal of Clinical Oncology, 20(4):1087-1093, 2002.
[10] C.S.
Jensen and R. T. Snodgrass.
Temporally enhanced database design.
In M.P.
Papazoglou, S. Spaccapietra, and Z. Tari, editors, Advances in Object-Oriented Data Modeling, pages 163-193.
MIT Press, 2000.
[11] C.S.
Jensen, R.T. Snodgrass, and M.D.
Soo.
Extending existing dependency theory to temporal databases.
IEEE TKDE, 8(4):563-581, 1996.
[12] P. C. Kanellakis.
Elements of Relational Database Theory, volume B: Formal Models and Sematics of Handbook of Theoretical Computer Science, pages 1073-1156.
Elsevier and MIT Press, 1990.
[13] U.W.
Lipeck and G. Saake.
Monitoring dynamic integrity constraints based on temporal logic.
Information Systems, 12(3):255-269, 1987.
[14] V. Vianu.
Dynamic functional dependency and database aging.
Journal ACM, 34(1):28-59, 1987.
[15] J. Wijsen.
Design of temporal relational databases based on dynamic and temporal functional dependencies.
In J. Clifford and A. Tuzhilin, editors, Workshop on Temporal Databases, pages 61-76.
Springer, 1995.
[16] J. Wijsen.
Temporal FDs on complex objects.
ACM TODS, 24(1):127-176, 1999.
References  [17] J. Wijsen, J. Vandenbulcke, and H. Olivie.
On time-invariance and synchronism in valid-time relational databases.
Journal of Computing and Information, pages 1192-1206, 1994.
[1] C. Bettini, S. Jajodia, and X.S.
Wang.
Time Granularities in Databases, Data Mining, and Temporal Reasoning.
Springer, 2000.
[2] J. Chomicki.
Efficient checking of temporal integrity constraints using bounded history encoding.
ACM Transactions on Database Systems, 20(2):149-186, 1995.
9  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE