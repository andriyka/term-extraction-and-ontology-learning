2011 Eighteenth International Symposium on Temporal Representation and Reasoning  Synthesising Classic and Interval Temporal Logic Sven Schewe Department of Computer Science University of Liverpool Liverpool, United Kingdom sven.schewe@liverpool.ac.uk  Cong Tian ICTT and ISN Lab Xidian University Xi'an, 710071, P.R.China c.tian.xdu@gmail.com  Abstract--Linear-Time Temporal Logic (LTL) is one of the most influential logics for the specification and verification of reactive systems.
An important selling point of LTL is its striking simplicity, which might be a reason why none of the many extensions suggested to LTL have gained the same influence.
Interval based temporal logics like Interval Temporal Logic (ITL) are a more recent branch of temporal logics with their own niche of interesting applications.
On first glance, interval based temporal logics very little resemble LTL and the spread of these logics beyond their niche is hampered by a seeming structural incompatibility with LTL.
When competing for being applied on a larger scale, interval based temporal logics would fight a losing battle against a more established competitor with better complexity and mature tools.
In this paper, we suggest to extend ITL to Pop Logic (PL) by introducing a simple pop operator that revokes the binding of the chop operation--very much like the popping operation in a stack--and show that LTL can be viewed as a syntactic subset of PL.
This is a surprising twist: by strengthening the comparably exotic logic ITL slightly and by using the new pop and the old chop operator as primitive constructs, we obtain a logic for which LTL is a de-facto syntactic fragment.
The power of this extension is that it can, by subsuming both interval and classic temporal logics, synthesise both concepts to a common framework.
The charm of this extension is that PL does not sacrifice the simplicity that makes its sub-logics attractive.
power of LTL is restricted to star-free expressions.
To overcome this limitation, several extensions and variations have been proposed.
Notably, Quantified Linear Time Temporal Logic (QLTL) [17] and Extended Temporal Logic (ETL) [22], [21] are extensions of LTL for the expressiveness of full o-regular language.
Temporal Logic of Actions (TLA) is a variation of LTL where state changes can be easily handled through actions [12].
However, these extensions (or variations) affect the simplicity of LTL and make it less intuitive.
This might be one of the reasons why none of them has gained the same influence as LTL itself.
Interval based temporal logics are a more recent branch of temporal logics with their own niche of interesting applications.
The characteristic operator of these logics is the chop operator, often denoted by the symbol ';'.
Different from the traditional temporal operators (always) and U (until), a chop construct, p ; q, holds over a path (or an interval) if, and only if, the path can be split into two parts, such that p holds over the first part and q holds over the second part.
The chop operator was first used as a temporal construct by Harel, Kozen and Parikh [11] and studied in more depth by Chandra, Halpern, Meyer and Parikh [3].
Halpern, Manna, and Moszkowski showed that chop is a useful operator when reasoning about time-dependent digital hardware [10], which triggered the development Interval Temporal Logic (ITL), a temporal logic based on chop, chop star, next, and projection operations, by Moszkowski [13], [14].
Initially, ITL is confined within finite models.
Projection Temporal Logic (PTL) [5], [6], [7] is an extension of ITL with infinite models and a new projection construct, (P1 , .
.
.
, Pm ) pr j Q.
Compared to classic temporal logics, interval based temporal logics greatly simplify the formulation of certain correctness properties [8], which underlines the usefulness of these logics for specification and formal reasoning about concurrent systems.
Interval based temporal logics lend themselves particularly well to reasoning about properties with a 'scope'; such properties are very common in most programming languages.
Further, with chop operations, sequential behaviours can be described elegantly and succinctly; and full regular expressiveness can easily be achieved by the introduction of a chop star operator, which can be intuitively understood as the multi-time implementa-    I. I NTRODUCTION Temporal logics are popular formalisations that can express properties about the temporal order of events.
The family of temporal logics has grown over the years, containing linear [15] and branching time logics [4], [2], and, more recently, game, alternating time, and coordination logics [1], [9].
While linear time temporal logics are concerned with properties of paths, branching time logics describe properties that depend on the branching of computational tree structures.
There has been a long debate between linear time and branching time temporal logics, but three decades worth experiences have shown that branching time logics are hard to be understood and error-prone [16], [20].
In contrast, linear time temporal logics seem to lend themselves to the system designers.
This makes Linear-time Temporal Logic (LTL) [15], the original linear time temporal logic, one of the most influential logics in specification and verification.
From a theoretical point of view, one can show that the expressive 1530-1311/11 $26.00 (c) 2011 IEEE DOI 10.1109/TIME.2011.19  64  operator.
Intuitively, a chop operator pushes a new interval into an interval stack, while a pop-operator pops the top element of this stack (hence the name).
Just like ITL, its extension PL has a natural semantics for finite and infinite words.
tion of a chop operation.
Interval based temporal logics very little resemble LTL and the spread of these logics beyond their niche is hampered by a seemingly structural incompatibility with LTL.
When competing for being applied on a larger scale, interval based temporal logics would fight a losing battle against a more established competitor with better complexity and well developed tools.
This leads to the question of whether or not the differences between these logics can be bridged without affecting their simplicity.
A first approach would be to consider a simple merge of the operators.
Why not enrich LTL by a chop operator?
Or, likewise, ITL with an until?
The disadvantage of such a solution is that the strongest advantages of these logics is their simplicity: they are build around a single intuitive concept.
In this sense, each extension comes to the cost of elegance and effects the intuitive access to these logics.
In this paper, we discuss an alternative approach.
We introduce a natural extension of ITL, Pop Logic (PL), by introducing a simple operator pop operation, denoted as |, that revokes the binding of a chop operation.
(The name is inspired by the popping operation in a stack.)
The pop operation is interesting in itself: it can be used as a pseudo inverse of a chop operation, as (| ph) ; true is logically equivalent to ph, and it provides a fresh view on the interval temporal logics.
In PL, we view the scoping implied by the chop operator as the scoping invoked by a call.
The pop operation provides access to lower levels of the call tree, which implies a recognition of the call structure in the semantics of the logic.
This entails a semantics that accurately reflects this call structure.
But while it clearly provides some insight into the relation of calls and interval logic, the main advancement is the link it establishes with LTL: We show that LTL operators can be viewed as snippets of PL operators.
LTL can therefore justly be viewed as a defacto syntactic subset of PL.
This, in turn, provides another insight to interval temporal logics: Using the extension, we get--with LTL--a meaningful--and even popular--a PSPACE-complete sub-logic of PL.
We use this observation to define more general structural restrictions of PL that preserve this low complexity.
The remainder of the paper is organised as follows.
The following section presents the syntax and semantics of Pop Logic and we discuss its relation to ITL in Section III.
We then discuss the embedding of LTL into PL in Section IV and demonstrate the decidability of PL by embedding it in QLTL in Section V. (This proof simplifies, as a small side result, the known decidability proof of ITL.)
Finally, we study PSPACE-complete subsets of PL in Section VI.
A. Syntax of Pop Logic Pop Logic is interpreted over finite and infinite words over a countable set P of atomic propositions, which includes a special proposition  (true) that holds in every position of the word.
The syntax of Pop Logic is given by the grammar ph ::= p | !ph | ph [?]
ph |  ph | ph; ph | | ph,  where p [?]
P is an atomic proposition.
PL extends the syntax of ITL (see the following section) by the unary pop operator |.
B.
Semantics of Pop Logic We call a PL formula ph well formed if there exists no node in the formula tree of ph such that strictly more pop operators than chop operators occur on the way from the root of the formula tree to this node.
We define the PL semantics only for well formed formulas.
The intuition for the exclusion of ill formed formulas is that we would otherwise try to pop the bottom element of an interval stack.
For l, u [?]
o and u [?]
o  {[?
]}, [l, u] = {k [?]
o | l <= k <= u} and [l, u [= {k [?]
o | l <= k < u } are (integer) intervals.
The semantics of a well formed PL formula ph leans on the semantics of ITL, but as we have the power to revoke the effect of previous chop operators, we have to keep track of a stack of intervals, comparable to the call structure in recursive procedures.
Consequently, a sub-formula ps of ph needs to be interpreted in the context of this stack of intervals at the time where ps is evaluated.
PL is interpreted over a (finite or infinite) word s [?]
(2P )*  (2P )o .
When convenient, we interpret s as a function from [0, |s|[ to 2P , s : [0, |s|[- 2P .
In the following, I0 , .
.
.
, In (with n [?]
o) is a non-empty interval stack with [0, |s|[= I0 [?]
I1 [?]
.
.
.
[?]
In .
We first define the interpretation of a word s in an interval stack I0 , .
.
.
, In at a position k. s; I0 , .
.
.
, In ; k |= p s; I0 , .
.
.
, In ; k |= !ph s; I0 , .
.
.
, In ; k |= ph [?]
ps  II.
P OP L OGIC  iff k [?]
In and p [?]
s(k), iff s; I0 , .
.
.
, In ; k |= ph, iff s; I0 , .
.
.
, In ; k |= ph or s; I0 , .
.
.
, In ; k |= ps, s; I0 , .
.
.
, In ; k |= ph iff s; I0 , .
.
.
, In ; k + 1 |= ph, s; I0 , .
.
.
, In , [b, e[; k |= ph ; ps iff k [?]
[b, e[ and [?
]l [?]
[k, e[.
s; I0 , .
.
.
, In , [b, e[, [b, l]; k |= ph and s; I0 , .
.
.
, In , [b, e[, [l, e[; l |= ps, and s; I0 , .
.
.
, In , In+1 ; k |=| ph iff s; I0 , .
.
.
, In ; k |= ph.
In this section, we introduce Pop Logic (PL), a syntactical extension of ITL with a pop operator '|' that revokes the most recent effect (interval restriction) imposed by a chop  A finite of infinite word s is a model of ph, denoted s |= ph, if, and only if, ph holds initially on the complete word, that is, if, and only if, s; [0, |s|[; 0 |= ph holds.
65  Note that, as usual, for all finite words s and all k >= |s|, s; k |= .
No pop on the singleton stack.
: If the interval stack contains only one element, then the semantics of the pop operator is not properly defined.
Note that we could easily avoid this by defining 's; I0 ; k |= | ph if, and only if, s; I0 ; k |= ph'.
Choosing to do so would also allow us to treat ill formed formulas by a convention that could intuitively be phrased as 'an attempt to pop the bottom element of an interval stack is ignored'.
However, we consider it more natural to simply disallow such operations.
In PL, we have the following abbreviations: PUSH EVENTUALLY ALWAYS UNTIL  In order to obtain a simple logic, we have extended a basic version of ITL, ITL without star [5], [7], whose syntax simply represents the PL syntax without pop.
The semantics of ITL, however, is traditionally 'flat' in the sense that the semantics of ITL is normally not defined using an interval stack: Without the introduced pop operation, there is no requirement for it because preserving the top-most interval is unnecessary.
The traditional ITL semantics for chop is    s; [b, e[; k |= ph ; ps iff k [?]
[b, e[ and [?
]l [?]
[k, e[.
s; [k, l]; k |= ph and s; [l, e[; l |= ps.
This has no effect on the evaluation of s; [0, |s|[; 0 |= ph, because without a pop operation we would never refer to any other than the top interval on the interval stack.
= = = =  ps ; |th  : ps !
!ps   | (ps [?]
th) : th       V. D ECIDABILITY OF P OP L OGIC There are two obvious approaches to show the decidability of PL: A direct translation to automata and an embedding into QLTL.
We describe an embedding into QLTL, because it is a much simpler transformation.
It also simplifies the decidability proofs for the sub-logic ITL with finite [13] and infinite [5] word semantics.
The main reason for our choice, however, is that it again outlines the connection between PL (or ITL) and classic temporal logics.
The embedding of PL into QLTL is also a counter position to the embedding of LTL into PL discussed in the previous section.
QLTL: extends LTL slightly by introducing quantification [17], yielding the full power of o-regular expressions.
QLTL formulas are described by the following grammar:  IV.
E MBEDDING LTL IN P OP L OGIC In the following, we briefly present the related temporal logic LTL and discuss its embedding in PL.
The syntax of LTL is given by the following grammar: ph | ph Uph  The semantics of LTL formulas is only defined on infinite words.
Like with ITL, the concept of interval stacks does not exist in LTL and the interpretation of a formula ph at a position k is defined inductively by: s; k |= p s; k |= !ph s; k |= ph [?]
ps s; k |= ph s; k |= ph U ps     The first abbreviation introduces a push operator ':', which is closely related to the chop.
Different to chop, a push operation only increases the call stack on the left.
There is little difference in the effect of push and chop, as the evaluation of the truth of the formula on the right is started at the beginning of the second interval.
In our view, the push operation is the more useful, as it reflects a call and return situation; our intuition is that we first satisfy the formula on the right (pushing down one level) and then come back (pop) and satisfy the right side.
On infinite intervals, the eventually and always operators ' ' and ' ' have the same semantics as in LTL, with the natural extension for finite intervals (holds somewhere within the interval and holds throughout the interval, respectively).
A similar claim holds for until.
Using only the LTL operators, it is plain to see that we maintain the semantics of LTL.
Note that, in the LTL fragment, a chop (or pop) operator can only occur in the abbreviations for a temporal operator, and there it is 'guarded' in the sense that the stack cannot grow to a size of more than three.
III.
R ELATION OF P OP L OGIC TO ITL  ph ::= p | !ph | ph [?]
ph |  ps :th ps ps ps Uth  ph ::= p | !ph | ph [?]
ph |  ph | ph U ph | [?]x.
ph  p [?]
s(k), s; k |= ph, s; k |= ph or s; k |= ps, s; k + 1 |= ph, [?
]i >= k.s; i |= ps and [?]
j [?]
[k, i[.
s; j |= ph.
Likewise, the semantics of QLTL extends the semantics of LTL by introducing a rule for quantification,  A central advantage of Pop Logic is that it provides us with a very simple embedding of LTL, while preserving the scoping allowed for by ITL.
The LTL operators can be viewed as abbreviations of small snippets of PL, just as and operators in LTL can be viewed as snippets of LTL syntax.
where s [?]
sx : n - s(n)  sx (n) [?
]n [?]
o, to the inductive definition of the semantics of a formula.
While the quantifiers extend the expressiveness, quantification does not seem to be a concept that lends itself to human system analysts.
We freely confess that we would not trust ourselves when writing a QLTL specification, in    iff iff iff iff iff  s; k |= [?
]x.ph iff [?
]sx : o - 2{x} .
s [?]
sx ; k |= ph,    66   th fi = th, and thfi = th , and for a formula ps that appears par(ps),  fi = par( as a direct sub-formula of ps =| ps, we set ps psfi ).
 fi = psfi .
Otherwise, if ps is a direct sub-formula of ps , we set ps Using these terms, we define our translation k from PL to QLTL as follows:  particular with nested quantification under the scope of temporal operators.
A. Embedding Pop Logic into QLTL The embedding of PL into QLTL builds on a simple observation: The truth of a sub-formula depends on the interval stack.
In the interval stack, each interval but the interval at the bottom of the interval stack is introduced by a particular chop operator.
Each chop operator introduces two different intervals for its left and right sub-formulas and we index the interval in the interval stack with the respective sub-formula.
That is, for a sub-formula of a specification ph that is a chop formula ps ; th, we index with ps and th, respectively.
We index the interval at the bottom of the stack with ph.
An interval can be encoded by the existence of a proper assignment of truth values to interval propositions that are evaluated to true within the interval and to false outside of the interval.
We use pps to denote the truth values of an interval Ips .
This way, the existence of a suitable chop of an interval can be translated to a QLTL formula that intuitively says 'there is a chopping point for the given interval'.
The respective encoding requires that (1) the new intervals are proper intervals, (2) the last position of the left interval coincides with the first position of the right interval, and (3) the union of these intervals coincides with the chopped interval.
As the interpretation of a sub-formula depends--through the interval stack--on its position in the formula tree, its translation needs to take this position into account.
We call the complete formula ph and all direct sub-formulas th and th of a chop sub-formula th; th of ph interval identifiers.
ph can be used to identify the interval [0, |s|[ at the bottom of our interval stack, while th and th can be used to identify the left and right interval, respectively, which is added by the chop operation in th; th to the interval stack.
Note that th and th are defined by their positions in the formula tree; syntactically identical sub-formulas of ph have to be distinguished.
For a sub-formula ps of ph, we first look for the relevant interval identifier, which is the index of the top interval in the stack under which ps is interpreted.
The relevant interval identifier of ps can be found by, starting at ps, walking the formula tree upwards towards its root.
While walking up, we maintain a counter, which is initially 0.
The counter is incremented each time we pass a pop operator '|' and decremented each time we pass a chop operator ' ; ', reflecting the pushing and popping of the interval stack.
The first interval identifier we pass (including ps itself) with counter value 0 is the relevant interval identifier of ps, fi.
denoted ps In other words: if, for a true sub-formula of a specification ph, par(ps) denotes the sub-formula of ph whose direct subformula ps is, then the following holds.
For a specification fi = ph, for a chop formula ps = th; th , we set ps fi= ph, we set ph  *  *  * * *  leaves p (including ) of the formula tree are strengthened by a claim that the current position is within the top interval of the interval stack, reflected by the respective interval proposition: a sub-formula ps =  is translated to k(ps) = ppsfi and an atomic proposition ps = q is translated to k(ps) = ppsfi [?]
q; a sub-formula ps = !th is translated to k(ps) = !k(th) and a sub-formula ps = th [?]
th is translated to k(ps) = k(th) [?]
k(th ) (all boolean connectives can be translated fi = thfi = ps fi ); in this simple manner, note that th a sub-formula ps = th is translated to k(ps) = (k(th)), a sub-formula ps =| th is translated to1 k(th), and a sub-formula ps = th ; th is translated to [?
]pth , pth .
k(th) [?]
g(pth , pth , ppsfi ) [?]
(k(th ) [?]
pth [?]
pth ), where     g(p, q, r) = p [?]
((p [?]
q) - r) [?]
(p [?]
q) [?]
(q - !
p) simply checks if p and q define two intervals that properly chop the interval defined by r.          In order to ease the proof that a PL formula ph and its translation k(ph) to QLTL are semantically equivalent (that is, have the same models), we introduce a natural extension of the QLTL semantics to interval stacks.
Assuming without loss of generality that p0 , p1 , .
.
.
, pn are fresh propositional variables, we denote with PI0 ,...,In = P  {p0 , .
.
.
, pn } an extended set of atomic propositions.
For a word s = [0, |s|[- 2P , we denote by s; I0 , .
.
.
, In the o-word with * *  s; I0 , .
.
.
, In (k) [?]
P = s(k) and pi [?]
s; I0 , .
.
.
, In (k) if, and only if, k [?]
Ii .
Finally, we use s |= ph as an abbreviation for s; [0, |s|[; 0 |= ph.
Note that there is a difference between the bottom element of the stack and the remaining elements: While the bottom element--[0, |s|[--reflects the true length of a finite or infinite input word s, the other elements of the stack are introduced during the interpretation of the ph on s. Thus, the bottom element and the atomic proposition describing it (no matter if named p0 , pph , or pphfi ) are assumed to be explicitly given.
Theorem 5.1: For a PL formula ph and a word s, s |= ph holds if, and only if, s |= k(ph).
Proof: By induction over the structure of the formula, we show that s; Iph , .
.
.
, Ipsfi ; k |= ps holds for every sub-formula ps of ph if, and only if, s; Iph , .
.
.
, Ipsfi ; k |= k(ps).
1 This translation might look a bit surprising at first glance, because it may convey the impression that the | operator has no effect.
However, it is reflected in the fi th operations that identify the relevant interval identifiers-- and hence the interval propositions occurring in the translation.
67  The induction basis is trivial, as the claim holds by definition for the atomic propositions (including ).
The induction step for boolean connectives is also trivial.
For the next operation, we have s; Iph , .
.
.
, Ipsfi ; k |= ps s; Iph , .
.
.
, Ipsfi ; k + 1 |= ps =PL =IH s; Iph , .
.
.
, Ipsfi ; k + 1 |= k(ps) de f =QLT L s; Iph , .
.
.
, Ipsfi ; k |= k(ps) =k k(  the satisfiability problem and the word problem for finite and o-regular words.
For the lower bounds, we can use the matching hardness results of the syntactic sub-logic ITL for both finite and infinite [18] words.
VI.
A PSPACE-C OMPLETE S UBSET OF PL While Section V establishes the decidability and complexity of PL, the non-elementary complexity of PL is not appealing.
But we have also seen that the popular and inexpensive temporal logic LTL can be viewed as a de-facto syntactic sub-logic of PL, which implies that relevant sublogics of PL are in PSPACE.
In this section, we define a wider fragment of PL--which includes LTL--that is still decidable in polynomial space.
Depending on personal preferences, this sub-logic can be considered as a restriction of PL or as an extension of LTL.
To get an intuition for the extension, we adjust our translation k with complexity considerations in mind.
We approach finding a PSPACE fragment by looking at the translation of LTL, starting with the sub-logic of LTL that uses the eventually operator instead of until.
In LTL, ps is an abbreviation for  ; | ps, and this subformula translates to [?
]p , p|ps k() [?]
g(p , p|ps , p )[?]
; |ps , (p|ps [?]
k(| ps)).
g states that p and p|ps do chop p ; |ps and neither p nor p|ps occur in k(| ps).
In such a situation, we can avoid the existential quantification and simply translate k( ; | ps) to p [?]
(p [?]
k(| ps)).
; |ps ; |ps Adjusting k.: Avoiding quantification is a very useful tool, because without quantification the target language is LTL instead of QLTL.
In the remainder of the paragraph we therefore discuss properties of sub-formulas which allow either avoiding quantification, or at least to use it in a monotone and inexpensive way.
This raises the question of whether or not we can avoid the introduction of quantification.
For this we adjust our translation k from PL to QLTL to k, where we only touch the rules for chop sub-formula ps ; th.
For them we give two rules for cases, where the use of quantification can be avoided completely, and a fall-back rule that only avoids the introduction of the pth .
This fall-back rule, which is only used if neither of the two rules introduced later in this section apply, translates ps ; th to [?
]pps .k(ps) [?]
(pps [?]
pps;th  ) U (pps [?]
pps;th  [?]
k(th)[pth -  pps;th !pps ) .
] [?]
This fall-back rule is also a preparation for the more powerful rules in the special cases where quantification over pps can also be avoided, as it uses the concept of implicitly expressing the existence of a reasonable representation of the second interval.
The right side of the until marks the situation at the chopping point: pps holds, but ceases to do so in the next position, and the chopping point needs to be within the interval identified by pps;th  .
pth has to coincide with pps;th  from the chopping point onwards (and cannot  ps).
The induction step for the pop operator is also simple: s; Iph , .
.
.
, Ipsfi , I|ps  ; k |=| ps =PL s; Iph , .
.
.
, Ipsfi ; k |= ps =IH s; Iph , .
.
.
, Ipsfi ; k |= k(ps) de f =k s; Iph , .
.
.
, Ipsfi , I|ps  ; k |= k(| ps) For the last equivalence, note that the leading | operator fi ).
(Hence, its prevents that the variable p|ps  occurs in k(ps valuation does not matter.)
We conclude the inductive proof with the induction step for the chop operator, using the abbreviations Ips;th  = [b, e[, Ips = [k, c], and Ith = [c, e[.
We then get: s; Iph , .
.
.
, Ips;th  ; k |= ps; th PL = [?
]c [?]
[k, e[.
s; Iph , .
.
.
, Ips;th  , Ips ; k |= ps and , I s; Iph , .
.
.
, Ips;th  th ; c |= th IH = [?
]c [?]
[k, e[.
s; Iph , .
.
.
, Ips;th  , Ips ; k |= k(ps) and s; Iph , .
.
.
, Ips;th , I  th ; c |= k(th) QLT L s; Iph , .
.
.
, Ips;th =  ; k |= [?
]pps , pth .
k(ps)[?]
(k(th) [?]
pps [?]
pth ) g(pps , pth , pps;th ) [?]
de f =k          s; Iph , .
.
.
, Ips;th  ; k |= k(ps; th).
Note that we have to adjust k(ph) if we are interested in the satisfiability or validity problem as there is no word s to start with.
If we are only interested in infinite models, we can replace all occurrences of pph by , if are interested only in finite models, we can use k(ph) [?]
(pph U !pph ), and if we want to allow for both we can use their disjunction.
B.
Complexity of Pop Logic Having established a linear translation of well formed PL formulas to equivalent QLTL formulas, we can re-use the decision procedures of QLTL to decide PL specifications.
We thus inherit the non-elementary decision procedures for the satisfiability and word problem of QLTL from [17].
Matching hardness results are inherited from the syntactic sub-logic ITL of PL.
Theorem 5.2: The satisfiability, word, and model checking problems for PL are non-elementary decidable, and hard for this class even if restricted to finite or infinite words.
Proof: With k, we have established a linear translation from PL to equivalent QLTL specifications.
We therefore inherit the non-elementary decision procedures of QLTL for    68  appear in k(ps)).
We can therefore check the correctness of k(th)[pth - pps;th  ] instead of k(th) at the chopping point and avoid the introduction of pth .
Unfortunately, no similarly general technique for the left side of a chop operation can exist, because this would apply a lower complexity of Pop Logic.
But the observation that the introduction of pth can be avoided allows us to concentrate on pps when seeking sub-languages in PSPACE.
Our focus is on cases where the chopping point itself can be guessed.
We can avoid the introduction of (and quantification over) pps if we can identify a suitable chopping point within the interval identified by pps .
The simplest case in which this ;th is possible is, of course, if pps does not occur in k(ps).
This is, for example, the case in the de-facto sub-language that resembles LTL.
But we can do more.
We call a sub-formulas ps long for an interval proposition p if it holds that, if ps holds if p identifies the non-empty interval [b, e[, then it holds if p identifies the interval [b, e [ for all e >= e. Likewise, we call a sub-formula ps short for an interval proposition p if it holds that, if ps holds if p identifies the non-empty interval interval [b, e[, then it holds if p identifies the interval [b, e [ for all b < e <= e. We call a sub-formula ps finite if the interval stack Iph , .
.
.
, Ipsfi under which ps is evaluated contains an interval Ith stemming from the left side of a chop sub-formula th; th of ph.
(Finite simply guarantees that the respective interval is finite; in the finite semantics, all sub-formulas are finite.)
There are simple sufficient conditions for formulas to be long or short.
In particular, a sub-formula is both long and short for pps if pps does not occur in the translation k(ps).
This holds, for example, for ps =| ps .
Also, atomic propositions are short and long, longness is preserved by next operations, and shortness and longness are preserved by positive boolean combination, and shortness and longness are toggled by negation.
(That is, !ps is long if ps is short and !ps is short if ps is long.)
We can use a simplifying translation for ps; th in two cases: if ps is both short and long, and if ps is finite and long.
If we can identify the first case (to which we give preference to have an unambiguous rule) by the rules above we can define k(ps; th) to   k(ps)[pps - pps;th pps;th ] [?]
 [?]
k(th)[pth - pps;th ] .
Finally, we call chop operators safe if the sub-formula they govern is not translated to a quantified formula by k, and left if, on the path from the root to this formula, only left turns were taken at every chop operator.
As usual, we call these formulas positive if they are bound by an even number of negations, and negative otherwise.
A first observation is that, provided all chop operators are safe, the discussed translation goes to LTL, providing for a PSPACE complexity.
Theorem 6.1: The PL subset where all occurring chops are safe is a sub-logic of PL that contains LTL as a de-facto syntactic subset.
It has a PSPACE-complete satisfiability, validity, word, and model checking problem.
Proof: In the formulas from the LTL fragment of PL all chop operations are safe and the translation of PL formulas where all chop operations are safe go to LTL.
(Which also implies that this subset is no more expressive than LTL.)
Note that the formula tree of the target formula is not necessarily polynomial in the size of the source specification, because the 'long & finite' case adds multiple occurrences of (pps;th  [?]
k(th)[pth - pps;th  ]) in the translation of a chop sub-formula ps; th.
However, if we represent the formula as a directed acyclic graph (DAG), then this blow-up does not occur: there are merely multiple edges pointing to the same node.
Hence, the number of sub-formulas stays linear in the size of the PL formula.
This also outlines a difference between PL and LTL that cannot be bridged: While the valuation of a sub-formula of an LTL formula is independent of its position in the formula tree, the valuation of sub-formulas in PL depend on the interval stack under which they are interpreted.
We therefore cannot safely assume that the valuation is similar unless they must refer to the same interval stack when evaluated.
(Which 1 = ps 2 .)
is the case for two sub-formulas ps1 and ps2 if ps We can extend the relative tractability to larger classes of languages: There is no need for the target formula to be in LTL.
If we are interested in the satisfiability or word problem, then it suffices to reside in prenex QLTL with only existential quantification.
Theorem 6.2: The PL subset where all occurring unsafe chops are positive left formulas is a sub-logic with a PSPACE-complete satisfiability and word problem.
Proof: It is easy to show by induction that, provided all unsafe chop operations in a PL formula ph are positive left formulas, the target formula k(ph) has a formula DAG where no quantifier is bound by a temporal operator and all quantifiers occur positively.
We can hence re-write k(ph) to prenex normal form by simply moving all quantifiers to the front, which does not affect the size of the formula DAG.
For formulas of this type, the satisfiability and word problem are the same as for LTL, because leading existential quantification does not affect them.
Consequently, the co-problems of the negation of these formulas are also in PSPACE.
The right conjunct requires that there is a chopping point such that th holds in the right interval.
(Where, again, pth and pps;th  coincide on that interval.)
Shortness and longness together imply that ps holds on the left interval if, and only if, it holds on the interval identified by pps;th  ; it is therefore safe to use this interval instead.
If k(ps) is long for pps and ps; th finite, we can use the well defined last possible chopping point--the last point where a = (pps;th  [?]
k(th)[pth - pps;th  ]) holds.
We set k(ps; th) = k(ps)[pps - a] [?]
a.
69  ITL, but also the classic temporal logic LTL, as syntactic sub-logics.
As a result, we think that PL provides a useful bridge between classic and interval temporal logics: It allows for using both logics individually for sub-problems, and yet provides a simple framework to treat these specifications.
It therefore allows for naturally integrating aspects expressed by interval temporal logic in a predominantly classic LTL specification, or, less often, LTL aspects in a predominantly ITL specification.
In addition, we have characterised a relatively inexpensive (PSPACE-complete) fragment of PL, which includes and extends LTL.
We consider the identification of such sub-logics useful, as they can guide a system analyst in devising her specification: When the expensive steps can easily be identified, the decision to keep the specification in the current form--and pay the price in form of increased complexity--or to invest more work in reformulating the specification can be made informed.
Corollary 6.3: The PL subset where all occurring unsafe chops are negative left formulas is a sub-logic with a PSPACE-complete validity, word, and model-checking problem.
VII.
E XTENDED P OP L OGIC The logic PL introduced in Section II extends the most basic version of ITL.
In order to reach the full expressiveness of regular and o regular expressions, we extend the widespread version of ITL with star to Extended Pop Logic (EPL) in this section.
This provides us with the following grammar: ph ::= p | !ph | ph [?]
ph |  ph | ph; ph | | ph | ph*  Like the chop operator, the star operator pushes new intervals in the stack.
We extend the well formedness to: there exists no node in the formula tree of ph such that strictly more pop operators than chop and star operators (counted together) occur on the way from the root of the formula tree to this node.
For the star operator, we use the following semantics:  ACKNOWLEDGEMENT Sven Schewe is supported by the Engineering and Physical Science Research Council (EPSRC) through the grant EP/H046623/1 'Synthesis and Verification in Markov Game Structures'.
Cong Tian is supported by the NSFC Grant No.
61003078, 91018010, and 60910004, 973 Program Grant No.
2010CB328102, and ISN Lab Grant No.
ISN1102001.
Both Sven Schewe and Cong Tian are corresponding authors.
s; I0 , .
.
.
, In , [b, e[; k |= ph* iff k [?]
[b, e[ and there exist m [?]
N integers k = r0 < r1 < ... < rm = e such that [?
]i [?]
[0, m[.
s; I0 , .
.
.
, In , [b, e[, [ri , ri+1 + 1[; ri |= ph.
Lemma 7.1: EPL can be embedded in QLTL.
Proof: To prove this, it suffices to extend the function k and Theorem 5.1 accordingly.
The extension is a straight forward generalization of the rules (and proof) for the chop, with the difference that we mark finally many intervals instead of marking exactly two.
Technically this can be done by guessing the fringes of the intervals (existential quantification) and showing that all intervals defined by these fringes are suitable (universal quantification).
Theorem 7.2: EPL is decidable with non-elementary complexity.
It can express exactly the regular and o-regular languages.
Proof: The non-elementary lower bound and the expressiveness of EPL can be inferred from the respective lower bounds and expressiveness of ITL [18], [19].
The decidability and upper bound on the complexity are implied by Lemma 7.1.
R EFERENCES [1] R. Alur, T.A.
Henzinger, and O. Kupferman.
Alternating-Time Temporal Logic.
Journal of the ACM 49(5): pages 672-713, 2002.
[2] M. Ben-Ari, Z.
Manna, and A. Pnueli.
The temporal logic of branching time.
Acta Informatica 20: pages 207-226, 1983.
[3] A. Chandra, J. Halpern, A. Meyer, and R. Parikh.
Equations between regular terms and an application to process logic.
Proceedings of the Thirteenth Annual ACM Symposium on Theory of Computing (STOC 1981).
pages 384-390, 1981.
[4] E. M. Clarke and E. A. Emerson.
Design and syntesis of synchronization skeletons using branching time temporal logic.
In Proceedings of the IBM Workshop on Logics of Programs (LP 1981).
pages 52-71, 1982.
VIII.
D ISCUSSION  [5] Z. Duan.
An Extended Interval Temporal Logic and A Framing Technique for Temporal Logic Programming.
PhD thesis, University of Newcastle Upon Tyne, May 1996.
We have introduced Pop Logic, an interval temporal logic that synthesises the concepts of classic and interval temporal logic.
Pop Logic extends ITL only very modestly by introducing a pop operation that revokes the scoping of a previous chop operation.
This modest extension preserves the most important property of ITL: Pop Logic remains simple and intuitive.
But while the extension is sufficiently modest to preserve this important property, it is powerful enough to include not only  [6] Z. Duan, M. Koutny, and C. Holt.
Projection in Temporal Logic Programming.
In Proceedings of Logic Programming and Automated Reasoning (LPAR 94).
pages 333-344, 1994.
[7] Z. Duan, C. Tian, and L. Zhang.
A Decision Procedure for Propositional Projection Temporal Logic with Infinite Models.
Acta Informatica, 45(1): pages 43-78, 2008.
70  A PPENDIX : E MBEDDING LTL IN P OP L OGIC In this appendix, we show the semantic equivalence of the LTL fragment of PL in the PL semantics and the common LTL semantics.
Note that, for this comparison, the bottom element of the stack is always o = [0, [?][.
The inductive proof below makes use of the flatness of the translation.
As induction basis, the following obviously holds for all atomic propositions (including ) p [?]
P:  [8] E. A. Emerson.
Temporal and Modal Logic.
Computer Science Department, University of Texas at Austin, USA, 1995.
[9] B. Finkbeiner and S. Schewe.
Coordination Logic.
In Proceedings of the 19th Annual Conference of the European Association for Computer Science Logic (CSL 2010).
pages 305-319, 2010.
[10] J. Halpern, Z.
Manna, and B. Moszkowski.
A hardware semantics based on temporal intervals.
In Proceedings of the tenth International Colloquium on Automata, Languages and Programming (ICALP 1983).
pages 278-291, 1983.  s; o; k |=PL p =PL p [?]
s(k) =LT L s; k |=LT L p. For the induction step, we have to cover boolean connectives, next, and until.
Boolean connectives and next are trivial: s; o; k |=PL ph[?
]ps s; o; k |=PL ph or s; o; k |=PL ps =PL s; k |=LT L ph or s; k |=LT L ps =IH =LT L s; k |=LT L ph [?]
ps, s; o; k |=PL !ph s; o; k |=PL ph =PL =IH s; k |=LT L ph =LT L s; k |=LT L !ph, and s; o; k |=PL ph s; o; k + 1 |=PL ph =PL =IH s; k + 1 |=LT L ph =LT L s; k |=LT L ph,  [11] D. Harel, D. Kozen, and R. Parikh.
Process logic: expressiveness, decidability, completeness.
Journal of Computer and System Sciences 2: pages 144-170, 1982.
[12] L. Lamport.
The Temporal Logic of Actions.
ACM Transactions on Programming Languages and Systems 16(3): pages 872-923, 1994.
[13] B. Moszkowski.
Reasoning about digital circuits.
Ph.D Thesis, Department of Computer Science, Stanford University.
TRSTAN-CS-83-970, 1983.
[14] B. Moszkowski.
Compositional reasoning about projected and infinite time.
In Proceeding of the First IEEE International Conference on Enginneering of Complex Computer Systems (ICECCS 1995), pages 238-245, 1995.
Finally, for the until we have:  [15] A. Pnueli.
The temporal logic of programs.
In Proceedings of the 18th IEEE Symposium on Foundations of Computer Science (FOCS 1977).
pages 46-57, 1977.  s; o; k |=PL ps U th     de f = U s; o; k |=PL !
; | !
| (ps [?]
th) ; | th   =PL [?
]l >= k.s; o, [k, l]; k |=PL !
; | !
| (ps [?]
th) and s; o, [l, [?
][; l |=PL | th  =PL [?
]l >= k.s; o, [k, l]; k |=PL ; | !
| (ps [?]
th) and s; o; l |=PL th =PL [?
]l >= k.
[?
]m [?]
[k, l].
s; o, [k, l], [k, m]; k |=PL  and s; o, [k, l], [m, l]; m |=PL | !
| (ps [?]
th) and s; o; l |=PL th =PL  [?
]l >= k.
[?
]m [?]
[k, l].
s; o, [k, l], [m, l]; m |=PL | !
| (ps [?]
th)s; o; l |=PL th =PL [?
]l >= k.
[?
]m [?]
[k, l].
s; o, [k, l]; m |=PL !
| (ps [?]
th) and s; o; l |=PL th =PL [?
]l >= k.
[?
]m [?]
[k, l].
s; o, [k, l]; m |=PL | (ps [?]
th) and s; o; l |=PL th = [?
]l >= k.[?
]m [?]
[k, l].
s; o, [k, l]; m |=PL | (ps [?]
th) and s; o; l |=PL th =PL [?
]l >= k.[?
]m [?]
[k, l].
s; o; m |=PL ps [?]
th and s; o; l |=PL th =PL [?
]l >= k.[?
]m [?]
[k, l].
s; o; m |=PL ps or s; o; m |=PL th and s; o; l |=PL th =IH [?
]l >= k.[?
]m [?]
[k, l].
s; m |=LT L ps or s; m |=LT L th and s; l |=LT L th = [?
]l >= k.s; l |=LT L th and [?
]m [?]
[k, l[.
s; m |=LT L ps =LT L s; k |=LT L ps U th.
[16] T. Schlipf, T. Buechner, R. Fritz, M. Helms, and J. Koehl.
Formal verification made easy.
IBM Journal of Research and Development, 41(4-5): pages 567-576, 1997.
[17] A. P. Sistla.
Theoretical issues in the design and verification of distributed systems.
PhD thesis, Harvard University, 1983.
[18] C. Tian and Z. Duan.
Complexity of propositional projection temporal logic with star.
Mathematical Structures in Computer Science 19(1): pages 73-100, 2009.
[19] C. Tian and Z. Duan: Expressiveness of propositional projection temporal logic with star.
Theoretical Computer Science 412(18): pages 1729-1744, 2011.
[20] M. Y. Vardi: Branching vs.
Linear Time: Final Showdown.
In Proceedings of the Seventh International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS 2001).
pages 1-22, 2001.
[21] M. Vardi and P. Wolper.
Automata Theoretic Techniques for Modal Logics of Programs, Journal of Computer and System Sciences 32(2): pages 183-221, 1986.
[22] P. L. Wolper.
Temporal logic can be more expressive.
Information and Control, 56(1/2): pages 72-99, 1983.
71