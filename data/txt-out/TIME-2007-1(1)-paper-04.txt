The Effects of Bounding Syntactic Resources on Presburger LTL * Stephane Demri LSV, ENS Cachan CNRS, INRIA Saclay demri@lsv.ens-cachan.fr  &  Regis Gascon INRIA, I3S, CNRS Univ.
Nice Sophia Antipolis rgascon@sophia.inria.fr  Abstract LTL over Presburger constraints is the extension of LTL where the atomic formulae are quantifier-free Presburger formulae having as free variables the counters at different states of the model.
This logic is known to admit undecidable satisfiability and model-checking problems.
We study decidability and complexity issues for fragments of LTL with Presburger constraints obtained by restricting the syntactic resources of the formulae (the number of variables, the maximal distance between two states for which counters can be compared and, to a smaller extent, the set of Presburger constraints) while preserving the strength of the logical operators.
We provide a complete picture refining known results from the literature.
We show that model-checking and satisfiability problems for the fragments of LTL with difference constraints restricted to two variables and distance one and to one variable and distance two are highly undecidable, enlarging significantly the class of known undecidable fragments.
On the positive side, we prove that the fragment restricted to one variable and to distance one augmented with propositional variables is pspace-complete.
Since the atomic formulae can state quantitative properties on the counters, this extends some results about model-checking pushdown systems and one-counter automata.
In order to establish the pspace upper bound, we show that the nonemptiness problem for Buchi one-counter automata taking values in Z and allowing zero tests and sign tests, is only nlogspacecomplete.
Finally, we establish that model-checking one-counter automata with complete quantifier-free Presburger LTL restricted to one variable is also pspace-complete whereas the satisfiability problem is undecidable.
1  Introduction  Verification of infinite-state systems.
Model-checking is a well-known approach to verifying behavioral properties of computing systems that has been * Work  supported by the Agence Nationale de la Recherche, grant ANR-06-SETIN-001  1  very successful in the verification of finite-state systems, see e.g.
[CGP00].
The situation is different for infinite-state systems.
Despite that numerous symbolic representations have been proposed to deal with such systems (see e.g.
timed automata or counter automata), their formal verification remains a difficult problem.
Many general formalisms referring to infinite-state systems have an undecidable model-checking problem.
Sometimes, decidability can be regained by considering subproblems of the general problem, for example by restricting the number of counters/clocks/variables or by constraining their occurrences.
Counter systems.
The class of counter automata is an example of such a formalism.
Counter automata have many applications in formal verification.
Their ubiquity stems from their use as operational models of numerous infinite-state systems, including for instance broadcast protocols [FL02] and programs with pointer variables (see [BFLS06, BBH+ 06]).
Even the case of a single counter has found some applications in the verification of cryptographic protocols [LLT05] and the validation of XML streams [CR04] (see also the context-free languages defined by one-counter automata in [BB90]).
However, numerous model-checking problems for counter automata, such as reachability, are known to be undecidable.
This does not end the story since many subclasses of counter automata admit a decidable reachability problem such as reversal-bounded multicounter machines [Iba78, ISD+ 00] and flat counter systems [Boi98, CJ98, FL02].
These two classes of systems admit reachability sets effectively definable in Presburger arithmetic (assuming some additional conditions, unspecified herein).
Motivations.
Extending the linear-time temporal logic LTL with Presburger constraints allows to specify quantitative properties of counter systems that go beyond simple reachability.
Because this language is expressive enough to simulate Minsky machines [Min67], this extension is undecidable.
Attempts to identify decidable fragments have already been made in [BEH95, CC00] by restricting the use of the temporal operators (see also [BH96]).
In this paper, we are interested in the decidability and complexity of fragments of Presburger LTL obtained by restricting the following syntactic resources of the formulae: the set of Presburger constraints, the number of counters and the maximal distance between two states for which these counters can be compared.
We do not restrict the use of the logical operators.
Our investigation is based on the standard assumption that restricting the number of variables is a means of identifying decidable fragments of undecidable logics or to design counter/clock automata with decidable reachability problems (see examples for modal logics in [Hal95] or for alternating timed automata in [OW05, LW05]).
Furthermore this kind of analysis helps to understand the complexity gaps between decidable problems, see complexity results for model-checking subproblems in [DS02, LMS04].
Our goal is therefore to identify decidable and undecidable fragments of Presburger LTL (both for model-checking and satisfiability problems) refining existing results from [CC00, DG08].
2  Our contribution.
We define CLTL(DL) as a fragment of Presburger LTL where atomic formulae are difference constraints from quantifier-free Presburger arithmetic.
Unlike the version of Presburger LTL defined in [BEH95], the models are o-sequences of counter valuations.
The underlying fragment of Presburger arithmetic in CLTL(DL) is identical to the one in the logic Lp from [CC00].
However, it is possible in CLTL(DL) to state constraints between counters at two non-consecutive states.
For instance, "XXx = y" means that the value of y at the current state is equal to the value of x two states further.
We call X-length the maximal number of X operators prefixing a counter.
The two main undecidability results shown in this paper are the following: * satisfiability and model-checking for CLTL(DL) restricted to formulae of X-length two with at most one counter are S11 -complete (an exposition of the analytical hierarchy can be found in [Rog67]), * satisfiability and model-checking for CLTL(DL) restricted to formulae of X-length one with at most two counters are S11 -complete.
The logic CLTL(DL) was already known to be undecidable since it has been shown in [CC00] that CLTL(DL) restricted to formulae of X-length one with at most three counters is undecidable.
Similarly, undecidability of CLTL(DL) restricted to formulae with at most two counters has been shown in [DD07].
Hence, we push forward the decidability limits established by these results.
Then, we prove that model-checking and satisfiability problems for CLTL(DL) are pspace-complete when restricted to X-length one and to one counter.
This result completes our classification of CLTL(DL) fragments restricting the number of counters and the X-length of the formulae.
Actually, we establish this pspace-completeness result for an extension of CLTL(DL) including propositional variables and periodicity constraints of the form x [?
]k y + c (but still restricted to X-length one and to one counter).
The addition of propositional variables allows to reduce the model-checking problem to the satisfiability problem, more precisely to encode control states in a formula, whereas the addition of periodicity constraints is performed to get as rich an underlying quantifierfree fragment of Presburger arithmetic as possible.
Several problems involving one-counter automata can be encoded in these decidable fragments.
These problems are related to different applications such as verification of cryptographic protocols [LLT05], validation of XML streams (string representations of XML documents) [CR04], or resolution of the identification problem [WTT04].
These results complete our precise taxonomy of CLTL(DL) fragments with respect to decidability.
Our decidability results about CLTL(DL) fragments restricting the syntactic ressources of formulas are optimal with respect to the constraints used.
Satisfiability for LTL with quantifier-free Presburger constraints (properly including difference constraints) is undecidable even if restricted to X-length one and to one counter.
However, we show that one can regain decidability by restricting the class of models.
We prove that the model checking problem for the one variable fragment of this logic is pspace-complete when the class of models is 3  one-counter automata (with updates in Z).
To prove all our decidability and complexity results, we follow a standard automata-based approach [VW94, KVW00] but we introduce an original symbolic representation of models that can be recognized by a fine-tuned class of one-counter automata (instead of standard Buchi automata).
A nice property of this method is that it can be generalized to various LTL extensions that define o-regular classes of models.
The class of automata that we use have integer counters which are updated by adding -1, 0 or 1, zero-tests and sign-tests, and accept regular o-languages.
We show that the nonemptiness problem for such automata is nlogspace-complete.
This extends what is known about Buchi automata and variants of one-counter automata [VW94, LLT05].
Related work.
Decidability and complexity issues for LTL variants with Presburger constraints can be found in [BEH95, BH96, CC00].
This type of logical formalisms has been also considered in Artificial Intelligence (AI) and Knowledge Represention (KR), for instance in description logics with concrete domains in [Lut04] and in logics of space and time in [BC02].
Unlike these works, we study systematically the effects of restricting the number of variables, the X-length and, in a less systematic way, the set of constraints.
In the fragments we consider, we preserve the logical operators but we put restrictions on the form of atomic formulae.
This is in sharp contrast, for instance, with the flat fragment shown decidable in [CC00].
The complexity bound we obtain contrasts with the bound established in [CC00] which is obtained by reduction to satisfiability of Presburger arithmetic and is therefore rather high.
One-counter automata are interesting operational models.
Unlike multicounter automata, they have nice computational properties, see for instance complexity results about behavioural equivalences in [Kuc00, JKMS04] (see also [BHM03]).
Moreover, one-counter automata are equivalent to pushdown systems with a singleton stack alphabet.
Therefore the results on these systems can help to refine some results about pushdown systems.
For instance, the model-checking problem for one-counter automata with the modal u-calculus has been shown to be in pspace [Ser06] whereas the model-checking problems for pushdown automata over the modal u-calculus and the linear u-calculus are in exptime (see [Wal01] and [BEM97], respectively).
It is worth mentioning that in these logics the atomic formulae can only speak about the control states and not about the content of the counter.
This is a major difference with our formalism.
We refine these results by showing that model-checking one-counter automata over linear u-calculus is pspace-complete.
In [FWW97], a version of CTL[?]
with atomic formulae containing control states and regular conditions on the current stack is shown to admit a decidable model-checking problem over pushdown systems.
This result is improved in [EKS03] where exptime-completeness is established.
We establish that the restriction to LTL and one-counter automata is pspace-complete, refining the above result.
However, our model is more expressive than pushdown systems  4  with a single letter pushdown alphabet.
For instance, it allows incrementation modulo some integer or transition of the form Xx <= x + 1 that can be seen as lossy transitions.
Structure of the paper.
In Section 2, we introduce the fragments of Presburger arithmetic we consider and give a general definition for the extension of LTL with Presburger constraints between terms representing values of the variables at different states of the execution.
We also define the relevant satisfiability and model-checking problems we consider.
For the extension of LTL with the difference constraint language DL, we establish undecidability results for the fragments with X-length one and two variables, and X-length two and one variable.
In Section 3 we consider an extension of CLTL(DL) with periodicity constraints and propositional variables and we show how to translate a one-variable formula of this logic with X-length equal to one into a one-counter automaton.
This translation is the basis for the pspace upper bound results established in this paper and requires a finite abstraction of the models defined in the same section.
Based on the same approach, we show in Section 4 that model-checking one-Z-counter automata for LTL with full quantifier-free Presburger formulae restricted to one variable is pspace-complete.
The two pspace upper bounds are obtained thanks to the nlogspace-membership of the nonemptiness problem for a particular subclass of one-counter automata shown in Section 5.
Finally, Section 6 contains concluding remarks and open problems.
This paper is a completed version of [DG07].
2 2.1  Temporal logics, automata and Presburger constraints Linear-time temporal logics  Constraint languages.
Let VAR = {x0 , x1 , .
.
.}
be a countably infinite set of variables.
We consider several fragments of Presburger Arithmetic (PA).
The Difference Logic DL is defined by constraints of the form a ::= x ~ y + d | x ~ d | a [?]
a | !a where x, y [?]
VAR, d [?]
Z and ~ [?]
{<, >, <=, >=, =}.
We denote by DL+ the extension of DL with periodicity constraints of the form x [?
]k c or x [?
]k y + c (c [?]
N and k [?]
N \ {0, 1}).
Finally, QFP is the quantifier-free fragment of PA, which can be defined by the following grammar: X X a ::= ai xi ~ d | ai xi [?
]k c | a [?]
a | !a i[?
]I  i[?
]I  where ai [?]
Z \ {0} and I is a finite set of indices.
Obviously, we have the following inclusions between these languages: DL [?]
DL+ [?]
QFP.
Given a 5  valuation v : VAR - Z, the satisfaction relation v |= a is defined in the obvious way.
For instance, v |= x [?
]k y iff there exists z [?]
Z such that v(x) = v(y) + kz.
We assume that all integers are encoded in binary.
Linear-time temporal logics.
Given a constraint language L (typically DL, DL+ or QFP), we define the logic CLTL(L) as the extension of LTL [GPSS80] where the propositional variables are refined to atomic constraints from L over expressions representing different states of the variables.
The formulae of CLTL(L) are defined by the grammar: ph ::= ath | ph [?]
ph | !ph | Xph | phUph where a is a constraint in L and th is a substitution of all the free variables which possibly occur in a by terms of the form Xl xj .
The symbols X and U are respectively the classical operators "next" and "until" of LTL.
We also use the standard notations Fph and Gph as the abbreviations for [?
]Uph and !F!ph.
We call term a variable xi prefixed by a certain number l of X symbols, shortly denoted by Xl xi .
The encoding of Xl xi requires O(l + log(i)) bits.
Indeed, the symbol "X" in Xl xi is not a logical operator but a simple syntactic means to refer to the value of xi at the lth next state.
Given a CLTL(L) formula ph, we define its X-length |ph|X as the maximal number l such that a term of the form Xl x occurs in ph.
Intuitively, the X-length defines the size of a frame of consecutive states that can be compared in the formula.
We denote by CLTLlk (L) the restriction of CLTL(L) to formulae with at most k variables and X-length bounded by l. The models of CLTL(L) are o-sequences of valuations s : N - (VAR - Z) and the satisfaction relation is defined as in LTL except for atomic formulae: * s, i |= a[x1 - Xl1 xj1 ,..., xn - Xln xjn ] iff (s(i + l1 )(xj1 ),..., s(i + ln )(xjn )) |= a in PA, * s, i |= ph [?]
ph' iff s, i |= ph and s, i |= ph' , * s, i |= !ph iff s, i 6|= ph, * s, i |= Xph iff s, i + 1 |= ph, * s, i |= phUph' iff there exists j >= i such that s, j |= ph' and for every i <= k < j, we have s, k |= ph.
We abbreviate s, 0 |= ph to s |= ph.
The symbol |=, used at the level of the constraint language, is overloaded but this will not lead to any confusion.
As usual, a formula ph [?]
CLTL(L) is satisfiable iff there exists a model s such that s |= ph.
Note that the satisfiability problem for CLTL(QFP) can be placed easily in the class S11 from the analytical hierarchy (see e.g.
[Rog67]).
Indeed, any model of CLTL(QFP) restricted to n variables can be encoded by functions f1 , .
.
.
, fn : N - N. A first-order predicate on f1 , .
.
.
, fn which expresses that s, 0 |= ph (ph contains at most n variables) is routine to construct by structural recursion on ph.
We conclude that satisfiability for ph can be expressed by a S11 -sentence.
6  Constraint automata.
The model-checking problem we consider for CLTL(L) involves a class of automata whose transitions are labeled with constraints of L. A one-step constraint is an atomic formula of the form a[x1 - Xl1 xj1 , .
.
.
, xn - Xln xjn ] such that l1 , .
.
.
, ln <= 1.
One-step constraints express constraints on the values of the variables at the current state and the next state only.
A kvariable L-automaton A is a structure hQ, d, I, F i such that Q is a finite set of states, I [?]
Q is a subset of initial states, F [?]
Q is a subset of final states and d [?]
Q x A x Q where A is a finite subset of the set 1SCk (L) of Boolean combinations of one-step constraints from L built over the variables {x1 , .
.
.
, xk }.
a We use the notation q - - q ' as an abbreviation for hq, a, q ' i [?]
d. Note that L-automata have no input alphabet.
We do not use them as language acceptors but we are rather interested in the behaviors of such systems.
A configuration of A is a tuple hq, ci [?]
QxZk .
We denote by c(i) the ith value of c. The one-step transition relation - - is defined as follows: hq, ci - - hq ' , c' i def ' = there exists hq, a, q i [?]
d such that if for every i [?]
{1, .
.
.
k} the term xi takes the value c(i) and Xxi takes the value c' (i), then a holds true.
We write a - hq ' , c' i whenever we need to exhibit the constraint a on the transition.
hq, ci - The symbol - - is overloaded but this does not lead to any confusion.
A finite path w is a sequence of the form {0, .
.
.
, n} - (Q x Zk ) such that for every i [?]
{0, .
.
.
, n - 1} we have w(i) - - w(i + 1).
Infinite paths are defined in a similar way, by considering infinite sequences of the form N - (Q x Zk ).
We -* hq ' , c' i denote by - -* the reflexive and transitive closure of - -, i.e.
hq, ci - iff there is a finite path from hq, ci to hq ' , c' i.
An accepting run for A is an infinite path w such that w(0) [?]
I x Zk and the set {i [?]
N : w(i) [?]
F x Zk } is infinite (standard Buchi acceptance condition).
We write Lsymb (A) to denote the set of o-words accepted by A viewed as an automaton over the alphabet A.
A CLTL(L) model s realizes an o-word a0 a1 * * * over A iff for every i >= 0, we have s, i |= ai .
Given a CLTL(L) formula ph and an L-automaton A, the model-checking problem for CLTL(L) is to check whether there is a CLTL(L) model s that realizes some word of Lsymb (A) and such that s, 0 |= ph.
We denote this by A |= ph.
In other words, A |= ph iff there is an accepting run of A such that the corresponding valuation sequence, obtained by removing the states, satisfies ph.
States are removed since the atomic formulae of the logics only speak about counters.
This existential version of the problem simplifies forthcoming developments since we also deal with satisfiability.
Results about the universal version can be withdrawn from those presented herein.
For the restriction to CLTLlk (L), the model-checking problem takes as inputs a CLTLlk (L) formula and a k-variable L-automaton.
Counter automata.
In the rest of the paper, we mainly consider DL+ automata or subclasses that can simulate non-deterministic Minsky machines.
We introduce below subclasses of DL-automata on which we will restrict in some places the model-checking problem.
A k-Z-counter automaton is a restricted DL-automaton such that for every  7  a  transition q - - q ' in the automaton, the constraint a is a conjunction of the form below ^ ^ aupdatei atesti [?]
i[?
]{1...k}  i[?
]{1...k}  with * atesti [?]
{[?]}
[?]
{xi ~ 0 | ~ [?]
{<, >, =, 6=}}, * aupdatei [?]
{Xxi = xi + u | u [?]
Z} for every i [?]
{1 .
.
.
k}.
Moreover, we require that the initial values of the counters are equal to zero (with a zero test on every transition from an initial state).
Obviously, k-Z-counter automata form a proper subclass of k-variables DL-automata that admit also constraints of the form Xxi > xj or Xxi < xj + d. For ease of presentation, the elements of {[?]}
[?
]{xi ~ 0 | ~ [?]
{<, >, =, 6=}} are encoded by {[?
], <, >, =, 6=}, the elements of {Xxi = xi + u | u [?]
Z} by Z and we order the constraints according to an arbitrary ordering of the variables (from x1 to xk ).
For instance, the transition [?][?
]x =0[?
]Xx =x [?
]Xx =x -1  2 1 2 q ---- ----- --1---- --2-- q '  is encoded by [?
],=,0,-1  q ------ q ' .
A k-N-counter automaton is defined similarly except that V we only consider non-negative values for the counters.
So, we require that i[?
]{1...k} xi >= 0 is also part of the constraints on every transition.
When explicitly dealing with N-counter automata, we omit this additional constraint on the transitions.
We only refer in the remaining to automata with at most two counters.
In Section 3, we define an automata-based approach which differs from [VW94] by the use of one-Z-counter automata where the updates are restricted to {-1, 0, 1}, instead of classical Buchi automata.
Such automata are called simple.
Hence, counter automata are used as operational models (inputs of the model-checking problem) and also as language acceptors for adapting the automata-based approach from [VW94].
Proving the existence of accepting runs for simple one-Zcounter automata is not immediate since we are dealing with Buchi acceptance condition, the counter is interpreted in Z and zero/sign tests are allowed (see Section 5).
As far as two-N-counter automata are concerned, the existence of an accepting run is S11 -hard since the recurrence problem for nondeterministic two counter Minsky machines, known to be S11 -complete [AH94, Lemma 8], can easily be reduced to this problem.
2.2  Improving undecidability boundaries  Satisfiability for CLTL(DL) is undecidable since we can easily encode the executions of a multi-counter Minsky machine with a CLTL(DL) formula.
The proof of [CC00, Theorem 3] provides that CLTL13 (DL) satisfiability is already 8  S11 -hard.
We refine this result by showing that one variable and X-length two or two variables and X-length one is enough for high undecidability.
The idea of the two proofs below is standard and consists in encoding directly in the formula the instructions of the Minsky machines.
Depending on the available syntactic resources, configurations of the machine are represented differently.
Even though the proofs are not very difficult, we believe that it simply illustrates that having strictly less than three variables does not necessarily decrease the complexity of the logic.
Theorem 1 Satisfiability for CLTL21 (DL) is S11 -complete.
Proof.
We show that the existence of an accepting run for a two-N-counter automaton can be reduced to a satisfiability question in CLTL21 (DL).
This is sufficient to get S11 -hardness because such counter automata can easily simulate nondeterministic two counter Minsky machines whose recurrence problem is S11 -hard.
First we show that for every two-N-counter automaton A, there is a two-Ncounter automaton A' computable in logarithmic space in |A| such that A has an accepting run iff A' has an accepting run and none of the transitions of A' test1 ,test2 ,0,0  is of the form q --------- q ' .
In other words, at least one counter changes its value at every step of A' .
Let A = hQ, d, I, F i be a two-N-counter automaton.
The two-N-counter automaton A' = hQ' , d ' , I ' , F ' i is defined as follows: test1 ,test2 ,0,0  def  * Q' = Q [?]
{t [?]
d : t = q --------- q ' }, def  * I ' = I and F ' = F , test1 ,test2 ,0,0  * d ' is defined from d by replacing each transition t = q --------- q ' [?]
test1 ,test2 ,+1,0  [?],[?
],-1,0  Q' \ Q by q ---------- t and t ------ q ' .
Now let A = hQ, d, I, F i be a two-N-counter automaton such that every transition of d changes the value of at least one counter.
We pose Q = {q1 , .
.
.
, qn }, I = {qa1 , .
.
.
, qam }, F = {qb1 , .
.
.
, qbm' } and the variables used in the transition relation of A are denoted by x1 and x2 .
A configuration of the form hqi , c1 , c2 i is encoded by a sequence of 2i states repeating i times the pair c1 , (c1 + c2 + 1).
We recall that a CLTL21 (DL) model is simply an o-sequence of integers.
A new configuration is detected when four consecutive values c, d, c' , d' are found with either c 6= c' or d 6= d' (i.e.
when the value of a counter changes).
* The formula phch states the change of configuration: phch = x < Xx [?]
(x 6= X2 x [?]
X(x 6= X2 x)) * Let Beforei state that we are just before the configuration with control state qi : ^ def Beforei = phch [?]
X2 ( X2j (x = X2 x [?]
X(x = X2 x)) [?]
X2(i-1) phch ) 0<=j<i-1  9  * Initial configuration: def  phinit = x = 0 [?]
Xx = 1 [?]
_  ^  (  X2j (x = X2 x [?]
X(x = X2 x))  1<=i<=m 0<=j<ai -1  _  [?]
X2(ai -1) (ph' [?]
Beforej ' ))  hqai ,a,qj' i[?
]d def  * Recurring elements of F : phrec = * Simulation of the run: def  phrun = G  ^  W  (Beforei =  1<=i<=n  1<=i<=m'  GFBeforebi .
_  X2i (a' [?]
Beforej ))  hqi ,a,qj i[?
]d  where a' is obtained from a - - - -  by replacing x1 = 0 by x = 0, by replacing x2 = 0 by Xx = x + 1, by replacing Xx1 = x1 + d1 by X2 x = x + d1 for every d1 [?]
{-1, 0, 1}, by replacing Xx2 = x2 + d2 by ^ (X2 x = x + d1 ) = X(X2 x = x + (d1 + d2 )) d1 [?
]{-1,0,1}  for every d2 [?]
{-1, 0, 1}.
It is easy to show that A has an accepting run iff the formula phinit [?]
phrun [?]
phrec is satisfiable.
2 Theorem 2 Satisfiability for CLTL12 (DL) is S11 -complete.
Proof.
We prove this result by reducing the satisfiability problem for CLTL21 (DL) to the satisfiability problem for CLTL12 (DL).
Basically, the idea is to encode two states from a CLTL21 (DL) model into a single state in a CLTL12 (DL) model.
For instance, the CLTL21 (DL) model below x0 * x1 * x2 * x3 * * * is encoded as the following CLTL12 (DL) model    x2 x0 *** x3 x1 For the rest of this proof, we consider a CLTL21 (DL) model whose unique variable is x and we show how it can be encoded by a CLTL21 (DL) model with variables denoted by y0 and y1 .
We define a map f : CLTL21 (DL) x {0, 1} - CLTL12 (DL) such that f (ph, i) enforces the variable x in ph to be interpreted by yi .
10  '  * f (R(Xj1 x, .
.
.
, Xjs x), i) = R(Xj1 x, .
.
.
, Xjs x)[Xa x - Xa yb' ] ' where R(Xj1 x, .
.
.
, Xjk x)[Xa x - Xa xb' ] is obtained from R(Xj1 x, .
.
.
, Xjs x) ' by replacing every occurrence of Xa x by Xa yb' where a,a' and b' are such that (a + i) = 2a' + b' with a' > 0 and b' [?]
{0, 1}.1 * f is homomorphic for the Boolean operators, * f (Xph, 0) = f (ph, 1), * f (Xph, 1) = Xf (ph, 0), * f (phUps, 0) = f (ps, 0) [?]
(f (ph, 0) [?]
(f (ps, 1) [?]
((f (ph, 1) [?]
X(ph' Ups ' )))) and f (phUps, 1) = f (ps, 1) [?]
((f (ph, 1) [?]
X(ph' Ups ' )))) where - ph' = f (ph, 0) [?]
f (ph, 1), - ps ' = f (ps, 0) [?]
(f (ph, 0) [?]
f (ps, 1)).
One can easily show that ph is CLTL21 (DL) satisfiable iff f (ph, 0) is CLTL21 (DL) satisfiable.
2 The satisfiability problem can be reduced to the model-checking problem since ph [?]
CLTL(DL) is satisfiable iff A[?]
|= ph where A[?]
is the one-state DL[?]
automaton h{q}, d, {q}, {q}i with unique transition q - - q (i.e.
every model realizes the execution of A[?]
).
We obtain the following corollary.
Corollary 1 The model-checking problems for CLTL12 (DL) and CLTL21 (DL) are S11 -complete.
The S11 upper bound is obtained by reducing model-checking to satisfiability for CLTL(DL) along the lines of [SC85] (this technique is also used in the proof of Lemma 1).
Indeed, in order to simulate a propositional variable, we use a constraint of the form x = 0 assuming that x is not used already for other purposes.
By close inspection of the proofs of Theorems 1 and 2, one can even show that satisfiability and model-checking for CLTL12 (DL) and CLTL21 (DL) restricted to the temporal operator F (instead of until) are also S11 -hard.
3  PSPACE-completeness of CLTL11(DL+ ) with propositional variables  To complete the results of Section 2, we show that satisfiability for CLTL11 (DL) and model-checking CLTL11 (DL) formulae over one-variable DL-automata are both pspace-complete, thus refining the exptime bound established for pushdown systems [FWW97].
To do so, we establish a pspace upper bound for satisfiability of the richer logic CLTL11 (DL+ , PROP) that includes periodicity constraints of the form x [?
]k y + c, x [?
]k c (c [?]
N, k [?]
N \ {0, 1}) and propositional variables that can be viewed as specific variables with their values restricted to be in {0, 1}.
We get as a corollary that the model-checking problem 1 Note  that a' > 0 and b' [?]
{0, 1} imply that a' and b' are unique.
11  for CLTL11 (DL) is in pspace by reducing this problem in logarithmic space to the satisfiability problem for CLTL(DL+ , PROP).
The above-mentioned results complete our classification.
Furthermore, many problems on one-counter automata/nets can be encoded in CLTL(DL+ , PROP).
These problems come from several applications: verification of cryptographic protocols [LLT05], validation of XML streams (string representations of XML documents) [CR04], and resolution of the identification problem described in [WTT04].
For example, the class of one-variable DL-automata properly contains the one-counter automata used to validate XML streams against a recursive DTD in [CR04, Sect.5].
Below is the one-counter automaton recognizing the language {(ac)n a(e|cc)a(ca)n bm bm : n, m >= 1} where x is a counter and the alphabet is partitioned into a set of opening tags {a, b, c} and a set of corresponding closing tags {a, b, c}.
The symbol "=" for the transition between a7 and b8 refers to a zero-test and we assume that the acceptance condition of the automaton is defined with respect to the final configuration hb9 , 0i.
b, x--  a  c1  c, x++ a  a  a0  a2  a  a5  c  c3  a c  c  c6  c, x--  a c4  b9  a7  =, b, x++  b, x-- b8  b, x++  Checking if a word belongs to the language recognized by this automaton, a key problem in [CR04, Sect.5], can be expressed in our formalism.
The fragment CLTL11 (DL+ ) can also express concisely richer standard properties, for instance non-trivial safety properties of the form G(x < 2m ) and liveness properties such as G(x [?
]2n 0 = F(x [?
]3m 1)).
We also recall that DL-automata are strictly more expressive than one-counter automata since the transitions are not restricted to incrementationss and decrementations only.
Herein, we provide an optimal pspace upper bound refining the decidability result from [FWW97] for the model checking of CTL[?]
properties over pushdown systems.
3.1  Adding propositional variables  Let PROP = {p1 , p2 , .
.
.}
be a countably infinite set of propositional variables.
We define the logic CLTL(DL+ , PROP) as the extension of CLTL(DL+ ) obtained by adding propositional variables at the atomic level.
As a consequence, the models of CLTL(DL+ , PROP) are pairs of the form hs1 , s2 i such that s1 : N - 2PROP is a standard LTL model and s2 : N - (VAR - Z) is a CLTL(DL+ ) model.
The satisfaction relation is defined as for CLTL(DL) except at the atomic level: def  * for every proposition p [?]
PROP we have hs1 , s2 i, i |= p = p [?]
s1 (i) and 12  * for every DL+ -constraint a we have hs1 , s2 i, i |= a = s2 (i) |= a (using the satisfaction relation of CLTL(DL+ )).
def  There is no restriction on the propositional variables in the fragments of the form CLTLlk (DL+ , PROP).
3.2  Model-checking one-counter (DL+ )-automata  The presence of propositional variables in CLTL(DL+ , PROP) makes the reduction from the model-checking problem for CLTL(DL+ ) to the satisfiability problem for CLTL(DL+ , PROP) easy.
Lemma 1 There is a logspace reduction from the model-checking problem for CLTL(DL+ ) to the satisfiability problem for CLTL(DL+ , PROP).
Proof.
The reduction is similar to the reduction from model-checking to satisfiability for standard LTL [SC85].
Let ph be a CLTL(DL+ ) formula and A = hQ, d, I, F i be a DL+ -automaton with d [?]
Qx1SCk xQ.
We describe below the construction of a CLTL(DL+ , PROP) formula phA such that A |= ph iff ph[?
]phA is CLTL(DL+ , PROP) satisfiable.
For every location qi in Q = {q1 , .
.
.
, qn }, we introduce a propositional variable pi .
First, we state that a unique propositional variable holds true at each position: ^ _ def !pj ).
(pi [?]
phuni = j[?
]{1,...,n}\{i}  i[?
]{1,...,n}  The transition relation can be encoded as follows: _ ^ def (a [?]
Xpj )).
(pi = phnext = hqi ,a,qj i[?
]d  i[?
]{1,...,n}  Finally, initial configurations and the accepting condition are expressed by the formulae below: _ _ def def pi ).
pi , phacc = GF( phinit = qi [?
]F  qi [?
]I  def  The formula phA is phA = phinit [?]
G(phuni [?]
phnext ) [?]
phacc .
2  As a corollary, we have the following reduction for the model-checking problem of CLTL11 (DL+ ).
Corollary 2 The model-checking problem for CLTL11 (DL+ ) can be reduced in logspace to the satisfiability problem for CLTL11 (DL+ , PROP).
Proof.
The model-checking problem for CLTL11 (DL+ ) can be reduced to a satisfiability problem by using the reduction of Lemma 1.
The formula built with this construction always belongs to CLTL11 (DL+ , PROP).
Indeed, the guards from a one-variable (DL+ )-automaton are one-step constraints from 1SC1 which corresponds to the set of CLTL11 (DL+ ) atomic constraints.
2 13  We dedicate the remaining of this section to prove decidability of the satisfiability problem for CLTL11 (DL+ , PROP), which is partially based on the abstraction of models.
3.3  Symbolic models  Symbolic valuations.
In order to build an automaton that recognizes the symbolic models of a CLTL11 (DL+ ) formula, we first introduce a symbolic representation of valuations.
Without any loss of generality, we can assume that all the atomic constraints involving both x and Xx in a CLTL11 (DL+ , PROP) formula (and in any set of constraints used in the sequel) are of the form Xx ~ x+d and Xx [?
]k x + c where d [?]
Z, c [?]
N and k [?]
N \ {0, 1}.
Given a finite set X of one-step constraints from CLTL(DL+ ) built over the variable x, we consider the following syntactic resources.
* CONSx = {dmin , .
.
.
, d-1 , d0 , d1 , .
.
.
, dmax } is the set of constants d occurring in X in constraints of the form x ~ d and Xx ~ d. We assume that dmin < * * * < d-1 < d0 < d1 < * * * < dmax .
* CONSstep = {emin' , .
.
.
, e-1 , e0 , e1 , .
.
.
, emax' } is the set of constants e occurring in X in constraints of the form Xx ~ x + e. We assume that emin' < * * * < e-1 < e0 < e1 < * * * < emax' .
* K is the least common multiple (lcm) of all the integers k [?]
N \ {0, 1} such that a relation of the form [?
]k occurs in X.
Without loss of generality, we can assume that d0 = e0 = 0, dmax >= 0, emax' >= 0, dmin <= 0 and emin' <= 0.
We define an abstraction for valuations that is similar to regions for timed automata [AD94] and we shall prove that this abstraction fits exactly our goal.
A map {x, Xx} - Z (that can also be viewed as a pair hz1 , z2 i [?]
Z2 ) is represented by a tuple sv = hax , am , a'x , a'm , as i [?]
Cx x Modx x CXx x ModXx x Cstep (depending on X) such that * Cx is composed of constraints of the form below - di < x [?]
x < di+1 for i [?]
{min, .
.
.
, max -1}, - x = di for i [?]
{min, .
.
.
, max}, - x < dmin and dmax < x, * Modx is composed of the constraints of the form - x [?
]K c for c [?]
{0, .
.
.
, K - 1}, * CXx and ModXx are defined similarly to Cx and Modx respectively, by replacing "x" by "Xx" in the constraints used, * Cstep is composed of constraints of the form below - x + ei < Xx [?]
Xx < x + ei+1 for i [?]
{min' , .
.
.
, max' -1},  14  - Xx = x + ei for i [?]
{min' , .
.
.
, max' }, - Xx < x + emin' and x + emax' < Xx.
We call the tuple sv symbolic valuation and we write SV(X) to denote the set of symbolic valuations with respect to the set X.
By extension, SV(ph) denotes the set of symbolic valuations with respect to the set of atomic constraints of the CLTL11 (DL+ , PROP) formula ph.
Note that the size of the set SV(ph) is exponential in the size of ph (but each element has polynomial size with respect to |ph|).
Let v : {x, Xx} - Z be a valuation and sv be a symbolic valuation.
We note v |= sv iff v satisfies all the constraints in sv .
The following result shows the correctness of our symbolic valuation abstraction.
Lemma 2 Let X be a finite set of one-step constraints from CLTL11 (DL+ ) built over the variable x.
(I) For every map v : {x, Xx} - Z there is a unique symbolic valuation in SV (X) denoted by sv (v) such that v |= sv (v).
(II) For every pair of maps v, v ' : {x, Xx} - Z such that sv (v) = sv (v ' ) (sv (v), sv (v ' ) [?]
SV (X)) and for every a [?]
X, we have v |= a iff v ' |= a.
Proof.
(I) Given sv [?]
SV(X), let Vsv be the set of pairs hz1 , z2 i [?]
Z2 such that hz1 , z2 i |= sv.
By definition of symbolic valuations, it is obvious that {Vsv : sv [?]
SV(X), Vsv 6= [?]}
is a partition of Z2 .
(II) Let v and v ' be valuations such that sv (v) = sv (v ' ) = hax , am , a'x , a'm , as i and suppose that v |= a.
We proceed by induction on the structure of a (we omit the cases with Boolean connectives).
* If a is of the form x = d then v(x) = d and ax must be equal to a.
Indeed, we have d [?]
CONSx by definition of CONSx and so the only constraint of Cx satisfied by v is x = d (see the definition of Cx ).
Since v ' also satisfies ax , we have v ' |= a.
* If a is of the form x < d then v(x) < d and ax can be equal either to x = d' with d' < d or to d'' < x [?]
x < d' with d' <= d. In both cases, it is easy to check that if v ' |= ax then we also have v ' |= a.
* If a is of the form Xx ~ d (resp.
Xx ~ x + d) where ~[?]
{<, =}, the proof is similar to the two above cases, using the constraint a'x (resp.
as ).
* Let a be of the form x [?
]k c. We suppose that the constraint am is equal to x [?
]K c' .
By construction of K, k divides K and so we have am = (x [?
]k c'r ) is valid in Presburger arithmetic where c'r [?]
N is the remainder of the division of c' by k. As c and c'r belong to {0, .
.
.
, k - 1} and v satisfies both a and am , c must be equal to c'r .
Since v ' |= am and am = a is valid, we have v ' |= a.
15  * If a is of the form Xx [?
]k c (resp.
Xx [?
]k x + c) the proof is similar to the previous case, using the constraint a'm (resp.
the conjunction am [?]
a'm ).
2 Given an atomic formula a from CLTL11 (DL+ ), we note sv |=symb a iff for every valuation v such that sv (v) = sv we have v |= a.
Note that this notion is well-defined thanks to Lemma 2.
Our symbolic representation of CLTL11 (DL+ ) models relies on sequences of symbolic valuations.
We say that an infinite sequence r : N - SV(ph) of symbolic valuations with respect to ph is satisfiable iff there is a CLTL11 (DL+ ) model s : N - Z such that for every i [?]
N we have s, i |= r(i).
In this case, we write s |= r. A symbolic model with respect to ph is a pair hs1 , ri such that s1 : N - 2PROP and r : N - SV(ph).
We extend the symbolic satisfaction relation |=symb to symbolic models in a natural way.
The definition is identical to the satisfaction relation of CLTL(DL+ , PROP) except for atomic constraints: def hs, ri, i |=symb a = r(i) |=symb a.
3.4  Automata-based approach  We now show that given a CLTL11 (DL+ , PROP) formula ph, one can build an automaton Aph recognizing the set of symbolic models satisfying ph.
To define this automaton we extend the definition of simple one-Z-counter automata (where updates are restricted to {-1, 0, 1}) with an alphabet S and e-transitions.
The transitions are decorated by elements from S [?]
{e} and the constraints are the same as in one-Z-counter automata.
Adding an alphabet is motivated by the need to consider the automata as language acceptors.
So, we define * L' (A) = {s : N - (S [?]
{e}) : there is an accepting run w : N - (Q x Z) s(i)  such that [?
]i, w(i) -- w(i + 1)}, * L(A) = {s\e : s [?]
L' (A) and |s\e | = [?
]}, where s\e is obtained from s by erasing all the occurrences of the letter e. The set L(A) is the language accepted by A and corresponds to the accepting runs of L' (A) where non-e-transitions are fired infinitely often.
The construction of Aph relies on the following observation.
Lemma 3 A CLTL11 (DL+ , PROP) formula ph is satisfiable iff there exist a symbolic model hs1 , ri such that hs1 , ri |=symb ph and a CLTL11 (DL+ ) model s2 such that s2 |= r. Proof.
If ph is satisfiable then we consider a model hs1 , s2 i that satisfies it.
Let r : N - SV(ph) be the symbolic model such that r(i) = sv (vi ) where the valuation vi : {x, Xx} - Z is defined by vi (x) = s2 (i) and vi (Xx) = s2 (i + 1) for every i [?]
N. By construction, we have s2 |= r. Using Lemma 2(II) we can show that for every v such that sv (v) = r(i) we have s2 (i) |= a iff v |= a for every atomic subformula a of ph.
By definition of the symbolic satisfaction relation, this 16  implies that if s2 |= a then r |=symb a. Consequently, hs1 , ri |=symb ph because the symbolic satisfaction relation differs from CLTL(DL+ , PROP) satisfaction relation only in the case of atomic constraints.
Conversely, suppose that hs1 , ri |=symb ph and s2 |= r for some s1 , s2 and r. Since for every i [?]
N we have s2 , i |= r(i), the symbolic valuation r(i) corresponds to the abstraction of the valuation vi such that vi (x) = s2 (i) and vi (Xx) = s2 (i + 1).
By definition of |=symb , this implies that for every atomic subformula a of ph, if r(i) |=symb a then s2 , i |= a.
Thus, we can show that hs1 , ri |=symb ph and s2 |= r imply hs1 , s2 i |= ph by using the fact that CLTL(DL+ , PROP) satisfaction relation is different from the symbolic satisfaction only for atomic constraints.
2 So, we define Aph as the intersection of two automata Asymb and Asat such that L(Asymb ) is the set of symbolic models that symbolically satisfy ph.
Furthermore, L(Asat ) is the set of symbolic models of the form hs1 , ri such that r is satisfiable.
Both automata are simple one-Z-counter automata over the alphabet S = (2PROP x SV(ph)) but Asymb is essentially a finite-state automaton (the counter is not used).
Main steps to get the PSPACE upper bound.
The automaton Asymb is built as in [VW94] for LTL except at the atomic level.
We define cl (ph) the closure of ph with a slight modification to consider both atomic constraints and propositional variables.
Let us briefly recall that the closure set cl (ph) is the smallest set containing ph, closed under subformulae, negations (double negations are eliminated) and such that if psUps ' [?]
cl (ph), then X(psUps ' ) [?]
cl (ph).
A set X [?]
cl (ph) is an atom whenever it satisfies the usual conditions for subformulae whose outermost connective is Boolean and, we have psUps ' [?]
X iff (ps ' [?]
X or (ps, X(psUps ' ) [?]
X)) whenever psUps ' [?]
cl (ph).
Let A'symb be the generalized Buchi automaton defined as the structure hQ, d, I, F i such that: * Q is the set of atoms of ph, * I = {X [?]
Q : ph [?]
X}, hP,sv i,[?
],0  * X ------- Y iff (prop.)
P = X [?]
PROP, (constr.)
for every atomic formula a in X, sv |=symb a, (1-step) for every Xps [?]
cl (ph), Xps [?]
X iff ps [?]
Y , * Let {ps1 Uph1 , .
.
.
, psn Uphn } be the set of until formulae in cl (ph).
We pose F = {F1 , .
.
.
, Fn } where Fi = {X [?]
Q : psi Uphi 6[?]
X or phi [?]
X} for every i [?]
{1, .
.
.
, n}.
The automaton Asymb is a non-generalized Buchi automaton equivalent to A'symb .
It can be built in logarithmic space in the size of A'symb .
Note that the counter is useless in this construction.
17  Section 3.5 is dedicated to the lengthy construction of Asat .
The final automaton is obtained by synchronizing Asymb and Asat in the following way.
Let us pose Asymb = hQsy , dsy , Isy , Fsy i and Asat = hQsa , dsa , Isa , Fsa i.
The automaton Asat has e-transitions while Asymb has not.
The e-transitions of Asat can be fired independently of Asymb .
Otherwise, one can make a move in both Asymb and Asat when the same letter is read.
In this case, the counter is updated according to the transition in Asat because the counter is useless in Asymb .
Formally, the automaton Aph = hQ, d, I, F i is defined by: * Q = Qsy x Qsa , * I = Isy x Isa , * F = Fsy x Qsa (since we will have Qsa = Fsa ), e,t,u  e,t,u  def  * hq1 , q2 i --- hq1' , q2' i [?]
d = q1 = q1' and q2 --- q2' [?]
dsa , hP,svi,t,u  def  hP,sv i,[?
],0  * hq1 , q2 i ------ hq1' , q2' i [?]
d = q1 ------- q1' [?]
dsy and hP,sv i,t,u  q2 ------ q2' [?]
dsa .
We will show at the end of this section that Aph can be effectively built from ph in polynomial space thanks to the way Asat can be built.
Moreover the nonemptiness problem for one-Z-counter automata with alphabet and e-transitions is shown to be nlogspace-complete in Section 5.
By combining these two results, we obtain the result below.
Theorem 3 The satisfiability problem for the fragment CLTL11 (DL+ , PROP) is pspace-complete.
Proof.
The size of the automaton Aph is exponential in the size of the formula ph (denoted by |ph|) and it can be built in polynomial space with respect to |ph|.
Since the nonemptiness problem for the resulting automaton is in nlogspace and the composition of a logarithmic space function with a polynomial space function is a polynomial space function [BDG88, Lemma 3.35], we obtain a whole procedure in nondeterministic polynomial space.
Using Savitch's theorem, we can deduce that the problem is in pspace.
The pspace-hardness is given by the pspace-hardness of LTL.
The logic LTL is subsumed by the fragment CLTL11 (DL+ , PROP) because the number of propositional variables in this fragment is not concerned by the syntactic restrictions.
2 We can also deduce the following corollaries.
Corollary 3 The satisfiability and model-checking problems for CLTL11 (DL) are pspace-complete.
Proof.
These problems can easily be shown to be in pspace using Theorem 3 and Lemma 1.
In order to prove the pspace-hardness, we reduce the satisfiability problem for the one-variable fragment of LTL (shown to be to pspace-complete in [DS02, Corollary 3.2]) to the satisfiability problem for CLTL11 (DL).
Given an 18  LTL formula ph with a unique propositional variable p, we simply replace each occurrence of p by x = 0, providing a formula ph' in CLTL11 (DL).
It is obvious that ph is satisfiable iff ph' is satisfiable.
2 Corollary 4 The one-variable fragment of the counter logic Lp [CC00] has a pspace-complete satisfiability problem.
Another corollary of Theorem 3 is that model-checking one-clock discrete timed automata from [DPK03] with CLTL11 (DL+ ) can be done in pspace which contrasts with the undecidability results from [DPK03, Section 6].
A nice feature of this approach is that the temporal logic part is separated from the constraint part.
As a consequence, this method can be tailored to any extension with Presburger constraints of a temporal logic whose operators are definable in the Monadic Second Order logic (MSO), thanks to [GK03].
One just needs to replace the automaton Asymb by an appropriate automaton recognizing the models of the input formula in the corresponding propositional logic (instead of the LTL automaton).
By [GK03], this automaton can be built in polynomial space and so we preserve our complexity bound for this kind of extensions.
This includes extensions of LTL with past-time operators, with automaton-based temporal operators [Wol83], or fixpoints operators [Var88].
All these extensions are denoted by xCLTL in the following corollary.
Corollary 5 The satisfiability and model-checking problems for xCLTL11 (DL) are pspace-complete.
As a consequence, the satisfiability and model-checking of the linear u-calculus extended with DL-constraints is pspace-complete when the above syntactic restrictions are made.
This refines the result stated in [BEM97].
3.5  Construction of Asat  In the rest of this section, we describe the construction of the automaton Asat recognizing exactly the set of symbolic models hs1 , ri such that r is satisfiable.
We recall that the set of constants CONSx used in the symbolic representation of the models contains the following elements: d0 = 0, dmax >= 0 and dmin <= 0.
The alphabet of Asat is 2PROP x SV(ph) but since the set of propositional variables is not constrained in Asat , we omit them in the technical developments sv ,t,u below.
This means that for every non-epsilon transition of the form q ---- q ' defined in the rest of this section, we mean to consider all the transitions hX,sv i,t,u  q ------ q ' for some X [?]
2PROP .
The construction of Asat is done in a modular fashion.
The automaton Asat is made of a network of components/gadgets and its size is exponential with respect to the size of the input formula ph.
A component is defined as a simple one-Z-counter automaton hS, Q, d, I, F i such that * I and F are singletons, 19  * d is a subset of (Q \ F ) x {e} x {[?
], =, 6=, >, <} x {-1, 0, 1} x (Q \ I).
The unique state in I (resp.
F ) is called the input (resp.
output) state of the component.
Components are connected in the network by defining transitions between input states and output states.
Each component in Asat has the function either to check a property of the counter from constraints in Cx or to update the counter according to constraints in Modx or ModXx x Cstep (viewed as a conjunction).
We define below the components Aa,sv for some a,sv a [?]
Cx [?]
Modx [?]
(ModXx x Cstep ) and sv [?]
SV(ph).
We write qin (resp.
a,sv qout ) to denote the input (resp.
output) state of Aa,sv .
However, when the context is clear we shortly write qin and qout .
Each component Aa,sv enforces that the next symbolic valuation that is guessed is precisely sv .
For every sv = hax , am , a'x , a'm , as i [?]
SV(ph), we define the following components: ax ,sv ax ,sv ' * Aax ,sv is such that for every c [?]
Z, hqin , ci - -* hqout , c i iff c = c' and [x - c] |= ax .
This component checks that value of the counter c satisfies ax .
Figure 1 contains a graphical representation of components Ax=di ,sv and Adi <x<di+1 ,sv when di >= 0.
Components with di <= 0 can be defined analogously.
0 qin  1  di  2  e, >, -1  e, >, -1  (a)  e, =, 0 qout e, [?
], +1  0 qin  e, [?
], +1  di  di+1 -1  di +1 e, >, -1  (b)  e, =, 0  e, =, 0  qout e, [?
], +1  Figure 1: Components Ax=di ,sv (a) and Adi <x<di+1 ,sv (b) ha' ,as i,sv  * Aha'm ,as i,sv is such that for every c [?]
Z, [x - c] |= am and hqin m  , ci - -*  ha'm ,as i,sv  , c' i iff [x - c, Xx - c' ] |= a'm [?]
as .
This component updates hqout the counter according to ha'm , as i.
Figure 2 contains a graphical representation of the component Aha'm ,as i,sv with am = x [?
]2 1, a'm = Xx [?
]2 0 and as = x < Xx < x + 7.
To build Aha'm ,as i,sv , we determine on-the-fly (using am , a'm and as ) that Xx = x + i for some i [?]
{1, 3, 5}.
am ,sv am ,sv * Aam ,sv is such that for every c [?]
Z, hqin , 0i - -* hqout , ci iff [x - c] |= am .
This component updates the counter from 0 to a value satisfying am  20  e, [?
], +1  qin  e, [?
], +1  e, [?
], +1  e, [?
], +1  e, [?
], +1  e, [?
], +1  e, [?
], +1  e, [?
], +1  qout  e, [?
], +1  Figure 2: Component Aha'm ,as i,sv  (only used at the beginning of the run).
Figure 3 contains a graphical representation of some component Ax[?
]K c,sv .
+1  1  0 qin  e, [?
], +1  +(K - 1)  c  e, [?
], +1  e, [?
], +1  qout e, [?
], -1  -1  e, [?
], -1  -(K - 1)  Figure 3: Component Ax[?
]K c,sv  The automaton Asat = hS, Q, d, I, F i is defined as the "disjoint union" of the above-mentioned components with an additional initial state s0 , F = Q and with the following additional transitions.
* For every sv = hax , am , a'x , a'm , as i [?]
SV(ph), we have a transition e,[?
],0  am ,sv [?]
d. s0 --- qin  These transitions correspond to the choice of the first symbolic valuation.
After this choice, the value of the counter has to be updated in order to satisfy am .
This update is done by the component Aam ,sv .
* For every sv = hax , am , a'x , a'm , as i [?]
SV(ph), we have a transition e,[?
],0  am ,sv ax ,sv --- qin [?]
d. qout  21  am ,sv When the control state is qout during any execution, we know that the counter satisfies am .
The next step is to check that the constraint ax is satisfied.
So, we impose to continue the run by entering in the component Aax ,sv .
* For every sv = hax , am , a'x , a'm , as i [?]
SV(ph), we have a transition ha' ,as i,sv  e,[?
],0  ax ,sv qout --- qin m  [?]
d.  ax ,sv When the current control state is qout , the counter satisfies ax and it is now time to update it according to the constraints a'm and as , imposing constraints on the counter for the next position of symbolic model.
Therefore, the only way for the run to continue is to enter further in the component Aha'm ,as i,sv .
* For all pairs of symbolic valuations sv 1 = h(ax )1 , (am )1 , (a'x )1 , (a'm )1 , (as )1 i [?]
SV(ph) and sv 2 = h(ax )2 , (am )2 , (a'x )2 , (a'm )2 , (as )2 i [?]
SV(ph) such that - (a'x )1 [Xx - x] = (ax )2 and - (a'm )1 [Xx - x] = (am )2 we have a transition h(a' )1 ,(as )1 i,sv 1 sv 1 ,[?
],0  (a )2 ,sv 2  ----- qin x  qout m  [?]
d.  At this step, the letter sv 1 can be read since all the verifications have been successful.
The only way for the run to continue is to enter further in a component of the form A(ax )2 ,sv 2 .
The new symbolic valuation sv 2 that is guessed has to agree with sv 1 on some constraints.
Note that since (a'm )1 have been verified by Ah(a'm )1 ,(as )1 i,sv 1 and (a'm )1 [Xx - x] = (am )2 , we can go directly to the input state in A(ax )2 ,sv 2 .
By construction of the components the following property is satisfied.
Lemma 4 For all symbolic valuations sv 1 = h(ax )1 , (am )1 , (a'x )1 , (a'm )1 , (as )1 i [?]
SV(ph) and sv 2 = h(ax )2 , (am )2 , (a'x )2 , (a'm )2 , (as )2 i [?]
SV(ph), and for all c, c' [?]
Z, the propositions below are equivalent: (a )1 ,sv 1  (I) [x - c] |= (am )1 and hqin x h(a' )1 ,(as )1 i,sv 1  hqout m  sv  e *  (a )2 ,sv 2  1 - hqin x , c' i -  h(a'm )1 ,(as )1 i,sv 1  , ci - - hqin  e *  (a )2 ,sv 2  , c' i - - hqoutx  e *  , ci - -  , c' i,  (II) [x - c, Xx - c' ] |= sv 1 .
We can now state the main property: the set of satisfiable symbolic models (with respect to a formula ph) is recognized by the simple one-Z-counter automaton Asat .
Lemma 5 L(Asat ) is exactly the set of satisfiable symbolic models.
22  Proof.
Let hs, ri be a satisfiable symbolic model and for all i [?]
N, r(i) = h(ax )i , (am )i , (a'x )i , (a'm )i , (as )i i.
So there is a CLTL11 (DL) model s ' : N - Z such that s ' |= r. We can show that hs, ri [?]
L(Asat ) since there is an accepting run of the form e  (a )0 ,r(0)  - hqin m s0 -  e *  (a )0 ,r(0)  , s ' (0)i - - hqin x  e *  (a )1 ,r(1)  , s ' (1)i - - hqin  r(1)  (a )2 ,r(2)  , s ' (2)i .
.
.
, s ' (1)i -- hqin x  h(a' )1 ,(as )1 i,r(1)  , s ' (2)i -- hqin x  hqout m  h(a'm )0 ,(as )0 i,r(0)  r(0)  h(a' )0 ,(as )0 i,r(0)  hqout m  e *  , s ' (0)i - - hqin  e *  , s ' (0)i - -  h(a'm )1 ,(as )1 i,r(1)  e *  , s ' (1)i - -  Now suppose that hs, ri [?]
L(Asat ).
By construction of the network of components in Asat , there is an accepting run necessarily of the form e  (a )0 ,sv 0  - hqin m s0 -  h(a' )0 ,(as )0 i,sv 0  hqout m  h(a' )1 ,(as )1 i,sv 1  hqout m  e *  (a )0 ,sv 0  , c0 i - - hqin x  e *  h(a'm )0 ,(as )0 i,sv 0  , c0 i - - hqin e *  r(0)  (a )1 ,sv 1  , c1 i - - hqin  r(1)  (a )2 ,sv 1  , c2 i .
.
.
, c1 i -- hqin x , c2 i -- hqin x  e *  , c0 i - -  h(a'm )1 ,(as )1 i,sv 1  e *  , c1 i - -  By construction of each component and by Lemma 4, we have [x - c0 ] |= (am )0 and for every i [?]
N, [x - ci , Xx - ci+1 ] |= (ax )i [?]
(am )i [?]
(a'x )i [?]
(a'm )i [?]
(as )i .
So the model s ' : N - Z such that s ' (i) = ci satisfies r, i.e.
s ' |= r. This means precisely that hs, ri is a satisfiable symbolic model.
2  4  Model-checking one-Z-counter automata  A natural question is whether the decidability results of the previous section are optimal with respect to the fragments of Presburger arithmetic we have considered.
Lemma 6 below states that we do not preserve decidability when extending the constraint language to quantifier-free Presburger arithmetic.
Lemma 6 Satisfiability for CLTL11 (QFP) and model-checking CLTL11 (QFP) formulae over 1-variable QFP-automata are S11 -complete.
This follows directly from [Min67, Section 14.2] about one counter machines with multiplication and division by constants (plus S11 -hardness from [AH94, Lemma 8]).
Intuitively, the introduction of constraints of the form ax + by = 0 where a, b [?]
Z allow to encode a configuration hqi , c1 , c2 i of a Minsky machine, where qi is the ith control state, by the value 2c1 3c2 5i .
Zero tests, incrementations and decrementations can be encoded with constraints of the form x [?
]2 0, x [?
]3 0, Xx = 2x (incrementation of the first counter) etc.
As a consequence, the model-checking problem as it is defined in Section 2 is undecidable even for the fragment restricted to one variable and X-length one too.
In this section, the strategy to regain decidability consists in restricting the class of models to one-Z-counter automata.
Model-checking becomes decidable (even in pspace) for LTL with full quantifier-free Presburger constraints restricted to one variable but with no restriction on the X-length.
Indeed, the behavior of the unique counter in such automata is more constrained than in 23  QFP-automata.
However, the examples of applications given at the beginning of the previous section still hold.
This result is in sharp contrast with the results of the previous sections since the logic is much more expressive than CLTL(DL+ ).
Let A = hQA , dA , IA , FA i be a one-Z-counter automaton whose set of updates is of the form Xx = x + u with u [?]
{umin, umin + 1, .
.
.
, umax }.
Without loss of generality, we can assume that umin = -umax .
Given a CLTLo 1 (QFP) formula ph such that |ph|X = l, we consider the following syntactic resources: * K is the lcm of the integers k such that [?
]k occurs in ph (k [?]
N \ {0, 1}), P * CONS is the set of constants d [?]
Z such that ai Xi x ~ d occurs in ph,  * M = max{|d| : d [?]
CONS} is the maximal absolute value of the elements of CONS, P * COEF is the set of constants ai [?]
Z \ {0} such that ai Xi x ~ d occurs in ph.
Without any loss of generality, we can assume that amin = -amax where amin and amax are respectively the minimal and the maximal element of COEF.
For technical reasons (see the proof of Lemma 7), we define CONS(A, ph) as the set {dmin , .
.
.
, dmax } such that dmax = -dmin = M +  l(l + 1) amax umax .
2  We define a symbolic valuation with respect to A and ph as an element of the set SV(A, ph) = Cx x Modx x C1step x * * * x Clstep such that * Cx is the set composed of the constraints x < dmin , dmax < x, and x = d for every d [?]
CONS(A, ph).
* Modx contains the constraint x [?
]K c for every c [?]
{0, .
.
.
, K - 1}.
* Cistep contains the constraint Xi x = Xi-1 x+u for every u [?]
{umin, .
.
.
, umax }.
Lemma 7 Let ph be a CLTLo 1 (QFP) formula such that |ph|X = l. (I) For every path v = hq0 , c0 i .
.
.
hql , cl i of A there is a unique symbolic valuation sv (v) [?]
SV (A, ph) such that v |= sv (v).
(II) For all valuations v, v ' : {x, Xx, .
.
.
, Xl x} - Z such that sv (v) = sv (v ' ) (sv (v) = sv (v ' ) [?]
SV (A, ph)) and for every atomic subformula a of ph, v |= a iff v ' |= a.
In the statement (II) we had to suppose that the valuations v and v ' correspond to some path in A.
Actually, this implies that the valuation v is such that for every i [?]
{0, .
.
.
, l - 1} we have |v(Xi+1 x) - v(Xi x)| <= umax (idem for v ' ).
Proof.
(I) The argument is similar to the proof of Lemma 2(I) since the definition of symbolic valuations induces a partition of the set of valuations obtained from runs of A.
24  (II) We proceed by induction on the structure of the formula.
Assuming that for every 1 <= i <= l, the constraint Xi x = Xi-1 x + ui is in sv (v), a term of the form b0 x+b1 Xx+b2 X2 x * * *+bl Xl x (some bi might be equal to zero) is equivalent to j=i j=l i=l X X X uj ) bi ( bj )x + ( j=0  i=1  j=1  Note that by definition of dmax = -dmin = M + l(l+1) 2 amax umax , for every 2 atomic constraint of the form b x + b Xx + b X x * * * + bl Xl x ~ d, the value 0 1 2 Pi=l Pj=i d - i=1 bi ( j=1 uj ) is also in CONS(A, ph).
Indeed, for every i [?]
{1, .
.
.
, l} we have umin <= ul <= umax and amin <= bi <= amax .
We recall Pl that by definition amin = -amax and umin = -umax .
Moreover, when ( j=0 bj ) is nonzero, Pi=l  Pj=i  (  j=0 bj )  bi ( Pl  i=1  j=1  uj )  belongs to the range of constants in CONS(A, ph).
Thus, we  can reduce every atomic constraint a [?]
ph without Boolean connective in the following way.
P * A constraint of the form ai Xi x ~ d can be reduced to constraints of ' the form x ~ d with dmin <= d' <= dmax and since sv (v) = sv (v ' ) we can conclude.
P * A constraint of the form ai Xi x [?
]k c can be reduced to a constraint of ' ' the form ax [?
]k c with c [?]
{0, .
.
.
, k - 1}.
The set of solutions is of the form x [?
]k' c'' for k ' = gcd (a, k) (computable in polynomial time).
As k ' divides K, x [?
]K cx implies x [?
]k' c'x for a unique c'x [?]
{0, .
.
.
, k ' - 1}.
We can conclude by using the hypothesis sv (v) = sv (v ' ).
The step with Boolean connectives is by an easy verification.
Note that the substitution can be done in polynomial time (the size of dmax is polynomial with respect to |ph|) and checking that an atomic constraint is satisfied by a symbolic valuation can be checked in polynomial time.
2 We define a symbolic satisfaction relation as in Section 3.3: sv |=symb a iff for every valuation v : {x, Xx, .
.
.
, Xl x} - Z (corresponding to a path with l + 1 configurations in A) such that sv (v) = sv we have v |= a.
We can naturally extend this relation to symbolic valuation sequences.
Lemma 8 Let ph be a CLTLo 1 (QFP) formula and A be a one-Z-counter automaton.
A |= ph iff there exist a symbolic model r [?]
SV (A, ph) such that r |=symb ph and an accepting run hq0 , c0 i, hq1 , c1 i, hq2 , c3 i, .
.
.
of A such that c0 , c1 , c2 .
.
.
|= r. Proof.
In a nutshell, if ph is satisfied by a run then the symbolic valuation sequence r : N - SV(A, ph) such that for every position i [?]
N the symbolic valuation r(i) is the abstraction of the subrun of length l starting at position i symbolically satisfies ph (see Lemma 7).
Conversely, we can prove that if r symbolically satisfies ph, then every run of A satisfying r also satisfies ph.
Indeed, for every i, the subrun of this run starting at position i satisfies r(i) and therefore also satisfies the subformulae that are symbolically satisfied by r(i).
2 25  Again, we build an automaton Aph as the intersection Asymb [?]
Asat such that Asymb recognizes the set of symbolic models satisfying ph and Asat recognizes the set of symbolic models abstracting an accepting run of A.
The definition of Asymb and the synchronization between Asymb and Asat are similar to what is done in Section 3.4 considering the alphabet S = SV(A, ph) (with e-transitions) and the corresponding relation |=symb .
Lemma 9 below is a pivot result for proving Theorem 4.
Lemma 9 Given a formula ph and a one-Z-counter automaton A, one can build a simple one-Z-counter automaton Asat over the alphabet S = 2PROP xSV(A, ph) such that L(Asat ) is the set of satisfiable symbolic models w.r.t ph and A.
Moreover, Aph can be effectively built from ph and A in polynomial space thanks to the way Asat is defined.
Proof.
Let A = hQA , dA , IA , FA i be a one Z-counter automaton and ph be a CLTLo 1 (QFP) formula such that |ph|X = l. The automaton Asat is defined over the alphabet S = SV (A, ph).
As in Section 3.5, the construction is modular.
We denote by QA x Q the set of states of Asat where Q is a set of auxiliary states used in the construction of components similar to components of Section 3.5.
For every sv = hax , am , a1s , .
.
.
, als i and qa [?]
QA , we define the following components: am ,sv am ,sv , 0i - -* hqa , qout , ci iff * Aqaam ,sv such that for every c [?]
Z, hqa , qin [x - c] |= am .
ax ,sv ax ,sv ' , ci - -* hqa , qout , c i iff c = c' * Aqaax ,sv such that for every c [?]
Z, hqa , qin and [x - c] |= ax .
* We also need to define another kind of components that update the counter.
For every d [?]
CONS(A, ph), the component Aqaa1 ,sv is such that for every a1 ,sv  c [?]
Z, hqa , qins  a1 ,sv  s  s , ci - -* hqa , qout , c' i iff [x - c, Xx - c' ] |= a1s .
These different components are connected as follows: am ,sv * The set of initial states is composed of the states of the form hq0 , qin i 1 l for every sv = hax , am , as , .
.
.
, as i [?]
SV(ph, A) and q0 [?]
IA .
* For every sv = hax , am , a1s , .
.
.
, als i [?]
SV(ph, A) and q0 [?]
IA , we have e,[?
],0  am ,sv ax ,sv hq0 , qout i --- hq0 , qin i [?]
d.
e,[?
],0  a1 ,sv  ax ,sv i --- hqa , qins * For all sv = hax , am , a1s , .
.
.
, als i [?]
SV(ph, A), hqa , qout belongs to d.  i  * For all sv 1 = h(ax )1 , (am )1 , (a1s )1 , .
.
.
, (als )1 i [?]
SV(ph, A), sv 2 = h(ax )2 , (am )2 , (a1s )2 , .
.
.
, (als )2 i [?]
SV(ph, A) and qa , qa' [?]
QA such that - (a1s )1 is equal to Xx = x + d, d  - qa' [?]
dA , - qa - 26  - (a1s )1 [?]
(a1m )1 = (a1m )2 is valid in Presburger arithmetic (checkable in polynomial-time), i+1 - for every 1 <= i <= l - 1, (ais )2 = (ai+1 x - Xi x, Xi x - Xi-1 x], s )1 [X a1 ,sv 1  s we have hqa , qout  sv 1 ,[?
],0  (a )2 ,sv 2  i ----- hqa' , qin x  * the set of final states is  ax ,sv {hqf , qout i|qf  i [?]
d.
[?]
FA }.
(a ) ,sv  - *** By construction, for every path in Asat of the form * * * hqi , qin x i i , ci i - sv i+l-1 sv i+1 sv i (a ) ,sv (a ) ,sv - * * * --- * * * ----- hqi+l , qin x i+l i+l , ci+l i * * * , - - hqi+1 , qin x i+1 i+1 , ci+1 i - we have ci , .
.
.
, ci+l |= sv i .
2 We can conclude about the complexity of the model-checking problem.
Theorem 4 Model-checking CLTLo 1 (QFP) formulae over one-Z-counter automata is pspace-complete.
Proof.
The pspace upper bound is corollary of Lemma 9 and Theorem 6.
The pspace-hardness can be obtained by using the result of [DS02] about the modelchecking of LTL restricted to one propositional variable.
2 This result can also be generalized to LTL extensions with MSO-definable operators (denoted by xCLTL11 (QFP) below).
Theorem 5 Model-checking xCLTL11 (QFP) formulae over one-Z-counter automata is pspace-complete.
5  Complexity of the nonemptiness problem for simple one-Z-counter automata  This last technical section is dedicated to prove the result used in Theorems 3 and 4 stating that the nonemptiness problem for simple one-Z-counter automata with alphabet can be decided in nlogspace.
This is an interesting result for its own sake even though it is instrumental to establish our pspace upper bounds.
The proof is divided in two main parts.
We first define several reductions to restrict the class of automata we have to handle.
Then, we show that the existence of accepting runs is equivalent to the existence of finite runs of polynomial length.
Even when it is not explicitly mentioned, in the rest of this section the counter automata are always simple counter automata (the updates of the counter are among {-1, 0, 1}).
5.1  Reduction to one-N-counter automata  We first show how to reduce in logarithmic space the nonemptiness problem for simple one-Z-counter automata with alphabet to the existence of an accepting run in one-N-counter automata (without alphabet).
We proceed with several 27  reductions.
The first step is to eliminate the alphabet and the e-transitions.
The main difficulty is to avoid accepting runs where e-transitions are fired forever after a certain position.
Lemma 10 Checking whether L(A) is non-empty for one-Z-counter automata A with alphabet can be reduced in logarithmic space to the existence of an accepting run in one-Z-counter automata (without alphabet).
Proof.
We show that given a one-Z-counter automaton A with alphabet S, it is possible to compute in logarithmic space a one-Z-counter automaton A' without alphabet such that L(A) 6= [?]
iff A' has an accepting run.
The idea of the proof consists in defining A' as two copies of A.
The copy that contains the final states is reachable only by reading a non-epsilon transition.
Given the one-Z-counter automaton A = hQ, d, I, F i, the one-Z-counter automaton A' = hQ' , d ' , I ' , F ' i is defined as follows: * Q' = Q x {1, 2}, I ' = I x {1}, F ' = F x {2}, * The transitions in d ' are defined from transitions in d: a,t,u  - for every q --- q ' [?]
d such that a [?]
S (u [?]
{-1, 0, +1}) t,u we have hq, ii - - hq ' , 2i for i [?]
{1, 2}, e,t,u  - for every q --- q ' [?]
d we have t,u  * if q [?]
F then hq, ii - - hq ' , 1i [?]
d ' for i [?]
{1, 2}, t,u  * if q 6[?]
F then hq, ii - - hq ' , ii [?]
d ' for i [?]
{1, 2} .
It is easy to show that L(A) 6= [?]
iff A' has an accepting run.
2  We now show that the existence of an accepting run for one-Z-counter automata can be reduced in logarithmic space to the same problem for the simpler class of one-N-counter automata.
Lemma 11 The existence of an accepting run in one-Z-counter automata can be reduced in logarithmic space to the existence of an accepting run in one-Ncounter automata.
Proof.
We show that given a one-Z-counter automaton A, one can compute in logarithmic space a one-N-counter automaton A' such that A has an accepting run iff A' has an accepting run.
The idea of the proof is simply to define A' as two copies of A, one copy when the counter is positive (see the states in Q x {+} below) and another one when the counter is negative (see the states in Q x {-} below).
The move from one copy to another is done when the counter is equal to zero and the sign of the counter changes.
These two different copies allow to simulate tests of the form x < 0 and x > 0.
Given the one-Z-counter automaton A = hQ, d, I, F i, the one-N-counter automaton A' = hQ' , d ' , I ' , F ' i is defined as follows: * Q' = Q x {+, -}, I ' = I x {+}, F ' = F x {+, -}, 28  * The transitions in d ' are defined from transitions in d: t,0  t,0  - q- - q ' [?]
d and t [?]
{=, 6=} imply hq, -i - - hq ' , -i [?]
d ' and t,0  hq, +i - - hq ' , +i [?]
d ' , >,0  6=,0  <,0  6=,0  - q -- q ' [?]
d implies hq, +i -- hq ' , +i [?]
d ' , - q -- q ' [?]
d implies hq, -i -- hq ' , -i [?]
d ' , =,-1  =,+1  - q --- q ' [?]
d implies hq, +i --- hq ' , -i [?]
d ' and =,+1  hq, -i --- hq ' , -i [?]
d ' , >,-1  6=,-1  <,-1  6=,+1  - q --- q ' [?]
d implies hq, +i --- hq ' , +i [?]
d ' , - q --- q ' [?]
d implies hq, -i --- hq ' , -i [?]
d ' , [?
],-1  6=,-1  =,+1  - q --- q ' [?]
d implies hq, +i --- hq ' , +i [?]
d ' , hq, +i --- hq ' , -i [?]
d ' [?
],+1  and hq, -i --- hq ' , -i [?]
d ' , 6=,-1  6=,-1  - q --- q ' [?]
d implies hq, +i --- hq ' , +i [?]
d ' and 6=,+1  hq, -i --- hq ' , -i [?]
d ' , - the remaining cases with incrementations by one are treated in a similar fashion.
It is easy to show that A has an accepting run iff A' has an accepting run.
2 Finally, we can simplify the problem once more, by restricting the class of one-N-counter automata we have to consider.
Lemma 12 The existence of some accepting run in one-N-counter automata can be reduced in logarithmic space to the existence of some accepting run in one-N-counter automata with no test of the form x 6= 0.
The simple proof is based on the replacement of each transition of the form [?
],u [?
],+1 6=,u [?
],-1 q -- q ' by the sequence q --- q1 --- q2 -- q ' where q1 and q2 are new states.
5.2  Zero-test free paths  We recall that the composition of logarithmic space reductions is a logarithmic space reduction and the composition of a logarithmic space reduction with a nondeterministic logarithmic space test can be done in nondeterministic logarithmic space.
For these reasons, we are restricting ourselves in the following to one-N-counter automata with the tests x = 0 and [?
], that we can obtain using the reductions we have just described.
We say that an infinite path w : N - (Q x N) for A is zero-test free iff [?
],ui  for every i [?]
N (with w(i) = hqi , ci i), there is a transition qi --- qi+1 and ci+1 = ci + ui .
Finite zero-test free paths are defined similarly.
In other words, the absence of zero-tests implies that the only "test" is [?].
We define below several properties on zero-test free paths that will be useful in the following.
29  Lemma 13 Let w = hq1 , c1 i, .
.
.
, hqn , cn i be a finite path such that hq2 , c2 i, .
.
.
, hqn , cn i is zero-test free.
There exists a finite path w' = hq1' , c'1 i, .
.
.
, hqn' ' , c'n' i such that q1' = q1 , qn' ' = qn , c'1 = c1 and n' <= |Q|2 + 2|Q| + 1.
Proof.
First, remark that if there exist two indices i, j > 1 such that qi = qj and ci >= cj then the subpath hqi , ci i, .
.
.
, hqj , cj i can be deleted from w, still providing a path since hq2 , c2 i, .
.
.
, hqn , cn i is zero-test free.
The values of the counter have to be updated adequately but since the new values are greater, every transition can be fired.
Note that this remark is not true if the path contains zero-tests.
So we can assume without any loss of generality that if there exist 1 < i < j <= n such that qi = qj , then ci < cj .
If there are no 1 < i < j <= n such that qi = qj , then n <= |Q| and so we can take w' = w. Otherwise, there exists a unique pair of indices hi0 , j0 i such that * i0 < j0 , * qi0 = qj0 , * q1 , .
.
.
, qi0 , .
.
.
, qj0 -1 is a sequence of distinct control states.
These indices correspond to the first control state that is repeated in the path.
By hypothesis, we must have N = cj0 - ci0 > 0.
Moreover, it is easy to check that i0 <= |Q| and j0 - i0 <= |Q| because the control states before the position j0 are distinct.
Since hqj0 , cj0 i, .
.
.
, hqn , cn i is a zero-test free path of A, there is a path ' ' = qn in the directed graph q1' .
.
.
qm of length at most |Q| such that q1' = qj0 , qm G = hQ, {hr, si : hr, [?
], u, si [?]
d}i of reachable control states without zero-test transitions.
Thus, we can use the following observation: If there is a path in G from a state q to a state q ' whose length is c then one can reach the control state q ' from any configuration hq, c' i such that c' >= c in A.
Indeed, one can fire all the transition corresponding to this path in A (the worst case is c decrements by one) since it is zero-test free.
So we build the finite path w' as the path composed of the following successive subpaths: * hq1 , c1 i, .
.
.
, hqi0 -1 , ci0 -1 i, hqi0 , ci0 i, .
.
.
, hqj0 -1 , cj0 -1 i, * hqi0 , ci0 + N i, .
.
.
, hqj0 -1 , cj0 -1 + N i, * hqi0 , ci0 + 2N i, .
.
.
, hqj0 -1 , cj0 -1 + 2N i, * ... * hqi0 , ci0 + (|Q| - 1)N i, .
.
.
, hqj0 -1 , cj0 -1 + (|Q| - 1)N i, ' , ym i.
* hqi0 , ci0 + |Q|N i, hq2' , y2 i, .
.
.
, hqm  30  This path is well-defined since qi0 = qj0 , cj0 = ci0 + N and the value of the counter is great enough to fire the last part of the path (the part corresponding to the path in G).
The restriction of w' to control states is presented below: length <=|Q|  length <=|Q| length <=|Q| z }| { z }| { z }| { ' .
q1 .
.
.
qi0 -1 (qi0 qi0 +1 .
.
.
qj0 -1 qj0 )|Q| q2' .
.
.
qm  Obviously, the length of this path is bounded by |Q|2 + 2|Q| + 1  2  It is also possible to easily adapt the above proof by requiring in the statement of Lemma 13 that c'm is greater than some constant K. In the proof, it is sufficient to repeat the sequence of transitions between qi0 and qj0 , |Q| + K times.
We now treat the case of infinite zero-test free path where a final state occurs infinitely often.
Our goal is to extract a cycle whose initial state is this final state.
Indeed, such a cycle allows to build a run satisfying the Buchi acceptance condition.
Lemma 14 Let w : N - (Q x N) be an infinite zero-test free path where there is a final state qf [?]
F such that {i [?]
N : w(i) is of the form hqf , ji} is infinite.
There exist i [?]
N and a finite path w' = hq1 , c'1 i, .
.
.
, hqn , c'n i such that n > 1, hq1 , c'1 i = w(i) with q1 = qf , qn = qf , c'n >= c'1 and n <= 2|Q|2 + 3|Q|.
Proof.
Let w(i) = hqi , ci i for every i [?]
N. Since < is a well-quasi ordering over the elements of N, there exist i0 and j0 such that: * i0 < j0 , * qi0 = qj0 = qf and * ci0 <= cj0 .
The finite path w'' = w(i0 ), .
.
.
, w(j0 ) satisfies all the properties of w' except that j0 - i0 can be greater than the desired bound.
At this point, we proceed similarly to the proof of Lemma 13.
Without any loss of generality, we can assume that if there exist i0 < i < j <= j0 such that qi = qj then ci < cj (otherwise, the subpath can be deleted).
If there are no i0 < i < j <= j0 such that qi = qj then the length of the path is smaller than |Q| and we can take w' = w'' .
Otherwise, there is a unique pair hi1 , j1 i such that * i0 <= i1 < j1 <= j0 , * qi1 = qj1 , * qi0 , .
.
.
, qi1 , .
.
.
, qj1 -1 is a sequence of distinct control states.
By hypothesis, we have N = cj1 - ci1 > 0 and one can check that i1 <= |Q| and j1 -i1 <= |Q|.
Since hqj1 , cj1 i, .
.
.
, hqj0 , cj0 i is a zero-test free path, there is a path 31  ' q1' .
.
.
qm of length at most |Q| in the graph G = hQ, {hr, si : hr, [?
], u, si [?]
d}i ' = qn .
The same observation about the graph G as in such that q1' = qj0 , qm Lemma 13 allows us to build the path w' composed of the following successive subpaths:  * hqi0 , ci0 i, .
.
.
, hqi1 -1 , ci1 -1 i, hqi1 , ci1 i, .
.
.
, hqj1 -1 , cj1 -1 i, * hqi1 , ci1 + N i, .
.
.
, hqj1 -1 , cj1 -1 + N i, * hqi1 , ci1 + 2N i, .
.
.
, hqj1 -1 , cj1 -1 + 2N i, * ... * hqi1 , ci1 + 2|Q|N i, .
.
.
, hqj1 , cj1 -1 + 2|Q|N i, ' , c'm i.
* hqi1 , ci1 + (2|Q| + 1)N i, hq2' , c'2 i, .
.
.
, hqm  This path is well-defined since qi1 = qj1 , cj1 = ci1 + N and the value of the counter is large enough to fire the last part corresponding to the path in G. The restriction of w' to control states is presented below: length <=|Q|  length <=|Q| length <=|Q| z }| { z }| { z }| { ' .
q1 .
.
.
qi0 -1 (qi0 qi0 +1 .
.
.
qj0 -1 qj0 )2|Q|+1 q2' .
.
.
qm  The length of this path is clearly bounded by 2|Q|2 + 3|Q|.
Moreover, c'm > ci0 since the first and last part of the path decrement the counter at most by 2|Q| whereas the repetition of the center loop increments it by 2|Q|N .
2  5.3  Paths with zero-tests  It remains to consider paths containing zero-tests.
We first state a result that is a consequence of [LLT04, Lemma 42].
Lemma 15 [LLT04] Let w = hq1 , c1 i, .
.
.
, hqn , cn i be a finite path of A such that hq2 , c2 i, .
.
.
, hqn , cn i is zero-test free and cn = c1 = 0.
There exists a finite path w' = hq1' , c'1 i, .
.
.
, hqn' ' , c'n' i such that q1' = q1 , qn' ' = qn , c'n' = c'1 = 0 and for every i [?]
{1, .
.
.
, n' }, c'i <= |Q|3 + |Q|2 .
Proof.
The statement of the lemma is a variant of [LLT04, Lemma 42] and the proof below is a slight adaptation of its proof.
First, we show the following property.
([?])
Let w = hq1 , c1 i, .
.
.
, hqn , cn i be a path such that cn = c1 + |Q|.
Then, there exists a subpath w' of w such that w' = hq, ci - -* hq, c + di for some 0 < d <= |Q| and q [?]
Q.
Indeed, there is a sequence 1 = i1 < i2 < i3 < .
.
.
< i|Q|+1 <= n such that cij+1 = cij + 1 for 1 <= j <= |Q|.
Consequently, there are l < l' such that qil = qil' and hqil , cil i - -* hqil , cil + di with d = cil' - cil and 0 < d = l' - l <= |Q|.
In a similar way, one can show the property below.
32  ([?][?])
Let w = hq1 , c1 i, .
.
.
, hqn , cn i be a path such that cn + |Q| = c1 .
Then, there exists a subpath w' of w such that w' = hq, c + di - -* hq, ci for some 0 < d <= |Q| and q [?]
Q.
Let w = hq1 , c1 i, .
.
.
, hqn , cn i be a path of A such that hq2 , c2 i, .
.
.
, hqn , cn i is zero-test free and cn = c1 = 0.
Let g be the value |Q| (g will be used also in the proof of LemmaP17).
The overweight of the path w, denoted by ov(w), is n defined as the sum i=1 max(ci - (|Q| x g 2 + |Q|2 ), 0).
The proof consists in transforming w into a path w' with identical first and last configurations and ov(w' ) < ov(w), whenever there is 1 < j < n such that cj > |Q| x g 2 + |Q|2 .
Given a finite path w = hq1 , c1 i, .
.
.
, hqn , cn i with ov(w) > 0, let hL, L' i be the unique pair of indices such that L is the smallest index such that cL = |Q| x g 2 + |Q|2 and cL+1 = |Q| x g 2 + |Q|2 + 1, and L' is the smallest index such that cL' -1 = |Q| x g 2 + |Q|2 + 1 and cL' = |Q| x g 2 + |Q|2 .
The proof is by induction on ov(w).
The base case with ov(w) = 0 is obvious.
Now, suppose that ov(w) > 0.
There exist b < L <= L' < b ' such that for b <= i <= b ' , ci >= |Q|2 and cb = cb ' = |Q|2 .
Figure 4 illustrates the behaviour of the counter.
Consequently, there exist b = b1 < b2 < .
.
.
< bg 2 +1 = L and counter  |Q|g 2 + |Q|2  |Q|2  0  b  b' L L' Figure 4: Counter values when ov(w) > 0  i  L' = b1' < b2' < .
.
.
< bg' 2 +1 = b ' such that for 1 <= j <= g 2 , cbj+1 = cbj + |Q| ' and cbj' = cbj+1 + |Q|.
By using ([?])
and ([?][?
]), we get that for 1 <= j <= g 2 , * there exists an ascending subpath hq, ci - -* hq, c + dj i of the path * - hqbj+1 , cbj+1 i for some 0 < dj <= |Q|, hqbj , cbj i - * there exists a descending subpath hq, c + d'j i - -* hq, ci of the path * ' ' ' hqbj' , cbj' i - - hqbj+1 , cbj+1 i for some 0 < dj <= |Q|, 33  There exists d [?]
{d1 , .
.
.
, dg 2 } such that d is equal to at least g values dj and there exists d' [?]
{d'1 , .
.
.
, d'g 2 } such that d' is equal to at least g values d'j .
(Remove) The path w' is obtained from w by removing d' ascending subpaths with increasing effect d and by removing d descending subpaths with decreasing effect d' .
It is easy to see that ov(w' ) < ov(w).
Observe that removing such subpaths causes no problem since 0 < d x d' <= |Q|2 and cb = c'b = |Q|2 .
2 In Lemma 16 below, the initial path is not necessarily zero-test free.
This is a direct consequence of the result stated above.
Lemma 16 Let w = hq1 , c1 i, .
.
.
, hqn , cn i be a finite path of A such that cn = c1 = 0.
There exists a finite path w' = hq1' , c'1 i, .
.
.
, hqn' ' , c'n' i satisfying q1' = q1 , qn' ' = qn , c'n' = c'1 = 0 and n' <= |Q|5 + |Q|4 .
Proof.
Let w = hq1 , c1 i, .
.
.
, hqn , cn i be a finite path of A such that cn = c1 = 0.
Let 1 = i1 < i2 < .
.
.
< im = n be such that ci1 = ci2 = * * * = cim = 0 and no other configuration has the counter equal to zero.
Note that subpaths of the form hq, 0i * * * hq, 0i can be withdrawn from w. Hence, without loss of generality, we can assume that m <= |Q|.
For every 1 <= j < m, the subpath hqij , cij i * * * hqij+1 , cij+1 i satisfies the conditions of Lemma 15.
So for every 1 <= j < m, there exists a path wj such that wj = hqij , 0i * * * hqij+1 , 0i with all the values of the counter smaller or equal to |Q|3 +|Q|2 .
Since subpaths of the form hq, ci, .
.
.
, hq, ci can also be withdrawn from wj (see remark in Lemma 13), we can assume that the length of wj is smaller than |Q| x (|Q|3 + |Q|2 ).
By concatenating the paths w1 , .
.
.
, wm-1 we can easily obtained a path w' = hq1' , c'1 i, .
.
.
, hqn' ' , c'n' i satisfying q1' = q1 , qn' ' = qn , c'n' = c'1 = 0 and n' <= (m - 1) x |Q| x (|Q|3 + |Q|2 ) <= |Q|5 + |Q|4 .
2 We finally consider accepting runs such that zero-tests are repeated infinitely often.
As stated in Lemma 14, we want to extract a cycle with a final state whose length is bounded by some polynomial.
Lemma 17 Let qf [?]
F and w = hq1 , c1 i, .
.
.
, hqn , cn i be a finite path such that hq2 , c2 i, .
.
.
, hqn , cn i is zero-test free, cn = c1 = 0 and qf [?]
{q1 , .
.
.
, qn }.
There is a finite path w' = hq1' , c'1 i, .
.
.
, hqn' ' , c'n' i such that q1' = q1 , qn' ' = qn , c'n' = c'1 = 0, qf [?]
{q1' , .
.
.
, qn' } and for every i [?]
{1, .
.
.
, n' }, c'i <= |Q|3 + 3|Q|2 + |Q|.
Proof.
The proof is similar to the proof of Lemma 15 except that when transforming a path, we require that qf remains in the path w' .
In order to get the present proof, from the proof of Lemma 15, it is sufficient to take g = |Q| + 1 and then to observe that in the part (Remove), there are g = |Q| + 1 subpaths for d and d' respectively, we can guarantee there is a way to remove subpaths while preserving the presence of qf .
2  34  Lemma 18 Let qf [?]
F and w = hq1 , c1 i, .
.
.
, hqn , cn i be a finite path such that cn = c1 = 0 and qf [?]
{q1 , .
.
.
, qn }.
There is a finite path w' of the form hq1' , c'1 i, .
.
.
, hqn' ' , c'n' i satisfying q1' = q1 , qn' ' = qn , c'n' = c'1 = 0, qf [?]
{q1' , .
.
.
, qn' ' } and n' <= 2|Q|5 + 3|Q|4 + 3|Q|3 + |Q|2 .
Proof.
Let qf [?]
F and w = hq1 , c1 i, .
.
.
, hqn , cn i be a finite path such that cn = c1 = 0 and qf [?]
{q1 , .
.
.
, qn }.
Let 1 = i1 < i2 < .
.
.
< im = n be such that ci1 = * * * = cim = 0 and no other configuration has the counter equal to zero.
There is k [?]
{1, .
.
.
, m - 1} such that a configuration of the form hqf , ci occurs in the subpath hqik , cik i, .
.
.
, hqik+1 , cik+1 i.
The paths hq1 , c1 i, .
.
.
, hqik-1 , cik-1 i and hqik+1 , cik+1 i, .
.
.
, hqim , cim i satisfy the hypothesis of Lemma 16.
So, there exist paths w1 = hq1 , 0i, .
.
.
, hqik-1 , 0i and w3 = hqik+1 , 0i, .
.
.
, hqim , 0i of length at most |Q|5 + |Q|4 .
Moreover, the path hqik , cik i, .
.
.
, hqik+1 , cik+1 i satisfies the hypotheses of Lemma 17 and therefore there is a path w2 = hqik , 0i, .
.
.
, hqik+1 , 0i of length at most |Q| x (|Q|3 + 3|Q|2 + |Q|) that contains a configuration of the form hqf , c' i.
By concatenating w1 , w2 and w3 , we obtain a path w' satisfying the desired properties.
2  5.4  Size bound for accepting runs  We now have all the elements to establish a bound on the size of a witness for the existence of an accepting run in one-N-counter automata without tests of the form x 6= 0.
Lemma 19 Let P1 (x) = x5 + x4 + x3 + 92 x2 + 5x + 1 and P2 (x) = 3x5 + 4x4 + 3x3 + x2 be two polynomials.
For every one-N-counter automaton A with no test of the form x 6= 0, A has an accepting run iff one of the propositions below holds true: ([?])
There exist a finite path hq1 , c1 i, .
.
.
, hqn , cn i with n <= P1 (|Q|) and i' < n such that qi' = qn [?]
F , ci' <= cn , q1 [?]
I, c1 = 0 and hqi' , ci' i, .
.
.
, hqn , cn i is a finite zero-test free path.
([?][?])
There is a finite path hq1 , c1 i, .
.
.
, hqn , cn i with n <= P2 (|Q|) such that there exists i' < n with qi' = qn , ci' = cn = 0, {qi' , .
.
.
, qn } [?]
F 6= [?
], q1 [?]
I, c1 = 0 and hqi' , ci' i, .
.
.
, hqn , cn i is a finite path that is not zero-test free.
Proof.
If either ([?])
or ([?][?])
holds true, then an accepting run can be easily defined by repeating infinitely the finite path hqi' , xi' i, .
.
.
, hqn , xn i. Conversely, let us suppose that there exits an accepting run w : N - (Q x N) of A performing finitely many zero-tests.
We pose w(i) = hqi , ci i for every i [?]
N. By hypothesis, there exist 0 < i0 <= i1 < i2 such that * ci0 -1 = 0 and no zero-tests are performed after the position i0 (we omit the particular case when w is zero-test free), * qi1 = qi2 [?]
F and ci1 <= ci2 .
35  By Lemma 16, there is a path w1 = hq0 , 0i * * * hqi0 -1 , 0i whose length is bounded by |Q|5 + |Q|4 .
Moreover, Lemma 14 implies that there exists a path w3 = hqi1 , ci, .
.
.
, hqi2 , c' i such that c <= c' whose length is bounded by 2|Q|2 + 3|Q|.
Since one step in the path can decrement the counter by at most one unit, the ith configuration hq '' , c'' i in w3 satisfies c'' >= c - i.
Hence, the sequence w3' = hqi1 , |Q|2 + p 23 |Q|qi, .
.
.
, hqi2 , c' + (|Q|2 + p 23 |Q|q - c)i obtained from w3 by adding (|Q|2 + p 23 |Q|q - c) is also a valid finite path (the value of the counter is never negative).
It remains to concatenate these two paths.
By using arguments similar to the proof of Lemma 13 (see the paragraph after its proof), one can show that there exists a path w2 = hqi0 -1 , 0i .
.
.
hqi1 , xi such that x >= |Q|2 + p 23 |Q|q whose length is bounded by 3 (2 + |Q|2 + p |Q|q) x |Q| + |Q|2 .
2 Since x >= |Q|2 + p 32 |Q|q, it will be possible to reproduce the sequence of transitions between qi1 and qi2 .
One just need to repeat the loop a sufficient amount of times.
By concatenating w1 , w2 and w3' we get a path satisfying ([?]).
Now we suppose that every accepting run of the automaton A contains infinitely many zero-tests.
We consider such an accepting run w : N - (Q x N) and we still note w(i) = hqi , ci i for every i [?]
N. There exists in w two indices 0 < i0 < i1 such that * qi0 = qi1 and ci0 = ci1 = 0, * a final state qf [?]
F occurs in the subpath w' = hqi0 +1 , ci0 +1 i, .
.
.
, hqi1 , ci1 i.
Such i0 , i1 exist because both final states and zero-tests are repeated infinitely often in w. By Lemma 16, there is a path w1 = hq0 , 0i, .
.
.
, hqi0 , 0i of length smaller than |Q|5 + |Q|4 .
Moreover, Lemma 18 implies that there is a path w2 = hq1' , c'1 i, .
.
.
, hqj' , c'j i whose length is bounded by 2|Q|5 +3|Q|4 +3|Q|3 +|Q|2 such that * q1' = qj' = qi0 , c'1 = c'j = 0, * there is j ' [?]
{1, .
.
.
, n} such that qj' ' [?]
F .
Observe that w2 is not zero-test free, otherwise the infinite path described below is accepting, which contradicts our hypothesis since it is zero-test free: hq0 , 0i, .
.
.
, hqi0 , 0i, (hq2' , c'2 i, .
.
.
, hqj' ' , c'j ' i, .
.
.
, hqj' , 0i)o .
By concatenating w1 and w2 we get a path w' satisfying ([?][?]).
2  So we can establish the main result of this section.
Theorem 6 Checking whether L(A) is non-empty for one-Z-counter automata A with alphabet is nlogspace-complete.
36  Proof.
Since the composition of logarithmic space reductions is a logarithmic space reduction, this problem can be reduced in logarithmic space to the existence of accepting runs for one-N-counter automata with no test of the form x 6= 0.
Lemma 19 states that the existence of accepting runs for such oneN-counter automata can be tested in non-deterministic logarithmic space, by distinguishing the accepting run performing finitely and infinitely many zerotests.
Indeed, verifying that a path of polynomial length verifies the conditions of Lemma 19 can be done in logarithmic space.
The composition of a logarithmic space reduction with a nondeterministic logarithmic space test can be done in nondeterministic logarithmic space.
Hence, the problem of checking whether L(A) is non-empty is in nlogspace.
The nlogspace-hardness can be obtained by reducing the graph accessibility problem.
2 Note that, if we extend one-Z-counter automata by allowing updates of the form Xx = x + u for some u [?]
Z (u encoded in binary), then the problem of the existence of accepting runs becomes np-hard.
This can be easily shown by a reduction from the np-complete problem SUBSET-SUM; a very similar proof is given in [RY86, Theorem 3.5] for the boundedness problem of vector addition systems with states restricted to one counter.
Moreover, the problem is in pspace since this problem can be reduced in polynomial space to our original problem.
However, we ignore the precise optimal complexity of this extended problem.
Recently, an np upper bound has been established for one-N-counter automata with succinct updates [HKOW09].
6  Conclusion  We have studied the decidability and complexity of LTL with Presburger constraints by restricting the number of variables, the X-length of the formulae and the set of constraints.
Figure 5 summarizes the complexity of satisfiability, model-checking over DL-automata and model-checking over k-Z-counter automata for most LTL-like specification languages considered herein.
As a technical lemma, we have proved that the nonemptiness problem for one-counter Buchi automata taking values in Z and allowing zero-tests and sign-tests is nlogspace-complete.
This result is interesting for its own sake.
These results design new decidable subproblems of undecidable problems from [CC00, DPK03] and establish new decidability boundaries for Presburger LTL.
Apart from the completion of our classification, the most positive results concern one-counter automata/nets, see applications in [CR04, WTT04, LLT05].
The pspace upper bound for model-checking one-Z-counter automata over CLTLo 1 (QFP), or even over its linear u-calculus extension, refines results from [FWW97, BEM97, Wal01, Ser06] that concern more general systems and languages.
37  CLTL13 (DL) CLTLo 2 (DL) CLTL21 (DL) CLTL12 (DL) CLTL11 (DL or DL+ ) CLTL11 (QFP) CLTLo 1 (QFP)  MC (DL)  SAT  MC (CA)  undec.
[Min67] undec.
[Min67] undec.
Cor.
1 undec.
[Min67] pspace-c. Theo.
3 undec.
Lem.
6 undec.
Lem.
6  undec.
[CC00] undec.
[DD07] undec.
Theo.
1 undec.
Theo.
1 pspace-c. Theo.
3 undec.
Lem.
6 undec.
Lem.
6  undec.
[Min67] undec.
[Min67] pspace-c. Theo.
4 + [DS02] undec.
[Min67] pspace-c. Theo.
4 + [DS02] pspace-c. Theo.
4 + [DS02] pspace-c. Theo.
4 + [DS02]  Figure 5: Summary Acknowledgments.
We would like to thank the anonymous referees for numerous helpful remarks and suggestions allowing us to significantly improve this article.
References [AD94]  R. Alur and D. Dill.
A theory of timed automata.
Theoretical Computer Science, 126:183-235, 1994.
[AH94]  R. Alur and Th.
Henzinger.
A really temporal logic.
Journal of the Association for Computing Machinery, 41(1):181-204, 1994.
[BB90]  J. Berstel and L. Boasson.
Context-free languages.
In Handbook of Theoretical Computer Science, Volume B, Formal models and semantics, pages 59-102.
Elsevier, 1990.
[BBH+ 06] A. Bouajjani, M. Bozga, P. Habermehl, R. Iosif, P. Moro, and T. Vojnar.
Programs with lists are counter automata.
In CAV'06, volume 4144 of Lecture Notes in Computer Science, pages 517-531.
Springer, 2006.
[BC02]  Ph.
Balbiani and J.F.
Condotta.
Computational complexity of propositional linear temporal logics based on qualitative spatial or temporal reasoning.
In FroCoS'02, volume 2309 of Lecture Notes in Artificial Intelligence, pages 162-173.
Springer, 2002.
[BDG88]  J. Balcazar, J. Diaz, and J. Gabarro.
Structural Complexity I. Springer, 2nd edition, 1988.
38  [BEH95]  A. Bouajjani, R. Echahed, and P. Habermehl.
On the verification problem of nonregular properties for nonregular processes.
In LICS'95, pages 123-133.
IEEE, 1995.
[BEM97]  A. Bouajjani, J. Esparza, and O. Maler.
Reachability analysis of pushdown automata: Application to model checking.
In CONCUR'97, volume 1243 of Lecture Notes in Computer Science, pages 135-150.
Springer, 1997.
[BFLS06]  S. Bardin, A. Finkel, E. Lozes, and A. Sangnier.
From pointer systems to counter systems using shape analysis.
In AVIS'06, 2006.
[BH96]  A. Bouajjani and P. Habermehl.
Constrained properties, semilinear sets, and Petri nets.
In CONCUR'96, volume 1119 of Lecture Notes in Computer Science, pages 481-497.
Springer, 1996.
[BHM03]  A. Bouajjani, P. Habermehl, and R. Mayr.
Automatic verification of recursive procedures with one integer parameter.
Theoretical Computer Science, 295(1-3):85-106, 2003.
[Boi98]  B. Boigelot.
Symbolic methods for exploring infinite state spaces.
PhD thesis, Universite de Liege, 1998.
[CC00]  H. Comon and V. Cortier.
Flatness is not a weakness.
In CSL'00, volume 1862 of Lecture Notes in Computer Science, pages 262-276.
Springer, 2000.
[CGP00]  E. Clarke, O. Grumberg, and D. Peled.
Model Checking.
MIT Press, 2000.
[CJ98]  H. Comon and Y. Jurski.
Multiple counters automata, safety analysis and Presburger arithmetic.
In CAV'98, volume 1427 of Lecture Notes in Computer Science, pages 268-279.
Springer, 1998.
[CR04]  C. Chitic and D. Rosu.
On validation of XML streams using finite state machines.
In WebDB, pages 85-90, 2004.
[DD07]  S. Demri and D. D'Souza.
An automata-theoretic approach to constraint LTL.
Information and Computation, 205(3):380-415, 2007.
[DG07]  S. Demri and R. Gascon.
The effects of bounding syntactic resources on Presburger LTL (extended abstract).
In TIME'07, pages 94-104.
IEEE, 2007.
[DG08]  S. Demri and R. Gascon.
Verification of qualitative Z constraints.
Theoretical Computer Science, 409(1):24-40, 2008.
[DPK03]  Z. Dang, P. San Pietro, and R. Kemmerer.
Presburger liveness verification of discrete timed automata.
Theoretical Computer Science, 299:413-438, 2003.
39  [DS02]  S. Demri and Ph.
Schnoebelen.
The complexity of propositional linear temporal logics in simple cases.
Information and Computation, 174(1):84-103, 2002.
[EKS03]  J. Esparza, A. Kucera, and S. Schwoon.
Model checking LTL with regular valuations for pushdown systems.
Information and Computation, 186(2):355-376, 2003.
[FL02]  A. Finkel and J. Leroux.
How to compose Presburger accelerations: Applications to broadcast protocols.
In FST&TCS'02, volume 2256 of Lecture Notes in Computer Science, pages 145-156.
Springer, 2002.
[FWW97]  A. Finkel, B. Willems, and P. Wolper.
A direct symbolic approach to model checking pushdown systems (extended abstract).
In INFINITY'97, volume 9 of Electronic Notes in Theoretical Computer Science.
Elsevier, 1997.
[GK03]  P. Gastin and D. Kuske.
Satisfiability and model checking for MSOdefinable temporal logics are in PSPACE.
In CONCUR'03, volume 2761 of Lecture Notes in Computer Science, pages 222-236.
Springer, 2003.
[GPSS80]  D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi.
On the temporal analysis of fairness.
In 7th Annual ACM Symposium on Principles of Programming Languages, pages 163-173.
ACM Press, 1980.
[Hal95]  J. Halpern.
The effect of bounding the number of primitive propositions and the depth of nesting on the complexity of modal logic.
Artificial Intelligence, 75(2):361-372, 1995.
[HKOW09] C. Haase, S. Kreutzer, J. Ouaknine, and J. Worrell.
Reachability in succinct and parametric one-counter automata.
In CONCUR'09, Lecture Notes in Computer Science.
Springer, 2009.
To appear.
[Iba78]  O. Ibarra.
Reversal-bounded multicounter machines and their decision problems.
Journal of the Association for Computing Machinery, 25(1):116-133, 1978.
[ISD+ 00]  O. Ibarra, J. Su, Z. Dang, T. Bultan, and A. Kemmerer.
Counter machines: Decidable properties and applications to verification problems.
In MFCS'00, volume 1893 of Lecture Notes in Computer Science, pages 426-435.
Springer, 2000.
[JKMS04] P. Jancar, A. Kucera, F. Moller, and Z. Sawa.
DP lower bounds for equivalence-checking and model-checking of one-counter automata.
Information and Computation, 188(1):1-19, 2004.
40  [Kuc00]  A. Kucera.
Efficient verification algorithms for one-counter processes.
In ICALP'00, volume 1853 of Lecture Notes in Computer Science, pages 317-328.
Springer, 2000.
[KVW00]  O. Kupferman, M. Y. Vardi, and P. Wolper.
An automata-theoretic approach to branching-time model checking.
Journal of the Association for Computing Machinery, 47(2):312-360, 2000.
[LLT04]  P. Lafourcade, D. Lugiez, and R. Treinen.
Intruder deduction for AC-like equational theories with homomorphisms.
Research Report LSV-04-16, Laboratoire Specification et Verification, ENS Cachan, France, November 2004.
69 pages.
[LLT05]  P. Lafourcade, D. Lugiez, and R. Treinen.
Intruder deduction for AC-like equational theories with homomorphisms.
In RTA'05, volume 3467 of Lecture Notes in Computer Science, pages 308-322.
Springer, 2005.
[LMS04]  F. Laroussinie, N. Markey, and Ph.
Schnoebelen.
Model checking timed automata with one or two clocks.
In CONCUR'04, volume 3170 of Lecture Notes in Computer Science, pages 387-401.
Springer, 2004.
[Lut04]  C. Lutz.
NEXPTIME-complete description logics with concrete domains.
ACM Transactions on Computational Logic, 5(4):669- 705, 2004.
[LW05]  S. Lasota and I. Walukiewicz.
Alternating timed automata.
In FOSSACS'05, volume 3441 of Lecture Notes in Computer Science.
Springer, 2005.
[Min67]  M. Minsky.
Computation, Finite and Infinite Machines.
Prentice Hall, 1967.
[OW05]  J. Ouaknine and J. Worrell.
On the decidability of metric temporal logic.
In LICS'05, pages 188-197.
IEEE, 2005.
[Rog67]  H. Rogers, Jr.
Theory of Recursive Functions and Effective Computability.
McGraw-Hill Book Company, 1967.
[RY86]  L. Rosier and H.-C.
Yen.
A multiparameter analysis of the boundedness problem for vector addition systems.
Journal of Computer and System Sciences, 32:105-135, 1986.
[SC85]  A. Sistla and E. Clarke.
The complexity of propositional linear temporal logic.
Journal of the Association for Computing Machinery, 32(3):733-749, 1985.
[Ser06]  O. Serre.
Parity games played on transition graphs of one-counter processes.
In FOSSACS'06, volume 3921 of Lecture Notes in Computer Science, pages 337-351.
Springer, 2006.
41  [Var88]  M. Vardi.
A temporal fixpoint calculus.
In POPL'88, pages 250- 259.
ACM, 1988.
[VW94]  M. Vardi and P. Wolper.
Reasoning about infinite computations.
Information and Computation, 115:1-37, 1994.
[Wal01]  I. Walukiewicz.
Pushdown processes: games and model-checking.
Information and Computation, 164(2):234-263, 2001.
[Wol83]  P. Wolper.
Temporal logic can be more expressive.
Information and Computation, 56:72-99, 1983.
[WTT04]  M. Wakatsuki, K. Teraguchi, and E. Tomita.
Polynomial time identification of strict deterministic restricted one-counter automata in some class from positive data.
In ICGI'04, volume 3264 of Lecture Notes in Artificial Intelligence, pages 260-272.
Springer, 2004.
42