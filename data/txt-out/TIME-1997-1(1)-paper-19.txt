BCTL: A Branching Clock Temporal Logic Mehmet A. Orgun  Chuchang Liu  Department of Computing Macquarie University NSW 2109, Australia  E-mail: { cliu,mehmet) @krakatoa.mpce.mq.
edu.au  Abstract  temporal logics assume that there is a unique future at any specific time; while branching time temporal logics [2,3,8] assume that there may be several possible futures at any moment in time.
This paper presents a branching time temporal logic called BCTL.
In this logic, branching time is represented b y branching clocks, which can be specified as Chronolog programs.
In BCTL, formulas are allowed to be defined on different branching clocks.
Apart from the temporal operators first and next, BCTL contains a next-bounded symbol !
and four modalities: VU, VO, 3 0 and 3 0 .
This logic can be used to describe nondeterministic programs and concurrent systems.
1  In order to guarantee that the definition of a (local) clock in TLC really specifies an "actual" linear clock, we proposed three clock constraints [7] to ensure the linearity and monotonicity of given clocks.
For any moment in time on a given linear clock, there is a unique "next" moment as its immediate successor.
When the clock constraints are relaxed, branching time can be obtained.
Thus, given a formula, executing the clock definition involves finding a branch of time in which we can prove that the formula is true.
Introduction  Chronolog [lo] is an extension of logic programming based on a linear-time temporal logic [4].
In [7], intending to extend the Chronolog temporal logic, we proposed that in a temporal logic formulas could be allowed to be defined on different clocks.
That is, every predicate can be assigned a local clock, so that each formula can also be clocked.
Therefore, reasoning about the behavior of a system depends on the clock assignment given.
This logic, called Temporal Logic with Clocks (TLC), can be used for modelling those systems where granularity of time is needed.
In TLC, the global clock is defined as the increasing sequence of all natural numbers, i.e., < 0,1,2,. .
.
>, and local clocks are subsequences of the global clock.
In other words, it is not required that every granularity is a refinement of another one.
Furthermore, in Chronolog(MC) [7], a programming language based on TLC, the presentation of multiple granularity of time in a program is explicitly given by a clock definition and a clock assignment.
The user is free to choose the granularity for each predicate symbol through clock assignments and definitions.
Therefore, the multiple granularity of time is more flexible in time representation and describing timing properties of systems.
In this paper, we extend TLC by allowing logical formulas to be defined on branching clocks, on which there may be some moments in time that are followed by more than one next moment.
The extension is called branching clock temporal logic (BCTL).
Apart from the temporal operators f i r s t and next, BCTL contains a next-bounded symbol !
and four modalities: VO ("for all branches always"), VO ("for all branches sometime"), 3 0 ("for some branches a1ways")and 30 ("for some branches sometime"), so that it has a more powerful expressive ability.
In particular, it is suitable for describing those systems which contain a number of processes running concurrently, such as concurrent systems and nondeterministic programs.
The structure of the rest of the paper is as follows.
Section 2 discusses branching clocks, including the definition and specifications of clocks.
In section 3, the syntax and semantics of BCTL are given.
In section 4, the axioms and inference rules of BCTL are given.
Section 5 discusses the properties of BCTL.
Section 6 gives a simple example, which shows how to describe some properties of systems based on branching clocks.
Last section concludes the paper with a brief discussion on related work.
Note that both Chronolog logic and its extension TLC are linear time temporal logics.
Usually, linear time  0-8186-7937-9/97 $10.000 1997 IEEE  140  2  Branching Clocks  clocks.
For example, consider the specification of a clock clc shown in Figure 2.
We use the set w of natural numbers to model the collection of moments in time.
In TLC [7], linear clocks can be viewed as sequences over w. Given a linear clock clc =< t o , t l , t 2 , .
.
.
>, we call n the rank of t , on ck, written as rank(t,,ck) = n. Inversely, we write t , = ck("), which means that t, is the moment in time on ck whose rank is n.  f i r s t ck(0).
next ck(N) <- ck(M), X i n {1,2,3,4), N is M+X.
Figure 2: Specification of a branching clock  Informally, any given clock ck can be represented as a meta-Chronolog program shown in Figure 1.
It satisfies the first clock constraint, however, it does not satisfy the second and the third ones.
For example, the next moment of time 0 may be 1, 2, 3 or 4.
The specification actually defines a branching clock because each moment has four successors.
Formally, we have the definition:  Definition 1 A branching clock ck is a tree which consists of a (finite or infinite) number of time nodes, or simply nodes, and satisfies the following conditions:  Figure 1: A Meta-specification of a clock Here we have two temporal operators, f i r s t and next, which refer to the initial and the next moment in time respectively.
The next moment is defined relative to a given moment in time, whereas the initial moment in time always refers to time 0.
To guarantee that such a specification really represents an actual clock, the following clock constraints are proposed [7]: With respect to the specification of a clock, we may have  - ck has a special node called root which is not a successor of any node, and each node has 0 or more nodes as its immediate successors (called next nodes of the node).
- each node is assigned a natural number, called the current time of the node.
- The current time of any node is strictly less than the current time of any of its next nodes.
1.
For any successful query first next(m) ck(X), m SX.
When there is no confusion, we do not distinguish between a node and the time with which the node is associated.
That is, when we talk about the node t , t may stand for the node itself or for the current time of the node.
2.
For any pair of successful queries f i r s t n e x t ( m ) ck(X) and f i r s t n e x t ( n ) ck(Y), if m < n, then X < Y.
3.
For any pair of successful queries first next(m) ck(X) and f i r s t next(m) c k ( Y ) , X = Y.
Definition 2 Let ck be a branching clock.
W e call < t,tl,tz,... > a branch of ck starting from t , or simply a branch from t , if tl is the current time of a next node o f t and, in general, for any t k (IC = 1 , 2 , .
.
.
), t k + l is the current time of a next node of t k when t k + l exists.
The notation next ( n ) denotes n applications of next.
The intuitive meaning of these constraints are as follows.
The first one says that the rank of a moment on the clock is not greater than the moment.
The main motivation for this constraint is computational.
The second one says that the clock can only tick forwards, that is, ck defined by the representation is monotonic.
The third one says that the clock is single-valued at each moment.
These constraints ensure that a clock specified by an appropriate Chronolog program is linear.
Given a branching clock, let t be a time node.
We define:  PI : B[t]:  the set of all next nodes oft, the set of all branches from t.  According to the definition of branching clocks, linear clocks are actually a particular kind of branching clocks.
If a clock has only one branch from the root, then it is linear.
When the clock constraints are relaxed, we have branching time.
That is, there may be a number of next moments as the immediate successors for a given moment in time on a clock.
Such clocks are called branching  141  Let ckl and ckz be any two branching clocks.
We now present a constructive method to generate a new branching clock ck from ckl and ck2, which we call the product of ckl and ck2.
In the following, for convenience, we write [ t ] to ~ denote the set of all next nodes of t on a given clock T, i.e., a tree T, and B [ ~ ] the T set of all branches from t on T .
1.
If min{tlt E ckl and t E ckz} exists, let to = min{tlt E clcland t E cka} be the root of ck; otherwise, ck is an empty clock.
2.
If there is only one node identified by to on ckl , then the tree consisting of all branches in B[tO],k, and with the root to, denoted by Tl(to), is called an accompanying tree of to on ckl.
If there are more than one node identified by t o in ck1, merge all B [ t 0 l c k l into a tree with the root to as the accompanying tree Tl(t0).
In the same way, obtain an accompanying tree Tz(t0) of to on ckz.
3.
For any node t on ck which has been generated, based on its accompanying trees T l ( t ) and T2(t), first find [tick, and then find the accompanying trees T1 (tz) and Tz(t,) for each t, E [tick.
The general idea for doing 3 is: for all t, E [ t ] ~check ~, , then t, E [t],k; If there is only one if t, E [ t ] ~if~so, node identified by t, on TI, then the tree consisting of all branches in B [ ~ , ] T and ~ with the root t, is Tl(t,), otherwise merge all B[t,],kl into a tree with the root t, as Tl(t,); in the same way obtain T2(tz).If the fact that t, E [ t ] is~ not ~ true, we may check [t']~,for some t' E [ t ] ~ ,and , so on.
Figure 3: An Example of Generating Clocks clock clc is the product of ckl and ckg, denoted as ck = clcl n ckz.
Because of space limitations, we do not give details for the method and the proof of the uniqueness of the generated clocks.
An example for constructing a branching clock from given clocks is shown in figure 3.
Syntax and Semantics of BCTL  3 3.1  In the above procedure, for any t E ck, the root of its accompanying tree T,(t) (i = 1 , 2 ) may be obtained by one node or by merging more nodes identified by t on ck,.
Such a node identified by t on ck, is called a corresponding node to t on ck.
Note that there may be other nodes which are also identified by t but do not make any contribution for the root of the accompanying tree, therefore, they are not regarded as nodes corresponding to t on ck.
Formulas  In the vocabulary of BCTL, apart from variables, constants, function symbols, predicate symbols, we also have two propositional connectives: 1 and A, one quantifier: V, two temporal operators: first and next, one next-bounded symbol: !
and punctuation symbols: (, ).
In BCTL, the definition of terms is as usual.
We now give the definition of (well-formed) formulas.
Definition 3 A formula is defined inductively as follows:  In the procedure of generating the branching clock clc, t o is uniquely determined by ckl and ck2 and, by induction, it can be shown that, for any t on ck generated by the method, [t] is also uniquely determined by its accompanying trees Tl(t) and T2(t), i.e., by clcl and ckz, ck must be therefore uniquely determined by ckl and ckz.
That is, we have actually defined an operation over the set of branching clocks: for any two branching clocks, there exists a unique branching clock, which is constructed by the method.
The resulting branching  - If p is an n-ary predicate symbol and eo, e l , .
.
.
, e,-1 are terms, then p(e0, e l , .
.
.
,en-l) is a formula (called an atomic formula, or an atom).
- If A and B are formulas, then so are T A , A A B , first A , next A and !next A .
-  142  If A is a formula and x is a variable, then (Vx)A is a formula.
We may also use the notation n e x t ( n )to denote n applications of n e x t .
In particular, we may write n e x t (0) and n e x t (I), which denote 0 and 1 application of n e x t respectively.
Similarly, !
n e x t ( n ) denotes n applications of !n e x t .
In the following, we always use ck to represent a clock assignment and simply call it a clock, and we also use the notation c k ( A ) , c k ( B ) ,.. .
,ckl,ckZ,.
.. to represent local clocks.
The connectives V, +, H and the quantifier 3 can be derived from the prime connectives and quantifier as usual.
The derived basic modalities are recursively defined as follows:  3.3  In the following, we provide the semantics of the elements of BCTL in terms of clocks and interpretations.
We assume that the meanings of variables and function symbols are "rigid", that is, independent of time nodes on a given branching clock.
V D A gf( f i r s t A) A ( V D n e x t A ) V O A gf( f i r s t A ) v ( V O n e x t A ) 3UA ( f i r s t A) A ( 3 U !
n e x t A ) 3 0 A e f ( f i r s t A) v ( 3 0 !
n e x t A )  We now define interpretations of BCTL as follows:  sf  Definition 5 A temporal interpretation I on a given clock ck of BCTL comprises a non-empty set D, called the domain of the interpretation, over which the variables range, together with for each variable, an element of D; for each n-ary function symbol, an element of [D" + D]; and for each n-ary predicate symbol p , an element of [ck(p)+ P(D")].
Note that each of the modalities VU, VO, 3 0 and 30 is an operator as a whole.
Their formal meanings will be given in next section.
3.2  Semantics  Clock assignment  We write + ~ , ~ k ,At to denote the fact that a formula A is true at moment t (or, more strictly, the time node t , t E c k ( A ) ) on the clock ck under a given interpretation I .
We define + ~ , ~ k ,inductively t as follows:  We now give the definition of a clock assignment, which assigns local branching clocks for all predicate symbols.
Definition 4 A clock assignment ck of B C T L is a map from the set S P of predicate symbols to the set CIC of (branching) clocks, i.e.
ck E [SP + CIC].
The notation c k ( p ) denotes the clock which is associated with a predicate symbol p on a given clock assignment ck.
If f (eo,.
.
.
,en.-l) is a term, then I ( f (eo,.
.
., en-1)) = I ( f) ( I ( e o ) ,.
* * ,I(%-1)).
For any n-ary predicate symbol p and terms eo, .
.
., .
.
,en-d if e,-l and any t E cW,+ ~ , ~ k , t and only if < I ( e o ) , .
.
.
, I ( e n - l ) > E I ( p ) ( t ) .
eo,.
We now extend the notion of a clock assignment to formulas.
Let A and B be formulas, p ( z 1 ,z2,.
.
.
,zn) an atomic formula, and ck a clock assignment.
We define a clock assignment ck on formulas of BCTL as follows:  Ck(p(z1,2 2 , .
.
.,5,)) = c ~ ( P ) c k ( i A ) = ck(A) c k ( A A B ) = &(A) n c k ( B ) c k ( f i r s t A) = c k ( A ) ck(next A) = ck(A) ck( !
n e x t A) = c k ( A ) c k ( ( V z ) A )= &(A)  For any t E &(A), + ~ , ~ t T , tA if and only if it ,t not the case that + ~ , ~ k A.
For any t E c k ( A ) fl c k ( B ) , k ~ , ~ k( ,At A B ) if and only if + ~ , ~ kA , for ~ all t E c k ( A ) corresponding to the node t on c k ( A AB ) and + ~ , ~ k B , t for all t E c k ( B ) corresponding to the node t on c k ( A A B ) .
For any t E c k ( A ) , + ~ , ~ k( ,V~s ) A if and only if + I [ d / 2 ~ , c k , t A for all d E D where the interpretation I[d/z] is just like I except that the varible x is assigned the value d in I [ d / z ] .
For any t E c k ( A ) , + ~ , ~ k ,ft i r s t A if and only if + ~ , ~ k A , t , ~where to is the root of c k ( A ) .
The only operation which requires the generation of new clocks is conjunction.
We propose to use the product operation discussed above to generate the clock of A A B.
Thus, every formula of BCTL can be clocked.
In general, let A be a formula of BCTL, sP-4 the set of predicate symbols occurring in A, and ck a clock assignment, then we have that c k ( A ) = flpEspAck(p).
For any t E c k ( A ) , k ~ , ~ nke, xt t A if and only if k ~ , ~A kfor, all ~ s E [t].
k~,~k,t !nextA if and only if there exists at least one time node s E [t]such that For any t E & ( A ) , +I,ck,s  143  A.
( R l ) B --+ A, B t- A.
(Modus Ponens)  We now give the following notations: k = l , c k , A:  A:  t=f,ck  kck  A:  k A:  (R2) A  denotes that A is true on a branch cki of &(A) under a given interpretation I , which means that A is true at all nodes on cki under I. denotes that A is true on the clock ck under a given interpretation I , which means that A is true at all time nodes on ck(,4) under I .
denotes that A is true on the clock ck under any interpretation.
denotes that A is true on any clock under any interpretation.
f i r s t A, when  &(A) is non-empty.
(R3) A t-ck next A, when there is always a next node on &(A), i.e., when there are no finite branches.
As can be seen from axioms A6 and A7, n e x t and !next are dual.
The soundness of the system says that the proof system for BCTL is valid with respect to the given semantics scheme.
Its proof is straightforward.
We omit the details.
Note that we do not discuss the issue of completeness of BCTL in this paper.
The proof system for BCTL  4  t-ck  5  We use the notation t- A to denote that A is a theorem of BCTL and k c k A to denote that A is a theorem of BCTL which holds on ck.
Then the notion of deducibility can be characterized in terms of theoremhood: r tA means that the formula A is deducible from the set r of formulas using axioms and inference rules in BCTL.
The explanation for I7 k c k A can be made in a similar fashion.
Properties of BCTL  In this section, we discuss the properties of temporal logic BCTL.
We first prove the following lemma: Lemma 1 Let A be a formula and t any moment (strictly, any time node) on the branching clock ck(A).
Then we have that VUA is true at t if and only if t=cki A for all branches cki E B[to],where t o is the root of ck(A).
The proof system for BCTL is as follows.
0  Proof.
Let I be any interpretation.
Without loss of generality, we assume that cki =< t o , t l , t 2 , .
.
.
>.
We now want t o show that, if VoA is true at t , then k I , c k i , t , A, for any t , on cki.
Actually, by induction on n and the definition of VU, from the fact that VOA is true at t , it is easy to show that for any natural number n f i r s t next(n)A is true at t. Thus, according to the semantics definition, f i r s t next(n)A is true at t iff next(n)A is true at t o iff n e x t ( n - l ) A is true at r , for all r E [to].Therefore, in particular, n e x t ( n - l ) A is true at tl.
Continuing the procedure, from the fact that f i r s t next(n)A is true at t , we must obtain that A is true at t,.
Therefore, considering the arbitrariness oft,, we have that b I , c k ; A.
Furthermore, since I can be any given interpretation, we have that + c k i A.  Axioms:  (Al) All substitution rules of first-order calculus.
(A2) f i r s t f i r s t A +) f i r s t A.
(A3) next f i r s t A +) f i r s t A (A4) !next f i r s t A +) f i r s t A (A5) f i r s t ( 1 A ) +) i ( f i r s t A ) .
(A6) next (TA)  +)  1  ( !next  A).
(A7) !
n e x t ( i A ) c> 1 next A.
(A8) f i r s t (Vx)(A) +) ( V ' z ) ( f i r s t A).
(A9) next (Vz)(A) +) (V'z) ( n e x t A).
(A10) !next (Vz)(A)  + (V'z) (!next  A).
(first A ) A ( f i r s t B ) .
( A l l ) f i r s t ( A A B ) +) (A12) n e x t ( A A I?)
C ) ( n e x t  The proof of the sufficiency is trivial, therefore it is omitted.
I  A)A(next B ) .
(A13) !
n e x t ( A A B ) --+ ( !
n e x t A)A(!next B ) .
(A14) next A --+ !next A.
This lemma says that VUA is true at any moment (time node) in time on a given branching clock if and only if A is always true at all branches on the clock.
Therefore, we naturally read VU as "for all branches always".
In other words, from the view of an investigator, the fact "VOA is true" means that he can find: A is true everywhere, which does not depend on when he investigates it or where he stands.
Note that temporal operators !
n e x t and n e x t do not satisfy the commutativity rule.
In general, the formula !next n e x t A +) n e x t !next A is not true.
0  Inference rules:  144  Similarly, we have following lemmas regarding about the modalities VO, 3 0 and 3 0 .
Because of space limitations, we omit their proofs.
Lemma 2 Let A be a formula and t be any moment o n the branching clock & ( A ) .
Then we have that t=ck,t V O A if and only i f for all branch cki E B[to],there exists T E cki so that F c k i , r A, where t o as the root of ck(A).
BUS  I  Lemma 3 Let A be a formula and t be any moment on the branching clock &(A).
Then we have that 3 O A if and only if there exists a branch Cki E B[to]so that k c k ; A, where to is the root of & ( A ) .
I  RE323 M  I  d323  OUT  Figure 4: Software Repeater Environment  Lemma 4 Let A be a formula and t be any moment o n the branching clock c k ( A ) .
Then we have that k & , t 3 0 A if and only if there exists a branch Cki E B[to] so that k c k i , T A f o r some r E cki, where to is the root of  Landwehr [6].
The problem may be described as follows.
An RS232 software repeater runs on a CPU interfaced to RS232 communications chip which comprises a receiver and a transmitter.
The receiver processes an incoming bit stream and assembles the data into byte's for handling by the software repeater.
The transmitter accepts bytes from the repeater and generates a serial bit stream.
The software repeater is required to copy incoming data from the receiver to the transmitter, with buffering as required, so that over an appropriate range of receiver and transmitter baud rates, all incoming data are correctly transmitted.
The problem specification requires the system to halt at the first occurrence of an error.
Figure 4 is a block diagram of the repeater environment.
To simplify RS232 repeater problem, we omit system initialization and buffer management, as proposed in [5].
Also, we assume that no errors occur and the problem will be simplified to access to status information.
We rationalize that by assuming an idealized ACE, inspired by INS8250A.
It has three separately addressable locations from which the CPU can access data:  &(A).
Lemma 2 says that V O A is true at any moment (time node) in time on a given branching clock if and only if A is true at sometimes on all branches of the clock.
Therefore, we read VO as "for all branches sometime".
Lemma 3 says that 3oA is true at any moment (time node) in time on a given branching clock if and only if A is true always on at least a branch of the clock.
Therefore, we read 30 as "for some branch always".
Lemma 4 says that 3 0 A is true at any moment (time node) in time on a given branching clock if and only if A is true at sometime on at least a branch of the clock.
Therefore, we read 30 as "for some branch sometime".
The properties of computational systems can be expressed by using BCTL formulas.
For example, a safety property is expressible as an invariance assertion of the form V O A .
6  I  AnExample  BCTL can be used to specify properties of concurrent systems and nondeterministic programs.
BCTL allows formulas to be defined on different clocks.
Although different processes may have different local branching clocks, the predicates which describe a local behavior of the system may be defined on the same local branching clock.
Thus, a property describing the local behavior may be expressed as a formula on the local branching  e 0  0  clock, and it may be proved by involving the clock only.
inport is the location where received bytes appear; dataready initialized by 0 (by the system, not the software) is set to 1 by ACE whenever a received byte appears at inport and is cleared to 0 as a side effect of reading inport; outport is the location at which the CPU writes data in order to transmit it.
The following is a proposed solution code, which is written in an assembly language:  We now give a simple example.
Consider RS232 software repeater problem, which is first proposed by  145  Note that the predicate copy can be directly defined by using inseq and outseq as follows: ~opy(X,Y)%~ X  <<  Y and Y  << X  Then the program should satisfy the following properties: VO((VX)(VY) (inseq(X)Aoutseq(Y) 3 Y << XI).
VU( (VX)(VY)(inseq(X) Aoutseq(Y) A-copy (X ,Y) + lo((3Z)(next outseq(Z)Acopy(X,Z)>>>>.
The first property says that for all branches (at any moment in time) we always have the fact that if X is the inport sequence and Y outport sequence up to now then Y is a prefix of X.
The second one says: it is always true for all moments on all branches that, if at the current time the outsequence Y is not a copy of the inport sequence X, then there exists a branch, at some moment in time on this branch, so that the outsequence Z at that moment is a copy of X.
The proofs of the properties of a system depend on the formal specification of the system, which can be written as a set of BCTL formulas.
Thus, those formulas representing properties can be directly derived from the set by using axioms and inference rules of BCTL.
For some cases we may need to use induction.
Figure 5: A Branching Clock  11: 12:  13: 14: 15:  check beq Ida sta jump  dataready 11  7  inport outport  In this paper, we have presented the temporal logic BCTL, which is an extension of first order logic with branching clocks.
In this logic, branching time is represented by branching clocks, which can be specified as Chronolog programs.
Due to introduction of the nextbounded symbol !
and the modalities, the logic is more expressive.
11  We assume that the time for executing each instruction, i.e.
the time from fetching an instruction to completing the execution of the instruction is as follows: 11:  1 unit time  12:  1 unit time  13:  2 unit time 1 unit time  14:  2 unit time  15:  When a given clock is linear, we actually obtain a linear time temporal logic.
At this time, !next is not needed.
We also do not need the modalities 3 0 and 30, and VU and VO can be directly replaced by 0 and 0, respectively.
In the case when the clock is linear, we can describe the properties of programs or systems in the same way.
For example, a safety property of a program is expressible as an invariant assertion CIA, which expresses A is true at all moments in time on the local linear clock of the program.
Let us consider a Consumer-Producer program [9], which consists of two processes: p l - Producer and p2 - Consumer.
We assume that L and M are the subsets of the instructions of p1 and p2, respectively, and a critical condition for the program is that executing instructions in L by pl and executing instructions in M by p2 can  Therefore, we may construct a branching clock as shown in figure 5.
In the figure, the label (or labels) made in each node denote the instruction which is currently fetched to be executed at the current time of the node.
We define the following predicates: inseq(X): outseq(X): x << Y: copy(X,Y):  Conclusions  X is inport sequence so far.
X is outport sequence so far Sequence X is a prefix of sequence Y Y is a copy of X.
All the predicates, according to our problem, can be defined on the same branching clock shown in figure 5 .
146  Acknowledgements  not happen simultaneously, i.e., it is never the case that simultaneously executes the instructions in'M when p1 is executing an instruction in L or vice versa.
Assume that the predicate e x e c u t e ( P , X ) denotes that process P is currently executing the instruction X , then the mutual exclusion can be specified by the formula p2  The work presented in this article has been supported in part by an Australian Research Council (ARC) Grant.
C. Liu has been supported by an Australian Postgraduate Award (APA) and an MPCE Postgraduate Research Scholarship at Macquarie University.
References K. Abrahamson.
Modal logics for concurrent program.
Lecture Notes in Computer Science, 70, 1979.
E. M. Clarke and E. A. Emerson.
Design and synthesis  A liveness property can be specified as an assertion OA, which says that A is true at some moments in time on the clock.
For example, to describe the fact that a data item D is currently sent the buffer by process pl, then we assert that at some moment from next moment in time the data must be received by process p2.
We may use the formula  of synchronization skeletons using branching time temporal logic.
In Logic of Programs: Workshop, Yorktown Heights, N Y , May 1981, volume 131 of LNCS, pages 52-71.
Springer-Verlag, 1981.
E. A. Emerson and J. Y .
Halpern.
"somtimes" and "not never" revisited: on brabching versus linear time temporal logic.
Journal of the Association for Computing Machinery, 1(33):151-178, 1986.
R. Goldblatt.
Logics of Time and Computation.
CSLI  send(p1,D) 4 0 n e x t r e c e i v e ( p 2 , D ) .
- Center for the Study of Language and Information,  Stanford University, 1987.
Lecture Notes no:7.
As it is expected, linear time logic with or without multiple clocks can be treated as a special case of the branching clock temporal logic BCTL.
P. Kearney, 3.
Staples, A. Abbas, and C. Liu.
Functional verification of real-time code: A simplified RS232 softwere repeater problem.
High Integrity Systems, 1(4):359-373, 1995.
Now let us mention a number of related works.
The early ideas about branching time logics can be found from Abrahamson [l].
Later, Ben-Ari et a1 [8]proposed the unified branching time system (UB).
Then Clarke and Emerson defined computational tree logic (CTL) [2].
And, in 1983, Emerson and Halpern gave the definition of CTL* [3].
These languages are all suitable for describing concurrent systems.
In particular, CTL* is a very powerful temporal logic which can be used for specifying a variety of program properties due to its modal operators.
For example, in CTL', the formula F = (VUA) V (VUTA) can be true when A is true at all time nodes on a given branching clock or A is false at all nodes on the given branching clock.
Also, the formula G = ( V O A ) A ( V O ~ Ais)false when A is true at all nodes on the given branching clock or A is false at all nodes on the given branching clock.
All these formulas can also be expressed in BCTL.
However, these formulas are not in the linear temporal logic LTL [ll]and no LTL formulas are equivalent to them.
Obviously, all the above formulas can be expressed in BCTL.
We can show that all the properties expressible in CTL* are expressible in BCTL.
Therefore BCTL also has a powerful expressive ability.
Future work includes completing theoretical study of BCTL, and extending Chronolog(MC) with multiple branching clocks.
Carl Landwehr.
The RS-232 software repeater problem.
In CIPHER, the Newsletter of IEEE Technical Committee on Secrity and Privacy, Summer, pages 3435, 1989.
C. Liu and M. A. Orgun.
Dealing with multiple granularity of time in temporal logic programming.
Technical Report TR-95-04, Accepted to Journal of Symbolic Computation, Department of Computing, Macquarie University, Sydney, NSW 2109, Australia, October 1995.
Z.
Manna M. Ben-Ari and A. Pnueli.
The temporla logic of branching time.
In Proceedings of the 8th Annual ACM Symposium on Principles of Programming languages, pages 164-176, 1981.
Z.
Manna and A. Pnueli.
Verification of concurrent programs: The temporal framework.
In R. S. Boyer and J. S. Moore, editors, The Correctness Problem in Computer Science.
Academic Press, 1981.
M. A. Orgun and W. W. Wadge.
Theory and practice of temporal logic programming.
In L. Fariiias del Cerro and M. Penttonen, editors, Intensional Logics for Programming, pages 23-50.
Oxford University Press, 1992.
A. Pnueli.
A temporal logic of concurrent programs.
Theoretical Computer Science, 13:45-60, 1981.
147