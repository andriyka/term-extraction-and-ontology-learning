2013 20th International Symposium on Temporal Representation and Reasoning  Optimal Design of Consistent Simple Temporal Networks Romeo Rizzi and Roberto Posenato Computer Science Department University of Verona Verona, Italy {romeo.rizzi,roberto.posenato}@univr.it restricted requiring to check the consistency frequently.
In the case that an STN becomes (is) inconsistent, it is desirable to easily adjust constraints to make the network consistent again.
One method to solve the inconsistency is finding a minimum set of constraints that has to be removed in order to make the graph free of negative cycles.
It is known that this problem is NP-hard [2], and in fact it is APX-hard because the Feedback Arc Set (FAS) problem can be reduced to it.
Indeed, the feedback arc sets of a graph G = (V, E) are precisely the sets of constraints whose removal makes consistent the STN made of G with weight -1 associated to each one of its arcs.
FAS is APX-hard [3], and can be approximated to within O(log(n) log(log(n))) [4], [5].
In this paper, we denote by n and m the number of nodes and arcs of the graph of reference, respectively.
Therefore, in the literature, many alternatives to tackle the problem have been proposed.
To the best of our knowledge, the most interesting ones are the following.
Planken et al.
[6] presented a polynomial-time algorithm that maintains partial path consistency when new constraints are added or existing constraints are tightened.
In such a way it is possible to verify if the set of new/modified constraints can be accepted or not.
Even if the proposed system exhibits a practically good performance, it does not determine the minimal network and, therefore, the set of all possible values for each timepoint.
Indeed, the algorithm has to be applied iteratively in order to successfully add/restrict constraints to a consistent STN.
Dasdan [2] presented the problem to solve constraint violations in an STN as a more general problem, called Temporal and Spatial Difference Constraint Violations Problem.
After showing that the problem is NP-hard, Dasdan considered specific domain driven conditions on how to modify constraints and, then, gave a polynomial-time algorithm to assist a designer to plan a consistent network by an iterative debugging procedure.
The proposed algorithm determines which constraints are violated supporting the ordering of violations using their inherent criticality or user-defined priority.
This paper introduces a different approach that allows one to solve the constraint violations problem in only one step producing, in polynomial time, a globally optimal network.
Our viewpoint is that each violated constraint should be repaired  Abstract--Simple Temporal Networks (STNs) are used in many applications, as they provide a powerful and general tool for representing conjunctions of minimum and maximum distance constraints between pairs of temporal variables.
During construction of an STN, it is possible that the network presents some constraint violations that need to be resolved.
One way to solve such violations is to remove a minimal number of constraints, already shown to be an APX-hard problem.
Another way is relaxing some constraints in different ways till violations are solved and choosing the best configuration according to one or more criteria.
In this paper, assuming that it is possible to increase any constraint bound of an STN paying a constraint-specific cost, we exhibit a polynomial-time algorithm that repairs an STN eliminating all constraint violations at minimum global cost.
Index Terms--Simple Temporal Networks; STNs design; optimization problem; consistency; minimum cost flow; linear programming.
I. I NTRODUCTION In many areas of Artificial Intelligence (AI), including knowledge representation and planning & scheduling, the representation and management of quantitative temporal aspects is of crucial importance.
Examples of possible quantitative temporal aspects are: constraints on the earliest start time and latest end one of activities, constraints over the minimum and maximum temporal distance between activities, etc.
In many cases, these constraints can be represented as an instance of a Simple Temporal Network (STN) [1], a directed weighted graph where a node represents a time-point variable (timepoint), usually corresponding to the beginning/end of activities, and an arc represents a temporal distance constraint between a v pair of timepoints, e.g., x - y stands for y - x <= v, where v [?]
R. In an STN it is possible to represent constraints like u <= y - x <= v (minimal and maximal temporal distance v -u between x and y) as a pair of arcs, x - y and y - x.
An STN is said to be consistent if it is possible to assign a real value to each timepoint so that all temporal constraints are satisfied.
The consistency property can be verified by searching for negative cycles in the graph and it has been shown that the consistency check and the determination of the earliest/ latest value for each timepoint can be calculated in polynomial time [1].
During the development of an STN, new timepoints or constraints may be added or existing constraints may be 1530-1311/13 $26.00 (c) 2013 IEEE 1550-1311/13 DOI 10.1109/TIME.2013.12  19  (i.e., its bound can be augmented, not reduced) paying a linear cost that can be specified for each constraint.
Within such setting, we exhibit a O(nm) time algorithm that, given a not consistent network, returns a consistent one at minimum global reparation cost.
Since each constraint may have a specific cost function, it is possible to customize in a detailed way the fixing phase and obtain the consistent network avoiding the iterative fixing procedures proposed by other approaches.
Our framework also allows for more general convex cost functions to be dealt with, and we offer algorithms that are efficient both in theory and in practice.
II.
BACKGROUND AND N OTATION In this section, we introduce our basic terminology, some definitions and well-know results about circulations and conservative graphs; we also restate a characterization of the consistency property of STNs.
Our graphs are directed.
For every node v, dv+ denotes the set of arcs exiting v and dv- denotes those entering.
A graph is eulerian if |dv+ | = |dv- | at every node v. It is well known that eulerian graphs can be decomposed into directed circuits [10].
Given a function c : E 7- R, we write ce or c(e) P interchangeably, and when F is a set, c(F ) stands for e[?
]F ce .
Given a directed graph G = (V, E), together with an upper bound capacity ce [?]
R+ , and a value `e [?]
R specified for every arc e, a circulation in (G, c) is the specification of an amount of flow fe to be sent along every arc e, subject to the conservation of flow constraints:  A related line of research was fostered by Khatib et al.
[7].
In [7], the authors introduced a generalization of STNs: Simple Temporal Problems with Preferences (STPPs).
In an STPP each constraint is represented by an arc, an interval, and a preference function.
An assignment of reals to the timepoints is a feasible solution for an STPP if, for every arc, the difference between its two timepoint values falls within the arc interval.
The preference function specifies a quality measure for each point in the interval and, therefore, the goal is to find a solution optimizing the global preference value.
They provide polynomial-time algorithms for the case where the preference function of each constraint is convex.
Though the formalism they proposed is rich, their global preference value essentially amounts however to the maximum of the preference values on the single constraints.
This can be regarded as a bottleneck problem and can hence be solved by means of a binary search on the optimum solution value.
Indeed, it is a property of this framework that, once the optimal solution value has been guessed, then checking whether a solution of that value exists reduces to a classical STN consistency problem.
These results were improved in [7], where the solution to the bottleneck STPP was extended to semi-convex preference functions and with the observation that the sum of costs STTP (i.e., utilitarian global temporal value) can be formulated as a linear program when each preference function is a linear one.
f (dv+ ) = f (dv- ) for every node v. A circulation f is called admissible ifP 0 <= fe <= ce for every arc e. The value of a circulation f is e[?
]E `e fe .
The problem of finding a maximum value circulation can be solved by linear programming, since we optimize a linear function, and all constraints are linear.
As for more efficient solutions, combinatorial algorithms are known for this problem (for a comprehensive survey see [11]).
The main algorithmic approaches pursued in the literature and in applications are: Minimum Mean Cycle Canceling: it is the first special case of cycle canceling (a general primal method) proven to involve a polynomial number of iterations.
In [12], the authors proposed a simple polynomial-time algorithm which runs in O(nm(log n) min{log(nC), m log n}) time on a network of n vertices, m arcs, and arc costs of maximum absolute value C. Successive Shortest Path and Capacity Scaling: in [13] a dual method is presented which can be viewed as the generalizations of the Ford-Fulkerson algorithm.
Cost Scaling: in [14] a primal-dual approach is presented which can be viewed as the generalization of the push-relabel algorithm [15].
Network Simplex: a specialized version of the linear programming simplex method.
Morris et al.
[8] generalized the positive result on the utilitarian version of STPP to convex piece-wise linear functions.
Moreover, proposed a characterization of different notions of global temporal value and the identification of tractable subclasses of STPPs.
Finally, Peintner et al.
[9] proposed a greedy algorithm, and offered an experimental evaluation, for solving STPPs where the preference functions have not to be convex.
In practice, the circulation problem is the classical problem that we have to solve when, once a maximum flow has been found, we seek to find a minimum cost one by iteratively redirecting the flow along cycles of negative costs in an auxiliary network.
Indeed, even if the traditional approaches improve the flow considering one negative circuit at each iteration, it can be argued that these approaches are ultimately interested in finding a circulation of maximum value, that, in turn, can be regarded as a maximum-value eulerian subgraph in the auxiliary network, which decomposes into a packing of cycles.
A weighted graph (G, `) is called conservative when P `(C) := e[?
]C `e >= 0 for every directed circuit C of G.  The remainder of the paper is organized as follows.
in Sect.
II we introduce some definitions and well-know results in order to state a new property of STNs.
In Section III we introduce the problem to repair an inconsistent STN as a linear programming one, while in Section IV we present and discuss the combinatorial algorithm that solves the repair problem most effectively.
In Section V we suggest a suitable approach to get practical solutions when each one of the arc cost functions is convex.
Finally, Section VI concludes the paper.
20  The Bellman-Ford algorithm [16] can be used to produce in O(nm) time: * *  either a proof that (G, `) is not conservative in the form of a negative circuit C in G; or a proof that (G, `) is conservative in the form of a potential function p : V 7- R such that for every arc e = (u, v) of G, its reduced length `pe := `e - pv + pu is non-negative.
[?]
arc (u, v) of G.  h-2, 3 i  h-6, 1 i  B  h-4, 2 i  A h6, 1 i  D h5, 1 i  Fig.
1.
A graph with two negative cycles.
Each label has the form hl, ci, where l is the length and c is the cost of the associated edge.
programming problem: + + + + min `+ (A,B) + `(B,A) + 3 `(A,C) + 3, `(C,A) + 2 `(A,D)  (1)  + + + + + `+ (D,A) + `(B,C) + 2 `(C,B) + 2 `(C,D) + 2 `(D,C)  +  tB <= tA + 6 + `(A,B)    +  t   A <= tB - 6 + `(B,A)   +  tC <= tA + 2 + `(A,C)      tA <= tC - 2 + `+  (C,A)   +   tD <= tA - 4 + `(A,D) tA <= tD + 5 + `+ (D,A)    tC <= tB - 2 + `+  (B,C)     tB <= tC + 3 + `+  (C,B)     tD <= tC - 3 + `+  (C,D)    tC <= tD + 4 + `+ (D,C)   `+ >= 0.
Proof.
If t : V 7- R is a scheduling for (G, `), then each reduced length `t(u,v) := `(u,v) -tv +tu is non-negative by (1); thus (G, `t ) is conservative and, since `(C) = `t (C) for every circuit C of G, then (G, `) is conservative as well.
On the other side, if (G, `) is conservative, then, using the Bellman-Ford algorithm, it is possible to determine a potential function p : V 7- R such that for every arc e = (u, v) of G, pv <= pu + `e .
Such p satisfies (1) and, therefore, (G, `) is consistent.
(Ex1)  By well-known results about linear programming, and convex programming, this model will be amenable of polynomialtime solution algorithms even when the linear addenda ce `+ e in the objective function get replaced by general convex functions and even when the whole objective function is a generic (smooth) convex function in the variables `+ e , e [?]
E. However, in the next section, we will provide extremely efficient combinatorial algorithms in order to more conveniently solve the problem.
III.
P ROBLEM F ORMULATION In this section, we formalize the problem to solve the inconsistency of an STN as a linear programming problem.
Let us consider a graph G = (V, E) augmented by the following two functions: *  h-3, 2 i h2, 3 i  Theorem 1 ( [1], [16], [17]).
An STN (G, `) is consistent if and only if it is conservative.
*  h4, 2 i  h3, 2 i  An STN can be viewed as a weighted graph (G, `) whose nodes are timepoints that must be placed on the real line and whose arcs express mutual constraints on the allocations of their endpoints.
An STN is called consistent if there exists a scheduling t : V 7- R such that tv <= tu + `(u,v)  C  h-2, 1 i  length ` : E 7- R, and, cost c : E 7- R+ , where R+ .
ce represents the unitary cost for increasing `e .
Here, the weighted graph (G, `) may contain negative cycles.
We are interested at a minimum cost plan to transform an inconsistent STN (G, `) into a consistent one by suitably relaxing some of its constraints (increasing the lengths of some of the arcs) and paying a cost specified by the cost function c. Our minimum cost network design problem can be expressed by means of the following linear programming problem: P min (u,v)[?
]E c(u,v) `+ (u,v) ( (P1) tv <= tu + `(u,v) + `+ [?]
arc (u, v) of G, (u,v)  IV.
T HE C OMBINATORIAL A LGORITHM In this section, we propose an efficient combinatorial algorithm that repairs, at a minimum global cost, an inconsistent STN where constraint bounds are allowed to be augmented paying a cost.
By Theorem 1, the problem to repair an inconsistent STN can be regarded as the request for a minimum cost plan to transform (G, `) into a weighted graph with no negative cycles (conservative weighted graph) by suitably increasing the lengths of some arcs.
This view leads to an alternative mathematical formulation of the Problem P1: P min e[?
]E ce `+ e ( (P2) `+ (C) >= -`(C) [?]
directed cycle C of G  `+ >= 0, where `+ : E 7- R+ is the decision variables vector specifying the length increment adopted for each arc.
`+ >= 0.
Example 1.
Fig.
1 depicts a STN where cycles ACB, ACD, and ADCB are negative.
The associated minimum cost network design problem is given by the following linear  Example 2.
Considering the Problem (Ex1) presented in Example 1, the only meaningful constraints are those associated  21  (only a polynomial number of variables) linear programming formulation by making the link with the classical concept of circulation.
Indeed, as recalled in Section II, a circulation can be regarded as an eulerian subgraph, which then can be decomposed into a packing of cycles.
Therefore, Problem (P3) can be regarded as an instance of the more classical and compact max circulation problem.
The following two lemmas are meant to prove this formally.
to the negative cycles in the graph.
Therefore, Problem (Ex1) can be rewritten as the following linear programming problem: + + + + min `+ (A,B) + `(B,A) + 3 `(A,C) + 3, `(C,A) + 2 `(A,D) + + + + + `(D,A) + `(B,C) + 2 `(C,B) + 2 `(C,D) + 2 `+ (D,C)  + + + (cycle ACB)  `(A,C) + `(C,B) + `(B,A) >= 1  `+ + + (cycle CAD) (C,A) + `(A,D) + `(D,C) >= 2 + + + `(A,D) + `(D,C) + `+ + ` >= 3 (cycle ADCB)  (C,B) (B,A)   + ` >= 0.
(Ex2)  Lemma 2.
From any feasible solution l to Problem (P3), we P can determine P a circulation f of (G, c) with value e[?
]E -`e fe = C -`(C)lC .
P Proof.
For every arc e of G, let fe := C3e lC .
Note that fe >= 0 since l >= 0 and does not exceed the capacity ce by the feasibility of l. Also, this f obeys the conservation of flow constraints since it is a linear combination of characteristic vectors of directed circuits.
Finally, X X X -`e fe = -`e lC  Even though the above linear programming problem has an exponential number of constraints, the separation problem associated to the polytope of its feasible solutions essentially amounts to the detection of a negative cycle C in the weighted graph (G, ` + `+ ), whence can be solved in polynomial time by means of the Bellman-Ford algorithm.
It follows then by the milestone equivalence result [15] between separation and optimization that an optimal solution to Problem (P2) can be found in polynomial time by means of the ellipsoid algorithm.
Indeed, it was this observation that suggested us to propose and pursue our STN design framework, safe in the knowledge that we were proposing a model amenable of efficient algorithmic solutions.
Now, we want to show how it is possible to solve the problem in a more effective way by means of a combinatorial algorithm.
As a starting point, we consider the dual of Problem (P2): P max C -`(C)lC (P (P3) for every edge e [?]
E, C3e lC <= ce l >= 0,  e[?
]E  =  C3e  lC  X e[?
]C  -`e =  X  -`(C)lC .
C  Lemma 3.
From any circulation f of (G, c) we P can determine a feasible solution l to Problem (P3) with C -`(C)lC = P -` f .
e e e[?
]E Proof.
Let d be a natural number such that d * fe is integer for every e. Let G(d * f ) be the multigraph obtained form G by taking d * fe parallel copies of arc e, for every e. Since f obeys the conservation of flow constraints, then G(d * f ) is an eulerian digraph and can be decomposed into directed circuits.
Clearly, each one of these circuits maps down naturally to a unique circuit of G (when all copies of an edge are read just as that original edge of G).
For every directed circuit C of G, let nC the number of circuits in the decomposition of G(d * f ) that map down to C. Then we define lC := ndc .
Example 3.
Considering the Problem (Ex2) presented in Example 2, its dual is the following linear programming problem: (B, A) (A, C) (C, A) (A, D) (C, B) (D, C)  X C  where there is a variable lC for every directed circuit C of G. Problem (P3) essentially asks for packing negative cycles into (G, c) (clearly, if `(C) > 0, then lC = 0 in every optimal solution to Problem (P3)).
max lACB + 2 lCAD + 3 lADCB  lACB + lADCB <= 1 for the arc      lACB <= 3 for the arc      l <= 3 for the arc CAD  lCAD + lADCB <= 2 for the arc    lACB + lADCB <= 2 for the arc      lCAD + lADCB <= 2 for the arc    l >= 0.
e[?
]E  This simple reduction already delivers an efficient purely combinatorial algorithm to solve Problem (P3), whence its consequences deserve to be explicitly pinned down in the following fact.
Fact 4.
An optimal solution to Problem (P3) can be obtained in O(nm(log n) min{log(nC), m log n}) time.
Furthermore, when c is an integer valued function, then the optimal solution l obtained is also integer.
(Ex3)  On this small example, it can be easily seen that the optimal solution is given by lACB = 0, lCAD = 1, and lADCB = 1.
The value of the optimal solution is 5.
Proof.
The proof follows from Lemma 2 and 3.
The time bound refers to the algorithm in [12].
The integrality considerations follow from the well known total unimodularity properties of network flows.
Unfortunately, due to the exponential number of constraints of the primal Problem (P2), the dual Problem (P3) is bound to have an exponential number of variables.
However, we can faithfully express this problem by means of a more compact  Now we concentrate on how to solve Problem (P2), the problem of true pertinence to us and core of the framework we intend to propose in this paper, assuming the optimal solution l to Problem (P3) is given.
22  The following algorithm will do the job in O(nm) time even in case l is not integral.
P c | C3e lC = ce }, E 0 := {e [?]
E | PLet E := {e [?]
E 6= c 0 C3e lC = 0}, and E := E \ (E [?]
E ).
Starting from (G, `), we determine a new weighted graph (G0 , `), with G0 = (V, E 0 ), as follows.
First, we copy all e [?]
E in E 0 ; then, for every arc e = (u, v) [?]
E c [?
]E 6= , we introduce in E 0 a new arc eR = (v, u) and extend ` by setting `(eR ) = -`(e); next, we remove from E 0 all arcs in E c .
In practice, for every arc e [?]
E c we replace e with one reversed both in direction and in length while for every arc e [?]
E 6= we add a parallel arc eR with opposite direction and length, this time without removing e. The mate operator [*]R is defined as [e]R := eR for every e [?]
E \ E 0 and [eR ]R := e for every eR [?]
E 0 \ E 0 , and can be extended to every edge set F [?]
(E [?]
E 0 ) \ E 0 by setting [F ]R = {[f ]R : f [?]
F }.
Note that `(F [?]
[F ]R ) = 0 for every F .
With this notation, E 0 = E 0 [?]
E 6= [?]
[E 6= ]R [?]
[E c ]R .
2 C  -3 -2  -4 -3  3  2  2  -2  6 6  5 4  B 5  A 0  D -2  Fig.
2.
The auxiliary graph (G0 , `) based on the optimal solution lCAD = lADCB = 1 and the instance graph depicted in Fig.
1.
Bold labels associated to nodes represent values of the potential function p returned by Bellman-Ford algorithm with A as starting node.
2) then, decrease it back by e on each arc e [?]
C \ C [?]
(E 0 [?]
E 6= ) = C [?]
([E 6= ]R [?]
[E c ]R ); this step nullify the f on arcs nor present in G; 3) finally, decrease it by e on each arc e such that eR [?]
C [?]
[E 6= [?]
E c ]R , i.e., e [?]
[C]R [?]
(E 6= [?]
E c ) as required by the definition of f~.
The first step does clearly not spoil the property of f being a circulation since C is eularian.
But the very same argument works for the next two steps combined since (C [?]
([E 6= ]R [?]
[E c ]R )) [?]
([C]R [?]
(E 6= [?]
E c )) is also eulerian as [C [?]
([E 6= ]R [?]
[E c ]R )]R = [C]R [?]
(E 6= [?]
E c ) for the operator [*]R is idempotent and [A [?]
B]R = AR [?]
B R and [A [?]
B]R = AR [?]
B R .
Finally, by taking e := e := min{mine[?]C[?
](E 0 [?
]E 6= ) (ce - fe ), mineR [?
][C]R [?
](E 6= [?
]E c ) fe }, then the circulation f~ is admissible.
Note that e > 0.
Lemma 5.
If l is an optimal solution to Problem (P3), then (G0 , `) is conservative.
Proof.
Assume that (G0 , `) is not conservative and let C be a negative circuit in (G0 , `).
P Also, represent Pl as a circulation f of (G, c) with value P -` f = e e e[?
]E C -`(C)lC .
This is done by setting fe := C3e lC for every arc e of G, as more exaustively explained in the proof of Lemma 2.
Since l is an optimal solution to Problem (P3), it follows that f is a maximum value circulation for (G, c) by Lemma 3.
We will contradict this fact by showing how the negative circuit C can be used to produce a better circulation.
Since C is a directed circuit of G0 then C [?]
E 0 = E 0 [?]
6= E [?]
[E 6= ]R [?]
[E c ]R .
We suggest to modify f as follows:  0 6=  fe + e if e [?]
C [?]
(E [?]
E ), f~e = fe - e if eR [?]
C [?]
[E 6= [?]
E c ]R ,   fe otherwise.
Example 4.
Considering the dual problem presented in Example 3, we now build up the auxiliary weighted graph (G0 , `) based on the optimal solution lCAD = lADCB = 1 with value l = 5.
Here, E c = {(B, A), (A, D), (D, C)}, E 6= = {(C, B), (C, A)}, and E 0 := E \ (E c [?]
E 6= ).
The auxiliary weighted graph (G0 , `) is represented in Fig.
2.
Now, since (G0 , `) is conservative, then we can can compute in O(nm) time a potential function p : V 7- R such that Clearly, for every edge of G0 , that is, for every edge e = (u, v) [?]
E 0 = E 0 [?]
E 6= [?]
[E 6= ]R [?]
[E c ]R , the reduced length `p (e) := X X X X `e f~e = `e fe + e `e-e `eR `(e) - pv + pu is non-negative.
In this way, for every edge e[?
]E e[?
]E e [?]
E 0 [?]
E 6= we have that e[?]C[?
](E 0 [?
]E 6= ) e[?]C[?
]([E 6= ]R [?
][E c ]R  =  X e[?
]E  =  X e[?
]E  ` e f e + e   X  `e+e  e[?]C[?
](E 0 [?
]E 6= )  `e fe + e `(C) <  X     X  `p ((u, v)) >= 0 ,  `e   whereas, for every edge e = (u, v) [?]
E c we have that  e[?]C[?
]([E 6= ]R [?
][E c ]R  `p ((u, v)) = `((u, v)) - pv + pu  `e fe ,  e[?
]E  = -`((v, u)) - (-pu ) + (-pv )  as long as e > 0, since `(C) < 0.
Also, for every e > 0, f~ is a circulation for G since we can think of it as obtained from the circulation f through the following three steps:  = -`p ((v, u)) <= 0.
Based on this, we propose considering the following solution to Problem (P2): ( 0 for every e [?]
E 0 [?]
E 6= , + ` (e) = -`p (e) for every e [?]
E c .
1) first, increase fe by a same quantity e on all the arcs e of the directed circuit C; this step could extend f to arcs not present in G;  23  2 C  1  C  -2  4  0 -3  3 0  1 0  0  -6 + 1 = -5  -1  B 5  -2  A 0  1  B  D -2  3  Simple reductions from FAS, like those mentioned in the introduction, already show that the problem becomes APXhard as soon as the costs are non convex.
We have already observed in Section III that our model must be in class P when the cost function is convex.
Here we want to indicate more effective approaches P for the case when the global cost function is of the form e[?
]E ce (`+ e ), with each ce (*) convex.
Assume first cP e (*) is a convex piecewise linear function: in k this case ce = i=1 fxi ,mi , where  0 [?]
0 <= x <= xi , fxi ,mi (x) = mi (x - xi ) [?]
x >= xi .
!
=- =-  e[?
]E c  C3e  X  lC  =-  X  X  `p (e) `p (e)  e[?]C[?
]E c  C  <=-  lC  lC  X  `p (e)  C  e[?
]C  X  lC `p (C)  Note that the arc e = (u, v) can then be represented by k arcs (where k was P the number of pieces) ej = (u, v) with `(ej ) = `(e) + i<=j xi and c(ej ) = mj , for j = 1, .
.
.
, k. Notice that the cost function associated to each one of these k arcs is now linear so that we are back to the model investigated into the previous section.
The same trick essentially works in order to obtain an effective FPTAS for the more general case when all the costs ce (*) are semiderivable convex functions, since, for any e > 0, and for each B > 0, each such function can be approximated by a convex piecewise fuction pe (*) with ce (x) <= pe (x) <= (1 + e)c  e (x) for each x >= 0 with x <= X, and made of O 1e log B pieces, where B <= ce (X).
e[?
]E  =-  X  D 5  V. C ONVEX C OSTS  e[?
]E c  X  A  Fig.
4.
A minimal-cost consistent STN determined from the original STN of Fig.
1.
The bold labels represent the new length values of the associated edges.
This is a feasible solution to our original problem simply because (` + `+ )p = `p + `+ >= 0, and the feasibility of the resulting STN network is certified by the same potential computed above.
In order to prove its optimality, we analyze its cost as follows: X X ce `+ (e) = -ce `p (e) X  -4 + 2 = -2  6  Fig.
3.
The values of `p for the STN of Fig.
1 determined using the potential function depicted in Fig.
2.
e[?
]E  -2  2  `(C)lC .
e[?
]E  Since we could rewrite the cost of the proposed solution to Problem (P2) as the optimal solution value of its dual Problem (P3), then the optimality follows by the weak duality theorem.
Example 5.
Fig.
3 depicts `p obtained applying the potential function p defined in the auxiliary graph (G, `) of Fig.
2 to the original length ` function of the STN in Fig.
1, as previously described.
The optimal solution to the primal problem (i.e., the minimal-cost consistent STN) is determined considering only the negative edges values in Fig.
3 and adding their absolute values to the corresponding original edge lengths in Fig.
1, as depicted in Fig.
4.
Thus constraint (B, A) is relaxed by 1 and constraint (A, D) is relaxed by 2.
The cost of these relaxations is 1 * 1 + 2 * 2 = 5 and is indeed the same as the cost of the solution to the dual problem, whence optimality is confirmed and we have produced the optimal solution to our original problem.
VI.
C ONCLUSIONS In the literature, there are different frameworks and approaches aimed to solve the constraint violations in an inconsistent STN.
Some authors proposed semi-automated protocols in which a designer interacts with a solving algorithm proposing a set of constraints to be removed/relaxed.
In this paper, we propose a novel framework where the problem of eliminating constraint violations is reformulated as an optimization problem where violated constraints can be relaxed paying a cost.
In this way, we show that the problem is tractable and can be solved by linear programming.
Therefore, the framework allows a designer to solve the inconsistency of an STN in only one step.
Moreover, we offer an analysis of the mathematical structure of the model that leads to effective (time complexity O(nm))  The most expensive step in computing this optimal solution to Problem (P2) along the above lines, once the l are given, is the computation of the potential function p, which can be done in O(nm) by a standard Bellman-Ford algorithm.
24  combinatorial algorithms that allow the resolution of bigger instances.
As for future work, we aim to evaluate the practical performances of the proposed algorithms and the effectiveness and applicability of the framework in some application domains.
[8] P. Morris, R. Morris, L. Khatib, S. Ramakrishnan, and A. Bachmann, "Strategies for global optimization of temporal preferences," in Principles and Practice of Constraint Programming - CP 2004, ser.
LNCS, M. Wallace, Ed.
Springer, 2004, vol.
3258, pp.
408-422.
[Online].
Available: http://dx.doi.org/10.1007/978-3-540-30201-8 31 [9] B. Peintner and M. E. Pollack, "Any time, complete algorithm for finding utilitarian optimal solutions to STPPs," in Proc.
of the 20th nat.
conf.
on Artificial Intelligence, ser.
AAAI'05, vol.
1.
AAAI Press, 2005, pp.
443-448.
[Online].
Available: http://dl.acm.org/citation.cfm?
id=1619332.1619404 [10] D. B.
West, Introduction to graph theory, 2nd ed.
Prentice, 2001.
[11] R. K. Ahuja, T. L. Magnanti, and J.
B. Orlin, Network flows: theory, algorithms, and applications.
Prentice H., 1993.
[12] A. V. Goldberg and R. E. Tarjan, "Finding minimum-cost circulations by canceling negative cycles," J. of the ACM (JACM), vol.
36, no.
4, pp.
873-886, 1989.
[13] J. Edmonds and R. M. Karp, "Theoretical improvements in algorithmic efficiency for network flow problems," J. of the ACM (JACM), vol.
19, no.
2, pp.
248-264, 1972.
[14] A. V. Goldberg and R. E. Tarjan, "Finding minimum-cost circulations by successive approximation," Math.
of Oper.
Res., vol.
15, no.
3, pp.
430-466, 1990.
[15] M. Grotschel, L. Lovasz, and A. Schrijver, Geometric Algorithms and Combinatorial Optimization, 2nd ed., ser.
Algorithms and Combinatorics.
Springer, 1993, vol.
2.
[16] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction to Algorithms.
The MIT Press, 2001.
[17] R. Bellman, "On a routing problem," Quarterly of Applied Mathematics, vol.
16, no.
1, pp.
87-90, 1958.
R EFERENCES [1] R. Dechter, I. Meiri, and J. Pearl, "Temporal constraint networks," Artificial Intelligence, vol.
49, no.
1-3, pp.
61-95, 1991.
[2] A. Dasdan, "Provably efficient algorithms for resolving temporal and spatial difference constraint violations," ACM Tran.
on Design Aut.of Elect.
Sys.
(TODAES), vol.
14, no.
1, p. 8, 2009.
[3] V. Kann, "On the approximability of NP-complete optimization problems," Ph.D. dissertation, Royal Inst.
of Tech.
Stockholm, 1992.
[4] G. Even, J. S. Naor, B. Schieber, and M. Sudan, "Approximating minimum feedback sets and multicuts in directed graphs," Algorithmica, vol.
20, no.
2, pp.
151-174, 1998.
[5] E. Speckenmeyer, "On feedback problems in digraphs," in GraphTheoretic Concepts in Computer Science: WG'89, vol.
15.
Springer Verlag, 1990, p. 218.
[6] L. Planken, M. de Weerdt, and N. Yorke-Smith, "Incrementally solving STNs by enforcing partial path consistency," in Proc.
of ICAPS, 2010, pp.
129-136.
[7] L. Khatib, P. Morris, R. Morris, and F. Rossi, "Temporal constraint reasoning with preferences," in Proc.
of the 17th int.
joint conf.
on Artif.
Intelligence, vol.
1.
Morgan Kaufmann, 2001, pp.
322-327.
25