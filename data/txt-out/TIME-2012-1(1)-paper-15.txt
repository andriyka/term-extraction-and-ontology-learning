2012 19th International Symposium on Temporal Representation and Reasoning  Compositional Refinement for Real-Time Systems with Priorities Abdeldjalil Boudjadar, Jean-Paul Bodeveix, Mamoun Filali IRIT-UPS, Universite de Toulouse Toulouse, France {boudjada, bodeveix, filali}@irit.fr  Si is an abstraction of Si .
With the above fact, checking that S satisfies a property P becomes more tractable and simply consists of checking that each component Si satisfies a property Pi , where P is a composition of Pi .
That is what happen in compositional verification [14] and abstractionbased verification [6].
Defining the parallel composition and finding a suitable refinement relation for real-time systems with communication, priorities and variables is a tough task.
Real-time system properties are often formalized using timeconstraints and priorities.
To consider such concepts, we introduce real-time systems with a global space (variables and clocks) and priorities (static and dynamic).
Similarly to process algebras, to deal with hierarchical design and specifications, real-time formalisms have known a large number of composition approaches.
However, a compositional framework with high-level concepts like variables, communication and priorities is still lacking.
Several works [11], [16], [22], [13] have focused on this subject by analyzing thoroughly the problem and criticizing existing solutions.
In fact, this paper is a follow up of [12] where we have revisited the composition of timed systems, without priorities, and proposed a new communication mechanism for UPPAAL timed automata.
In [12], we have defined an original composition operator endowed with good properties (associativity, refinement, etc.
), and supporting communications via synchronization of actions and shared variables.
Through the introduction of priority, we revisit the framework defined in [12] for reasoning about the composition of timed systems.
Thereafter, our framework, defined with priorities, will be instantiated for UPPAAL timed automata with three priority orders : static priority, priority on channels and priority on processes, where we will analyze different priority relations, and give both operational semantics and refinement of timed automata TA and networks of timed automata NTA (in compositional way).
The rest of our paper is organized as follows: Section 2 presents the existing related work.
In Section 3, we present the formal basis of our work, where we introduce Communicating Labelled Transition Systems with location Invariants and Priorities (CLTSIP).
We give a sufficient condition for the bisimilarity and define an associative product of CLTSIPs.
Moreover, we define ETTSs as CLTSIPs which synchronize on time instants.
Section 4 introduces UPPAAL TA and NTA with committed locations, priority on channels and priority on processes.
Here, we show the compositionality of NTA semantics in terms of ETTSs, where the two corresponding ETTS-based semantics  Abstract--High-level requirements of real-time systems like as time constraints, communications and execution schedulability make the verification of real-time models arduous, where a system is the interaction of a possibly unbounded set of components.
Priorities have been introduced to resolve execution conflicts, and by that, prevent the combinatorial explosion of state space.
In this paper, we are interested in the composition and refinement of timed systems by considering static and dynamic priorities.
Firstly, we propose a revised definition of the product of extended timed transition systems with static and dynamic priorities associated to individual transitions.
Afterwards, we study the (compositional) refinement of compound extended timed systems.
Without sacrificing compositionality, we instantiate this framework for the case of UPPAAL networks of timed automata with static priority Committedness, dynamic priority between channels and priority between processes.
Moreover, we show how to associate an Extended Timed Transition System (ETTS) to timed automata (TA), where an unique generalized dynamic priority system of ETTS is derived from both dynamic priority orders: priority between channels and priority between processes.
Keywords-Timed systems; composition; refinement; priorities.
I. I NTRODUCTION The concurrency theory [25] is an extremely helpful concept whereby the design of complex systems becomes as far as tractable.
It has by now established itself as an extensive research field for mastering the schedulability of executions.
However, concurrency has a real impact on model checking of real-time systems, where conflicts and non-determinism of executions are greatly diverging together with the number of system (competing) processes, which often leads to combinatorial explosion of the state space, the reason for this being that time is considered as part of the state.
To tackle non-determinism and execution conflicts, priorities have been introduced as a scheduling order.
Composition, refinement and model-checking of timed systems with priorities have been intensively studied [9], [18], [22], [3], [17], [16], [13].
The ultimate goal of these work is to deal with details resulted from the use of clock variables and evolutive data structures, required by real-time applications.
Abstraction refinement [19] plays a key role in the design and verification of real-time systems.
It enables to abstract unbounded data structures and implementation details whereby, we are able to perform model checking on a system S  = S1  ...  Sn instead of the original complex system S = S1  ...  Sn , where each 1530-1311/12 $26.00 (c) 2012 IEEE DOI 10.1109/TIME.2012.21  57  priority orders on channels and on processes, and establish their compositional semantics in terms of ETTSs.
are equivalent: a direct one (an ETTS associated to the NTA) and the product of ETTSs, associated to individual timed automata, composed with a restriction.
We also establish an interesting refinement property stating that: the refinement of a NTA consists in the refinements (separately) of its individual TA.
Finally, we show an application of our framework to refine a version of the Alternating Bit Protocol [28], and conclude with future work.
III.
T RANSITION S YSTEM E XTENSIONS In this section, after introducing priorities, we give a brief recall of one of the fundamental models of concurrency, transition systems, originally introduced in [27] and since then studied extensively by [26] and others.
Roughly speaking, transition systems are an elegant model for representing the behavioral aspects.
Due to their safety properties verifiable using model-checking, transition systems have been intensively applied to the modelling of complex systems, as well as for giving semantics to synchronous languages and realtime formalisms.
In what follows, we define composable symbolic transition systems (CLTSIP) as a modeling framework.
Thereafter, we give their associative product and study the refinement of their parallel composition.
II.
R ELATED W ORK Composition and refinement of real-time systems with priorities have been intensively studied [18], [16], [13], [22], [9] during the last two decades.
However, a compositional framework merging different priority systems is still relatively lacking.
Several works of Sifakis [11], [18], [3], Cleaveland [9], [15] and UPPAAL team [16], [17] have focused on the modeling and synthesis of timed systems with priorities.
They represent a common theoretical basis for the modeling with priorities.
The authors of [18] define a design framework for both safety and deadlock-freedom requirements.
The framework consists of a priority system, where an action ai has (dynamic) priority over another action aj once a condition cij is satisfied together with the enabledness of actions.
In the same way, [11] defines a dynamic priority on actions, where an action ai has a priority on an action aj during a certain time interval.
In fact, such dynamic priority relations are a partial function because they are only applied under the satisfaction of an extra condition on comparable actions.
In [16], the authors define an extension of timed automata with a dynamic priority order between actions and another priority order between processes.
They give an efficient algorithm to compute subtractions of DBMs (Difference Bounded Matrices).
The authors define a non compositional semantics of networks of extended TA, in terms of timed transition systems.
Under certain restrictions, they show how an unique generalized priority order can be derived from both action and process priority orders.
In [9], the authors describe a modeling framework for real-time systems, using dynamic priorities, which essentially extends CCS (Calculus of Communicating Systems) algebra [25] with dynamic priorities.
Such a proposal reduces drastically the state space of systems and preserves their functional behavior.
In fact, action priorities are not constant and may change when the system evolves.
Formally, each action priority is inferred from delays preceding that action.
Accordingly, the longer is the delay preceding an action, the lower is its priority.
In this paper, we present a compositional framework for the composition and refinement of timed systems with both static and dynamic priorities.
To this end, we consider an extended structure of timed transition systems ETTS with variables, location invariants and communication where each transition possesses a static priority s and a dynamic one d. We define an associative parallel product of ETTSs together with a compositional refinement property.
Moreover, we instantiate our framework for the case of UPPAAL networks of timed automata, with the static priority committedness and dynamic  A.
Priority Systems Priorities [9], [15], [18], [3], [22], [13] have been introduced as a way to structure and control the usage of shared resources, by specifying that some actions or behavior are privileged over others.
They offer a scheduling order to deal with nondeterminism and execution conflicts.
The BIP language [3] and ACSR algebra [13] provide a powerful mechanism to express different sort of priorities.
Mainly, we distinguish static and dynamic priorities: *  *  Static priorities [12], [7], [4] define an order between transition executions regardless of their enabledness.
With such priorities, non-enabled higher-priority transitions hide enabled lower-priority transitions, which often leads to a deadlock.
In UPPAAL timed automata [4], the static priority is represented by the notion of Committedness (two priority levels) where committed transitions [7], those outgoing from a committed location, have priority over non-committed ones.
Dynamic priorities [22], [18], [9], [16] state that an enabled transition hides a lower-priority transition.
[18] introduces a conditional dynamic priority relation, where an enabled transition hides a lower-priority one if a given condition holds.
Another class of priority relations [11] consists to restrict the applicability of priority to a given time interval.
The semantics of priority relations [11], [18], defined over timed systems, is given by a model transformation where only dynamically higher-priority transitions are held.
Definition 1 (Priority system): A priority system P is a triplet P, fi,  where P, fi is a join semi-lattice, and  : P x P - P is an associative and commutative operator defining the maximum of two values.
We also use i pi to represent the maximum of a finite non empty set of values.
In fact, the join semi-lattice P, fi represents a partially ordered set of priority values, where each subset of P has a least upper bound.
58  *  B. Labelled Transition Systems Labelled transition systems [2] are the reference model used to express and compare behaviors through simulations.
They offer a strong notion of equivalence that can be checked efficiently.
Firstly, let us start with a brief recall of classical labelled transition systems (LTS).
Definition 2 (LTS): A labelled transition system (LTS) over an alphabet S is a tuple Q, Q0 , T r, a, b, l where: 0 * Q is the state space such that Q [?]
Q is the set of initial states, * T r is the set of transitions, * a : T r - Q and b : T r - Q are functions associating, respectively, source and target states to each transition, * l : T r - S is a function associating to each transition a label.
l For the sake of simplicity, we write t : q - q  for t [?]
T r  with a(t) = q, b(t) = q , l(t) = l. If useless, the name of a transition will be omitted.
Moreover, projection functions a, b and l can be omitted and systematically inferred from the transition relation -.
By now, we give LTSs simulation to check that a concrete LTS implements an abstract one.
Definition 3 (Simulation): Given two labelled transition systems Tc = Qc , Q0c , T rc  (concrete) and Ta = Qa , Q0a , T ra  (abstract), Ta simulates Tc through a relation R [?]
Qc x Qa , denoted by Tc  R Ta , if: 0 0 * [?
]qc [?]
Qc , there exists qa [?]
Qa such that R(qc , qa ).
l    * [?
]qc qc qa l, if qc -c qc and R(qc , qa ) there exists qa [?]
l    Qa such that qa -a qa and R(qc , qa ).
Accordingly, two LTSs Ti and Tj are bisimilar through a relation R [?]
Qi x Qj , denoted by Ti ~R Tj , if Ti  R Tj and Tj  R-1 Ti .
*  Static priority expresses that a higher-priority transition hides a lower-priority one.
The hiding is supposed to be static: a non-firable high-priority transition can hide a firable lower-priority transition.
Dynamic priority states that an enabled priority transition hides lower-priority ones.
An enabled transition is firable if it is not hidden by another higher-priority enabled transition.
Throughout this paper, the static priority is considered first.
We have also introduced location invariants over the global space to restrict the set of states, by reducing the global space valuations.
Definition 4 (CLTSIP): Given two priority systems Ps = Ps , fis , s  (static) and Pd = Pd , fid , d  (dynamic), a composable LTS with location invariants and priorities (CLTSIP) over a shared space G, an action language A 1 , a set of one-to-one channels C and a set of synchronization events M is a tuple Q, q 0 , G0 , I, T r, a, b, l where: * * * * * *  *  C. Composable LTS with Location Invariants and Priorities  Q is the set of locations (local states), q 0 is the initial location, G0 is the set of initial global states, I : Q - 2G associates an invariant to each location, T r is the set of transitions, a : T r - Q and b : T r - Q are functions associating, respectively, the source and target locations of each transition, l : T r - LxAxPs xPd is a function associating to each transition the corresponding label, action, static priority value and dynamic one, where L = C?
[?]
C!
[?]
M [?]
{t } is the set of labels.
C!
and C?
correspond respectively to send and receive labels over channels C. M is the set of multiple (many to many) synchronization events and t is the internal event.
Moreover, a CLTSIP must satisfy the wellformedness condition: n-ary synchronization transitions, with a label in M , are supposed to have the lowest static and dynamic priorities.
In this section, we define composable LTS with location invariants and priorities (CLTSIPs), as an extension of labelled transition systems with shared variables, communication, static priority, dynamic priority and location invariants.
Moreover, we specialize both state space and alphabet to allow several communication protocols between transition systems: * via a shared space: we distinguish local and global state spaces, and introduce abstract actions that update the global state space.
These actions can be non-deterministic and blocking.
* via CCS-like channels [25]: we introduce a set C of sendreceive channels, where two transitions synchronize if their actions are complementary.
The resulting transition, of such a synchronization, corresponds to an internal transition in the composition.
* via CSP (Communicating Sequential Processes)-like synchronization [21]: we introduce a set M of many-to-many synchronization events, which enable to model a system transition where all processes perform a lock-step [21].
Throughout this paper, we use such a synchronization to model time-evolution transitions.
Furthermore, to reduce the non-determinism and execution conflicts, we consider the following priority mechanisms.
l/a  Here and elsewhere, we write t : q ---s,d q  for a transition t [?]
T r with a(t) = q, b(t) = q  , l(t) = l, a, s, d.
If not needed, the name of a transition will be omitted.
Again, the set of transitions T r is often denoted by the transition relation -, which enables to omit the projection functions a, b and l. The semantics [[.]]
of the action language A is given by [[.]]
: A - 2GxG .
Let us consider the following predicates: *  *  l/a  A transition t : q ---s,d q  is said to be enabled in a global state G if [?
]G | (G, G ) [?]
[[a]] and G |= I(q  ).
l/a  A transition t : q ---s,d q  is said to be statically hidden     l /a  if [?
]t : q ----s ,d q  such that s [?
]s s .
*  l/a  A transition t : q ---s,d q  is said to be dynamically   l /a  hidden if [?
]t : q ----s ,d q  enabled and non statically hidden such that d [?
]d d .
Accordingly, a transition is said to be hidden if it is statically and dynamically hidden.
1 This action language is abstract here.
It will be made more precise in section IV-B  59  Definition 5 (Semantics of a CLTSIP): Given a global space G, a static priority system Ps = Ps , fis , s , a dynamic priority system Pd = Pd , fid , d  and an action language semantics [[.]]
: A - 2GxG .
The semantics of the CLTSIP Q, q 0 , G0 , I, T r is the LTS: * Q x G, 0 0 0 * {q } x (G [?]
I(q )),   l/a    from a location corresponding to q in the abstract CLTSIP T2 .
The universal quantifier given in Item (2) dissociates the condition on priorities from that of refinement and makes, by that, the proofs further simpler than that of the LTS-based refinement.
Proof.
Straightforward.
1) Restriction of a CLTSIP: The restriction [25] of a CLTSIP, over a set of channels, is a CLTSIP where transitions composable over these channels have been removed together with transitions of lower static priority.
Definition 7 (CLTSIPs restriction): Given a CLTSIP T = Q, q 0 , G0 , I, -- over a shared space G and a set of channels C. Let C  [?]
C, we define the restriction of T over C  , denoted l/a by T \C  , to be the CLTSIP Q, q 0 , G0 , I, {t : q ---s,d q  |    {(q, G), l, (q , G ) | [?
]t : q ---s,d q [?]
T r, G |= I(q), enabled(t, G), !statically hidden(t) and !dynamically hidden(t)} In fact, LTS states correspond to the product of both locations and space valuations of the CLTSIP.
Namely, an enabled transition t, of CLTSIP, is held if it is not statically hidden by a higher-priority transition t , i.e.
s [?
]s s , and if it is not again dynamically hidden by another enabled non-hidden transition, i.e enabled(t , G) [?]
!statically hidden(t ) = d [?
]d d .
Definition 6 (Similarity): A CLTSIP Ti is said to be (bi)similar to CLTSIP Tj if their associated LTSs are (bi)similar.
The presence of both static and dynamic priorities makes the semantics of CLTSIPs rather complex.
It would be much more readable if we could get rid of managing priorities during simulation proofs.
To this end, we consider a sufficient condition for the refinement of CLTSIPs, expressed as the simulation of the corresponding LTSs.
Firstly, we introduce the predicate *  l /a  l[?]
/ C  [?]
[?
]t : q ----s ,d q  , l [?]
C  = s s s}.
In fact, from each location, a transition is held if it is neither labelled by a communication l [?]
C  , nor statically hidden by another communicating transition (over C  ) outgoing from that location.
Theorem 2 (Refinement and restriction): Let Tc , Ta be two CLTSIPs defined on the same set of channels C, then Tc   Ta = Tc \C   Ta \C.
Proof.
It consists to show that each non-hidden concrete transition of Tc \C, labelled by t or m [?]
M , has a corresponding abstract transition non-hidden in Ta \C.
2) Product of CLTSIPs: In what follows, we define an associative n-ary product of CLTSIPs, where locations of composition are simply obtained by the product of individual CLTSIP locations.
Moreover, our product is parameterized by two internal operations defined on the action language: * a1  a2 is used to compose actions associated to sendreceive communication.
* a1  a2 is used to compose actions associated to global synchronizations (lock-step).
This operation is supposed to be commutative, respectively associative, in order to establish the commutativity, respectively associativity, of the product.
Definition 8 (N-ary product of a family of CLTSIPs): Given an indexed family Ti = Qi , qi0 , G0i , Ii , -i 1..n of n CLTSIPs defined over the same shared space G, action language A, static priority system Ps and dynamic priority system Pd , their product   P1..n Ti is defined by the CLTSIP  i Qi  , q10 , .
.
.
, qn0 , i G0i , I, - over G, Ps and Pd where I(q) = i Ii (qi ) and - is the smallest relation such that:  l /a  l/a  Ismax ts (t : q ---s,d q  )  [?
]t : q ----s ,d q  !
(s [?
]s s ) defining a higher static priority transition outgoing from lol/a cation q.
In the same way, Ismax td (t : q ---s,d q  )  l /a  [?
]t : q ----s ,d q  !
((d [?
]d d ) [?]
enabled(t , G)), with (G, G ) [?]
[[a ]], is a predicate defining a higher dynamic priority transition outgoing from location q. Theorem 1 (Refinement of CLTSIPs): Given two CLTSIPs T1 and T2 with their respective static and dynamic priority systems (Ps1 , Pd1 ) and (Ps2 , Pd2 ).
T1 refines T2 through the refinement relations Rl [?]
Q1 xQ2 and Rg [?]
G1 xG2 , denoted T1  Rl ,Rg T2 , if 1) The associated LTSs satisfy the sufficient condition for simulation, i.e: 0 0 * Rl (q1 , q2 ), 0 0 * [?
]x [?]
G1 , [?
]y [?]
G2 | Rg (x, y), *  l/a1  [?
]t : q1 ----s1 ,d1 q1 , [?
]q2 x x y such that (x, x ) [?]
[[a1 ]].
If Rl (q1 , q2 ) and Rg (x, y) then there exist q2 [?]
Q2 , a2 , y  , s2 [?]
Ps2 , d2 [?]
Pd2 such that l/a2  q2 ----s2 ,d2 q2 [?]
(y, y  ) [?]
[[a2 ]] [?]
Rl (q1 , q2 ) [?]
Rg (x , y  ), * [?
]q1 [?]
Q1 q2 [?]
Q2 , Rl (q1 , q2 ) [?]
I2 (q2 ) = I1 (q1 ), 2) For all t1 [?]
T r1 and t2 [?]
T r2 such that Rl (a1 (t1 ), a2 (t2 )) and Rl (b1 (t1 ), b2 (t2 )), then Ismax ts (t1 ) = Ismax ts (t2 ), Ismax td (t1 ) = Ismax td (t2 ).
Roughly speaking, the refinement consists of establishing a mapping between the transitions of refining and refined CLTSIPs.
In fact, from each location q of the concrete CLTSIP T1 , the presence of a transition t1 , with a maximal priority, states the presence of a maximal-priority transition outgoing  ti :qi - --s,d qi l/a  l[?]C![?]C?[?
]{t }  q- --s,d q[i-qi ] l/a  Async(ti )  m/ai  ([?
]i) qi ----si ,di qi m [?]
M m/  J  i ai  q- ------s s  q ,d d i i i    Sync  c?/aj  c!/ai  ti : qi ----si ,di qi tj : qj ----sj ,dj qj (P C) i =  j t /ai aj  q- -----s  60  q[i-qi ,j-qj ] s d i  sj ,di  dj  SR(ti , tj )  where (P C) is a priority condition stating that if static, respectively dynamic, priorities of transitions ti and tj are increased upto the maximum si s sj , respectively di d dj , no new hiding may occur.
For example, the static priority condition for CLTSIP Ti can be formally expressed as  [?
]t : l/a qi ---s,d qi | (s s si ) [?]
(s s si s sj ).
The notation q[i - qi ] states the replacement of the ith location of vector q by location qi .
If we consider UPPAAL TA, in which transition priorities are assigned to channels, then di = dj = di d dj .
About transition rules, Async(ti ) represents internal transitions and potential synchronizations that a CLTSIP may be willing to engage in with its environment.
Rule Sync defines a n-ary synchronization of a set of transitions on the same event m, which will be instantiated by a time-transition in the ETTS.
Rule SR(ti , tj ), for send/receive, corresponds to a synchronized communication of both Ti and Tj on compatible events through a channel c [?]
C. Let us mention that n-ary synchronization transitions, labelled by m, cannot block or be blocked.
One may remark that our product is syntactical, whereby, all of the CLTSIP non-composable transitions are held.
Theorem 3 (Generalized associativity): If  is associative, i.e.
i[?
]I j[?
]Ji ai,j = i[?]I,j[?
]Ji ai,j , the product of CLTSIPs is associative, i.e.
: Pi[?
]I (Pj[?
]Ji Ti,j ) ~ Pi[?]I,j[?
]Ji Ti,j Proof.
It essentially consists of defining an isomorphism between the two structures, state space and transitions, preserving labels and priorities.
 3) Compositional Refinement of CLTSIPs Product: Modelchecking of real-time systems suffers from the state explosion problem, the reason for this being that time is considered as part of the state, leading then to a widely large or even infinite state space of the system.
Abstraction refinement plays a key role in the model-checking of complex systems where unbounded data structures can be abstracted.
However, for compound systems, defining the refinement of the whole system is an arduous task.
In what follows, we show how the (compositional) refinement [19] of CLTSIPs product has been brought to a set of simpler refinements of individual CLTSIPs.
Theorem 4 (Compositional refinement): Given two products of CLTSIPs T1  ...  Tn and T1  ...  Tn defined on the same priority systems (with total orders).
T1  ...  Tn refines T1  ...  Tn , denoted by T1  ...  Tn  [?
]i Rli ,Rg T1  ...  Tn where Rli [?]
Rlj (qi , qj )(qi , qj ) = Rli (qi , qi ) [?]
Rlj (qj , qj ), if:  * [?
]i Ti  Ri ,Rg Ti , l * each concrete transition and its corresponding abstract one have the same priorities (morphism), * refinement preserves deadlock-freeness, where deadlockfreeness is defined by the existence of firable transitions.
Through this theorem, we are able to perform model checking on the composition of CLTSIPs, T1  ...  Tn , instead of the original composition T1  ...  Tn .
In fact, through the last two conditions of this theorem, we may reduce the refinement of CLTSIPs to classical refinement relations of transition systems, and by that, the proof would be much more tractable (note that we do not claim that composition preserves deadlock freeness).
Proof.
Given a transition of the concrete product, it is either asynchronous from some Ti and has a corresponding abstract  transition in Ti with the same priority, which is in turn present in the abstract product, or a synchronization SR of two transitions from Ti and Tj that have abstractions in Ti and Tj which synchronize in the abstract product with the same priority, or again an n-ary synchronization Sync which, as previously stated, leads to an n-ary synchronization in the abstract product.
Moreover, if a concrete transition has priority over ready 2 transitions, then the corresponding abstract one has also priority.
 D. Timed Transition System Extensions Timed transition systems [20] are the reference model to define the semantics of real-time formalisms such as time Petri nets and timed automata.
Basically, a Timed Transition System (TTS) is a labeled transition system where labels can be events or durations.
In this section, we define extended timed transition systems (ETTS) as CLTSIPs which synchronize on time.
ETTS actions are considered as a pair (guard, assignment) of CLTSIPs.
Furthermore, we consider the global state space structured as valued variables.
Definition 9 (ETTS): An Extended Timed Transition System (ETTS) on a set of variables V valued over a domain D, a static priority system Ps , a dynamic priority system Pd and a set of channels C is a CLTSIP over the global space G = DV where the synchronization events m [?]
M are time instants of D = R>=0 .
Its action language is defined as the set of pairs (guard, assignment), where a guard is a predicate over variables of V and an assignment is a partial function mapping variables to expressions built on V. The semantics of an ETTS depends on its action language semantics.
Here, we have chosen the following definition for the (guard, assignment) pairs: Action a:=  language g/ v[?
]V v := ev | aa | j[?
]J aj  Semantics  [[g/ v[?
]V fi v := ev ]](x, x ) = g(x) [?]
v[?
]V x (v) = [[ev ]](x)  The notation g/ v[?
]V states the parallel update of variables of V as an assignment guarded by g. Both action composition operators  and  are left undefined.
Their semantics will be chosen to conform with the semantics of timed automata action composition.
IV.
I NSTANTIATION FOR UPPAAL UPPAAL [4] is an integrated tool environment for modeling, validation and model checking of real-time systems modeled as networks of timed automata.
The tool has been used successfully and routinely for many industrial case studies.
In this section, we consider UPPAAL timed automata (TA) [4] as an instantiation of CLTSIPs.
The UPPAAL language [24] considers 3 priority orders: a static binary priority so-called Committedness associated to locations, a dynamic priority order on channels and another dynamic priority order between 2 Transitions outgoing from the same state and, for dynamic priority, enabled.
61  processes.
In fact, location committedness is a high level mechanism defining two priority levels, where transitions outgoing from committed locations have priority over transitions outgoing from non-committed locations, independently of their enabledness.
* In UPPAAL [4], committedness is associated to states where systems cannot delay if the current state is committed.
* In order to define a compositional semantics of timed automata composition, using a products of TTSs (Timed Transition Systems), [7] proposes a restriction on UPPAAL so that a committed state has always a firable outgoing transition.
* With respect to our previous work [10], we do not require such a restriction but we use a slightly modified structure of TTSs.
Location committedness is considered as a static priority system with two priority values {true, f alse}.
Moreover, the dynamic priority order on channels [11], [18], [16] states that a synchronizing transition t on a channel c, which has priority over a channel c , has priority over transitions composable on c if it is firable, i.e.
the guard of t is satisfied.
We also consider the priority order on TA processes, which is a dynamic relation stating that the executions of a timed automaton have priority over the executions of other TA.
In what follows, we introduce UPPAAL TA with the three priority orders (committedness, priority on channels and priority on TA) and define their ETTS-based semantics, where an unique generalized dynamic priority system is derived from both priority on channels and priority on TA.
To this end, on a composition, static priority is checked first and if the conflict is not solved we may refer to the priority order on channels.
Again, if the choice of a transition from a conflict cannot be made, we compare then the dynamic priorities associated to the involved TA.
of the static priority system with two values.
Moreover, the unique dynamic priority system of ETTS semantics is derived from a merge of both priority orders fic and fita .
Definition 11 (Priority systems corresponding to TA): Given a timed automaton T [?]
TA defined on a total priority order fic on channels and a total priority order fita on elements of TA, where TA is the set of timed automata names, the static priority  system associated to T is defined by Ps = {[?
], }, =,  and the dynamic one is defined by Pd = ({, default} [?]
C) x TA, fid , d  where (x, y) fid (x , y  )  x [?
]c x [?]
(x = x [?]
y fita y  ).
Since the orders fic and fita are total in UPPAAL, the priority order fid is total.
default is the UPPAAL priority level assigned to t -transitions and  is the lowest priority level.
In fact, the static priority system is straightforward, whereas the dynamic priority system consists in checking first the priority on channels and if the choice of a transition cannot be made, we refer then to priorities of the corresponding TA.
By now, we give the semantics of TA in terms of ETTSs where ETTS locations are TA locations.
Definition 12 (ETTS of a TA): Given a set of channels C, a priority order fic on channels, a priority order fita on TA and a set kh of clocks.
The semantics of a timed automaton with committed locations and priorities T = Q, q 0 , K, I, -ta  is defined by the ETTS Q, q 0 , G0 , I, - over the global space kh - D, static priority system Ps and dynamic priority system Pd where G0 = kh x {0} and - is the smallest relation such that: q- ----ta q g/t /r  g/t /fix[?
]r x:=0  q- ---------q[?
]K,(default,T ) q  ----  g/l/r  q l[?
]C ta q g/l/fix[?
]r x:=0 q[?
]K,(l,T )  q- --------- q[?
]K  A. TA with Committed Locations and Priorities Timed automata [1] have been introduced as a modeling framework to support the description and analysis of timed systems.
In fact, a timed automaton is structured as a finitestate machine extended with a finite collection of real-valued clocks initialized to zero and increased synchronously.
Definition 10 (TA with committedness and priorities): Given a set of clocks kh, a set of channels C, a priority order fic on channels of C and a priority order fita on TA, a timed automaton with committedness and priorities is a tuple Q, q 0 , K, I, - where: 0 * Q is a set of locations where q [?]
Q is the initial location, * K [?]
Q is a set of committed locations, kh-D * I : Q - 2 associates a clock invariant (a set of clock valuations) to each location, kh-D * -[?]
Q x 2 x 2kh x S x Q is the transition relation defined with a clock guard, a reset set and an event l [?]
S. S = C?
[?]
C!
[?]
{t } is the set of transition labels.
[?
]/t /skip  q- ------,(default,T ) q  Tau  Com q  Empty  q	[?
]K [fix[?
]kh x:=x+d]I(q)/d/fix[?
]kh x:=x+d  q- ----------------------[?
],(,T ) q  Time  For transition rules T au and Com, both guards and labels of T transitions are still unchanged in the corresponding ETTS transitions.
The semantics of a reset r consists in a parallel reinitialization of clocks x [?]
r. Moreover, the static priority of each ETTS transition corresponds to the committedness of the TA source location q, whereas the dynamic priority is the pair of label l for a communication, respectively default for internal and Empty transitions and  for Time transitions, and the name of the automaton T .
Empty transitions are not firable and especially introduced to hold the committedness of TA locations, when that locations do not have outgoing transitions.
From each non committed location q, we may perform a Time-transition adding an amount d, respecting the invariant of q, to each clock x [?]
kh.
One may distinguish that no transition can be blocked by Time-transitions because they have the lowest static and dynamic priority values.
g/l/r  We write q ---- q  for (q, g, r, l, q  ) [?]-.
Different semantics of TA with priorities in terms of TTS have been proposed [19], [23], [29], [5].
Here, we define the semantics of TA with priorities in terms of ETTSs where committedness is an instance  Simulation: a timed automaton Tc refines another TA  62  Ta if the simulation relation holds between their associated ETTSs: Tc   Ta  ET T S(Tc )   ET T S(Ta ).
qi [?]
K i [?
]/t /skip  q -------,(def ault,Ti ) q fi  B.
Networks of TA with Committedness and Priorities In order to model concurrency and communication, TA have been extended with parallel compositions, giving rise to the NTA.
Several semantics for TA composition have been studied [4], [7], [16], [23], [29] and various parallel composition operators have been proposed, the well known ones are those of CCS [25] and CSP [21].
The UPPAAL language [24] has adopted the CCS parallel composition which allows interleaving of actions as well as hand-shake synchronization.
In this section, to compare NTA through simulation and bisimulation relations, we define their semantics in terms of ETTS and establish a compositionality result.
Definition 13 (Networks of timed automata): A network of timed automata with committed locations, priority on channels fic and priority on TA fita is a finite collection of TA.
First, let us choose the following action language and its underlying semantics for ETTS.
q  The semantics of NTA is parameterized by the way guarded actions are composed on a send/receive synchronization, i.e.
(gs /as )  (gr /ar ).
The semantics [[a  a]], depends on the semantics chosen for TA composition, is still unspecified.
Definition 14 (NTA semantics): Given a set of clocks kh, a set of channels C, a priority order fic on C and a priority order fita on timed automata, the semantics of an 0 NTA  N = Qi , qi , Ki , Ii , -i 1..n is defined by the ETTS  i Qi , q10 , .
.
.
, qn0 , kh x {0}, I, -  over the global space kh - D, static and dynamic priority  systems Ps and Pd given in Definition 11 where I(q) = i Ii (qi ) and - is the smallest relation such that: g/t /r   j  q j [?]
K j = qi [?]
K i  g/t / x[?
]r x:=0  q ----------qi [?
]Ki ,(def ault,Ti ) q[i - qi ] gi /c!/ri  g/t /r  Taui  gj /c?/rj  qi ------i qi qj ------j qj i = j g/r = gi /ri  gj /rj  q [?]
Kk = (qi [?]
Ki [?]
qj [?]
Kj ) k k q -----qi [?
]Ki [?
]qj [?
]Kj ,(c,max(Ti ,Tj )) q   i qi [?]
Ki xi :=xi +d -------------[?
],(,max({Ti |i[?
]1..n}) g/d/  Time  J  i  q    where, for rule SRi,j (c), q  = q[i - qi , j - qj ] and for Time transitions, the guard g = [ i xi := xi + d]I(q) states that the location invariant I(q) should be respected after updating clocks.
Such an invariant corresponds to the intersection of individual TA location invariants.
Through rule Tau, an internal (statically) non-hidden transition of a TA corresponds to an internal transition of the ETTS semantics.
Hiding is not local, i.e not only attached to a given TA.
In fact, from each TA location, after checking that such a location of the NTA state vector does not have the weakest committedness, we check then whether the current TA transition is not hidden by another transition outgoing from that location.
Rule SRi,j (c) describes the synchronization of TA Ti and Tj on a channel c, where the input transition guard is only checked after taking into account the effect of the output transition action.
Such a synchronization is held if either the send or the receive transition is not statically hidden.
The dynamic priority of the resulting transition corresponds to that of channel c and the maximum process priority of both Ti and Tj .
Finally, both Empty and Time rules have been earlier explained.
Definition 15 (NTA refinement): The refinement between networks of timed automata is defined as the refinement between their associated ETTSs.
Formally, given two NTA Nc and Na ; then: Nc   Na  ET T S(Nc )   ET T S(Na ).
Accordingly, we establish the following theorems: Theorem 5 (Compositionality of NTA semantics): The ETTS of a NTA is bisimilar to the restriction to Time and Tau-transitions of the product of ETTSs associated to individual TA, i.e.
ET T S(N T A) ~ Pi ET T S(T Ai )\C.
Proof.
It is direct because we have the same composition rules in both sides.
The difference resides in the occurrence of unmatched communication transitions in the ETTSs product, but these transitions will be suppressed by the restriction.
This proof has been formalized and validated using the C OQ theorem prover.
 Theorem 6 (Refinement and parallel composition): Given 2 networks of TA N = T1 , .., Tn  and N  = T1 , .., Tn  defined on the same set of channels, N refines N  if:  * [?
]i Ti  Ri ,Rg Ti , l  * channel priority orders of N and N are equivalent, * each concrete process and its corresponding abstract one have the same priority (morphism),    * [?
]q q , Rl (q, q ) = Comm(q) = Comm(q ), * refinement preserves deadlock-freeness.
Proof.
It follows from theorems 4 and 5 together with the restriction theorem 2.
Action language a:= a  a | j[?
]J aj | (g/r) | (g/c := c + d) | (g/skip) Semantics a  a is still unspecified fi [[j aj ]](x, x ) = j [[aj ]](x, x ) fi fi   [[g/r]](x, x ) = g(x) [?]
c[?
]r x (c) = 0 [?]
c[?
]r / x (c) = x(c)   [[g/c := c + d]](x, x ) = g(x) [?]
x (c) = x(c) + d [[g/skip]](x, x ) = g(x) [?]
(x = x)  qi -----i qi  Empty  SRi,j (c)  C. Experiments In this section, we give an application of our compositional framework to refine a version of the well known Alternating  63  Bit Protocol [28] (ABP).
In fact, we aim to verify that the number of correctly received messages is less than the number of correctly sent ones, and their difference is bounded by one.
To send a new message, the TA Sender synchronizes with the TA Mmedium on channel send and increments the shared variable s. The TA Receiver receives the sent message via a synchronization with the Mmedium on channel receive and updates the shared variable r by adding one.
The intended property is represented by the auxiliary Boolean variable Ok  s == r [?]
s == (r + 1).
This property cannot be verified using the UPPAAL toolbox on the NTA formed by Sender, Receiver, Mmedium, Amedium because of the unboundedness3 of s and r. To deal with the unboundedness, a clever idea consists in the replacement of both Sender and Receiver automata by finite abstractions, where the evolutions of variables s and r are respectively modeled by two shared Boolean variables b1 = (s == r), initialized to true, and b2 = (s == r+1), initialized to f alse, with a slight modification of the corresponding involved transitions.
The abstraction refinement of processes Mmedium and Amedium is the identity relation.
Accordingly, the new property Ok = b1 [?]
b2 can be checked.
The abstraction refinement of each TA by its corresponding finite abstraction has been checked using a manual proof of the refinement ref in between their ETTSbased semantics, where both local and global spaces have been considered.
The local space refinement Rl consists in: (a) the correspondence of local states; (b) the identity of local variables values.
However, for the global space, the refinement Rg consists to: (a) match the values of b1 and b2 of the abstract system to the corresponding expressions computed through s and r in the concrete system; (b) check the identity between the other shared variables values.
We may write then ref in = RlSender [?
]RlReceiver [?
]RlM medium [?
]RlAmedium [?
]Rg .
This result has been checked using UPPAAL and a manual proof of refinement using observers.
Acknowledgment.
We wish to thank the anonymous referee for his scrutinous reading and valuable remarks.
R EFERENCES [1] R. Alur.
Timed automata.
In 11th International Conference on Computer Aided Verification, volume 1633 of LNCS, pages 8-22.
1999.
[2] A. Arnold.
Finite transition systems: semantics of communicating systems.
Prentice Hall International Ltd., Hertfordshire, UK, 1994.
[3] A. Basu, M. Bozga, and J. Sifakis.
Modeling heterogeneous real-time components in BIP.
In SEFM'06, pages 3-12.
IEEE Computer Society, 2006.
[4] G. Behrmann, A. David, and K. G. Larsen.
A Tutorial on Uppaal.
Department of computer science, Aalborg university, 2004.
[5] J. Bengtsson and W. Yi.
Timed automata: Semantics, algorithms and tools.
In Lectures on Concurrency and Petri Nets, pages 87-124. volume 3098 of LNCS, Springer-Verlag, 2004.
[6] B. Berard, M. Bidoit, A. Finkel, F. Laroussinie, A. Petit, L. Petrucci, and P. Schnoebelen.
Systems and Software Verification - Model-Checking Techniques and Tools.
Springer-Verlag Berlin, 2001.
[7] J. Berendsen and F. Vaandrager.
Compositional Abstraction in RealTime Model Checking.
In FORMATS'08, pages 233-249, 2008.
[8] B. Berthomieu, J. Bodeveix, M. Filali, H. Garavel, F. Lang, F. Peres, R. Saad, J. Stoecker, F. Vernadat, P. Gaufillet, and F. Lang.
The syntax and semantics of FIACRE.
Technical report, 2009.
[9] G. Bhat, R. Cleaveland, and G. Luttgen.
Dynamic priorities for modeling real-time.
In FORTE X/PSTV XVII '97, Osaka, pages 321- 336.
Chapman and Hall, 1996.
[10] J. P. Bodeveix, A. Boudjadar, and M. Filali.
An alternative definition for timed automata composition.
In ATVA'11, pages 105 -119, Taiwan, 2011.
LNCS 6996.
[11] S. Bornot, G. Gossler, and J. Sifakis.
On the construction of live timed systems.
In TACAS'00, pages 109-126, 2000.
[12] A. Boudjadar, J.-P. Bodeveix, and M. Filali.
Revising and extending the UPPAAL communication mechanism.
In SC'12, volume LNCS 7306, pages 114 - 131.
Springer Heidelberg, 2012.
[13] P. Bremond-Gregoire, I. Lee, and R. Gerber.
ACSR: An algebra of communicating shared resources with dense time and priorities.
In CONCUR, pages 417-431, 1993.
[14] E. M. Clarke, D. E. Long, and K. L. McMillan.
Compositional model checking.
In LICS'89, pages 353-362, 1989.
[15] R. Cleaveland, G. Luttgen, and V. Natarajan.
Priority in process algebras.
Information and Computation, 87:58-77, 1999.
[16] A. David, J. Hakansson, K. G. Larsen, and P. Pettersson.
Model checking Timed Automata with Priorities Using DBM Subtraction.
In FORMAT'06, pages 128-142.
LNCS volume 4202, 2006.
[17] E. Fersman, P. Pettersson, and W. Yi.
Timed Automata with asynchronous processes: Schedulability and decidability.
In TACAS'02, pages 67-82.
Volume LNCS 2280, Springer-Verlag, 2002.
[18] G. Gossler and J. Sifakis.
Priority systems.
In FMCO'03, pages 314- 329, 2003.
[19] F. He, H. Zhu, W. Hung, X.
Song, and M. Gu.
Compositional abstraction refinement for timed systems.
In TASE'10, pages 168 -176, 2010.
[20] T. A. Henzinger, Z.
Manna, and A. Pnueli.
Timed transition systems.
1992.
[21] C. A. R. Hoare.
Communicating Sequential Processes.
Prentice-Hall, 1985.
[22] P.-A.
Hsiung and S.-W. Lin.
Model checking timed systems with priorities.
In RTCSA'05, pages 539-544, USA, 2005.
[23] H. E. Jensen, K. G. Larsen, and A. Skou.
Scaling up Uppaal: Automatic Verification of Real-Time Systems using Compositionality and Abstraction.
In FTRTFT'00, pages 19-30, 2000.
[24] K. G. Larsen, P. Pettersson, and W. Yi.
Uppaal in a nutshell.
In Journal on software tools for technology transfert, 1997.
[25] R. Milner.
Communication and Concurrency.
Prentice Hall Ltd., 1989.
[26] M. Nielsen, G. Rozenberg, and P. Thiagarajan.
Transition-systems, event structures, and unfoldings.
Information and Computation, 118:191 - 207, 1995.
[27] M. Nielsen, G. Rozenberg, and P. S. Thiagarajan.
Elementary transition systems.
Theoritical Computer Science, pages 3-33, 1992.
[28] G. J. Veltink and S. Mauw.
Algebraic Specification of Communication Protocols.
Cambridge Tracts in Theoretical Computer Science No.
36, 2008.
[29] S. Yovine.
Model checking Timed Automata.
In Lectures on Embedded Systems.
Lecture Notes in Computer Science 1494, Springer-Verlag, 1998.
V. C ONCLUSION In this paper, we have studied the refinement and composition of different timed systems with priorities.
For the parallel composition operator we have defined, we give a corresponding (compositional) refinement relation.
As a semantic model, our compositional framework has been successfully instantiated to define a compositional semantics of networks of timed automata, in which an unique generalized dynamic priority system of ETTS is defined from both NTA priority orders (channels, TA) with an important refinement property stating that: if each individual TA of an NTA refines another individual TA of another NTA, then the ETTS corresponding to the semantics of the first NTA refines the ETTS corresponding to the semantics of the second NTA.
Furthermore, the theorems established within our framework have been proved 4 .
In the future, we wish to extend our framework by other concepts, like assume-guarantee properties, in order to model and to analyze the semantics of the Fiacre language [8].
3 In fact, it is checked upto the size of UPPAAL integers, then UPPAAL throws an out of range exception.
4 Proofs will be available in the forthcoming PhD thesis of Abdeldjalil Boudjadar.
64