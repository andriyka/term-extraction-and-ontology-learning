Author manuscript, published in "14th International Symposium on Temporal Representation and Reasoning (TIME), France (2007)"  On the Equivalence of Automaton-based Representations of Time Granularities Ugo Dal Lago Dipartimento di Scienze dellaInformazione, UniversitaE di Bologna, Italy dallago@cs.unibo.it Angelo Montanari Dipartimento di Matematica e Informatica, UniversitaE di Udine, Italy montana@dimi.uniud.it  hal-00878435, version 1 - 30 Oct 2013  Gabriele Puppis Dipartimento di Matematica e Informatica, UniversitaE di Udine, Italy puppis@dimi.uniud.it  Abstract A time granularity can be viewed as the partitioning of a temporal domain in groups of elements, where each group is perceived as an indivisible unit.
In this paper we explore an automaton-based approach to the management of time granularity that compactly represents time granularities as single-string automata with counters, that is, BuEchi automata, extended with counters, that accept a single infinite word.
We focus our attention on the equivalence problem for the class of restricted labeled single-string automata (RLA for short).
The equivalence problem for RLA is the problem of establishing whether two given RLA represent the same time granularity.
The main contribution of the paper is the reduction of the (non-)equivalence problem for RLA to the satisfiability problem for linear diophantine equations with bounds on variables.
Since the latter problem has been shown to be NP-complete, we have that the RLA equivalence problem is in co-NP.
1.
Introduction The notion of time granularity comes into play in a number of computer science scenarios, ranging from the specification and verification of timed workflow systems to the management of temporal constraints, from the design of temporal databases to temporal data mining applications.
According to a commonly accepted perspective, any time granularity can be viewed as the partitioning of a temporal domain in groups of elements, where each group is perceived as an indivisible unit (a granule).
Most granularities of practical interest are modeled as infinite sequences  of time granules, which present a repeating pattern and, possibly, temporal gaps within and between granules.
A number of different formalisms to finitely represent infinite time granularities have been proposed in the literature [11], based on algebraic [3, 15, 17, 18], logical [5, 10], stringbased [20], and automaton-based [7, 4] approaches.
We restrict our attention to the automaton-based approach.
First, we introduce single-string automata and we show that they are as expressive as Wijsenas string-based models.
Next, we show how to extend single-string automata with counters to take advantage of regularities of modeled granularities.
Besides making the structure of the automata more compact, this allow us to efficiently deal with those granularities which have a quasi-periodic structure.
Single-string automata with counters are then used to provide an effective solution to the equivalence problem for granularity specifications.
The decidability of such a problem implies the possibility of effectively testing the semantic equivalence of two different specifications, thus making it possible to use smaller, or more tractable, representations in place of bigger, or less tractable, ones.
The rest of the paper is organized as follows.
In Section 2 we define the notion of time granularity and we briefly describe the string-based model of time granularities.
In Section 3 we outline the distinctive features of the automatonbased approach, focusing our attention counters and multiple transitions, and we show how the fundamental problem of granularity equivalence can be formulated in terms of the proposed class of automata.
In addition, we briefly analyze the relationships between the automaton-based approach and the logical one.
In Section 4 we introduce Restricted Labeled single-string Automata and we provide a formal characterization of the words they recognize.
Fi-  Day  ...  ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  Week  ...  ... 1  BusinessWeek  2  4  ...  ... 1  BusinessMonth  3  2  3  4  ...  ... 1  Figure 1.
Some examples of time granularities.
nally, in Section 5 we show how the equivalence problem for RLA can be efficiently solved by reducing it to the satisfiability problem for linear diophantine equations with bounds on variables.
The last section provides an assessment of the work and outlines future research directions.
periodically group instants of the temporal domain (most granularity applications are only concerned with such a kind of structures), one can easily succeed in representing and manipulating them through finite objects.
In [20], Wijsen proposes a string-based framework for time granularities.
Infinite granularities are modeled as infinite words over an alphabet consisting of three symbols, namely, fi (filler),  (gap), and o (separator), which are respectively used to denote time points covered by some granule, to denote time points not covered by any granule, and to delimit granules.
A typical example is the infinite (ultimately periodic) word fififififi o fififififi o ..., which represents the granularity BusinessWeek over the temporal domain of days.
In order to guarantee a one-to-one correspondence between infinite strings and granularities, as well as to ease the treatment of the problems of granularity equivalence and granule conversion, Wijsen introduces an aligned form for string-based specifications of granularities.
Such a form forces any separator o to occur immediately after an occurrence of fi.
As pointed out by Dal Lago and Montanari [7], if we encode each occurrence of the substring fi o by a single symbol J, we align the symbols of the string-based representation and the elements of the temporal domain, thus establishing a one-to-one correspondence between strings and granularities.
Formally, we say that an D infinite word w a {fi, , J} represents a granularity G + if, for every t, x a N , we have t a G(x) iff w[t] 6=  and the substring w[1, t a 1] contains exactly x a 1 occurrences of J.
In the following, we shall adopt this simplified setting to represent granularities.
In particular, we can identify ultimately periodical granularities with ultimately periodic words and we can finitely represent them by specifying their prefix and repeating pattern.
Hence, any (finite or infinite) ultimately periodic time granularity can be modeled as an ordered pair (u, v) of finite words over the alphabet {fi, , J}, called granspec, where v differs from the empty string Il.
As an example, the granularity BusinessWeek is represented by the granspec (Il, fifififiJ).
hal-00878435, version 1 - 30 Oct 2013  2.
A Framework for Time Granularity The idea underlying all different notions of time granularity that have been proposed in the literature is that any time granularity can be viewed as a suitable partition of a fixed temporal domain.
The temporal domain is usually assumed to be left-bounded and discrete (for instance, the linear order (N+ , <)).
As a matter of fact, one of the main motivations for such an assumption is the observation that most problems of practical interest involve granularities that are ultimately periodic with respect to a fixed bottom granularity and left-bounded (that is, they have an initial granule).
It should be also noted that, by viewing (Z, <) as the disjoint union of (N+ , <) and its reverse order, it is not difficult to extend any given formalism from the case of left-bounded granularities to the case of bi-infinite granularities (the interested reader can read [19] for an application of such an idea in the field of formal languages and automata).
Definition 1.
A time granularity is a partition G of a subset T of the temporal domain (N+ , <) such that for every pair of distinct sets g, g 0 a G (hereafter called granules), either t < t0 holds for all t a g, t0 a g 0 or t0 < t holds for all t a g, t0 a g 0 .
The ordering on N+ induces an ordering on the set of granules of G: given g, g 0 a G, g < g 0 holds iff t < t0 holds for every t a g, t0 a g 0 .
Such an ordering naturally yields a labeling of granules: we say that x is the label of a granule g a G, and we write G(x) = g, if g is the x-th element of G according to the induced order <.
Note that Definition 1 captures both granularities that cover the whole temporal domain, such as Day and Week, and granularities with gaps within and between granules, like, for instance, BusinessWeek and BusinessMonth (see Figure 1).
Clearly, since the set of all structures that satisfy Definition 1 is uncountable, it is not possible to deal with all possible granularities by means of a finitary formalism.
However, by restricting to those granularities that, ultimately,  3.
From Strings to Automata The idea of viewing granularities as ultimately periodic words naturally connects time granularity to the fields of 2  s6    s5  J  As for the repeating pattern of the ultimately periodic word recognized by an SSA, one can exploit Knuth-MorrisPratt string matching algorithm [14] to compute the first non-trivial occurrence of v in v AV v (if v occurs as a substring in v AV v starting from the position i > 1, then v[1, i a 1] is the minimum repeating pattern of u AV v D , for any finite word u).
These properties lead to a straightforward algorithm that tests the equivalence of two given single-string automata M and N in time O(|M | + |N |), where |M | and |N | denote the number of states of M and N , respectively.
s4   fi  s0  fi  s1  fi  s2  fi  s3  Figure 2.
An SSA representing BusinessWeek.
hal-00878435, version 1 - 30 Oct 2013  formal languages and automata.
An automaton-based approach to time granularity, which generalizes the stringbased one in several respects, was originally proposed in [7].
The basic idea underlying the automaton-based approach to time granularity is the following one: we take a sequential BuEchi automaton M recognizing a single infiD nite word w a {fi, , J} (hence the name single-string automaton) and we say that M represents the granularity G iff w represents G.  3.1.
Counters and Multiple Transitions A major limitation of both string-based and automatonbased formalisms is that, whenever the granularity to be represented has a long prefix and/or a long repeating pattern, they produce lengthy representations.
As an example, recall that leap years recur with exactly the same pattern every 400 years; then, it is easy to see that the size of any granspec/SSA representing years (or months) of the Gregorian Calendar in terms of days, must have size greater than 105 .
In such cases, computations on representations of time granularities may become rather expensive.
In the following, we extend and refine the automaton-based approach by introducing counters in order to compactly encode redundancies of temporal structures.
Precisely, we exploit the possibility of activating different transitions from the same (control) state and we rule them through guards envisaging the values of the counters.
Definition 2.
A single-string automaton (SSA for short) is a quadruple M = (S, IL, I', s0 ), where aV S is a finite set of states, aV IL is a finite alphabet (usually {fi, , J}), aV I' is a total transition function from S to IL A S, aV s0 a S is the initial state.
The run of M is the (unique) pair (s, w) a S D A ILD such that s[1] = s0 and, for every i > 0, I' s[i] = w[i], s[i + 1] .
We say that w is the infinite word recognized by M if there exists s a S D such that the pair (s, w) is the unique run of M .
It is immediate to see that singlestring automata capture all and only the ultimately periodic granularities, namely, those granularities that can be represented by granspecs.
Figure 2 depicts an SSA representing the granularity BusinessWeek.
Definition 3.
An extended single-string automaton (ESSA for short) is a tuple M = (S, I, IL, I', Il, s0 , c0 ), where aV S is a finite set of control states, aV I is a finite set of counters, whose valuations belong to the set CI of functions from I to N, aV IL is a finite alphabet, aV I' is a total primary transition function from S to CI CI A IL A S, aV Il is a partial secondary transition function from S to LI A CI CI A IL A S, with LI being a suitable logical language interpreted over N with free variables belonging to I, aV s0 a S is the initial state, aV c0 a CI is the initial valuation.
The equivalence problem for SSA-based representations of time granularities trivially reduces to testing whether two given SSA recognize the same ultimately periodic word (i.e., automata equivalence problem).
Such a problem can be easily solved in linear time with respect to the number of states of the involved automata: given two SSA M and N recognizing two ultimately periodic words w1 and w2 , (i) compute the minimum prefix u1 (respectively, u2 ) and the minimum repeating pattern v1 (respectively, v2 ) of w1 (resp.
w2 ), and (ii) test whether u1 = u2 and v1 = v2 (notice that this holds iff w1 = w2 , namely, M and N are equivalent SSA).
As regards the prefix of the ultimately periodic word recognized by an SSA, one can exploit the following property to test whether u is the minimum prefix of w = u AV v D : u is the minimum prefix of w = u AV v D iff u[|u|] 6= v[|v|] (if this is not the case, then consider the proper prefix u[|u|a1] instead of u).
As in the case of single-string automata, the run of an ESSA is unique.
In order to formally define it, we need to introduce the notion of configuration.
A configuration for an ESSA M is a pair state-valuation (s, c), where s a S and c a CI .
The transitions of M are taken according to a total function aM : S A CI a IL A S A CI such that i) if Il(s) = (D, D, a, r) and c satisfies D, then aM (s, c) = (a, r, D(c)), 3  j mod 12 = 0 i a 0; j a 0; k a k + 1 J  fi  s7  i a 0; j a j + 1  s8  i  s0 i a i+1  a  i mod 26 = 0  s1  k mod 400 6= 200 aSS k mod 400 6= 300  fi  j mod 12 6= 10  J  k mod 400 6= 100 aSS  j mod 12 = 6 8 aSS  j  1  j mod 12 = 6 5 aSS  0;  +  s6  k mod 4 = 0 aSS  fi  j a  j mod 12 = 1  s5  j mod 12 = 6 3 aSS  J  fi  s2  fi  fi  s3  fi  s4  fi  fi i a 0; j a j + 1 J  i a 0; j a j + 1  hal-00878435, version 1 - 30 Oct 2013  J  Figure 3.
An ESSA representing Month.
ii) if Il(s) is not defined or c does not satisfy the formula in the first component of Il(s), then aM (s, c) = (a, r, D(c)), where I'(s) = (D, a, r).
Intuitively, a secondary transition of an ESSA is activated if its guard is satisfied by the valuation c; otherwise, a primary transition is activated.
The (unique) run of an ESSA M is then defined as the triple (s, c, w) a S D A CID A ILD such that (i) s[1] = s0 , (ii) c[1] = c0 , and (iii) aM (s[i], c[i]) = (w[i], s[i + 1], c[i + 1]) for all i > 0.
Given an ESSA M and its (unique) run (s, c, w), we say that w is the word recognized by M .
ondary transitions, several fundamental problems turn out to be undecidable.
As an example, if we allow guards of the form x = 0 and update operators of the form x a x a 1 and x a x + 1, then the halting problem for Minsky (twocounters) machines [16] can be easily reduced to the equivalence problem for ESSA, thus showing that the latter problem is undecidable.
In [7], Dal Lago and Montanari suggest to i) restrict to guards which are conjunctions of atomic formulas of the form t1 = t2 or t1 6= t2 , where both t1 and t2 are integer constants or terms of the form i mod d, with i a I and d a N+ ; ii) restrict to update operators which are functional compositions of the basic operators i a 0 and i a i + 1, where i ranges in I and the operator i a 0 (respectively, i a i + 1) maps a valuation c to the valuation c[0/i] (respectively, c[c(i) + 1/i]), with c[x/i] denoting the valuation such that c[x/i](i) = x and c[x/i](j) = c(j) for every j 6= i.
An interesting example of ESSA is given by Figure 3 which depicts an ESSA representing the granularity Month in terms of the granularity Day.
The automaton uses three counters, i, j, and k, to store the index of the current day, current month, and current year, respectively.
Each counter is initialized to 0, that is, the initial valuation c0 is such that c0 (i) = c0 (j) = c0 (k) = 0.
Control states are represented by circles, while transitions are represented by arrows annotated with the update operators.
e.g., j a j + 1, and the recognized symbol, e.g., fi).
Primary and secondary transitions are identified by continuous and dashed arrows, respectively; secondary transitions have guards, e.g., k mod 4 = 0, which are specified as additional annotations of the corresponding dashed arrows.
The resulting class of automata, called reducible extended single-string automata (shortly RESSA), is expressive enough to compactly encode granularities of practical interest and well behaved, namely, they guarantee decidability results for many relevant problems.
As an example, the automaton in Figure 3 is a RESSA.
Moreover, one can effectively map a RESSA to an equivalent SSA, thus proving that RESSA are as expressive as (but more compact than) SSA.
The equivalence between RESSA and SSA is obtained by defining, for any given RESSA M , an abstraction rela-  From the above example, it is clear how ESSA can be exploited to compactly encode redundancies of temporal structures.
However, the notion of ESSA is too general to be of practical interest: if we do not restrict the set of admissible formulas and update operators for primary and sec4  hal-00878435, version 1 - 30 Oct 2013  tion over the configurations of M , which turns out to be an equivalence of finite index compatible with the transition function aM (see [2, 10] for similar constructions).
Formally, we say that a relation az over a (possibly infinite) set X is compatible with a function f : X a X iff, for every x, x0 a X, x az x0 implies f (x) az f (x0 ).
If M = (S, I, IL, I', Il, s0 , c0 ) is a RESSA and, for each counter i a I, di is the least common multiple of all constants d that appear inside terms of the form i mod d in Il(S), then we can define the relation az =M over the set SACI of configurations of M in such a way that (s, c) az =M (s0 , c0 ) 0 0 iff s = s and, for all i a I, c(i) = c (i) (mod di ).
It is easy to show that az =M is an equivalence of finite index which is compatible with the transition function aM .
As a matter of fact, according to the classification introduced by Henzinger and Majumdar [13], this means that RESSA belong to the first class of symbolic transition systems (i.e., infinite-state systems having finite bisimilarity quotients).
One can also prove that there is an exponential bound on the size of the SSA equivalent to a given RESSA.
This shows that the equivalence problem for RESSA is in EXPTIME.
propositional letters are replaced with formulas of the form D[i1 xj1 , ..., ik xjk ], which are obtained by substituting il xjl for all free occurrences of yl in the IPC++ -formula D(y1 , ..., yk ), for l = 1, .
.
.
, k. A model of a PLTLmod formula is an infinite sequence of valuations, namely, a function of the form c : N A {x, y, ...} a Z.
As an example, we show the encoding of some granularities of the Gregorian Calendar taken from [10].
These granularities are modeled as infinite sequences of valuations for the corresponding integer variables as follows: aV sec aA60 0 aSS (0 a$?
sec < 60 aSS sec aA60 sec + 1), aV min aA60 0 aSS (0 a$?
min < 60 aSS (sec = 59 a min aA60 min + 1) aSS (sec 6= 59 a min = min)), aV hour aA24 0 aSS (0 a$?
hour < 24 aSS (min = 59 aSS sec = 59 a hour aA24 hour +1) aSS (min 6= 59 a" sec 6= 59 a hour = hour )), aV day aA7 0 aSS (0 a$?
day < 7 aSS (hour = 23 aSS min = 59 aSS sec = 59 a day aA7 day + 1) aSS (hour 6= 23 a" min 6= 59 a" sec 6= 59 a day = day)),  3.2.
The logical counterpart of RESSA  aV as for the granularities Month and Year, one can encode them by fixing some end dates far ahead in the time line (such an assumption is necessary since we cannot use constraints like year = year + 1 without incurring in undecidability [6, 10]).
In [10] Demri describes a logical framework that allows one to express, in a concise way, integer periodicity constraints over a linear temporal domain.
The formalism is based on a fragment of Presburger linear temporal logic, denoted PLTLmod .
More precisely, the logical language is obtained by combining PLTL (i.e., linear temporal logic with past-time operators) with a suitable first-order constraint language IPC++ , whose formulas are built via standard Boolean connectives and existential quantifications, starting from basic atomic formulas of the form x = d, x < d, x > d, x = y, x aAk d, and x aAk y + [d1 , d2 ], where x, y, ... are variables interpreted over Z and d, k, d1 , d2 , ... are integer constants.
Given a valuation c : {x, y, ...} a Z for the variables x, y, ..., the semantics of an atomic formula is the obvious one: aV c  (x = d) iff c(x) = d, aV c  (x < d) iff c(x) < d, aV c  (x > d) iff c(x) > d, aV c  (x = y) iff c(x) = c(y), aV c  (x aAk d) iff c(x) aAk d, aV c  (x aAk y + [d1 , d2 ]) iff c(x) aAk c(y) + d for some d1 a$?
d a$?
d2 .
The constraint language IPC++ is a strict fragment of Presburger arithmetic [12].
The language PLTLmod can be viewed as the temporalization (via PLTL) of IPC++ .
Formally, let i xj be the value of the variable xj at the i-th successor of the current time point.
PLTLmod formulas are PLTL formulas whose  Notice that no propositional variables appear in PLTLmod .
However, any propositional variable P can be easily encoded by an IPC++ -formula of the form xP = 1, where xP is a fresh variable associated with P .
Demri shows that, like plain LTL but unlike full Presburger LTL, PLTLmod enjoys a PSPACE-complete satisfiability problem [10].
Such a result is achieved by first defining suitable automaton-based representations for (abstracted) models of PLTLmod -formulas and then by reducing the satisfiability problem to the emptiness problem for these automata.
In [10], Demri establishes an interesting connection between RESSA and linear temporal logics with integer periodicity constraints by reducing the equivalence problem for RESSA to a satisfiability problem for a suitable fragment of PLTLmod .
To this end, the guards associated with RESSA secondary transitions are rewritten as Boolean combinations of formulas like x aAk d and a z.
(x aAk z aSS y aAk0 z), and thus they belong to a (strict) fragment of IPC++ , denoted IPCa in [10].
Let PLTLa be the Presburger LTL fragment obtained by combining PLTL and IPCa .
Demri shows that the equivalence problem for RESSA is reducible to the satisfiability 5  problem for PLTLa -formulas or, equivalently, to the emptiness problem for a suitable class of BuEchi automata, where the input symbols are atomic IPCa -formulas.
The size of the formulas corresponding to a given instance of the equivalence problem for RESSA is shown to be polynomially bounded with respect to the size of the automata, thus proving that the equivalence problem for RESSA is in PSPACE.
Such a result improves the previously known EXPTIME upper bound given by Dal Lago and Montanari in [7].
Moreover, in [10] a reduction from the satisfiability problem for quantified boolean formulas to the equivalence problem for RESSA is also given, thus showing that the equivalence problem for RESSA is actually PSPACEcomplete.
 J  D Figure 4.
An RLA representing Monday.
circles, while states in SIl are represented by triangles.
Primary and secondary transitions are represented by continuous and dashed arrows, respectively.
The (initial values of) counters are associated with states in SIl (for the sake of readability, we depict them as labels of the secondary transitions exiting states in SIl ).
4.
Restricted Labeled Single-string Automata  hal-00878435, version 1 - 30 Oct 2013  6  Definition 4.
A restricted labeled (single-string) automaton (RLA for short) is a tuple M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ), where aV SIL and SIl are disjoint finite sets of (control) states (hereafter, we shall denote by S the set SIL aS SIl ); aV IL is a finite alphabet; aV aS : SIL a IL is a total labeling function; aV I' : S * S is a partial primary transition function whose transitive closure I' + is irreflexive (namely, it never happens that (s, s) a I' + ); aV Il : SIl a S is a total secondary transition function such that for every s a SIl , (Il(s), s) a I' + ; aV s0 a S is the initial state; aV c0 : SIl a N+ aS {D} is the initial valuation.
In this section we introduce a new class of automata, called restricted labeled single-string automata (RLA for short), which are an attempt to find a suitable trade-off between the handiness of SSA and the compactness of (reducible) ESSA [9].
RLA are similar to RESSA, since they exploit counters to compactly encode repeating patterns of time granularities.
However, the distinctive feature of this class of automata lies in the structure of the transition functions, which is now more restricted.
As an example, we define a uniform policy of counter update.
By exploiting such restrictions, we will be able to devise improved algorithms for several problems on time granularities, including the equivalence one.
Counters of RLA range over the natural numbers extended with a special value D; they can be either set to their initial value or decremented (we tacitly assume that n < D for all n a N and D a 1 = D).
Let us denote by CSIl the set of all valuations of the form c : SIl a (N aS {D}) for the counters of an RLA M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ).
A configuration for M is a pair (s, c), where s a S and c a CSIl .
The transitions of M are taken according to a partial function aM : S A CSIl * S A CSIl satisfying the following conditions: i) if s a SIL and I'(s) is defined, then aM (s, c) = (I'(s), c), namely, if the automaton lies in a labeled state and there is an exiting primary transition, then it takes the primary transition, which does not change the valuation, ii) if s a SIl and c(s) > 0, then aM (s, c) = (Il(s), c0 ), where c0 = c[c(s) a 1/s], namely, if the automaton lies in a non-labeled state whose counter has a positive value, then it takes the secondary transition and it decrements the counter by 1, iii) if s a SIl , c(s) = 0, and I'(s) is defined, then aM (s, c) = (I'(s), c0 ), where c0 = c[c0 (s)/s], namely,  We now give an intuitive description of RLA structure and behavior.
First of all, to simplify the notation and the formalization of properties, labels are moved from transitions to states.
Moreover, the set of states is partitioned into two groups, respectively denoted by SIL and SIl .
SIL is the set of states where the labeling function is defined, while SIl is the set of states where it is not defined.
Furthermore, like in the case of ESSA, we distinguish between two kinds of transition, respectively called primary and secondary transitions.
At any point of the computation, at most one (primary or secondary) transition is taken according to an appropriate rule envisaging the state at which the automaton lies and the value of the counter associated with that state.
Primary transition functions can be defined in any state, while secondary transition functions are only defined in non-labeled states.
A primary transition can be taken in a non-labeled state s only once the secondary transition associated with s has been consecutively taken c0 (s) times, where c0 (s) is the initial valuation for the counter associated with s. Figure 4 depicts an RLA recognizing the word (J6 )D , which represents the granularity Monday in terms of the granularity Day.
States in SIL are represented by IL-labeled 6  hal-00878435, version 1 - 30 Oct 2013  As an example, if we denote by s0 the initial state of the RLA of Figure 4, by s1 its successor, by s2 the top-most state, and by s3 the right-most state, we have that  if the automaton lies in a non-labeled state whose counter has value 0 and if there is an exiting primary transition, then it takes the primary transition and it reinitializes the counter, iv) if none of the above conditions holds, then aM (s, c) is undefined.
Notice that, since aM may be not defined on some configurations, the run of an RLA may be finite.
The run of an RLA M is defined as follows.
Let X a be the set of all (finite and infinite) words over X, namely, X a = X a aS X D .
The run of an RLA M is the pair (s, c) a S a A CSaIl of maximum (possibly infinite) sequences of states and valuations such that (i) s[1] = s0 , (ii) c[1] = c0 , and (iii) aM (s[i], c[i]) = (s[i + 1], c[i + 1]) for all 1 a$?
i < |s| (= |c|).
Given the RLA M and its run (s, c), one can extract a (finite or infinite) sequence of a labeled states sIL a SIL by discarding the valuations and the non-labeled states.
Such a sequence is said to be the labeled run of M .
We say that M recognizes the word w iff w = aS(sIL ) (here aS is extended from states to sequences of states in the natural way).
aV the I'-degree of s0 (respectively, s1 , s2 , s3 ) is 2 (respectively, 1, 2, 0), aV the Il-degree of s1 is 1 and the Il-degree of s3 is 2, aV IM = {(s1 , s3 )} and IaM consists the pair in IM plus the pairs (s1 , s1 ) and (s3 , s3 ).
For every state s, let DsM be the finite or infinite word inductively defined as follows: aV if s a SIL , then DsM = aS(s), aV if s a SIl and m is the Il-degree of s, then DsM = c0 (s) M M DIl(s) AV DI'(Il(s)) AV ... AV DI'Mma1 (Il(s)) .
The well-definedness of DsM directly follows from the principle of Il-induction.
RLA-recognizable words can be characterized as expressions like (fi4 J2 )D and fi6 ((fi2 )2 2 )D , which feature nested repetitions, as stated by the following proposition.
Notice that Definition 4 allows situations where states and transitions of an RLA form an unconnected (directed) graph.
We can overcome these clumsy situations by discarding useless states and transitions.
Since counters of reachable configurations range over finite domains, it is immediate to see that RLA recognize either finite or ultimately periodic words.
Proposition 1 (Dal Lago, Montanari, Puppis [9]).
The word recognized by an RLA M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ) is of M the form DsM0 AV DI'(s AV ... AV DI'Mn (s0 ) , where n is the I'-degree 0) of s0 .
4.2.
A Complexity Measure for RLA  4.1.
RLA-recognizable Words  We now briefly describe a measure of complexity for RLA (for further details, we refer the reader to [9]).
Besides the usual complexity measure based on the number of states of the automaton, there is another natural complexity measure which takes into account the nesting structure of RLA transition relations.
Such a complexity measure plays a fundamental role in the analysis of main algorithms on RLA [9] and it will be used in the next section in the proof of one basic lemma.
For every state s of an RLA M and every integer n, let CM s,n be defined as follows (here we use double induction on s and n, where the ordering for the first, dominant, argument is induced by the relation IaM ):  The solution to the equivalence problem for RLA takes advantage of the following characterization of the words recognized by RLA, based on the notions of I'-degree and Il-degree of states.
The I'-degree of a state s a S is the (unique) natural number n such that I' n (s) is defined, but I' n+1 (s) is not.
For instance, the initial state of the automaton of Figure 4 has I'-degree 2.
For each non-labeled state s a SIl , the Ildegree of s is the least n a N such that (Il(s), s) a I' n .
For instance, the lower-middle state of the automaton of Figure 4 has Il-degree 1.
The notion of Il-degree can then be used to represent the nested structure of RLA transitions in terms of a binary relation IM over the set SIl defined as follows: (s, r) a IM iff s = I' i (Il(r)), where i is less than the Il-degree of r. Note that the reflexive and transitive closure IaM is antisymmetric, namely, (s, r) a IaM and (r, s) a IaM imply s = r. Thus, IaM can be given the status of a well-founded partial order over the set of non-labeled states.
Such a partial order immediately suggests an induction principle, called Ilinduction, which we will extensively use in both definitions and proofs.
aV if n < 0, then CM s,n = 0; aV if n aL 0, s a SIL , and I'(s) is undefined, then CM s,n = 1; aV if n aL 0, s a SIL , and I'(s) is defined, then CM s,n = M 1 + CI'(s),na1 ; aV if n aL 0, s a SIl , m is the Il-degree of s, and I'(s) is M undefined, then CM s,n = 1 + CIl(s),ma1 ;  7  aV if n aL 0, s a SIl , m is the Il-degree of s, and I'(s) is M M defined, then CM s,n = 1+max CI'(s),na1 , CIl(s),ma1 .
equivalence of two given RLA in non-deterministic polynomial time.
Our solution is based on a reduction of the non-equivalence problem to a number-theoretic problem, precisely, the problem of testing the satisfiability of linear diophantine equations, where variables are constrained by lower and upper bounds.
hal-00878435, version 1 - 30 Oct 2013  The complexity kM k of M is defined as kM k = CM s0 ,n , where s0 is the initial state of M and n is the I'-degree of 2 s0 .
It is easy to show that kM k a$?
|M | .
As an example, the complexity of the automaton in Figure 4 is 6.
We start by giving some preliminary definitions.
The operations of addition + and multiplication AV in Z can be naturally extended to the power-set 2Z as follows: if S, T a Z, then S + T = {x + y a Z : x a S, y a T } and S AV T = {x AV y a Z : x a S, y a T }.
By a slight abuse of notation, we shall write expressions of the form k AV S, denoting the set {k AV x : x a S}.
Furthermore, we call interval any subset of Z of the form [i, j] = {x : i a$?
x a$?
j}, where i a Z aS {aD} and j a Z aS {D}.
The running time of several algorithms operating on RLA-based representations of time granularities, e.g., granule conversion ones, can be expressed in terms of the complexities of the involved automata.
This is the case, for instance, with simple algorithms that look for occurrences of particular symbols in the word recognized by a given RLA M , which require time O(kM k).
In many cases, the running time of such algorithms turns out to be sub-linear with respect to the number of transitions to be taken to reach the addressed symbol occurrence, thus showing that algorithms working on RLA-based representations outperform those running on equivalent granspecs/SSA.
As an example, by exploiting the optimization algorithms described in [9], we can obtain an RLA representing the granularity Month in terms of days with 87 control states and complexity 14.
Both these values are significantly less than the size of any equivalent granspec/SSA (see Section 3).
Such an automaton is described by the following expression: a  Intuitively, the idea underlying our solution to the equivalence problem for RLA is to represent the set of positions of all the occurrences of a labeled state in the labeled run of an RLA M by a union of m distinct sets of the form k1 I1 + ... + kn In , where the values m and n are polynomially bounded with respect to the number of states of M and each Ij is a suitable interval of Z.
Given two RLA M and N , one can decide whether M and N recognize the same infinite word by testing the emptiness of every set resulting from the intersection of two expressions E1 and E2 , where E1 represents the positions of the occurrences of an a-labeled state of M and E2 represents the positions of the occurrences of a b-labeled state of N , with a 6= b.
The latter problem can then be reduced to the problem of testing the non-satisfiability of some linear diophantine equations with lower and upper bounds on the variables.
Even though the satisfiability problem for linear diophantine equations with bounds on variables is known be NPcomplete, several solutions that perform well in practice (even on equations with thousands of variables) have been proposed in literature (see, for instance, [1]).
The above argument shows that the equivalence problem for RLA is in co-NP.
We provide no proof of the co-NPhardness of the equivalence problem for RLA.
As a matter of fact, we conjecture that the problem can be solved by a deterministic algorithm which takes polynomial time with respect to the size of the input automata.
Unfortunately, at the moment we are only able to provide a non-deterministic algorithm for the non-equivalence problem of RLA.
a ` A'2 a2 fi2 (fi28 J)2 fi30 (Jfi29 )2 fi J a  aa  a  AT AT a ` A'2 a2 3 25 fi3 (fi27 J)2 fi30 (Jfi29 )2 fi J  AT a ` A'2 a2 4 fi3 (fi27 J)2 fi30 (Jfi29 )2 fi J a ` A'2 a2 fi2 (fi28 J)2 fi30 (Jfi29 )2 fi J a  AT AT AT a ` A'2 a2 3 24 3 fi3 (fi27 J)2 fi30 (Jfi29 )2 fi J  !D  The above arguments account for the compactness and tractableness of RLA compared to granspecs/SSA.
5.
The Equivalence Problem for RLA In this section we focus our attention on the equivalence problem for RLA-based representations of time granularities.
As we previously pointed out, two single-string automata represent the same time granularity iff they accept the same ultimately periodic word.
In Section 3 the equivalence problem for RESSA has been shown to be solvable in polynomial space with respect to the size of the input automata.
Here we show that in the case of RLA we can devise a more efficient algorithm, which tests the (non-)  The argument can be formalized as follows.
Given an RLA M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ), let us denote by (s, c) its (unique) run and by sIL the corresponding labeled run.
Without loss of generality, we can temporarily assume that aS is the identity function, which maps a labeled state s to itself (hence, we have IL = SIL ).
Such an assumption allows us to think of DsM , as defined in Section 4, as a se8  quence of labeled states, rather than a sequence of symbols.
From Proposition 1, we immediately have  4: 5: 6:  M AV ... AV DI'Mn (s0 ) , sIL = DsM0 AV DI'(s 0)  7: 8:  where n is the I'-degree of s0 .
In addition, for every nonlabeled state s a SIl , with Il-degree m, we set:  9: 10: 11:  M M M DM s = DIl(s) AV DI'(Il(s)) AV ... AV DI' ma1 (Il(s)) .
12: 13:  hal-00878435, version 1 - 30 Oct 2013  To keep track of the set of positions of any labeled state, we introduce the notion of (p, q-succinct) linear progression.
14: 15: 16: 17:  Definition 5.
Given a set P a Z and two positive integers p, q, we say that P is a p, q-succinct linear progression if there exist m a$?
p, n1 , ..., nm a$?
q, k1,1 , ..., k1,n1 , ..., km,1 , ..., km,nm a Z, and someSintervalsP I1,1 , ..., I1,n1 , ..., Im,1 , ..., Im,nm such that P = 1a$?ia$?m 1a$?ja$?ni ki,j Ii,j .
18: 19: 20: 21: 22: 23: 24: 25:  For every s a SIL , every r a S, and every n a Z less than or equal to the I'-degree of s, we denote by Ps,r,n the set of positions of all the occurrences of s in the sequence M AV ... AV DI'Mn (r) .
Clearly, the set of positions of all DrM AV DI'(r) the occurrences of s in the labeled run sIL of M is Ps,s0 ,n , where n is the I'-degree of s0 .
26: 27: 28:  Now, by exploiting the definition of DrM , we can easily verify the following recursive equations:  else if r a SIL then if I'(r) = aL then if r 6= s then return a else return {1} end if else P a 1 + RLAPositions(M, s, I'(r), n a 1) if r 6= s then return P else return {1} aS P end if end if else m a Il-degree(r) P a RLAPositions(M, s, Il(r), m a 1) + |DM r | a [0, c0 (r) a 1] if I'(r) = aL then return P else Q a RLAPositions(M, s, I'(r), n a 1) + |DrM | return P aS Q end if end if  The following lemma shows that the set Ps,r,n is actually 2 2 an |S| , |S| -succinct linear progression.
aV Ps,r,n = a, if n < 0; aV Ps,r,n = a, if n aL 0, r a SIL \ {s}, and I'(r) is undefined;  Lemma 2.
For every s a SIL , every r a S, and every n a Z less than or equal to the I'-degree of r, Ps,r,n is a 2 2 |S| , |S| -succinct linear progression.
aV Ps,r,n = {1}, if n aL 0, r = s, and I'(r) is undefined; aV Ps,r,n = Ps,I'(r),na1 + 1, if n aL 0, r a SIL \ {s}, and I'(r) is defined;  aV Ps,r,n = {1} aS Ps,I'(r),na1 + 1 , if n aL 0, r = s, and I'(r) is defined;  Proof.
First of all, note that the succinct linear progressions satisfy the following properties (compositionality): aV if P is a p, q-succinct linear progression, then P + kI is a p, q + 1-succinct linear progression for every integer k and every interval I,  aV Ps,r,n = Ps,Il(r),ma1 + |DM r | AV [0, c0 (r) a 1], if n aL 0, r a SIl , m is the Il-degree of r, and I'(r) is undefined;  M aV Ps,r,n = Ps,Il(r),ma1 + |D | AV [0, c (r) a 1] aS 0 r  M Ps,I'(r),na1 + |Dr | , if n aL 0, r a SIl , m is the Ildegree of r, and I'(r) is defined.
aV if P is a p, q-succinct linear progression and P 0 is a p0 , q 0 -succinct linear progression, then P aS P 0 is a p + p0 , max (q, q 0 )-succinct linear progression.
Now, on the grounds of the recursive definition of Ps,r,n , for every pair of states s, r and every integer n, we can write [ X Ps,r,n = ki,j Ii,j  The above equations lead to a straightforward procedure RLAPositions(M, s, r, n) that computes (a progressionbased representation of) the set Ps,r,n for the automaton M .
1a$?ia$?m 1a$?ja$?ni  RLAPositions(M, s, r, n) 1: let M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ) 2: if n < 0 then 3: return a  for some integers m, n1 , ..., nm and then denote by pr,n (respectively, qr,n ) a suitable upper bound for m (respectively, for n1 , ..., nm ).
Clearly, Ps,r,n is a pr,n , qr,n -succinct linear progression, where pr,n and qr,n may depend on r and n, 9  but not on s. Moreover, by exploiting the compositionality of succinct linear progressions, we can assume that pr,n and qr,n satisfy the following recursive equations:  Moreover, the values defining each term of P of the form k AVI can be represented using polynomial space with respect to the size of the automaton (here the size of the automaton comprises the number of the control states and the size of the initial valuation for the counters).
This basically means that the size of P is polynomially bounded by the size of the automaton.
It also follows that RLAPositions(M, s, s0 , n) takes polynomial time with respect to the size of the input.
aV pr,n = 0, if n < 0; aV pr,n = 1, if n aL 0, r a SIL , and I'(r) is undefined; aV pr,n = 1 + pI'(r),na1 , if n aL 0, r a SIL , and I'(r) is defined; aV pr,n = pIl(r),ma1 , if n aL 0, r a SIl , m is the Il-degree of r, and I'(r) is undefined;  We conclude the section by showing how to reduce the non-equivalence problem for RLA to the satisfiability problem for linear diophantine equations.
aV pr,n = pIl(r),ma1 + pI'(r),na1 , if n aL 0, r a SIl , m is the Il-degree of r, and I'(r) is defined;  Theorem 4.
Two RLA M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ) and 0 N = (SIL , SIl0 , IL, aS0 , I' 0 , Il 0 , s00 , c00 ) recognize two different 0 words iff there exist a state s a SIL and a state s0 a SIL , 0 0 with aS(s) 6= aS (s ), such that  aV qr,n = 0, if n < 0;  hal-00878435, version 1 - 30 Oct 2013  aV qr,n = 1, if n aL 0, r a SIL , and I'(r) is undefined; aV qr,n = 1 + qI'(r),na1 , if n aL 0, r a SIL , and I'(r) is defined;  Ps aS Qs0 6= a,  aV qr,n = 1 + qIl(r),ma1 , if n aL 0, r a SIl , m is the Il-degree of r, and I'(r) is undefined;  where Ps (respectively, Qs0 ) is the set of positions of all the occurrences of s (respectively, s0 ) in the labeled run of M (resp.
N ).
aV qr,n = 1 + max (qI'(r),na1 , qIl(r),ma1 ), if n aL 0, r a SIl , m is the Il-degree of r, and I'(r) is defined.
Proof.
If M and N recognize two different words, say w and w0 , we let i be the first position such that w[i] 6= w0 [i].
We then define s = sIL [i] and s0 = s0IL .
Clearly, aS(s) 6= aS(s0 ) holds and i belongs to both Ps and Qs0 .
Conversely, if M and N recognize the same word w, then w = aS(sIL ) = aS0 (s0IL ), where sIL (respectively, s0IL ) is the labeled run of M (respectively, N ).
This implies that, for every s a SIL and 0 , with aS(s) 6= aS0 (s0 ), Ps aS Qs0 = a holds.
s0 a SIL  Finally, by exploiting double induction on r and n, it is easy to verify that ( ) 0 i    t = I' (r), 0 a$?
i a$?
n,   2 pr,n a$?
t, t0 :  a$?
|S| 0 0 a  t = t a SIL a" (t, t ) a IM  2  qr,n = CM r,n a$?
|S| .
Let P and Q be two linear progressions.
If we write [  P = ki,1 Ii,1 + ... + ki,ni Ii,ni ,  Consider now the generic case of an RLA whose labeling function aS is not necessarily the identity function.
1a$?ia$?m  Q=  Proposition 3.
For every RLA M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ) and every labeled state s a SIL , the set of positions of 2 2 all the occurrences of s in sIL is a |S| , |S| -succinct linear progression.
[   hi,1 Ji,1 + ... + hi,n0i Ji,n0i ,  1a$?ia$?m0  then we have P aS Q 6= a  Proof.
Given an RLA M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ), we define a new RLA M 0 = (SIL , SIl , SIL , aS0 , I', Il, s0 , c0 ), where aS0 (s) = s for every s a SIL .
Clearly, the labeled run of M coincides with the labeled run of M 0 .
Therefore, the claim trivially follows from Lemma 2.  iff, for some 1 a$?
i a$?
m and 1 a$?
i0 a$?
m0 , the following linear diophantine equation with bounds on variables is satisfiable: dLa dL' dL,ki,1 xi,1 + ... + ki,ni xi,ni = hi0 ,1 yi0 ,1 + ... + hi0 ,ni yi0 ,n0i0 a 1 a$?
j a$?
ni .
min(Ii,j ) a$?
xi,j a$?
max (Ii,j ) dL' dLl a 1 a$?
j a$?
n0i0 .
min(Ji0 ,j ) a$?
yi0 ,j a$?
max (Ji0 ,j )  As a consequence of Proposition 3, we have that the set of positions of all the occurrences of a labeled state in the labeled run of an RLA can be effectively represented by a succinct linear progression P , where the number of its terms (i.e., sets of the form k AV I) is polynomially bounded by the number of control states of the automaton.
Checking the satisfiability of a generic linear diophantine equation with bounds on variables is known to be an NP-complete problem.
As a matter of fact, as regards the NP-hardness, one can reduce the well-known subset sum 10  hal-00878435, version 1 - 30 Oct 2013  problem (i.e., given a finite set Z of integers, decide whether there exists a subset Z 0 of Z that exactly sums to 0) to the satisfiability problem for linear diophantine equations.
More precisely, given a finite set Z = {k1 , ..., kn } of integers, we define the linear diophantine equation k1 z1 + ... + kn zn = 0, where each variable zi can be either 0 or 1.
It clearly follows that the equation is satisfiable iff Z is a positive instance of the subset sum problem.
Even though the satisfiability problem for linear diophantine equations with bounds on variables is NPcomplete, several efficient algorithms, based on non-trivial properties of rings and lattices, have been proposed in the literature, e.g., [1].
These algorithms can solve (systems of) linear diophantine equations with thousands of variables in a reasonable time and thus they can be effectively exploited to test the emptiness of sets resulting from the intersection of two linear progressions.
Then, we focused our attention on equivalence problems for automaton-based specifications of time granularities, proving that (i) the equivalence problem for single-string automata is decidable in linear time, (ii) the equivalence problem for reducible extended single-string automata is decidable in polynomial space and it is complete for such a class (this result is due to Demri [10]), and (iii) the (non)equivalence problem for restricted labeled single-string automata is decidable in non-deterministic polynomial time.
As for the non-equivalence problem for restricted labeled single-string automata, we exactly showed that it can be reduced to the satisfiability problem for linear diophantine equations with bounds on variables.
This latter problem is known to be NP-complete, which immediately provides an upper bound to the complexity of the original problem.
However, it remains an open question to establish whether such an upper bound is optimal or not, that is, to establish whether the equivalence problem for restricted labeled single-string automata is co-NP-complete or not.
It is conceivable that the equivalence problem for restricted labeled single-string automata may enjoy a deterministic polynomial-time solution, as happens, for instance, for a number of different problems over restricted labeled singlestring automata, e.g., granule conversion problems and optimization problems [8, 9].
The following (non-deterministic) algorithm solves the non-equivalence problem for RLA (namely, it has a computation that returns true iff the two input automata were not equivalent) by reducing it to the satisfiability problem for linear diophantine equations.
RLANonEquivalence(M, N ) 1: let M = (SIL , SIl , IL, aS, I', Il, s0 , c0 ) 0 , SIl0 , IL, aS0 , I' 0 , Il 0 , s00 , c00 ) 2: let N = (SIL 3: n a I'-degree(s0 ) 4: for all s a SIL do 5: P [s] a RLAPositions(M, s, s0 , n) 6: end for 7: n0 a I'-degree(s00 ) 0 do 8: for all s0 a SIL 9: Q[s0 ] a RLAPositions(N, s0 , s00 , n0 ) 10: end for 0 11: choose s a SIL , s0 a SIL with aS(s) 6= aS0 (s0 ) 0 12: if P [s] aS Q[s ] 6= a then 13: return true 14: else 15: return false 16: end if  Acknowledgements We would like to thank the anonymous referees for their useful remarks and constructive criticisms.
References [1] K. Aardal, C. A. Hurkens, and A. Lenstra.
Solving a system of linear diophantine equations with lower and upper bounds on the variables.
Mathematics of Operations Research, 25(3):427a442, 2000.
[2] R. Alur and D. Dill.
A theory of timed automata.
Theoretical Computer Science, 126:183a235, 1994.
[3] C. Bettini, S. Jajodia, and X. Wang.
Time Granularities in Databases, Data Mining, and Temporal Reasoning.
Springer, July 2000.
[4] D. Bresolin, A. Montanari, and G. Puppis.
Time granularities and ultimately periodic automata.
In Proceedings of the 9th European Conference on Logics in Artificial Intelligence (JELIA), volume 3229 of LNCS, pages 513a525.
Springer, 2004.
[5] C. Combi, M. Franceschet, and A. Peron.
Representing and reasoning about temporal granularities.
Journal of Logic and Computation, 14:51a77, 2004.
[6] H. Comon and V. Cortier.
Flatness is not a weakness.
In Proceedings of the 14th International Conference on Computer Science Logic (CSL), volume 1862 of LNCS, pages 262a276.
Springer, 2000.
6.
Conclusions In this paper, we considered the problem of modeling time granularities and that of testing the equivalence of their specifications.
We first showed how to finitely represent ultimately periodic time granularities in terms of automata, starting from the most basic notion of automaton (singlestring automaton) and then extending it with counters in order to compactly encode repetitions (extended single-string automaton and restricted labeled single-string automaton).
11  hal-00878435, version 1 - 30 Oct 2013  [7] U. Dal Lago and A. Montanari.
Calendars, time granularities, and automata.
In Proceedings of the 7th International Symposium on Spatial and Temporal Databases (SSTD), volume 2121 of LNCS, pages 279a298.
Springer, 2001.
[8] U. Dal Lago, A. Montanari, and G. Puppis.
Towards compact and tractable automaton-based representations of time granularity.
In Proceedings of the 8th Italian Conference on Theoretical Computer Science (ICTCS), volume 2841 of LNCS, pages 72a85.
Springer, 2003.
[9] U. Dal Lago, A. Montanari, and G. Puppis.
Compact and tractable automaton-based representations for time granularities.
Theoretical Computer Science, 373(1-2):115a141, 2007.
[10] S. Demri.
LTL over integer periodicity constraints.
In I. Walukiewicz, editor, Proceedings of the 7th International Conference on Foundations of Software Science and Computation Structures (FOSSACS), volume 2987 of LNCS, pages 121a135.
Springer, 2004.
[11] J. Euzenat and A. Montanari.
Time granularity.
In M. Fisher, D. Gabbay, and L. Vila, editors, Handbook of Temporal Reasoning in Artificial Intelligence, pages 59a118.
Elsevier, 2005.
[12] S. Ginsburg and E. Spanier.
Semigroups, Presburger formulas and languages.
Pacific Journal of Mathematics, 16(2):285a296, 1966.
[13] T. Henzinger and R. Majumdar.
A classification of symbolic transition systems.
In Proceedings of the 17th International Symposium on Theoretical Aspects of Computer Science (STACS), volume 1770 of LNCS, pages 13a34.
Springer, 2000.
[14] D. Knuth, J. Morris, and V. Pratt.
Fast pattern matching in strings.
SIAM Journal on Computing, 6:323a350, 1977.
[15] B. Leban, D. McDonald, and D. Foster.
A representation for collections of temporal intervals.
In Proceedings of the AAAI National Conference on Artificial Intelligence, volume 1, pages 367a371.
AAAI Press, 1986.
[16] M. Minsky.
Computation: Finite and Infinite Machines.
Prentice-Hall, 1967.
[17] M. Niezette and J. Stevenne.
An efficient symbolic representation of periodic time.
In Proceedings of the International Conference on Information and Knowledge Management (CIKM), pages 161a168, Baltimore, MD, 1992.
ACM Press.
[18] P. Ning, S. Jajodia, and X. Wang.
An algebraic representation of calendars.
Annals of Mathematics and Artificial Intelligence, 36:5a38, 2002.
[19] D. Perrin and P. Schupp.
Automata on integers, recurrence distinguishability, and the equivalence and decidability of monadic theories.
In Proceedings of the Symposium on Logic in Computer Science (LICS), pages 301a304.
IEEE Computer Society, 1986.
[20] J. Wijsen.
A string-based model for infinite granularities.
In C. Bettini and A. Montanari, editors, Proceedings of the AAAI Workshop on Spatial and Temporal Granularities, pages 9a16.
AAAI Press, 2000.
12