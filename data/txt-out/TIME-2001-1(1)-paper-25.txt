Temporal aspects of semistructured data Barbara Oliboni, Elisa Quintarelli, and Letizia Tanca Dipartimento di Elettronica e Informazione Politecnico di Milano Piazza Leonard0 da Vinci, 32-20133 Milano (Italy) oliboni,quintare,tanca@elet.polimi.it  Abstract  have addressed the problem of accessing in a uniform way this kind of semistructured data [l].
Among these, we can cite LOREL [14], UnQL [3], WebSQL [15], WebOQL [2], StruQL [13], G-Log [17].
It is a common approach to represent semistructured data by using data models based on labeled graphs [4,17, 11,5].
As for the classical database field, also in the context of semistructured data it is interesting to take into account the dynamic aspects of data, i.e their evolutions through time and eventually through consecutive updates, in order to query and impose restrictions on how the data changes in time.
To query a temporal database, relational languages must be extended to take into account the time coordinate [191; in the same way ,in the context of semistructured data, models and query languages must be extended in order to consider dynamic aspects.
A work which addresses the problem of representing and querying changes in semistructured data is [6,7].
The authors introduce a model, DOEM, and a language, Chorel, for querying over data and changes.
The model uses annotations on both the nodes and edges of OEM graphs (see [16]) to represent changes.
Intuitively, annotations are the representation of the history of nodes and edges.
To implement DOEM and Chorel they use a method that encodes DOEM databases as OEM databases and translates Chorel queries into equivalent Lore1 queries over the OEM encoding.
With this implementation they allow annotations on a DOEM graph D to be attached to the nodes and edges of a OEM database OD.
In this way, for each object o of D there is a complex object or in OD with some sub-objects, which are required in order to represent the history of the node o, its old values or relationships with other nodes.
This method causes a growth in the number of nodes of the final graph over which it is possible to apply the query.
The main aim of our approach is to overcome this problem: on one hand, we adopt a model which reduces the amount of annotations needed for information representation; on the other hand, we plan to effectively apply model checking techniques as a way to effectively solve queries  In many applications information about the history of data and their dynamic aspects are just as important as static information.
During the last years the increasing amount of information accessible through the Web has presented new challenges to academic and industrial research on database.
In this context, data are either structured, when comingfrom relational or object-oriented databases, or partially or completely unstructured, when they consist of simple collections of text or imagejles.
In the context of semistructured data, models and query languages must be extended in order to consider dynamic aspects.
We present a model based on labeled graphs for representing changes in semistnrctured data and a SQL-likequery language for querying it.
1 Introduction Classical database models represent static aspects of data.
Thus, the information in the database consists of data currently true in the world.
However, in many applications, information about the history of data and their dynamic aspects are just as important as static information.
Consider, for example, records of various kinds: financial, personnel, medical.
When history is taken into account, queries can ask about the evolution of data through time and constraints may restrict the way changes occur [S, 91.
It is clear that this kind of queries is useful whenever data are not static, they change over time and their evolution needs to be taken into account.
During the last years the increasing amount of information accessible through the Web has presented new challenges to academic and industrial research on database.
In this context, data are either structured, when coming from relational or object-orienteddatabases, or partially or completely unstructured, when they consist of simple collections of text or image files.
A number of research projects  0-7695-1107-4101 $10.000 2001 IEEE  119  which are able to take into account static and dynamic aspects of semistructureddata.
When the properties belong to some classes of formulae the problem of finding if a model possesses a given property is decidable and algorithms running in linear time on both the sizes of the model and the formula can be employed [lo].
Consequently it is important to keep the size of semistructureddatabases as small aspossible.
The structure of this paper is as follows.
In Sect.2 we present a graphical data model suitable to represent static and dynamic aspects of semistructured data In Sect.
3 we describe possible changes to a semistructureddatabase and in Sect.
4 we introduce a possible SQL-like query language.
Finally, in Sect.
5 we report some conclusions.
2 A graphical Temporal Data Model for semistructured data  trace of different time intervals when an object exists in the database.
e  can be seen as composed by four single-valuedfunc,Cs, e,.
with abuse of notation, when the tions ern, context is clear, we will use C for nodes and edges: i f e = (m,(t,Ic,w),n), then !,(e) = t, [,,(e) = k, and Cv ( e ) = v. It is also required that:  eLn  (Vx E N)(CTn(x) = complex -+ &(x) = I)(i.e., values are associated to atomic objects only); (Vx E N)(CTn(x)= atomic -+ Cv(x) = I ) (i.e., time multi-intervals are not associated to atomic objects because in the database the time multi-interval of a value coincides with the time multi-interval of its unique ingoing edge);  (V(m, label, n) E E)(CTn( m ) = complex) (i.e., atomic nodes are leaves);  In this section we introduce a data model based on labeled graphs, useful to represent static and dynamic aspects related to semistructureddata.
This choice is general enough to apply to several approaches presented in the literature [11, 17, 141.
In order to represent dynamic aspects of semistructured databases and to allow querying about their evolution through time, we add the information about the time multiinterval of objects and relations to their graph.
In this way, we are able to derive, for example, if a particular information is currently true, or it was true in a previous state, if it has been deleted or updated.
This approach allows us to store the minimal amount of information,in fact we avoid duplicating a lot of nodes and edges.
(V(nz, (relational, ZabeZ),n) E E)(CTn(n) = atomic -+ label = "Has Property") (i.e., each atomic nodti is connected to its parent by an edge labeled "HasProperty").
(Vx E E)(Cx(z)= temporal -+ l v ( x ) = I)(i.e., time multi-intervals are associated to relational edges only); (Vx E E ) ( C z ( z ) = temporal -+ C L e ( z ) = "Temporal")(i.e., the label "Temporal" is associated to each temporal edge).
Note that two nodes may be connected by more than one edge, provided that edge labels be different.
In this, work we assume that each node of a semistructured temporal graph is unequivocally characterized by an identijier.
Moreover, the label of the (unique) root represents the name of the database.
For the sake of readability, in the examples we usually omit the type label of nodes and edges.
Temporal edges are represented by jagged lines.
As we said in Def.
1 we distinguish two kinds of nodes: complex objects, graphically represented by rectangles, and atomic objects, depicted as ovals.
Complex objects are related to other cornplex objects and possibly "possess" a number of attributes (atomic objects), whereas atomic objects represent objects with an atomic value (i.e.
a string, an integer, but also a text, an image, a sound) and do not exist independently of their parent complex object.
For this reason we choose to replicate atomic objects with the same atomic value but connected to different complex objects, although they represent the same printable information.
This is also the reason why we do not associate an independent time multi-intlerval to atomic objects.
For each complex object it  Definition 1 A semistructuredtemporal graph is a directed labeled graph ( N ,E , T , e), where N is a Cfinite)set of nodes, E is a set of labeled edges of the form (m,label, n), with m,n E N , label E (7, x (C,U{I}) x (VU{I})),r E N is the root of the graph, and C : N -+(7,U {I}) x (C, U {I}) x (SU{I})x(VU{I}).
I m e a n s 'undefined',and:  7, = { complex,atomic } is a set of typesfor nodes; 7, = { relationa1,temporal } is a set of types for edges;  L , and C, are sets of labels to be used respectively as names for complex or atomic objects (nodes), and relations (edges).
We require that C, n Le = 8;  S is a set of strings to be used as atomic values;  V is a set of multi-intervalssuch as [tl,t 2 ) U [ts,t 4 ) U .
.
.U[t,-l ,t,), with n > 1, to be used as time intervals for nodes and edges.
We use a multi-interval to keep  120  Assume we are given a time domain T = { t o , t l ,t z , .
.
.
}, discrete and totally ordered.
It is easy to obtain from a semistructured temporal graph the snapshot at time t. In fact: 0  Scourse, [01/01/1997,01/11/2000)~  0  0  Title  Data Bases  Web Data Bases  software Engineering  the original snapshot St, (G) of a semistructuredtemporal graph G, contains exactly those nodes and arcs of G that have as start time to.Note that to is the moment of the database creation, i.e.
when the first object is recorded.
The snapshot at time t St (G) of a semistructuredtemporal graph G, is obtained by considering those arcs and objects of G with a time multi-interval I containing an interval [ti,t i + i ) such that t i t < ti+l.
<  Figure 1.
A semistructuredtemporal graph reporting Faculty data  0  is possible to declare a key,that is a subset of its properties (attributes)that identifies in a univocal way the object itself.
For example, in Fig.
1 we show a semistructuredtemporal graph, called Faculty (note that Faculty is the label of the root node) that represents the information about some teachers and related courses.
In this work we choose to represent transaction time in order to keep trace of information changes, and thus we deal with static rollback databases (see [19, IS]).
By using this approach changes may only be made to the most recent static state, and there is no way to record retroactive/postactive changes, or to correct errors.
Moreover, in this way the history of database activities is recorded.
In this work we will only take care of system or transaction time.
Thus ours is an "append-only'' database: updates are only performed on time multi-intervals.
As explained above, we associate a multi-interval I = [ti, t 2 ) U .
.
.
U [tn-i,t n ) ,with n > 1, to each relational edge and complex object; for each time interval [t ti+l)in I,with i E { 1,. .
.
, n - I}, the instant ti represents the start time, while ti+l, called end time, represents the time instant when that piece of information (node or edge) ceased to be true in the database.
In the following sections, when an entity is currently true, i.e.
it is current in the database at the present time, t , assumes the constant value "now".
This value can be seen as 03 and it does not cause difficulties when it is used as end time, although the time interval is open to the right.
In the examples we propose later in this work, time granularity depends on the application: it may be one day, or one year, etc.
However, our approach will encode instants of time in a discrete fashion.
Conceptually, a temporal database appears as a sequence of states called snapshots, indexed by some time domain.
The current snapshot of a semistructured temporal graph G is the snapshot at time now, i.e.
all the objects and relations of G with a time multi-interval I containing an interval [t,now),for all start times t (note that the constant now is such that now 2 t for each instant of timet).
2.1 Comparison with the DOEM model In [6, 71 the authors propose a model to represent changes in semistructured data, based on the Object Exchange Model (OEM) (see [16]), a simple graph-based data model, with objects as nodes and object-subobject relationships represented as labeled arcs.
Change operations (i.e.
node insertion, update of node values, addtion and removal of labeled arcs) are represented in DOEM (for Delta-OEM) by using annotations on the nodes and arcs of an OEM graph.
For example, in Fig.
2 we show the DOEM graph correspondingto the instance in Fig.
1: note that only edges are labeled with the name of destination objects.
Actually, in both OEM and DOEM edges represent containment relations between objects, and do not allow to indicate different semantic relationships between objects, for this reason our model has a higher expressive power.
Annotations are represented in DOEM by rectangles containing the name of the change operation and the date when the modification occurred.
The DOEM semistructured databases are not directly implemented by using this simple model, but using OEM databases, thus causing a growth in the number of nodes of the final graphs over which queries are applied.
In Fig.
3 we report the OEM database corresponding to DOEM graph in Fig.
2.
Note that in this OEM graph annotations have been encoded into complex objects storing the history of change operations by means of connected sub-objects.
To highlight the difference between our temporal data model and DOEM we consider an update operation to an atomic object, because it clearly distinguishes the two approaches by considering the number of added nodes.
For example, to perform  $,  121  3 Operations  \ Faculty  In this section we list possible changes to a semismc.ured database and how its semistructured temporal graph LS consequently modified.
Let G = (N, E, e) be a semistructured temporal graph.
We consider the following change operations:  I Teacher  Create a complex object create-complex-node(obj, complex, 1 , P, t,,,) creates at time t,,, a node with labels er, (obj) = complex, e,, (obj) = 1 , set of attributes P. This operation Creates also the set of atomic objects P by calling the operation create-atomic-node for all x E P, as described below.
Note that obj is the identifier of the creaited object.
With a create operation, a subset K of P may also be defined as the object key.
When the key IS not declared with this operation, then the object is new,i.e.
obj # N, and [ ~ ( o b j=) [tcre, now).
0therwise, if the key K is declared and there is a complex object 0' in G that was current in a past instant of time, with the same labels and key, then with this operation we add to the multi-intervalof 0'another time interval [ t c r e , now).
Otherwise, if (0')= [t,now) then the creation is rejected.
In Figure 4 we show the creation of the complex object "L-Objl" at time "CreateDatel" and the creation of its atomic object "LAttl", with the same creation date in the "Has Property" edge between "L-Obj 1" and "L Attl": create-complex-node(obj 1, complex,L-Obj 1, {obj2}, CreateDatel), where obj2 is an atomic object with label L A t t l and value Value.
t:1m1/99  t 1/01/99  Software Engineering WebDa Bases  ov: Data Bases  Figure 2.
A DOEM semistructured database  .
the update on the Title of the Course previously called Data Bases, into Web Data Bases in the semistructured graph of Fig.
1, we only add an atomic object with the new name, whereas in DOEM the number of added nodes is shown in the dashed region of Fig.
3.
Note that we add the minimum piece of information to keep trace of the update.
d - o b j l , [Creae-Datel, now)>  Val%  Figure 4.
A complex object has been created  b  ........................................
-.
?-  Figure 3.
A OEM semistructured database  122  Create an atomic object create-atomic-node(obj,objp,atomic, 1 , s, tCre) creates at time t,,, a node with labels l ~ , ( o b j ) = atomic, CL, (obj) = 1, &(obi) = s andCv(obj) = I, and whose parent is obj,.
Moreover, we create an edge frorn the parent complex object obj, to the atomic object itself, with label "Has Property" and time multiinterval [t,,, ,now).
Note that an atomic object is always connected to a complex object, because it represents a property of the complex object, and thus the  ~  time interval of its ingoing edge must be contained in a interval of its parent.
0  Remove a relation (between complex objects) remove-edge(obj1,label, objz, t,,,) removes at time  t,,, an existing edge.
The operation modifies the time multi-interval of the edge from [t1, t 2 ) U .
.
.
U [tn-l,t n ) U [t,now) to [tl,t 2 ) U .
.
.
U [t,-l, tn) U [t,t,,,).
In Figure 7 we show the deletion of the relation "Rell" at time "RemDateT: remove-edge(obj1,R e l l , obj2, RemDate2).
Note that if we remove an edge (objl, label, obj2) we do not delete the object objz, although it is not reachable, because it is a current object (i.e.
it is currently true) that could be useful for further change operations.
Remove an object remove-node(obj,k,t,,,)  removes at time trem the current node with identifier obj (if it exists).
This operation merely consists of modifying the time multiinterval of the node, if it is a complex object, or of the ingoing edge, if it is an atomic object, from [tl,t z ) U .. .
U [tn-l,tn)U [ t , n m )to [ t l ,t 2 ) U .. .
U [tn-l,tn)U [t,t,,,).
If the object is complex, in order not to leave dangling references, we have to modify the time multi-interval of all its ingoing and outgoing edges.
Formally, for each edge e = (m,label, obj) or e = (obj,label,n) with [,(e) = [ t l ,t 2 ) U .
, .
U [tn--l,tn)U [ t , n m ) ,we set [,(e) = [ t l , t 2 ) U .
.
.
U [tn-l,tn) U [t,trem).
In Figure 5 we show the deletion of the complex object "L-Objl" in date "RemDatel" and the deletion of its atomic object "LAttl": remove-node(obj1, complex, RemDatel).
L cL-Objl, [Create-Datel, now)>  Figure 7.
A relation has been removed  <L_Objl, [Create-Datel, Rem-Datel)> 0  Val"EUR-  above (note that the deletion date is t u p d ) , then we create a new object, i.e.
we add an atomic node, with a new identifier obj2 and the same father of objl, to the set of nodes N , and create a temporal edge from the old object objl to the new object objz, labeled with "Temporal".
In Figure 8 we show the change of the value of "LAttl" (we suppose its identifier is Attl) at time "ChangeDate2": update(Att1,Oldvalue, Newvalue, ChangeDate2).
Figure 5.
An object has been removed  0  Create a relation create-edge(obj1,label, obj2, t,,,) adds at time t,,, an edge labeled label between objl and objz.
Obviously, objl and obj2 must be existing and current complex objects.
This operation does not make sense between a complex and an atomic object because properties, represented by means of atomic objects, are part of complex objects.
With this operation we add to the temporal graph the relational edge (objl, (relational, label, [t,,,, now)),obj2).
In Figure 6 we show the new relation "Rell" created in date "CreateDate2" between the complex objects "L-Objl" and "L-ObjT: create-edge(obj1,R e l l , objz, CreateDate2).
1  Update a value update(obj1, old-value, new-value, t u p d ) changes at time t u p d the value of an atomic object from old-value to new-value.
In order to compute this operation we remove the atomic object objl as described  Old Value  New Value  Figure 8.
A value has been updated  I , 3.1 Example c L O b j l , [Create-DaIel, now)?
eRell, [Create-Date2, now)>  11 I  When we create a semistructured database we create a set of objects with their relations.
In Figure 9 we show a database containing a teacher and a course: each element has its time multi-interval which contains at the beginning only an interval.
Note that if an object is currently true, the  d-Obj2, [Create-Date2, now)>  Figure 6.
A relation has been created  123  end time is now.
We now suppose to create the database of Figure 9 at time 01/01/1997, consequently all the objects have as time multi-interval [01/01/1997, now).
CTacher.
[01/01/1997.
now)>  Mary Jones  C T ~ C I I~~o ,i m 1 / 1 ~ 7 ,  Figure 11.01/01/1999: a new course has been added  doursc, [01/01/1997, now)> &Propmy,  [01/01/1997, now)>  Figure 9.01/01/1997: Initial database At time 01/01/1998 we suppose to add a new teacher who also teaches "Software Engineering".
Accordingly to the previous definitions, the new objects and the new edge have as time multi-interval [01/01/1998, now).
-  Figure 12.
01/01/2000: changed  a value has been  In date 01/11/2OOO we remove the "Software Engineering'' course (Figure 13).
To delete one existing object we change the time multi-interval of the object itself and of its "Has Property" edges too.
In this case we change the time multi-interval of the "Course" node named "Software Engineering", of its "Title" property (with the: ingoing edge "HasProperty"), and of the relation "Teitches" (between the teacher John Smith and the course "Software Engineering"), from [01/01/1997, now) to [01/011/1997,01/11/2000).
Figure 10.01/01/1998: a new teacher has been added  Now let us suppose that at time 01/01/1999 we add a new course with title "DataBases" (and time multiinterval [01/01/1999, now)) (see Figure 11).
We also suppose that the teacher Mary Jones stops teaching "Software Engineering" and starts teaching the new course.
The time multi-interval of the correspondent relation "Teaches" between "Teacher" (Mary Jones) and "Course" ("Software Engineering") changes from [01/01/1997, now) to [01/01/1997, 01/01/1999)1 Note that the time multiinterval of the "Software Engineering" course does not change because the course still exists.
In date 01/01/2000 the title of "Data Bases" course changes in "Web Data Bases".
In this case, as shown in Figure 12, we add the new atomic object with label "Web Data Bases" and change the time multi-interval of the old object from [O1/01/1999, now) into [O1/01/1999,0l/Ol/2OOO).
We also add a temporal edge with label "Temporal" between the two atomic objects.
124  coramsB-p  -  lOW"lW9  ..D  8.-)  mp  .**bD#.
*-  -1omm59l  ov,mp  --8==w  Figure 13.
01/11/2000: an object has been deleled  In date 01/01/2001 the previously deleted course "Software Engineering" and its property "Title" become current again (Figure 14).
With this operation we add to the time multi-intervals of the objects course and title (actually, of the ingoing edge of the title atomic object) an interval [01/01/2001, ncno),so the current multi-intervals become [01/01/1997,01/11/2000) U [01/01/2001, now).
not give a precise grammar for the graphical version of our language, but it is quite intuitive to associate a meaning to the graphical counterpart of each specific query.
A work which addresses the problem of comparing and translating graphs and textual queries is [12].
More in detail, we represent complex objects with thin line rectangles and atomic objects with thin line ovals.
Each object has a label composed by its name and the time interval (note that we represent a generic interval with I).
The part of the graph depicted with thin lines represents the conditions specified in the WHERE clause (i.e.
the structure of required information).
A bold square links the result of the query (i.e.
the object specified in the SELECT clause).
Figure 14.
01/01/2001: a deleted object has been added  4 TS-QL: Temporal Semistructure Query Language  Query 1.
Find the names of the teachers who were working (i.e.
teaching at least one course) in 1998.
In this section we give an informal overview of the semantic concepts of the SQL-like query language TS-QL, syntactically specified in Appendix 4.1, aimed at querying semistructured data modeled by means of semistructured temporal graphs (see Sect.
2).
We use the concept of path expression, which identifies a path on the information graph.
The path expression has to start and finish with a node label and may contain wildcards.
The SELECT clause specifies the form of the result of a query by means of a list of path expressions.
In particular the result is a set of paths in the instance graph.
A path expression may contain different wildcard characters, whose meaning is the following:  SELECT Teacher.HasProperty.Name FROM Faculty WHERE EXISTS Teacher.Teaches.Course AND Teacher.Teaches -+ INTERVAL (begin "01/01/1998"  OR begin before "01/01/1998")  AND end after "01/01/1998" This query requires to find in the Faculty database the name of those Teacher objects connected to at least a Course object by means of an edge labeled Teaches, such that its time multi-interval is composed also by an interval which contains the year "1998".
The EXISTS clause is needed because this is a semistructured database, thus in principle no constraint imposes that the Teaches edge should end with the node of type Course.
In the SQL-like query these requirements are specified through paths, which are graphically depicted in Fig.
15.
Note that the time intervals of the reported objects are generic, and thus replaced with the symbol I, while the interval of the edge Teaches is specified as described in the WHERE clause.
The result of this query applied to the database depicted in Fig.
13 are the Teacher objects with names Mary Jones and John Smith.
represents a sequence (eo, 01, el, .
.
.,on,e,) with n 2 0.
Note that if n = 0 the sequence is composed by an edge.
represents a sequence (eo) or (eo, 01, el).
represents a sequence (eo,01, e l , .
.
.
,on, en), with n 2 0 and (ei) = Temporal for all 1 5 i 5 n 1.
Note that if n = 0 then the sequence is composed by a unique temporal edge.
+  The FROM clause contains a list of database names (actually, a list of root node labels of semistructured temporal graphs) and specifies the name of the databases (i.e.
their temporal graphs) to be considered as informationsources.
The WHERE clause specifies some conditions (possibly linked by connectives AND, OR) on objects or sub-objects matching the SELECT clause.
It is thus possible to define restrictions on the values of atomic objects or on the time intervals of nodes and edges.
Now we show some examples of queries on a database called Faculty; Fig.
13 reports a part of its semistructured temporal graph.
Note that here time granularity is "one day".
For each query we report the SQL-like form based on the grammar described in Appendix 4.1, and a possible correspondent graphical representation.
In this work we do  Figure 15.
Example of visual query Find the names of teachers who were working in 1998  Query 2.
Find the names of teachers who were teaching the "Data Bases" course in 1999.
125  SELECT FROM  WHERE  AND  SELECT  Course.HasProperty.Title.#.Title FR.OM Faculty WHlERE Course.HasPmperty.Title = "Data Bases"  Teacher.HasProperty.Name Faculty  Teacher.Teaches.Course.HasProperty.Name = "Data Bases"  Teacher.Teaches + INTERVAL (begin "01/01/1999" OR begin before "01/01/1999") AND end after "01/01/1999"  4.1  Grammar of TS-QL  In this subsection we introduce a preliminary grammar for the language TS-QL.
We plan to add new temporal operators to the language and the possibility to express nested queries arid constraints.
This query is rather similar to the previous one, but a restriction on the value of the course name is imposed.
In this case we do not have the EXISTS condition in the WHERE clause because we need to f h d a precise Course object.
The graphical version is in Fig.
16, here the name of the Course object is specified under the representation of the atomic object Name.
<query>::= SELECT [<label> AS] <select list> [FROM <from list> ] [WHERE [<label> AS] <condition>  I  <select list>::= <general path expression>, <select list>l <general path expression> <general path expression>::= <node label>I <object label>.<edge label>.<general path expression>I <object label>.<wildcard>.<general path expression>I <attribute label>.#.<attribute label> <node label>::= <object label>I <attribute label> <wildcard>::=  Figure 16.
Example of visual query Find the names of teachers who were teaching the "Data Bases" course in 1999  <from hi>::= <DB label>, <fromlist>l <DB label> <condition>::= <condition> OR <condition>I <condition> AND <condition> I <predicate>  Query 3.
Find the current name of the course called "Data Bases".
SELECT FROM WHERE  * I?
<predicate>::= EXISTS <general path expression>I <complex path expression> <op> <value>) <complex path expression> <op> <complex path expression> 1 <general path expression>.<temporal path expression> <temporal condition>  Course.HasProperty.Title.Temporal.Title Faculty Course.HasProperty.Te = "Data Bases"  The peculiarity of this query is the use of a temporal edge in order to find the current name of the Course previously called Data Bases-andthus, the temporal edge is required to retrieve the value of an atomic object that was updated.
<complex path expression>::= <attribute label>l <node label>.<edge label>.<complex path expression>I <node label> .<wildcard>.<complex path expression> I <temporal path expression>::= <object label> + INTERVAL I <edge label> + INTERVAL <temporall condition> ::= <temporal op> <value>I <interval op><general path expression>.<temporal path expression>I <interval op> <interval values> I <temporal condition> AND<temporal condition> I <temporal condition> OR<temporal condition>  D..Ba  Figure 17.
Example of query Find the current name of the course called Data Bases  <op>::==  I >1<1>=  I =<I  =!
=  <temporal op>::= begin I end 1 begin before 1 end before I begin after I end after  Note that in order to find all the names of the course called "Data Bases" we have to write the following query:  126  <interval op>::= precede I overlap I equal  [SI J. Chomicki.
Temporal integrity constraints in relational databases.
IEEE Data Engineering Bulletin, pages 33-37,  The intuitive meaning of the remaining nonterminals is the following: <label> <DB label> <attribute label> <object label> <attribute label> <edge label> <value> <interval values>  June 1994.
Special Issue on Database Constraint Management.
[9] J. Chomicki.
Temporal query languages: a survey.
In Proc.
Intemational Conference on Temporal Logic, pages 506534.
Springer-Verlag.
July 1994.
[lo] E. M. Clarke, E. A. Emerson, and A. P. Sistla.
Automatic verification of finite-state concurrent system using temporal logic specification.
ACM Trans.
Program.
Lang.
Syst., 8(2):244-263, 1986.
[ll] M. Consens and A. Mendelzon.
Graphlog: a visual formalism for real life recursion.
In Proc.
of the Ninth  a string a database name a node name a complex node name a atomic node name an edge label a constant string a constant interval  5 Conclusion  ACM SIGACT-SIGMOD-SIGARTSymposium on Principles of Database Systems, April 1990.
In this work we have introduced a graphical data model for representing static and dynamic aspects of semistructured data and we have proposed the SQL-like query language TS-QL.
We plan to give a precise semantics and'a graphical counterpart to this language, and to apply model checking techniques and algorithms to efficiently solve the data retrieval problem.
[12] E. Damiani, B. Oliboni, L. Tanca, and D. Veronesi.
Using wg-log schemata to represent semistructured data.
In Proc.
of the Eighth Working Conference on Database Semantics (DS-S),pages 331-349, January 1999.
[13] M. Femandez, D. Florescu, A.
Levy, and D. Suciu.
A query language for a web-site management system.
SIGMOD Record (ACM Special Interest Group on Management of Data), 26(3):4-11, September 1997.
References  [14] J. McHugh, S. Abiteboul, R. Goldman, D. Quass, and J. Widom.
Lore: a database management system for SIGMOD Record, 23(3):54-66, semistructured data.
September 1997.
[15] A. Mendelzon, G. Mihaila, and T. Milo.
Querying the world wide web.
In Proceedings of the Fourth Conference on Parallel and Distributed Information Systems, December 1996.
[ 161 Y. Papakonstantinou, H. Garcia-Molina,and J. Widom.
Object exchange across heterogeneous information sources.
In P. S. Yu and A. L. P. Chen, editors, Proceedings of the Eleventh lntemational Conference on Data Engineering, March 6-10, 1995, Taipei, Taiwan, pages 251-260.
IEEE ComputerSociety, 1995.
[ 171 J. Paredaens, P. Peelman, and L. Tanca.
G-Log: A Declarative Graphical Query Language.
IEEE Trans.
on Knowledge and Data Eng., 7(3):436-453, 1995.
[ 181 N. L. Sarda.
HSQL: A Historical Query Language.
In Temporal Databases: Theory, Design, and Implementation, Benjamin/Cu"ings 1993, pages 110-140.
[l] S. Abiteboul.
Querying Semi-structured Data.
In Proc.
of the 6th Intemational Conference on Database Theory, pages 1-18, Lecture Notes in Computer Science 1186, 1997.
[2] G. Arocena and A. Mendelzon.
WebOQL: Restructuring documents, databases, and webs.
In Proc.
of the 14th International Conference on Data Engineering, pages 336-350.
IEEE Computer Society Press, 1998.
[3] P. Buneman, S. B. Davidson, G. G. Hillebrand, and D. Suciu.
A Query Language and Optimization Techniques for Unstructured Data.
In H. c!
Jagadish, Inderpal Singh Mumick (Eds.
): Proceedings of the 1996 ACM SIGMOD International Conference on Management of Data, Montreal, Quebec, Canada, pages 505-516, June 1996.
[4] P. Buneman, S. B. Davidson, G. G. Hillebrand, and D. Suciu.
Adding structure to unstructured data.
In Database Theory; Sixth Intemational Conference Proceedings, pages 336-350, 1997.
[5] S .
Ceri, S. Comai, E. Damiani,P.
Fratemali, S. Paraboschi, and L. Tanca.
XML-GL a graphical language for querying and restructuring xml documents.
In Proceedings of the eight International World wide Web Conference WWWS, Toronto, Canada, May 1999.
[6] S. S. Chawathe, S. Abiteboul, and J. Widom.
Representing and querying changes in semistructured data.
In Proceed-  [19] R. Snodgrass and I. Ahn.
A taxonomy of time in databases.
In Proc.
of ACM SIGMOD Intemational Conference on Management of Data, pages 236-246, May 1985.  ings of the Fourteenth Intemational Conference on Data Engineering, February 23-27, 1998, Orlando, Florida, USA, pages 4-13.
IEEE Computer Society, 1998.
[7] S. S. Chawathe, S. Abiteboul, and J. Widom.
Managing historical semistructured data.
Theory and Practice of Object Systems, 5(3):143-162, 1999.
127