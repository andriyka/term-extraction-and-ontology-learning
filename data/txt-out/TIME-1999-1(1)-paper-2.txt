Symbolic Representation of User-defined Time Granularities Claudio Bettini Roberto De Sibi DSI, University of Milan via Comelico 39, 20135 Milan, Italy bettini@dsi.unimi.it, rdesibi@it.oracle.com  Abstract In the recent literature on time representation, an effort has been made to characterize the notion of time granularity and the relationships between granularities, in order to have a common framework for their specification, and to allow the interoperability of systems adopting different time granularities.
This paper considers the mathematical characterization of finite and periodical time granularities, and it identifies a user-friendly symbolic formalism which captures exactly that class of granularities.
This is achieved by a formal analysis of the expressiveness of well-known symbolic representation formalisms.
1.
Introduction There is a wide agreement in the AI and database community on the requirement for a data/knowledge representation system of supporting standard as well as user-defined time granularities.
Examples of standard time granularities are days, weeks, months, while user defined granularities may include businessweeks, trading-days, working-shifts, school-terms, with these granularities having different definitions in different application contexts.
The work in [3, 4] represents an effort to formally characterize the notion of time granularity and the relationships between granularities, in order to have a common framework for their specification and to allow the interoperability of systems adopting different time granularities.
The formal definition, however, is essentially a mathematical characterization of the granules, and it is not suitable for presentation and manipulation by the common user.
The goal of this paper is identifying an intuitive formalism which can capture a significant class of granularities within the formal framework and which is closed for this class with respect to the operations it  allows.
This class can be intuitively described as containing all finite granularities, as well as all periodical ones.
Instead of inventing yet another symbolic formalism for this purpose, in this work we consider some existing proposals, analyzing their expressiveness with respect to our goal.
A symbolic formalism, based on collections of temporal intervals, was proposed in [11] to represent temporal expressions occurring in natural language and used in several application domains like appointment scheduling and time management.
This formalism has been adopted with some extensions by many researchers in the AI [9, 15, 6] and Database area [8, 5].
From the deductive database community, a second influential proposal is the slice formalism introduced in [14], and adopted, among others, in [2].
None of these formalisms and extensions seems to have the expressive power we are seeking, despite some of the proposals include features that go beyond what is needed in our framework.
For example, [6] provides a powerful formalism to represent calendars and time repetition, including existential and universal quantification, which supports the representation of uncertainty, a feature not considered in our framework.
Moreover, some calendar expressions in [6] go beyond the specification of granularities, as defined in [4, 3] and in this paper, allowing the representation of overlapping granules of time.
The formalism can represent recurring events in the form of non-convex intervals, but it does not seem to be able to represent what in the following we call gap-granularities, where gaps may not only occur between one granule and the next, but also within granules.
A business-month seen as an indivisible time granule defined as the union of all business-days within a month is an example.
Relevant work on non-convex intervals and repetition includes [10, 13], but the emphasis in these works is more on reasoning with qualitative relations than on calendar expression representation.
In addi-  tion to the research cited above, significant work on time granularity includes [16, 12, 7].
The contribution of this paper is twofold: on one side we give results on the expressiveness of the formalisms proposed in [11] and [14] which we identify as the two basic approaches to symbolic representation, while, on the other side, we propose an extension to one of these formalisms that allows to capture exactly the class of finite and infinite periodical granularities we defined in [3].
In the next section we introduce the formal notion of time granularity.
In Section 3 we briefly describe the collection and slice symbolic representation formalisms, and we evaluate their expressiveness and formal properties.
In Section 4, we propose an extension to the collection formalism to capture gapgranularities, and we conclude the paper in Section 5.
Appendix A summarizes the syntax of the symbolic formalism, and Appendix B contains the proofs of the results in the paper.
2.
Characterization of time granularities In this section we introduce the mathematical characterization of time granularities as proposed in [4] and further refined and summarized in [3].
Granularities are defined with respect to an underlying time domain, which can be formally characterized simply as a set whose elements arefiordered by a relation ship.
For example, integers , natural numbers  	   , rational , and real numbers are all possible choices for the time domain.
Definition 1 A granularity is a mapping  from the integers (the index set) to subsets of the time domain  such that: (1) if  and    and   are nonempty, then each element of   is less than all ele and ments of   , and (2) if  and       are non-empty, then   is non-empty.
The first condition states that granules in a granularity do not overlap and that their index order is the same as their time domain order.
The second condition states that the subset of the index set that maps to non-empty subsets of the time domain is contiguous.
While the time domain can be discrete, dense, or continuous, a granularity defines a countable set of granules, each one identified by an integer.
The index set can thereby provide an aencodinga of the granularity in a computer.
The definition covers standard granularities like Days, Months, Weeks and Years, bounded granu-  larities like Years-since-2000, granularities with non-contiguous granules like Business-Days, and gap-granularities, i.e., granularities with non-convex intervals as granules like Business-Months.
As an example of the encoding, Years-since-2000  can be defined as a mapping  , with  mapped to the subset of thetime domain corresponding to the  year 2000,    to the one corresponding to the "!$#  year 2001, and so on, with   for " .
Independently from the integer encoding, there may be a atextual representationa of each non-empty granule, termed its label, that is used for input and output.
This representation is generally a string that is more descriptive than the granuleas index (e.g.,aAugust 1997a, a1/2/2000a, etc.)
.
Among the many relationships between time granularities (see [4]), the following defines an essential concept for this paper.
Definition 2 A granularity spect to a granularity  if %  is periodical with re-    there exists a (possibly infi1.
For each '& )!
( of the integers such that %  nite) subset  *,+.-0/   ; 32  54  2.
There exist 1 & , where 1 is less than the number of non-empty granules of % , such that for "!$* +.-0/  8!
all , if and 5& %    % 671 "!
2; # *;+.-0/  < then % 9:1 .
The first condition states that any non-empty granule %  is the union of some granules of  ;  %  for instance, assume is the union of the gran =?>@A  =6B3C@C@C =6DE ules    .
The periodicity property (condition 2 in the definition) ensures that the 1;F G  granule after %  = >  , i.e., , if non-empty, is % H1 2;3  = B 2;A@CC@C@  = D 2;      the union of  .
This results in a periodic apatterna of the composition of 1 granules of % in terms of granules of  .
The pattern repeats along2 the time domain2 by ashiftinga each granule of % by granules of  .
is also called the aperioda of % .
The condition on 1 enforces that at least one granule of % is a periodic repetition of another granule.
A granularity % which is periodical with respect to  C@CisC. specified by: (i) the 1 sets of indexes of  > (JI (LKNM describing the non-empty granules of 2 % within one period; (ii) the value of ; (iii) the indexes of first and last non-empty@granules in % , if their CC@C. > value is not infinite.
Then, if ( I  OP3@CC@(C. KNM are the sets  of indexes of  describing % , re% 1RQ spectively, then the description of an arbitrary granule    *  -0/   2     is given by1  1   .
fi	  Many common granularities are in this kind of relationship, for example, Years is periodical with respect to both Days and Months.
Business-Months is periodical with respect to Business-Days, which in turn is periodical with respect to Days.
Most practical problems seem to require only a granularity system containing a set of time granularities which are all periodical with respect to a basic granularity.
Usually Days, Hours, Seconds or Microseconds take this role, depending on the accuracy required in each application context.
In this paper, for simplicity, we assume there is a fixed basic granularity covering the whole time domain.
%    Definition 3 We say that a granularity  is periodical if it is periodical with respect to the basic granularity.
In Figure 1 we represent the whole set of granularities, according to Definition 1, partitioned in two main subsets: those having all granules with contiguous values (NO - GAP) and those admitting granules with non-contiguous values (GAP).
The inner circle identifies finite and periodical granularities: finite granularities are divided (dash line) into finite irregular and finite periodical2 while infinite periodical granularities are divided into those having a first non-empty granule and no last granule (INFINITE - R), those having a last non-empty granule and no first granule (INFINITE - L), and those infinite on both sides (INFINITE).
This classification will be useful when considering the expressive power of symbolic formalisms.
3.
Two approaches to symbolic representation In this section we first remind the syntax and semantics of collection and slice formalisms, and then analyze their expressiveness with respect to the class of periodical granularities.
3.1.
Collections and slices The temporal intervals collection formalism was proposed in [11].
A collection is a structured set of intervals where the order of the collection gives a measure of the structure depth: an order 1 collection is 1 This formula is correct provided that no granule of  is empty, but it can be easily adapted to the case with finite index for first and last non-empty granules.
2 Despite this formal distinction, finite granularities will be treated uniformly in the results.
GAP  NO-GAP FINITE  INFINITE-R INFINITE-L INFINITE  Figure 1.
A classification of time granularities.    )
an ordered list of intervals, and an order  ( collection is an ordered list of collections having order  Q .
Each interval denotes a set of contiguous moments of time.
For example, the collection of Months, where each month is represented as the collection of days in that month, is a collection of order 2.
In order to provide a user-friendly representation of collections, the authors introduce two classes of operators on collections and the notion of calendar, as a primitive collection.
A calendar is defined as an order 1 collection formed by an infinite number of meeting3 intervals which may start from a specific one.
The two classes of operators are called dicing and slicing.
A dicing operator allows to further divide each interval within a collection into another collection.
For example, Weeks:during:January1998 divides the interval corresponding to January1998 into the intervals corresponding to the weeks that are fully contained in that month.
Other dicing operators are allowed, adopting a subset of Allenas interval relations [1].
Slicing operators provide means of selecting intervals from collections.
For example, [1,-1]/Weeks:during:January1998 selects the first and last week from those identified by the dicing operator above.
In general, slicing can be done using a list of integers, as well as with the keyword the, which identifies the single interval of the collection (if it is single), and the keyword any, which gives nondeterministically one of the intervals.
Collection expressions can be arbitrarily composed using these two classes of operators starting from calendars, which are explicitly specified either by a periodic set of intervals, or as a grouping of intervals from previously defined 3 Interval    meets interval    if  starts when    finishes.
calendars.
The slice formalism was introduced in [14] as an alternative to the collection formalism in order to have an underlying evaluation procedure for the symbolic expressions.
It is based on the notions of calendar and slice.
Similarly to the collection formalism, calendars are periodic infinite sets of consecutive intervals, but there is no first nor last interval.
Intervals in a calendar are indexed by consecutive integers.
Once a basic calendar is given in terms of the time domain, other calendars can be defined dynamically from exist=fi L 	  > C@C@C  ing ones by the construct    which generates a new calendar with  intervals in > each period, the first one obtained grouping gran	 	   ules of calendar , starting , the second  B from grouping the successive granules, and so on,	with  >C@CC@  > treated 	 asB a 	 circular list.
A calendar is 	 B > a	 B subcalendar of ( ) if each interval of 	fiis> exactly covered by finite number of intervals of . Weeks, Days,  Months are calendars with 8 Days Months, Days Weeks, Weeks Months.
A slice is a symbolic expression built from calendars and denoting a (finite or infinite) set of not necessarily C	 >  consecutive intervals.
It has the form  where the sum identifies the starting points of the inter	 vals and  their duration.
Each is a symbol denot ing a calendar and is either a set of natural numbers  >C	fi> or the keyword all.
If the sum is simply 	 > , it denotes the starting points of the intervals of whose  > > of all inindex belongs to , or the starting points C	 M  > !
=fi  >   tervals if .
If !
"!$# % the sum is   C	  with it denotes the starting points   #   	 of the> -th interval of following each point in M >   C	  .
For example,   !
% !
% the sum all.Years + 2,4 .Months + 1 .Days denotes the set of points corresponding to the beginning of the first day  of February andC 	(April of each ' 	)' year.
The duration has the form & where 	('  	 is a symbol denoting a calendar such that 	*'  , and & is the number of successive intervals of specifying the !
% duration.
Hence, the slice all.Years + 2,4 .Months !
% + 1 .Days  2.Days denotes a set of intervals corresponding to the first 2 days of February and April of each year.
3.2.
Expressiveness and relationships Both collections and slices essentially characterize periodic sets.
Similarly to granularities, even in these formalisms there is the notion of a basic calendar, which defines the finest time units in the domain.
Without loss of generality, in the following of  the 	 paper we assume that this basic calendar (denoted by ) is the basic granularity we 	 mentioned in Seccan be associated tion 2.
A period, in terms of with each slice expression ( as well as with any collection expression + .
Intuitively, the period indicates 	 the number of instants of after which the same pattern of intervals denoted by the expression is repeating; each interval in a period can be obtained by a constant shift the corresponding interval in another pe	fi>of @CC@C@ 	 riod.
If are the calendars appearing in the  expression, then the is the least common 2 #$, 	 	,period  2 #$, 	 multi	, ple of   .
Technically,   , is   + >   fi =  # 	 , 	         defined as   /.
 , where /.
 =fi  #  	  	, is a list of integers, each one de	 noting the duration an interval in terms 	 !1  /.
 of =fi # 	 	,  of    of 32 &      ,0 ,        re3  2 &  returns the 45 element of the  , and   turns=fithe number of elements in the  .
For example, /.
   #  Years/Days !768:9<;689; 8:9<;6=8:9:9<> ,4 2 #$, "!
@?
9  and, hence,   Years/Days .
We now consider the expressiveness of slice expressions with respect to the formal notion of granularity introduced in Section 2.
If all the intervals denoted by a slice ( are disjoint, we call ( a disjoint slice.
We also say that a granularity  is equivalent to a slice ( , if each granule of  is formed by	 the union of a set of granules of the basic granularity ( ) and this set is represented by one of the intervals denoted by the slice; moreover, each of the intervals must describe one of these sets.
Theorem 1 Given a disjoint slice ( , there exists a nogap finite granularity, or a no-gap infinite periodical granularity  equivalent to ( .
!
>    C	  C  	)'   & Technically, if ( is an in   > !
=< finite slice ( !BA >  > ), we have an algorithm to derive DC@C@CC.A    DC% >  % Q the intervals    % Q ,    where % is the length in terms of the basic calen	 	*' dar corresponding to & granules of , starting at  .
These intervals are the ones denoted by ( within a slice period.
Then, a periodical granularity can  !
2 !
2  #$, 1   be defined by taking , , where 2  #$, 	 <!
 is> the slice period in terms of , and   	 L  !
C@C@C *FEHG 4I G M J  EKG  .
It is shown that for each   is equivalent to ( .
When ( is finite, the same algorithm can be easily adapted to derive all the intervals ( denotes.
Then, the equivalent granularity is simply defined explicitly mapping each granule to one of these intervals.
Disjointness ensures that the result of this mapping is indeed a granularity.
4 Ignoring  exceptions to leap years.
!
%  Example 1 Let ( =all.Weeks + 2,3# .Days .
  be  12.Hours be an infinite slice and % 2  #$, 9  is hours the basic calendar.
The slice (the number of hours in a week) and in the period containing !
Hours(1) A ;6=8:9$CA ? the 90O$C% slice denotes the set of intervals .
The periodical granularity  , equivalent to ( , is defined by tak!fi 1 ing (the number of * intervals in a Lperiod), J B	 2 !
2  #$,  !
  J   , Hours and  0"!$* J  I L  J  Hours .
  The following example shows that if a slice is non-disjoint, then there is no equivalent granularity.
!
%  Example 2 Let ( =all.Weeks + 2,3 .Days  3.Days.
According to the slice semantics, this expression denotes all intervals spanning from Tuesday to Thursday and all intervals from Wednesday through Friday.
By Definition 1, no pair of granules of the same granularity can overlap.
Hence, no granularity can be found which is equivalent to ( .
 To understand the expressiveness of the slice formalism with respect to granularities, we still need to check if any granularity in the identified classes is representable by a disjoint slice.
Theorem 2 Given a no-gap finite granularity or a no-gap infinite periodical granularity, there exists an equivalent slice.
The theorem states that any finite (periodical or not) granularity can be represented by a slice, and that the same holds for periodical granularities which are unbounded on both sides.
INFINITE - R and INFINITE L granularities cannot be represented by a slice, since the only way to denote an infinite set of intervals with  > !
=fi a slice is to have , and there is no way within the slice formalism to impose a minimum or a maximum on that set.5 From the above results we can conclude that disjoint slices can represent exactly the set of granularities identified in Figure 2, while non-disjoint ones do not represent granularities at all.
Unfortunately, it seems that there is no way to enforce disjointness by simple syntax restrictions.
We now consider the collection formalism.
GAP     NO-GAP                                                              FINITE                                      INFINITE-R INFINITE-L                                              INFINITE                                                          Disjoint slice expressions  Figure 2.
The subset of the granularities captured by the slice formalism  any two intervals equal or disjoint.
  and .
contained in +  are either  Proposition 1 follows from the semantics of the operators, and from the fact that each calendar contains only disjoint intervals.
Similarly to slices, we say that a granularity  is equivalent to a collection of  is formed by the union of the + , if each granule 	 represented by one of the intervals in granules of the collection; moreover, each interval in the collection describes the composition of one of the granules of  .
Theorem 3 Given a collection expression, there exists an equivalent no-gap periodical or finite non periodical granularity.
Similarly to Theorem 1, we developed an algorithm to parse the expression, to derive its period, the intervals it denotes within the period6 , and lower/upper bounds if present.
Once the intervals are derived, we have all the data that is needed to define the granularity  , since it will have the same period, the intervals within the period define the corresponding granules, and the lower/upper bounds are used to impose a starting/ending non-empty granule.
Proposition 1 Any collection + resulting from the application of a dicing or slicing operator is such that  Example 3 Consider !
% + = 1/Mondays:during:Years.
 .2000 .
This collection expression identifies an order 1  5 Note however, that the addition of a reference interval (bound) to each slice, as used in [2], provides an easy extension to capture all no-gap periodical granularities.
6 The intervals may be structured in a collection of order higher than 1, but this is irrelevant with respect to the time granules that the expression denotes.
collection that contains all first Mondays of each year starting since Monday, January 1st 2001.
We assume Days is the basic calendar with Days(1) = Saturday, Jan 1st 2000.
We first have to compute the expression period.
Since Mondays is defined as 1/Days:during:Weeks with the periods  of Days and Weeks equal to and respec    !
tively,  is the period computed for Mondays.
Similarly, since the period for Years @?
9  with respect to the basic calendar is (4 years in Days), the whole expression period is computed  @?
9  !
O  as  (28 years in Days).
2 !
O Then, is defined as having period ,  !
 1 (the number of granules in each period), ,!
8:9  E,!
8    Days Days  (1/1/2001),  !
O  (7/1/2002), ...,  Days (3/1/2028), !
'#  and   for   .
To obtain these intervals the algorithm first restricts years to those after 2000, then it represents all Mondays within those years, and in the end it extracts the intervals corresponding to the first Monday.
 We also have the counterpart of Theorem 3.
Theorem 4 Given a no-gap periodical or finite nonperiodical granularity, there exists an equivalent collection expression.
GAP   NO-GAP    fi fi fi fi      fi fi fi fi   FINITE      fi fi fi fi      fi fi fi fi   fi fi fi fi  INFINITE-R         fi fi fi fi      fi fi fi fi  INFINITE-L     fi fi fi fi      fi fi fi fi  INFINITE     fi fi fi fi      fi fi fi     fi fi fi   collection expressions  Figure 3.
The subset of the granularities captured by the collection formalism Note that in this case, all granularities in the right side of the inner circle of Figure 3 are captured.
We can conclude that slices and collections have incomparable expressiveness, since slices can represent sets of overlapping intervals, and collections can represent INFINITE - R and INFINITE - L periodical granularities.
From the above results, it is clearly possible to translate from one formalism to the other, when considering expressions denoting FINITE or INFINITE granularities, but it seems to be difficult to devise general rules to translate at the symbolic level, preserving the intuitiveness of the expression.
Indeed, despite the + operator in slices may be intuitively interpreted as equivalent to :during: in collections, they actually have a different semantics.
The collection formalism has been extended with some additional operators in [8].
In particular, control statements if-then-else and while are introduced to facilitate the representation of certain sets of intervals, as for example, the fourth Saturday of April if not an holiday, and the previous business-day otherwise.
Unfortunately, the syntax allows the user to define collections which contain overlapping intervals7 .
This implies that there are collection expressions in the extended formalism for which there does not exist an equivalent granularity.
4.
An extension proposal Both the collection and slice formalisms as well as their known extensions cannot represent gap granularities.
Indeed, this requires a non-convex interval representation for each granule which is formed by non-contiguous instants.
For example, they cannot represent Business-Months, where each granule is defined as the set of Business-Days within a month, and it is perceived as an indivisible unit.
We propose an extension to the collection formalism in order to capture the whole set of periodical granularities.
We introduce the notion of primitive collection, which includes calendars as defined in the collection formalism as well as order 1 collections of non-convex intervals, where each of the intervals represents a gran2 	 ule.
A primitive collection can be specified by 2 	 !
=fi L 	  2 	     @ I , where is a synchronization point with respect to an existing calendar 	 2 	  I , is the period expressed in terms of I , and is the set of non-convex intervals8 identifying the posi2 	 tion of granules within a period.
The synchro of 2 	 nization point says that will start at the same 	   instant as I .
7 For example, consider an expression representing a semester following the last day of the month, if it is a Sunday, otherwise the week following that day.
Considering 31/5/1998 and 30/6/1998, both the semester starting 1/6/1998 and the week starting 1/7/1998 will be denoted, with the first properly containing the second.
8 Each   is the non-convex interval representing the  -th granule.
Example 4 Suppose a company has 2 weekly working shifts for !
its employees: % and shift1= !
Monday, Wednesday, Saturday % shift2= Tuesday, Thursday, Friday .
It may be useful to consider these as two periodic granularities, where each shift is treated as a single time granule within a week.
If Thursday 1/1/1998 is taken as Days(1), shift1 = =fi ;   D!B6A EDCA 8 =8$CA 9 =9$C >%     Days .
Indeed, the synchronization point is 5, since the first granule of shift1 following Days(1) starts 	 on Monday January 5th 2 1998 which is 5 days later.
I is Days, is 7 days and is composed L > !
the6KA period  DCA 8 =8$CA 9 9 C> by which identifies the single granule within the period, formed by the first, third, and sixth day, starting from 5/1/1998, and repeating every 7D!Bdays.
= =fi 9  6A EDCSimilarly, A 8 =8$CA ?
?
C shift2 >%  Days denotes    the first, third and fourth day, starting from 6/1/1998, and repeating every 7 days.
 The user can specify collection expressions by arbitrarily applying dicing and slicing operators starting from primitive collections.
Since operators now apply to non-convex intervals, we need to revise  .
be non convex intheir definition.
Let and  !
6KA =?> >C@CC@C. A =  C> .
!
tervals, , and 6KA  > , > C@with CC@C@ A  ,,< C> !
$ !
L P = >    ( ; moreover, let! L C@C@C =  L %  >   > 4!
and ( , > C@CC     :",   % be the sets of values rep resented by and .
respectively.
Dicing operators are based on the following binary relations on non-convex intervals:9    fi         	            , .
 iff (  32 .
(    DH .
8!
  iff ( (   =  H  .
= >fi!
>@ iffH and   .
iff > !
    =?> ,     .
iff   > .
    iff  C operator  !
A > dicing $ @CC@C@= D %  C    #   ,             Example 5 Consider the collection expression Weeks:  :2/shift1:during:1998/Years where shift1 was defined in Example 4.
This expression denotes all weeks following the end of the second work-shift !PCC@C@6A EC C 8:of9<; 1998.
C > C@CC % Years is the order 1 collection A , C C and, 89;$C for simplicity, we assume the interval corresponds to year 1998.
Then,6KA  the slicing 1998/Years C C 89;$C> returns the interval , and the dicing shift1:during:1998/Years returns the finite collection of order all the work-shifts !
6KA ;6 ; 1C composed A  C A O by O$C > 6KA 8;;6=8;:;$C during 1998: , , , ..., , A 8<; 8; C A 8:9EO 89EO$C >% , .
The selection of the second of those the non-convex inter6KA    work-shifts  CA  ?
 ?
:C Areturns   C > val .
the dicing 6KA     CA  ?
 ?
:C A  Finally,  C> Weeks:>: generates the order 1  collection !Bof after 6A  all    8$the C >3 6Kweeks A  9 8EO that C>A@CC@start C% January -th, i.e., .
 We state a formal property of the proposed extension.
Theorem 5 The extended collection formalism can represent all and only the granularities which are either periodical or finite non-periodical.
To support this result, the algorithm used in the proof of Theorem 3 has been extended to consider nonconvex intervals.
The granularities captured by the proposed extension are shown in Figure 4.    takes an order 1 collection as its left operand and an interval .
as its right operand, and it returns an order 1 !"!
 !
 !
C@CC  $collection  .
% + for some   and .
If !
$ !
 $ .
3<!
the strict form is used, then +  !R CC@C    .
% for some , i.e., only the por  and  tion of which is contained in .
is part of the resulting    collection.
When the right operand is a collection, instead of a single interval, the same procedure is applied for each of its intervals, resulting in a collection of one order higher.
A slicing operator  + replaces each order 1 collection contained in + with!
the  -th non> CC@C % convex interval in that collection, while    +  replaces it with the collection made of the subset of intervals position in the collection is specified by !
> C@CC whose %   .
  9 This set of relations is similar to the one chosen in [11] for convex intervals.
We consider it only as a good basic set which allows the representation of most common granularities while having a simple implementation.
It can be extended to a richer set considering, for example, the taxonomy of relations given in [10].
5.
Conclusions In this paper we have considered a recently proposed theoretical framework for time granularities and we have analyzed two of the most influential proposals for calendar symbolic representation.
On one side, we have shown that the theoretical framework is general enough to capture all the sets of disjoint intervals representable by those formalisms.
On the other side we have shown exactly which subclass of granularities can be represented by each formalism.
From this                            GAP  NO-GAP  FINITE  INFINITE-R INFINITE-L  cation to Temporal Reasoning, Annals of Mathematics and Artificial Intelligence, 22(1,2):29a58, Baltzer Science Publ., 1998.
A preliminary version appeared in Proc.
of TIME96.
[5] F. Casati, B. Pernici, G. Pozzi, G. Sanchez, J. Vonk, Conceptual workflow model, in book Database support for workflow management: the WIDE project, chap.3, Kluwer, in press.
INFINITE  fififi fififi fififi fififi  extended collection expressions  Figure 4.
The subset of granularities captured by the proposed extension  analysis, we have proposed an extension of the collection formalism which captures a well-defined and large class of granularities, providing a good coverage of granularities that may be found in database and temporal reasoning applications.
We are currently working at the definition and implementation of set operations, performed at the symbolic level, among extended collection expressions.
This problem has interesting applications (see e.g., [2]) but it is not addressed in [11] and derivative work for collections, and only briefly investigated in [14] for slices.
References [1] James F. Allen, Maintaining Knowledge about Temporal Intervals, Communications of the ACM, 26(11):832a843, 1983.
[2] Elisa Bertino, Claudio Bettini, Elena Ferrari and Pierangela Samarati, An Access Control Model Supporting Periodicity Constraints and Temporal Reasoning, ACM Transactions on Database Systems, 23(3), 1998.
[3] C. Bettini, C.E.
Dyreson, W.S.
Evans, R.T. Snodgrass, X.S.
Wang, A glossary of time granularity concepts, in book: Temporal Databases: Research and Practice, O. Etzion, S. Jajodia, S. Sripada (Eds.
), LNCS State-of-the-art Survey 1399, pp.
406-413, Springer, 1998.
[4] C. Bettini, X. Wang, and S. Jajodia, A General Framework for Time Granularity and its Appli-  [6] D. Cukierman, J. Delgrande, Expressing Time Intervals and Repetition within a Formalization of Calendars, Computational Intelligence, 14(4):563a597, 1998.
[7] I.A.Goralwalla, Y.Leontiev, M.T.Ozsu, D.Szafron, C.Combi, Temporal Granularity for Unanchored Temporal Data, in Proc.
of CIKM, pp.
414-423, ACM Press, 1998.
[8] R. Chandra, A. Segev, and M. Stonebraker, Implementing calendars and temporal rules in next generation databases, in Proc.
of ICDE, pp.
264a 273, 1994.
[9] J. Koomen, Reasoning about recurrence, Int.
Journal of Intelligent Systems, 6:461a496, 1991.
[10] P. Ladkin, Time representation: a taxonomy of interval relations, in Proc.
of AAAI Int.
Conf., pp.
354a359, 1986.
[11] B. Leban, D. Mcdonald, and D. Foster, A representation for collections of temporal intervals, in Proc.
of AAAI, pp.
367a371, 1986.
[12] A. Montanari.
Metric and Layered Temporal Logic for Time Granularity, ILLC Dissertation Series 1996-02, Institute for Logic, Language and Computation, University of Amsterdam, 1996.
[13] R. Morris, W. Shoaff, and L. Khatib, Domainindependent temporal reasoning with recurring events, Computational Intelligence, 12(3):450a 477, 1996.
[14] M. Niezette and J. Stevenne, An efficient symbolic representation of periodic time, in Proc.
of CIKM, Baltimore, pp.
161a168, 1992.
[15] P. Terenziani, Reasoning About Periodic Events, in Proc.
of 2nd International Workshop on Temporal Representation and Reasoning (TIME), Melbourne Beach, Florida, 1995.
[16] The TSQL2 Temporal Query Language, R. T. Snodgrass ed., Kluwer Academic Pub., 1995.
A  Syntax  In the following, we summarize the syntax of the sym	 bolic formalism.
Note that is the basic calendar in the considered system, and text variables (e.g., day, month, ...) are often used in symbolic expres	 sions to denote the calendars (PC) generated from .
E  :==  6  >      interval-list PC > B + .rel.=fi+  =sel/E 	  2 	  :==  =  H $,  .
 3 :==  2 H     PC rel                +  >  :rel: +      D H      B    interval-list :== interval interval,interval-list interval :== [integer,integer] sel :== integer [integer .
.
.
integer] !
% integer-list integer-list :== integer integer,integer-list    !
'   L  for begin !L   !
to     2    #$,fi  for every element in .
.
.
do    B  do  do for every element in  begin , 	 !
O ;	   !
for each ( to Q ) do begin              !
             ,   , LN receives as input two calThe function 	 	 > > > endars ( and 4 ) and two integer numbers (  and # 4 # 4 ) and it computes the index of the -th interval 	 > of 4 which	 comes after the starting point of the  th interval of  .
fi   fi  returns the index   of	 the granule The	 function B > of which contains the   -th granule of if one exists, and indefinite otherwise.
Each point  identified by the algorithm is the beC	*' ginning of an interval with duration & 	 .
However, in order to derive intervals in terms 	 of we need to  is contranslate this duration in terms 	 ' of .
If tained in the  -th granule of , then the new duration % is equal to  Q 	  where  is the maximum  index of a granule of contained in the  "& 	(' .
CThis allows to derive the intervals th of> !BA  granule C@CC.A     C % >   > $% Q $% Q denoted    by the slice ( in one period.
The intervals in other peA 2  #$,     32 @  #$,     riods are simply given by   C :  2 #$,  %  Q where	   ,   is the  slice period in terms of , and is an integer.
Then, by > taking a periodical granularity  can be defined !
2 !
2 #$,  !
L  * E G 4I G M J  EHG 1  , !
' @CC@C.  , and   for each   .
It is easily seen that  is indeed a granularity, since the disjointness of the slice guar> antees that granules of  do not overlap.
4 By definition  !
 * E G I G M  EHG J    J of periodicalgranularity, if C@C@C@ > 8!
# for some  EHG  EHG 4 > I G M and    1 , then "!* E G 4I G M 	 2;  J J EHG  9:1   .
 Suppose now, by contradiction, that there exists within an interval denoted by ( but is not the in	 dex of a granule of contained in any granule of A2      32        %   Q  C , for  , i.e., &   !
@CC@C. % 	   but some integer  , and   & is not included in   for any  .
Then, since ( is periodical,  2    A     DC    %  Q , and by constructionof Q & "!	  CC@CF	       %  Q  granularity  ,       H!
2  .
Then, by the periodicity of  ,        Proofs    !
end; end; end;  Proof of TheoremC 1.
 C	 ' 	 >  & and be the basic calLet ( be     > !
=fi endar.
We first consider an infinite slice ( ), and we illustrate an algorithm to derive the points !
 >C@C@C  % , where each  represents the starting 	  point of the  -th interval denoted by ( in terms of .
The algorithm works as follows: As the first step  C	 we add a  a as the last element in the sum describing the slice ( .
(This is a technical trick to obtain the 	 starting points in terms of .)
The main loop consid	 > ers each granule of within a slice period, starting 	 >  from .
This avoids checking an infinite number of granules.
Then, we consider each one of the possible combinations	 of the offsets, and we compute the index in terms of of the single granule denoted by the corresponding slice.
C	 2  #$, >  ; INPUT:  !
  > @CC@C. ,%   OUTPUT:  ;  METHOD:   >    ,   , L 	   # 4  	 4 > !
if (  indefinite) then begin , 	 !
  ; break; end; end; , !
O if (  	 ) then begin A C !
    B                  	        C@CC  2             	    Q .
Hence is     contradicting contained in  the hypothesis.
!6E@C@CCA %    	  s.t.
t   & We can that   & A 2  (  conclude 3   2 (    D  fi C       %  Q      .
On the other side, suppose there exists 	    s.t.
is contained in , for some integer , but      & A 2    C   32     % for any integer and  Q      1 .
Since  	 is periodical, 2    there must exist an   is contained in    integer   such that where   1 .
By construction of granularity  , if "!
  <C@CC 	      %  Q , then the interval  A     DC   %  Q is one of those denoted by ( .
Hence,  2    by   belongs to an interval denoted ( .
However, 2  since ( is periodical with period , also must be in one of these contradicts  intervals.
!6E@CC@CAthis  %  	 the  hypothesis.
 i    &  s.t.
t $  Hence,  A 2 (  2  ( DC      :%  Q .
&   When ( is finite, the same algorithm can be easily adapted to derive all the intervals ( denotes.
Then, the equivalent granularity is simply defined explicitly mapping each granule to one of these intervals.
Disjointness of the slice ( ensures that the result of this mapping is indeed a granularity.
In the finite case the equivalence between  and ( is trivial.
  %      Proof of Theorem 2.
Let  be a no-gap infinite periodical granularity.
By Definition 3,  is periodical wrt the basic granularity 	 which we identify with the basic 2 	 calendar .
Then, has a period in terms of , 1 granules within  each period, and an explicit description of these C@CC@ > (LI ( KNM granules within a period by sets of 	 indexes of .
Since the granularity has noA = gaps,  C each set !
canO C@be represented by	 =< an interval   CC  with   .
Let be the calendar 	1 Q generated from including these intervals as well as the largest intervals that can be added to these ones order to cover the whole time line.
Formally, 	 =fi in !
=fi  =  	  =   = >  C@CC.  3=  D 2       =6D  Q    I  >    = D   4  >  D Q  I  Q  Q  I  E@CC@C.  KNM  >  Q  Q  =  I  KNM  >  Q    , where the calendar constructor was defined in Section 3.1.
In this case = 2 I is used as a synchronization point, and is=fi the  period of  .
(If one of the values in the   @ 	 =fi O expression evaluates to it is ignored.)
Let be a calendar such that interval=<starts where a 	 =fi each !
= =	 3= >  I granule of starts:    Q = C@C@C = D = D C@C@C@ = 2 = > >  4 I Q I  Q KNM .
We now show =fi that to the C 	 =fi   is  equivalent C	 =fi slice expression .
First, if !
=6 CC@C  	  A=  C , then must be   =fi C	 =fi  EC 	 =fi .
By construction, 	 =fi an interval in = contains an interval starting on .
Indeed, this is trivial   I      =fi  Q    KNM  Q                if we  1 , otherwise, by the periodicity of      know that there exists containing as first granule 	  = 2     !R     1  with    MOD 1  .
Then, by = 2   construction,   1 is the starting point of an 	 =< 	 =fi interval2 in= and, since and  have the same period , must also be a starting point of 	 =fi 	 =fian  interval A=  C of .
Moreover, by construction of , is 	 =< 	 =< also one of the intervals in , since contains all intervals denoted by  plus the newly inserted 	 =< ones.
Then, according to the 	 the slice semantics, gives =fi the starting points and the duration, implying that A=  C is among the intervals denoted by the slice.
        It is easily seen, by the construction of 	 fi =   	 < =   and   , that the vice-versa also holds, i.e., for each in-  terval [r,s] by the slice, there exists  such that "!
denoted   7C@CC  	  .
  	 =fi 	 If=fithe  granularity is finite (periodical or not), and are generated explicitly listing all the intervals.
The equivalence proof is analogous.
  Proof of Proposition 1.
The proposition follows from the semantics of the opC C erators.
Indeed, the expression + $ + , apart from possibly structuring the intervals into a collection of higher order, only selects some of the intervals in + .
Hence, for each interval in + the collection we derive is a subset of that in + .
Since + has only disjoint intervals, its subsets are also disjoint.
However, there may be some interval .
in + satisfying relation C $  C with more than one interval in + .
This leads to the multiple presence of .
in the resulting collection.
Strict operators (  ) select common subintervals of intervals in + and + , and there is no way of generating overlapping intervals if there are none in + and + .
The other type of operators (slicing) simply select some intervals from a collection + based on their index.
Since we assumed that collection expression are built from calendars recursively applying only slicing and dicing operators, and no calendar has overlapping intervals, we can conclude that the derived collections only contain equal or disjoint intervals.
              Proof of Theorem 3.
The proof is based on an algorithm to compute the intervals denoted by a collection expression within its period if it is infinite, or all the intervals if it is finite.
Clearly, the algorithm is trivial when the collection is explicitly given as a set of intervals; Otherwise, for each dicing and slicing operator allowed in the expression, the algorithm has to generate the intervals resulting from its application.
The algorithm represents each infinite collection of order 1 by a finite set of intervals  within one of the periods, by the period value, and possibly by lower and upper bounds identified by values =fiL    and  .
The choice of the beginning of the period is induced either by the calendar definition (if the order-1 collection is a defined calendar) or by the specific operations that have been applied.
The algorithm evaluates the collection expression from right to left.
When the algorithm applies dicing to a collection, its order is increased by 1, while if it applies dicing to an interval it becomes a collection of order 1.
On the other side, if the algorithm applies slicing (with a single slicing value) to a collection, its order is decreased by 1, resulting in a single interval if the collection had order 1.
If the algorithm applies a  a or a  a dicing to a finite collection expression it returns a lower or upper bounded collection expression, while for other operators a finite collection is returned.
If the algorithm generates a bounded collection expression,=<L it stores the minimum value    or the maximum  bounding the collection.
At the end of the algorithm, if we have 2 !
.
 ,    , , then the collection expression is finite, otherwise the collection is periodic.=fiIfL   is defined, then it is lower bounded and if  is defined, it is upper bounded.
The algorithm to calculate the intervals identified by a collection expression uses a set of procedures implementing each slicing and dicing operator.
Here, for the sake of brevity, we only illustrateC # the  =case  EC of the procedure!
that implements the < C # fi@ =@3EC  operator.
Let + be the collection expression identifying the intervals of overlapping    those of , where and are collection expressions themselves.
thatC the intervals denoted by  are A >, >CAssume @C@CC@ A  =, .
Then, for each interval A  =, C !
C C@C   , we execute the following with  code, where  denotes the granularity identifying  	 the same granules (intervals)  = fi as the collection , is the basic calendar, and  	 fi is a function returning the indexes of granules of (an interval) forming the = -th granule of   .
A  , C INPUT: !BA  >  ;> C@CC@C. A    C %   OUTPUT: ; # allA  the  =, C intervals of which overlap METHOD: !
' ;  fi  + = !
fi ;  A  +   + C !
= + fi  fi , ;,  + while   do begin !
   + =         !
  A+   + C   +      !
M  >  =   +       fi  fi fi  fi  end; Details of the algorithm are reported in the extended version of this paper.
Once we have derived the intervals denoted by a collection expression, we still need to find an equivalent granularity.
We first consider an arbitrary collection expression + denoting an infinite number of intervals.
Suppose that, by the global algorithm above, !BA >  described  C% we obtain the set of intervals > CC@CC.A identified by2 + within one of   the collectionas =<periods, the period and, if they exL .
Then, we can define the periodiist,    and  2 cal granularity  as having period equal to that of the collection, 1 equal  to!
 	(the number of intervals   C@CC 	  in !
the period), and for   CC@C   .
If the collection is bounded =fiby a miniL one  in terms mum 	 value   and/or a maximum !
#  of , then we impose   	 for each   that would contain granules=fiL of with indexes lower than .
This can be checked by the   or greater than  formula given in Section 2 to derive granules of periodical granularities.
If + is finite not periodical, we can similarly apply the algorithm, this time deriving all the intervals denoted by + .
Then, each interval defines explicitly a granule of  .
It is easily seen that, if the algorithm computing the intervals denoted by + is correct, the above construction leads to a granularity equivalent to + .
While this is trivial in the finite non-periodical case, the periodical case must be considered in detail.
Each granule is the union of a set of 	 granules of specified by one of the intervals denoted by + , since they have been explicitly defined this way within one period, and the period length has been taken equal for + and  .
We show that for each interval A  C there is a corresponding granule.
Suppose is an interval denoted by + , and there is no  such that "!
 C@CC 	  .
+ must denote more   A  C intervals than those contained in a period, and must not have been in the period considered by the algorithm, otherwise   would have been explicitly A D0 deD@C fined that way.
Then, there must be an interval among the 1 intervals !returned byD the algorithm,   2 !
  2 and D an integer such that and ,   2 where is the period.
Then, by the property of  be	 5!
ing periodical 	 wrt  2   , we know  that for each   ,   * -0/   1  unless   has been  fi   !   explicitlyHdefined as empty.
Consider 1 ; .
Ei!* 	  2      H!
# -	     ther   , or .
      The first would contradict the assumption that there  !
  C@CC 	  is no  such that   .
The second, by the construction of  , can only be true if    , as given by the formula above, would contain  	  =fiL    with 7   or      .
Both cases lead  to a contradiction, since , and we assumed A  C to be one of the intervals denoted by + , that is =fiL      .
Hence, we can conclude that  is equivalent to + .
  Proof of Theorem 4.
Let  be the granularity considered in the theorem.
Following the first part of proof 	 the =< 	 =fiof Theorem 2, we and .
If  is finite construct the calendars non-periodical or INFINITE periodical, 	 =<C it  =  isHEeasily C 	 =fi seen that the collection expression C =  HEC is equivalent to  , where A LL <CCis  =  defined HECA C C on generic intervals as follows: if L !
 and .
A slightly more elaborate C H C construction makes use of the   relation C  =  HEC defined in [11] instead of .
FINITE, INFINITE R, and INFINITE - L periodical granularities require an additional term in their equivalent collection expression.
If the definition  !
A of  C specifies a first     , then we define non-empty granule 	 =<C  =  HEC 	 =fi AC C 	 + as   Q !
 A .
 Similarly, C for aC filast non-empty granule   , using C  	    .
If the definition of   specifies !
A  aC first and a =filast non-empty granule       L  !
A  C   + and , then we define as  2 	 C =  HEC 2 	  , A C C C 	 .
  32   .
               Proof of Theorem 5.
Introducing non-convex intervals as granules, Theorems 3 and 4 are extended with analogous proof techniques to show that the gap counterpart of all the periodical granularities is captured by the extended formalism.
Regarding the extension of Theorem 3, the only relevant part that needs to be modified is the algorithm.
In particular, the procedures implementing dicing operators must follow the new semantics when applied to non-convex intervals.
Details of the algorithm are reported in the extended version of this paper.
Depending on the expression being periodical or not, all the non-convex intervals or only those in a period are derived, each one defining a granule of the gap granularity  .
Then  is easily shown to be equivalent to the extended collection expression.
Let us consider now the extension of Theorem 4.
The finite non-periodical case is trivial, hence we consider here the periodcal case.
Let  be a gap granularity 2 with a period , 1 granules@C(with gaps) within each C@C. > (LI (LKNM period described by sets of indexes of 	 the basic granularity .
Each set can!
beOfirepresented C@C@C  by a non-convex interval  with   .
1 Q If  has no first nor last 2 granule, then we can de	 fine a primitive collection equivalent to  .
Let      6KA =    CC@C@C@A =    C> 2 	 above be .
Then, is I =fi I  = =	 32     I given by   @ , where contains I L C@C@C@L > 1 non-convex intervals I KNM , where each inL A = + = I    = I  C terval in!
 O is given by ! Q for I  I Q I  CC@C O CC@C  each    and   1 Q .
Essentially, we just transformed the granularity description in the equivalent notation for primitive collections.
Similarly to Theorem 4 FINITE, INFINITE - R, and INFINITE - L periodical gap-granularities are accommodated by using C C C C , the operators a  a, a  a, and a .
  32 a.
  