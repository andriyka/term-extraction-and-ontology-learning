2010 17th International Symposium on Temporal Representation and Reasoning  Conflict-Tolerant Real-time Specifications in Metric Temporal Logic Sumesh Divakaran, Deepak D'Souza and Raj Mohan M Department of Computer Science and Automation Indian Institute of Science Bangalore 560012, India.
{sumeshd,deepakd,raj}@csa.iisc.ernet.in  The key idea in this framework is to specify a "conflicttolerant" behaviour for each feature, and then to build a controller for each feature that meets its conflict-tolerant specification.
Unlike a classical safety specification, which can be viewed as a prefix-closed language of behaviours, a conflict-tolerant specification is an advice function which specifies a safety language for each possible finite behaviour of the system.
This is depicted in Fig.
1: If one considers the set of all possible behaviours of the system as a tree growing downwards, then part (a) shows the shaded "cone" denoting a classical safety language, and part (b) depicts what a tolerant specification may look like, with safety cones prescribed for each possible behaviour of the system.
A controller for such a specification must itself be "tolerant" in that it not only advises the system on what actions to take next (like a classical controller), but also keeps track of possible deviations from its advice, and goes on to advise next events so as to control the subsequent behaviour of the system.
A conflict-tolerant controller satisfies a tolerant specification given as an advice function f if after every system behaviour s, the subsequent controlled behaviour of the system stays within the safety language f (s).
Abstract--A framework based on the notion of "conflicttolerance" was proposed in [1], [2] as a compositional methodology for developing and reasoning about systems that comprise multiple independent controllers.
A central notion in this framework is that of a "conflict-tolerant" specification for a controller.
In this work we propose a way of defining conflicttolerant real-time specifications in Metric Interval Temporal Logic (MITL).
We call our logic CT-MITL for Conflict-Tolerant MITL.
We then give a clock optimal "delay-then-extend" construction for building a timed transition system for monitoring past-MITL formulas.
We show how this monitoring transition system can be used to solve the associated verification and synthesis problems for CT-MITL.
Keywords-conflict-tolerance; delay-then-extend construction; verification; synthesis;  I.
Introduction A framework based on the notion of "conflict-tolerance" was proposed in [1], [2] as a way of developing and reasoning about systems that are composed of a base system along with multiple independent controllers that each implement a certain feature for the system.
Such systems appear commonly in software intensive domains, examples of which include a telecom switch which provides different features to subscribers, like call forwarding and call screening; or an automobile with several time-dependent features like cruise control and stability control.
Typically the controller for each feature is developed independently, and the controllers are all integrated together using a hand-coded supervisory controller.
Unfortunately in certain configurations of the system - as the reader may well imagine for the example features mentioned above - the individual controllers may profer conflicting advices on how the system should proceed next.
These conflicts are typically resolved by suspending the lower-priority controller and then waiting for a "reset" state of the system before restarting the controller.
As a result the system loses out on the suspended feature's utility during this period.
The framework in [1], [2] proposes a way of designing each controller so that, based on a priority ordering among the features, it is easy to compose them in a way in which each controller is utilised "maximally."
Thus each controller's advice is taken at all times except when each of its advised actions is in conflict with a higher priority controller.
1530-1311/10 $26.00 (c) 2010 IEEE DOI 10.1109/TIME.2010.23  s  (a)  (b)  Figure 1.
(a): A classical safety specification and (b) a conflict-tolerant specification.
An important component missing in the framework of [1], [2] is the ability to specify conflict-tolerant specifications in a popular specification language like temporal logic.
In this paper our aim is to fill this gap in the domain of real-time systems, by proposing a way of specifying conflict-tolerant specifications in Metric Interval Temporal Logic (MITL) [3], [4].
The logic we propose, called CT-MITL for "ConflictTolerant MITL," is a syntactic fragment of MITL.
A CT-MITL specification is a conjunction of formulas of the form (ph = ps), where ph is a past-MITL formula, and ps is a disjunction of formulas of the form c, where c is a system action or the symbolic event d which stands for "time 35  Let s = d0 a1 d1 * * * am dm , and t = e0 b1 e1 * * * bn en , be timed words such that it is not the case that: n, m > 0 and dm = e0 = 0.
Then we define the concatenation of s and t, denoted s * t (or simply st when clear from the context), to be the timed word d0 a1 d1 * * * am (dm + e0 )b1 e1 * * * bn en .
We say a timed word s is a prefix of a timed word t, written s  t, if there exists a timed word s' such that s * s' = t. We denote the set of all timed words over S by TS* .
We note that our timed words are essentially Alur-Dill timed words except that we use a delay-based representation and allow timed words to end with delays.
It will often be convenient to view a timed word s over S as a map from [0, dur(s)] to S [?]
{d}, which tells us whether the event at time t in [0, dur(s)] is an action point a [?]
S, or the symbolic event "d" which denotes a non-action point or "time elapse."
Thus if s = d0 a1 d1 * * * an dn , for each t [?]
[0, dur(s)] we can define ( k-1 ak if n > 0 and [?
]k [?]
{1, .
.
.
, n} : t = Si=0 di , s(t) = d otherwise.
elapse."
A CT-MITL formula defines an "immediate" advice function in a natural way: at the end of any behaviour s, we check whether the past formula ph is true, and if so, advise a set of next actions that satisfy ps.
The associated verification problem for CT-MITL is to check, given a base system B and a conflict-tolerant controller C (both modelled as Alur-Dill timed transition systems), and a conflict-tolerant specification in the form of a CT-MITL formula th, whether C satisfies the advice function induced by th, with respect to the given base system B (as described above).
We note that an advice function is in general a richer object than a classical safety specification, and thus the verification problem for CT-MITL is more general than the classical verification problem for MITL.
In general, a controller C may satisfy th as a classical MITL specification, but may not satisfy it as a conflict-tolerant specification.
Nevertheless, we show that the verification problem, as well as the associated feasibility and synthesis problems, for CT-MITL can be solved algorithmically, using essentially the same technique as for classical MITL [4], [5], [6].
The main step is to build for a given past-MITL formula ph a deterministic transition system that "monitors" the truth of ph along every timed word it reads.
The construction we give is inspired by the elegant compositional construction of a deterministic timed automaton for a past-MITL formula given in [6].
Our construction is slightly different, as we use a "delay-then-extend" idea to handle the main inductive case of I ph, which is provably clock-optimal and potentially uses one clock less than earlier constructions in [4], [6].
This step can also be implemented very simply in modelling and simulation tools like SIMULINK [7], using simple off-theshelf "delay" and "pulse" blocks (see [8]).
A more detailed technical report is available in [8].
Our logic and techniques specialize easily to the discrete (untimed) setting as reported in [9].
By last(s) we will mean the value s(dur(s)) in S [?]
{d}.
For t [?]
[0, dur(s)] we use the notation s[0, t) to denote the prefix of s of duration t which does not end in an action point.
Thus s[0, t) = t where t  s, dur(t) = t, and last(t) = d. A timed language over S is simply a set of timed words over S. A timed language L is called prefix-closed if whenever s [?]
L and t  s, we have t [?]
L. We denote by L the prefix-closure of L. For a timed language L [?]
TS* and a timed word s, we denote by exts (L), the set of extensions of s that are in L. Thus exts (L) = {t [?]
TS* | s * t [?]
L}.
We use a variant of Alur-Dill timed transition systems [10] which have "time can progress" conditions [11] as state invariants, to model the systems we consider.
To begin with let C be a finite set of clocks.
A valuation for the clocks in C is a map v : C - R>=0 .
We denote by ~0 the valuation which maps all clocks in C to 0.
For a valuation v and t [?]
R>=0 , by v + t we mean the valuation that maps each x [?]
C to v(x) + t, and by v[0/X], for a subset of clocks X of C, the valuation which maps each x in X to 0, and each x in C - X to v(x).
A clock constraint g over C is a boolean combination of atomic constraints of the form x ~ c, where x is a clock in C, ~[?]
{<, <=, =, >, >=} and c is a rational constant.
We write v |= g to say that the valuation v satisfies the clock constraint g, with the expected meaning.
By Ph(C) we denote the set of clock constraints over C. A timed transition system (TTS) over an alphabet S is a structure of the form T = (Q, C, s, -, tcp), where Q is a finite set of states, C is a finite set of clocks, s [?]
Q is the initial state, -[?]
Q x S [?]
{o} x Ph(C) x 2C x Q is a finite set of transitions, and tcp : Q - Ph(C) specifies the condition under which time can progress in a given state.
A configuration of T is a pair (q, v) where q [?]
Q and v is a valuation for the clocks in C. From a given configuration (q, v) of T , there are c two kinds of transitions: (Discrete) (q, v) - (q' , v' ) where  II.
Preliminaries For an alphabet of symbols S we denote the set of words over S by S* , and by o the empty word.
Let R>=0 and Q>=0 denote the set of non-negative reals and rationals respectively.
We will use the standard notation to describe intervals of reals.
So for example the interval (1, 2] denotes the set {t [?]
R>=0 | 1 < t <= 2}.
An interval is non-singular if the set it denotes is not a singleton set.
Whenever convenient we use 'h' (resp.
'i') to denote a left-open or left-closed (resp.
right-open or right-closed) interval bracket.
A timed word s over S is a string in (S[?
]R>=0 )* of the form d0 a1 d1 a2 d2 * * * an dn , where n >= 0, d0 , dn [?]
R>=0 , di [?]
R>0 for 0 < i < n, and a j [?]
S for 1 <= j <= n. We use the notation dur(s) to denote the duration of s, which in this case is Pn i=0 di .
We use the symbol e to denote the empty timed word whose representation is simply "0."
36  c [?]
S [?]
{o}, if there exists (q, c, g, X, q') [?
]-, such that v |= g, d and v' = v[0/X]; and (Delay) (q, v) - (q, v + d) where d [?]
R>=0 , if for all 0 <= d' < d, we have (v + d' ) |= tcp(q).
A run of T on a timed word s staring from a configuration (q, v) is a sequence of time points 0 = t0 <= t1 < t2 < * * * < tn <= tn+1 = dur(s), with n >= 0, along with a sequence of configurations of T , (q0 , v0 ), (q1, v1 ), .
.
.
, (q2n+1 , v2n+1 ), satisfying (q0 , v0 ) = (q, v); for each i [?]
{1, .
.
.
, n + 1}, ti -ti-1 (q2i-2 , v2i-2 ) - (q2i-1 , v2i-1 ); and for each i [?]
{1, .
.
.
, n}, ci (q2i-1 , v2i-1 ) - (q2i , v2i ), where ci = s(ti ) if s(ti ) [?]
S, and o otherwise.
A semirun of T on s starting from a configuration (q, v) is defined to be the run of T on s if tn < tn+1 and is defined to be the sequence of time points 0 = t0 <= t1 < t2 < * * * < tn = dur(s), along with the sequence of configurations of T , (q0 , v0 ), (q1, v1 ), .
.
.
, (q2n-1 , v2n-1 ), satisfying the expected conditions, otherwise.
The timed language of T , denoted L(T ), is the set of all timed words on which T has a run starting from the initial configuration (s, ~0).
Similarly, we denote by L(q,v) (T ) the language of timed words on which T has a run starting from the configuration (q, v).
We say a TTS T is deterministic if there is at most one semirun of T on any timed word s [?]
TS* .
For a deterministic TTS T , and a timed word s on which T has a semirun , we note that the semirun is unique.
Let (q, v) be the unique configuration reached by the semirun of T on s and let us denote it by configT (s).
Then we define Ls (T ) = LconfigT (s) (T ).
It will be convenient sometimes to use constraints over both the states and clocks in a TTS.
A configuration constraint g over a set of states Q and a set of clocks C is a boolean combination of atomic constraints of the form q (for q [?]
Q) and x ~ c (as for clock constraints).
Once again, the notion of when a configuration (q, v) satisfies a configuration constraint g is defined in the expected way.
A TTS with configuration constraints is a TTS which uses configuration constraints instead of clock constraints, and the notions of runs, etc, are defined in a similar manner as for TTS's.
Let T1 = (Q1 , C1 , s1 , -1 , tcp1 ) and T2 = (Q2 , C2 , s2 , -2 , tcp2 ) be two timed transition systems, possibly with configuration constraints, over the same alphabet S. We assume that the set of clocks C1 and C2 , and states Q1 and Q2 are disjoint.
Then the synchronized product of T1 and T2 , denoted by T1 k T2 , is given by the TTS (Q1 x Q2 , C1 [?]
C2 , (s1 , s2 ), -, tcp) where - and tcp are defined as follows. '
' * ((p, q), g, c, X, (p , q )) [?
]- if either there exist transitions (p, g1, c, X1 , p' ) [?
]-1 and (q, g2 , c, X2 , q' ) [?
]-2 , and g = g1 [?]
g2 , and X = X1 [?]
X2 ; or c = o and there exists a transition (p, g, o, X, p') [?
]-1 , and q = q' (or vice-versa).
* tcp((p, q)) = tcp1 (p) [?]
tcp2 (q).
We note that the synchronized products as defined above  generates the intersection of the timed languages L(T1 ) and L(T2 ).
Finally, we define the notion of an "open" TTS which we will make use of in our inductive construction of monitoring TTS's.
An open TTS (over S) with respect to the pairwisedisjoint set of states and clocks Q1 , C1 , .
.
.
, Qn , Cn , is a structure U = (Q, C, s, -, tcp), similar to a TTS over S, that uses "open" configuration constraints over Q1 , C1 , .
.
.
, Qn , Cn .
An open configuration constraint is a boolean combination of configuration constraints over Q, C, and atomic constraints of the form Ti .q (where q [?]
Qi ), and Ti .x ~ c (where x [?]
Ci ).
Given TTS's Ti = (Qi , Ci , si , -i , tcpi ), we can define the composition of U and T1 , .
.
.
, Tn , denoted U k T1 k * * * k Tn , to be the TTS with configuration constraints obtained by taking the parallel composition of U, T1 , .
.
.
, Tn as defined above, but where the constraints Ti .q and Ti .y ~ c are interW preted as the configuration constraints u[?
]QxQ1 x***xQn , u(i)=q u and y ~ c respectively.
Wherever convenient we denote constraints Ti .q and Ti .y ~ c by q and y ~ c respectively.
III.
Conflict-Tolerant Control In this section we recall some of the key notions in the real-time conflict-tolerant framework from [2].
We begin with the notion of a base system.
Some of the example systems we use here are adapted from [2], [12].
A base system is modelled as a TTS over an alphabet comprising "system" or "controllable" events S s , and "environment" or uncontrollable events Se .
We call such an alphabet a partitioned alphabet, and use the convention that S = S s [?]
Se .
Let us fix a partitioned alphabet (S s , Se ) for the rest of this section.
A base system (or plant) over (S s , Se ) is a deterministic TTS B over S, which we assume to be nonblocking in that whenever s [?]
L(B), then exts (L(B)) , {e}.
x >= 2, rel, {x} x < 1, rel, {x}  rel  x = 1, rel, {x} P  L  x<2  x<1  x < 1/2  (a) x >= 1, rel, {x} x<1  (b)  x = 1, rel, {x}  x > 1, rel, {x}  x < 1, rel, {x} x = 1, rel, {x}  x > 1, rel, {x}  x < 1, rel, {x}  x<1 x < 1, rel, {x}  (c)  x = 1, rel, {x}  E  1 < x < 2, rel, {x}  (d)  Figure 2.
(a) Base system, (b) classical controller, and (c), (d) conflicttolerant controllers.
Fig.
2 (a) shows a simple base system model which has only one system event "rel" (say for "releasing" a unit of lubricant), and no environment events.
In the classical framework, a real-time safety specification for a controller is given by a prefix-closed timed language.
A controller for a given base system satisfies this specification if all behaviours of the controlled base system are contained  37  in the specified safety language.
For example, the TTS shown in Fig.
2(b) is a classical controller for the example base system that ensures a rel event after every 1 time unit.
A conflict-tolerant specification on the other hand is a collection of safety languages, one for each possible behaviour of the base system.
This is formalised as an "advice function" below, which advises a timed language of future extensions for each possible behaviour.
tracking (corresponding to the unconstrained behaviour) and advising (corresponding to constrained behaviour).
Finally, we say T ' is complete w.r.t.
a timed language L [?]
TS* if L [?]
L(T ).
A conflict-tolerant controller C for B is a conflict-tolerant TTS over S that is complete with respect to L(B).
The controller C is valid wrt B if *  Definition 1.
A (real-time) advice function over an alphabet * S is a mapping f : TS* - 2TS which satisfies the following conditions: * for every timed word s over S, f (s) is a prefix-closed language.
* f is consistent, i.e.
for all timed words s, t over S, if t [?]
f (s) then f (st) = extt ( f (s)).
*  An alternate way of describing an advice function is an immediate advice function which is a mapping g : TS* - 2S[?
]{d} .
Given a timed word s over S, and a timepoint t [?]
[0, dur(s)], we say s is according to the immediate advice g at time t if s(t) [?]
g(s[0, t)).
The immediate advice function * g above induces an advice function fg : TS* - 2TS given by: fg (s) = { t [?]
TS* | st is according to g in hdur(s), dur(st)]} where 'h' = '[' if s(t) = d and '(' otherwise.
It is easy to verify that the two conditions in Def.
1 are satisfied by fg , and hence that it is a valid advice function.
A conflict-tolerant controller is similar to a classical controller which synchronizes with the base system and controls the choice of possible next system events available to the base system.
The main difference however is that a conflict-tolerant controller also keeps track of the system events that are against its advice, and goes on to control the subsequent behaviour of the system.
A real-time conflict-tolerant controller is modelled as an annotated TTS described below.
A conflict-tolerant timed transition system (CTTS) over S is a tuple T ' = (T , N, tcp' ) where T = (Q, C, s, -, tcp) is a deterministic TTS over S, N [?
]- is a subset of transitions designated as not-advised, and tcp' is the advised time-canprogress condition for states of T .
Let (q, v) be a configuration of the TTS T .
Then the unconstrained language generated by T ' starting from (q, v), denoted L(q,v) (T ' ), is defined to be L(q,v) (T ).
The constrained language generated by T ' starting from (q, v) is denoted Lc(q,v) (T ' ), and defined to e ), where T e is the transition system obtained from be L(q,v) (T T by deleting all not-advised transitions (i.e.
transitions in N) and replacing the time-can-progress condition tcp by tcp' .
Let s be a timed word in L(T ).
Let (q, v) be the unique configuration reached by T on s. Then, the constrained extensions of s, denoted Lcs (T ' ), is Lc(q,v) (T ' ).
Thus a CTTS can be viewed as working in two "modes:"  C is non-restricting: If se [?]
L(B) for some environment event e [?]
Se , then se [?]
Lcs (C).
Thus the controller must not restrict any environment event e enabled in the base system after any base system behaviour s. C is non-blocking: If s [?]
L(B), then Lcs (BkC) , {e}.
Thus the controller must not block the base system after any base system behaviour s.  We now describe when a conflict-tolerant controller satisfies a given conflict-tolerant specification with respect to a given base system B.
Let f be a conflict-tolerant specification in the form of an advice function over S. A conflict-tolerant controller C for B satisfies f if for each s [?]
L(B), Lcs (BkC) [?]
f (s).
Thus after any base system behaviour s, if the base system follows the advice of C, then the resulting behaviour conforms to the safety language f (s).
Fig.
2(c) and (d) show two conflict-tolerant controllers for the example base system in Fig.
2(a).
In the figure we use the convention that the "not-advised" transitions are shown with dotted arrows, and the advised tcp' conditions are shown in the state (the tracking tcp conditions are all "true").
The first tolerant controller's behaviour is to advise a rel event if 1 or more time units have elapsed after the last rel event, no matter when it took place.
On the other hand, the second tolerant controller in part (d) also advises a rel event after 1 time unit if the last two rel events were exactly 1 time unit apart or "punctual;" but if the last two rel events were less than 1 time unit apart ("early") it advises a rel event after 2 time units, and if the last two rel events were more than 1 time unit apart ("late") it advises a rel event after 0.5 time units.
The states of the controller are marked "P", "E", and "L" for "Punctual", "Early", and "Late" respectively, and keep track of this property for the last two rel events.
We note that as classical controllers, both the controllers have the same effect as the classical controller in part (b): behaviours that are controlled according to their advice will always be (prefixes of) behaviours of the form (1 * rel)* .
However as tolerant controllers their behaviours are quite different.
We will return to these examples in the next section when we illustrate our logic for specifying tolerant specifications.
IV.
Conflict-Tolerant Metric Interval Temporal Logic In this section we present our logic for specifying realtime conflict-tolerant specifications, called CT-MITL.
Our logic is based on the well-known timed temporal logic  38  Metric Interval Temporal Logic (MITL) [4] which is a popular logic for specifying real-time properties.
We begin by recalling the syntax and semantics of MITL.
The syntax of an MITL formula over an alphabet S is given by: th ::= [?]
| [?]
| a | !th | th [?]
th | thU I th | thS I th where a [?]
S and I is a non-singular interval with end points in Q>=0 [?]
{[?]}.
We interpret formulas of MITL in a "continuous" manner over timed words.
Let s be a timed word, t a timepoint in [0, dur(s)], and th an MITL formula.
Then we define the satisfaction relation s, t |= th, as follows.
We always have s, t |= [?]
and s, t 6|= [?].
In addition we have: s, t |= a s, t |= th1 U I th2  iff iff  s, t |= th1 S I th2  iff  lock-req, unlock-req, crash, ok  lock-req, unlock-req, crash, ok  lock U  Figure 3.  unlock  L  Door motor base system.
a couple of conflict-tolerant specifications in CT-MITL.
For convenience we use notation of the form ">= 1" to denote the interval [1, [?]).
Example 1.
The CT-MITL formula th1 below specifies an immediate advice function "advise a rel event if one unit or more of time has elapsed since the last rel or init event, and time elapse otherwise."
s(t) = a [?
]t'' > t : t'' - t [?]
I and s, t'' |= th2 and [?
]t' : t < t' < t'' , s, t' |= th1 [?
]t'' < t : t - t'' [?]
I and s, t'' |= th2 and [?
]t' : t'' < t' < t, s, t' |= th1 ,  (((!rel) S >=1 (rel [?]
init)) = rel) [?]
((<1 (rel [?]
init)) = d)).
with the boolean operators interpreted in the standard way.
We note that we have used versions of the "Until" and "Since" operators that are "strict" in both the arguments, as is often done when the underlying time domain is dense.
We will make use of the following derived operators: W d = !
a[?
]S a, phS ps = phS [0,[?])
ps, init = !([?
]S [?])
(init thus characterizes the timepoint 0), I th [?]
[?
]U I th, I th [?]
!I !th, I th [?]
[?
]S I th, and I th [?]
!I !th.
For an MITL formula th and a timed word s, we say s |= th iff s, 0 |= th.
We set L(th) = {s [?]
TS* | s |= th}.
The "past" fragment of MITL is obtained by disallowing the U operator.
We will make use of the "strict past" fragment, denoted MITLP , which are past MITL formulas which are not a boolean combination of formulas, one of which is of the form a for some a [?]
S. Thus an MITLP formula cannot refer to the current time point.
For an MITLP formula ph, we will say s |= ph to mean s, dur(s) |= ph.
We can now introduce the logic CT-MITL.
A ConflictTolerant MITL (CT-MITL) formula over an alphabet S is an MITL formula th over S of the form ^  (phi = psi )  The tolerant controller of Fig.
2(c) can be seen to satisfy this conflict-tolerant specification w.r.t.
the base system of Fig.
2(a).
 Example 2.
The CT-MITL formula th2 below advises a rel event after 1 time unit (respectively 2 time units and 0.5 time units) depending on whether the last two rel events were 1 time unit apart ("Punctual"), less than 1 time unit apart ("Early"), or more than 1 time unit apart ("Late").
(  (((!rel)S >=1 P) = rel) [?]
(((!rel)S <1 P) = d) [?]
(((!rel)S >=2 E) = rel) [?]
(((!rel)S <2 E) = d) [?]
(((!rel)S >=0.5 L) = rel) [?]
(((!rel)S <0.5 L) = d)),  where P = init [?]
(rel [?]
((!rel)S =1 rel)), L = rel [?]
((!rel)S >1 rel)) and E = rel [?]
(<1 rel)).
The tolerant controller of Fig.
2(d) can be seen to satisfy the tolerant specification given by this formula.
 It is interesting to note that viewed as classical MITL specifications, both th1 and th2 describe exactly the same timed language: L(th1 ) = L(th2 ) = (1 * rel)*  .
However, as illustrated by the examples, the tolerant specifications induced by th1 and th2 are very different.
The controllers in Fig.
2 each satisfy their respective specifications, but not the other's.
Further, for any CT-MITL formula th, we always have L(th) = fth (e).
Thus the timed language denoted by th corresponds to the initial safety cone of the tolerant spec denoted by th.
As a final example we look at a couple of features for a car door motor system, adapted from [2].
The base system here (shown in Fig.
3) models a car door motor, which has environment events Se = {lock-req, unlock-req, crash, ok} and system events S s = {lock, unlock}.
The "Overheat Protection" feature aims to protect the motor from overheating due to the excessive locking and unlocking of doors within a short period of time.
It recommends that if two lock events occur within 30 sec the system events lock and unlock be disabled for 180 sec.
i[?
]{1,...,n}  where n >= 0, and for each i [?]
{1, .
.
.
, n}, phi is an MITLP W formula and psi is of the form c[?
]Xi c for some Xi [?]
S [?]
{d}.
The CT-MITL formula th given above induces the immediate advice function gth : TS* - 2S[?
]{d} given by: \ Xi .
gth (s) = i[?
]{1,...,k}, s|=phi  We use the convention that the intersection of an empty collection of sets is the universal set, in this case S [?]
{d}.
Thus, if s is such that none of the phi 's is true at the end of s, then the immediate advice given by gth on s is the set S [?]
{d}.
Finally, we will write fth to denote the corresponding advice function fgth .
We now give a few examples to illustrate the logic.
Returning to our example base system of Fig.
2(a), we give  39  The monitoring TTS for the formula !ps is derived from the MTTS (Tps , gps ) for ps, and is given by (Tps , !gps ).
For the case ps1 [?]
ps2 we assume that we have the monitoring TTS (Tps1 , gps1 ) for ps1 and (Tps2 , gps2 ) for ps2 .
Then the monitoring TTS for ps1 [?]
ps2 is given by (Tps1 k Tps2 , g) where g = Tps1 .gps1 [?]
Tps2 .gps2 .
Before we treat the two remaining cases, for a monitoring guard g we introduce the notation for the left-closure of g, denoted ~g:  Example 3.
A possible tolerant specification for this feature is: ((<=180 (lock [?]
<=30 lock)) = d [?]
env).
W Here env stands for the formula e[?
]Se e. See [8] for a possible tolerant controller that satisfies this specification.
 Example 4.
The "Crash Safety" feature for the door motor requires that if a crash occurs, then unless an ok event occurs the door must be unlocked within 15 seconds, and kept unlocked till an ok event occurs.
A possible tolerant specification for this feature is:  ~u ~(x [?]
c) ~(x [?]
c) ~(g1 [?]
g2 ) ~(g1 [?]
g2 )  ( ((!
(ok [?]
unlock) S <15 crash) = (d [?]
unlock [?]
env)) [?]
((!
(ok [?]
unlock) S >=15 crash) = (unlock [?]
env))).
See [8] for a tolerant controller satisfying the crash safety specification above.
  = = = = =  u, u [?]
Q [?]
S, x >= c, [?]
[?]
{>, >=}, x [?]
c, [?]
[?]
{<, <=}, ~g1 [?]
~g2 , ~g1 [?]
~g2 .
The notation g is defined symmetrically, and we set ~g = (~g) [?]
(g).
Let us now construct a monitoring OpenTTS for the formula ps1 S ps2 .
Let (Tps1 , gps1 ) and (Tps2 , gps2 ) be MTTS for ps1 and ps2 respectively.
Let U be the OpenTTS shown in Fig.
V. Then the TTS Tps1 S ps2 = U k Tps1 || Tps2 is an MTTS for ps1 S ps2 with gps1 S ps2 = (q1 [?]
q2 ) [?]
(x > 0).
We can now define the natural verification and synthesis problems for the logic CT-MITL.
Definition 2.
(Verification Problem for CT-MITL) Given a base system B over S, a conflict-tolerant controller C for B, and a CT-MITL formula th, check whether C is a valid conflict-tolerant controller for B which satisfies the advice function fth .
h, {x}  [?
], {x}  g2  h, {x}  q2  !gps2 , {x}  Definition 3.
(Synthesis Problem for CT-MITL) Given a base system B over S, and a CT-MITL formula th, check whether there exists a valid conflict-tolerant controller for B which satisfies the advice function fth .
If so, construct one.
!gps1 [?]
gps2 g0 q0  gps2 , {x}  gps2 , {x}  g1 q1  [?
], {x}  h, {x}  !gps2 , {x} gps2 , {x}  !gps2 , {x}  h, {x}  V. Monitoring Timed Transition System for MITLP  g3  The main step in solving the verification and synthesis problems for CT-MITL is the construction of a "monitoring" TTS for a given CT-MITL specification.
Without loss of generality we assume that the specification uses only the modalities untimed S and  as the modality S I can be expressed in terms of modalities  and S (see [13]).
A monitoring guard g over a set of states Q and clocks C is a boolean combination of configuration constraints and constraints of the form "a" for a [?]
S. A monitoring guard g is evaluated over a triple (c, q, v), where c [?]
S [?]
{d}, q [?]
Q, and v is a valuation over C, as follows: (c, q, v) |= g iff g is a configuration constraint and (q, v) |= g; and (c, q, v) |= a iff c = a.
Let ph be an MITLP formula.
A monitoring TTS (MTTS) for ph is a pair (Tph , gph ) where Tph is a TTS with configuration constraints and gph is monitoring guard wrt Tph , such that [?
]s [?]
TS* , s |= ph == (last(s), configT (s)) |= gph .
q3 [?
], {x}  g0 g1 g2 g3 h  (x > 0) = !gps1 (x > 0) = gps1 ((x = 0) = (~gps2 ) [?]
((x > 0) = gps1 ) ((x >= 0) = (!~gps2 ) [?]
((x > 0) = gps1 ) !gps1 [?]
!gps2 Figure 4.
OpenTTS U for ps1 S ps2 .
We now give our construction, called delay-then-extend or DTE for short, for the case (l,r) ps, 0 < l < r - l. Our construction uses an optimal number of clocks and in general it uses one clock less than the constructions in [4], [5].
Let (Tps , gps ) for be the monitoring automaton for ps.
Let Nn = {1, .
.
.
, n} and let U1 , U2 and U3 be the OpenTTS shown in Fig.
5, Fig.
6 and Fig.
7 respectively.
Let T = U3 ||U2 ||U1 ||Tps .
For a timed word s let r be the unique semirun of T on s and vt (x) be the valuation of clock x of T at time t in the semirun r. W Lemma 2.
Let g1 = !s0 [?]
( i[?
]Nn (qi [?]
(xi > l) [?]
pi [?]
(xi > W l) [?]
(yi < l))) and g2 = !s0 [?]
( i[?
]Nn ((xi > l) [?]
(yi >= l) [?]
(z < r-l))).
Then for any timed word s, (configTph (s), t) |= g1 [?
]g2 .
(configTph (s), t) |= g1 [?]
g2 == s, t |= ph.
Lemma 1.
Given an MITLP formula ph we can effectively construct an MTTS (Tph , gph ) for ph.
Proof.
We prove this lemma by induction on the structure of ph.
For the base case a [?]
S, the monitoring TTS is given by (Ta , a) where Ta is single state transition system .
40  g  ~!gps s0  g  g  g1  ~gps , {x1 , y1 , .
.
.
, xn , yn }  either gps is everywhere true in the interval (t' , t) in which case (configTph (s), t) |= !s0 [?]
qi [?]
(xi > l); or gps is nowhere true in the interval (t' , t) in which case (configTph (s), t) |= !s0 [?]
(xi > l) [?]
(yi >= l) [?]
(z < r - l).
Case (b): Otherwise let t'' be the point where yi last reset before t. Then (configTph (s), t'' ) |= gps  and there does not exist a subinterval of (t - vt (xi ), t - vt (yi ) + l)) of size atleast r - l such that gps is nowhere true in the subinterval.
So (configTph (s), t) |= g1 if t-t'' < l and (configTph (s), t) |= g1 [?
]g2 otherwise.
See [8] for details.
We observe that as Tph needs to reset at most a pair of clocks in an interval of size r - l, the no.
of clocks required by Tph is at most 2 * [?
]l/(r - l)[?]
+ 1.
We also observe that the construction can be extended to any given MITLP formula which is of the form hl,ri ps albeit with increased complexity.
~gps , yn >= r - l, {x1 , y1 }  ~gps , {x1 , y1 , .
.
.
, xn , yn }  f1  g2  f2  h1 h1  h  gn-1  h  g fn-1  gn  fn  hn-1 hn-1  h  h  ~gps , yn >= r - l, {x1 , y1 }  ~gps  for i [?]
Nn ~!gps  for i [?]
Nn (yi > 0), {yi } for i [?]
Nn 0 < yi < r - l for i [?]
Nn yi >= r - l, {xi+1 , yi+1 } for i [?]
{1, .
.
.
, n - 1}  g h fi gi hi  Figure 5.
U1 .s0  c1 e1  q1  !g  !g h  e' 1 e1  p1  e' 2  g h hi ci di ei e'i  q2  e2  g  h3 g  h  en e'n  d2  c1  h2  !g h  e2 d1  c1  OpenTTS U1 .
qn dn  en  p2  h1  Theorem 1.
Our construction for hl,ri ps uses the optimal number of clocks.
pn  g  Proof: Let us give a brief sketch of the proof.
Let s be a timed word over a such that |s| = 2n + 2 and for each i [?]
{0, .
.
.
, n}, the interval [i*(r -l), (i+1)*(r -l)) has exactly two a's.
Furthermore, the distance between any a's is not an integer and the distance between the a's at the even position and the next odd position is greater than (r - l).
Now we argue that in order to monitor s for (l,r) a we need atleast 2 * [?
]l/(r - l)[?]
+ 1 clocks and hence the theorem.
See [8] for a detailed proof.
We close this section with a sample construction for a monitoring TTS for the formula ph = <=180 (lock[?
]<=30 lock) which is the premise of the specification for the feature overheat protection given in section IV.
Let T1 be the TTS shown in Fig.
8(a) and let g1 = T1 .
(p1 [?]
(x <= 30)).
Then (T1 , g1 ) is an MTTS for <=30 lock.
Let T2 be the OpenTTS shown in Fig.
8(b).
Then (T2 ||T1 , g2 ) is an MTTS for ph with g2 = T2 .
(q1 [?]
(y <= 180)).
gps ~gps  ~!gps  [?]
(xi > 0) for i [?]
Nn yi >= r - l for i [?]
Nn yi < r - l for i [?]
Nn xi = l for i [?]
Nn !s0 [?]
(xi <= l) for i [?]
Nn Figure 6.
OpenTTS U2 .
U1 .s0 a1  a2 g1  b1  an-1 g2  b2  an gn-1  gn  bn-1 (yn >= l) [?]
(y1 > 0)  ai bi gi  (!s0 ) [?]
(yi <= l) for i [?]
Nn (yi >= l) [?]
(yi+1 > 0) for i [?]
{1, .
.
.
, n - 1} yi = l, {z} for i [?]
Nn Figure 7.
!lock  OpenTTS U3 .
p0  Proof: First let us prove that (configTph (s), t) |= g1 [?]
g2 = s, t |= ph.
Since (configTph (s), t) |= g there exists a clock xi such that vt (xi ) <= vt (x j ) for all i [?]
Nn and that s, t-vt (xi ) |= ~gps .
Now if (configTph (s), t) |= g1 (resp.
(configTph (s), t) |= g2 ) then there does not exist a subinterval of (t - vt (xi ), t) (resp.
(t - vt (xi ), t - vt (yi ) + l)) of size atleast r - l such that gps is nowhere true in the subinterval.
Therefore s, t |= ph.
See [8] for details.
Now let us assume that s, t |= ph and prove the converse.
Since s, t |= ph there exists a non negative point t' [?]
(t-r, t-l) such that s, t' |= gps .
Let xi be the clock in X that is last reset on or before t' (our construction guarantees that such a clock exists in X).
Then: Case (a): the clock yi is not reset in the interval (t' , t).
Then  g, !lock, !g, S  !lock lock, {x}  p1  lock, {x}  q0  g, !lock, !g, S g, lock, {y}  q1 g, lock, {y}  (a) Figure 8.
(b) (a): TTS T1 and (b): OpenTTS T2 .
VI.
Verification and Synthesis First let us discuss the verification problem for CT-MITL.
We solve the problem by first constructing the monitoring automaton for the specification and then taking the product of the base system and the controller with it.
Finally we construct the region graph of the product automaton.
Once we have the region graph we can run a reachability analysis  41  similar to one given in [2] on it to see whether it adheres to our requirements.
A detailed proof can be found in [8].
We now do a feasibility study on the conflict-tolerant controller for a given base system B and a CT-MITL speciVi=n W fication th = ( i=1 (phi = psi )) where each psi [?]
a[?
]S a over an alphabet S. This we do by first synthesizing a "maximal canonical conflict-tolerant controller" Cth which respects the specification th.
Now we do a reachability analysis on the region graph once again similar to the one given in [2] of the synchronized product B||Cth and check whether there exists a "restricting" or "non blocking" configuration in the graph.
See [8] for a detailed proof.
[6] ----, "From mitl to timed automata," in FORMATS, ser.
Lecture Notes in Computer Science, E. Asarin and P. Bouyer, Eds., vol.
4202.
Springer, 2006, pp.
274-289.
[7] R. H. Bishop, Modern control systems analysis and design using MATLAB and SIMULINK.
Reading, MA, USA: Addison-Wesley, 1997.
[8] S. Divakaran, D. D'Souza, and M. R. Mohan, "ConflictTolerant Real-Time Specifications in Metric Temporal Logic," Department of CSA, Indian Institute of Science, Technical Report IISc-CSA-TR-2009-9, 2009, uRL: http://archive.csa.iisc.ernet.in/TR/2009/9/.
[9] ----, "Conflict-Tolerant Specifications in Temporal Logic," in ISEC '10: Proceedings of the 3rd India software engineering conference.
New York, NY, USA: ACM, 2010, pp.
103-110.
References [1] D. D'Souza and M. Gopinathan, "Conflict-tolerant features," in CAV, ser.
Lecture Notes in Computer Science, A. Gupta and S. Malik, Eds., vol.
5123.
Springer, 2008, pp.
227-239.
[10] R. Alur and D. L. Dill, "A theory of timed automata," Theor.
Comput.
Sci., vol.
126, no.
2, pp.
183-235, 1994.
[2] D. D'Souza, M. Gopinathan, S. Ramesh, and P. Sampath, "Conflict-tolerant real-time features," in QEST.
IEEE Computer Society, 2008, pp.
274-283.
[11] J. Sifakis and S. Yovine, "Compositional specification of timed systems (an extended abstract)," in Symp.
on Theoretical Aspects of Comp.
Science, 1996, pp.
347-359.
[3] R. Koymans, "Specifying real-time properties with metric temporal logic," Real-Time Systems, vol.
2, no.
4, pp.
255- 299, 1990.
[12] M. Gopinathan, "Conflict Tolerant Features," Ph.D. dissertation, Department of CSA, Indian Institute of Science, 2009.
[4] R. Alur, T. Feder, and T. A. Henzinger, "The benefits of relaxing punctuality," J. ACM, vol.
43, no.
1, pp.
116-146, 1996.
[13] D. D'Souza and N. Tabareau, "On timed automata with input-determined guards," in FORMATS/FTRTFT, ser.
Lecture Notes in Computer Science, Y. Lakhnech and S. Yovine, Eds., vol.
3253.
Springer, 2004, pp.
68-83.
[5] O. Maler, D. Nickovic, and A. Pnueli, "Real time temporal logic: Past, present, future," in FORMATS, ser.
Lecture Notes in Computer Science, P. Pettersson and W. Yi, Eds., vol.
3829.
Springer, 2005, pp.
2-16.
42