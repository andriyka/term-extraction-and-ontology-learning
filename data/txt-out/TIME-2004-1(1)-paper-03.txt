Reasoning on Temporal Conceptual Schemas with Dynamic Constraints Alessandro Artale* Dept.
of Computer Science - Free Univeristy of Bozen-Bolzano artale@inf.unibz.it  Abstract This paper formally clarifies the relevant reasoning problems for temporal EER diagrams.
We distinguish between the following reasoning services: (a) Entity, relationship and schema satisfiability; (b) Liveness and global satisfiability for both entities and relationships; (c) Subsumption for either entities or relationships; (d) Logical implication between schemas.
We then show that reasoning on temporal models is an undecidable problem as soon as the schema language is able to distinguish between temporal and atemporal constructs, and it has the ability to represent dynamic constraints between entities.
1.
Introduction Temporally enhanced conceptual models have been developed to help designing temporal databases [12].
In this paper we deal with Extended Entity-Relationship (EER) diagrams1 used to model temporal databases.
The temporal conceptual model ERV T has been introduced both to formally clarify the meaning of the various temporal constructs appeared in the literature [2, 3], and to check the possibility to perform reasoning on top of temporal schemas [4].
ERV T is equipped with both a linear and a graphical syntax along with a model-theoretic semantics.
It supports valid time for entities, attributes, and relationships in the line of T IME ER [10] and ERT [15], while supporting dynamic constraints for entities as presented in MADS [14].
ERV T is able to distinguish between snapshot constructs--i.e.
each of their instances has a global lifespan--and temporary constructs-- i.e.
each of their instances have a limited lifespan.
Dynamic constructs capture the object migration from a source entity to a target entity.
The contribution of this paper is twofold.
Moving from the formal characterization of ERV T given in [3] we clarify the relevant reasoning problems for temporal EER diagrams.
In particular, we distinguish between six different reasoning services, introducing two new services for both entities and relationships: liveness satisfiability--i.e.
whether an entity or relationship admits a non-empty extension infinitely often in the future--and global satisfiability--i.e.
whether an entity or relationship admits a non-empty extension at all points in time.
After a systematic definition of the various reasoning problems we then show that all the satisfiability problems (i.e.
schema, * 1  The author has been partially supported by the EU projects Sewasie, KnowledgeWeb, and Interop.
EER is the standard entity-relationship data model, enriched with ISA links, generalized hierarchies with disjoint and covering constraints, and full cardinality constraints [8].
entity and relationship satisfiability problems) together with the subsumption problem (i.e.
checking whether two entities or relationships denote one a subset of the other so that there is an implicit ISA link between them) can be mutually reduced to each other.
On the other hand, checking whether a schema logically implies another schema is shown to be the more general reasoning service.
The second contribution is to prove that reasoning on temporal conceptual models is undecidable provided the diagrams are able to: (a) Distinguish between temporal and nontemporal constructs; (b) Represent dynamic constraints between entities, i.e.
entities whose instances migrate to other entities.
To the best of our knowledge, this is the first time such a result is proved.
Indeed, the result presented in [4] showed that ERV T diagrams can be embedded into the temporal description logic DLRU S --where U, S extend DLR with the until and since temporal modalities--and that reasoning in DLRU S was undecidable.
Instead, here we prove that even reasoning just on ERV T schemas is undecidable.
The undecidability result is proved via a reduction of the Halting Problem.
In particular, we proceed by first showing that the halting problem can be encoded as a Knowledge Base (KB) in ALC F --where F extends ALC with the future temporal modality--and then proving that such a KB in ALC F can be captured by an ERV T diagram.
Note that, in [9] the undecidability of ALC F is proved using: (a) complex axioms--i.e.
axioms can be combined using Boolean and modal operators--(b) both global and local axioms--i.e.
axioms can be either true at all time or true at some time, respectively.
Since ERV T is able to encode just simple global axioms, we modify the proof presented in [9] by showing that checking concept satisfiability w.r.t.
an ALC F KB made by just simple global axioms is an undecidable problem.
The paper in organized as follows.
The temporal description logic ALC F and the conceptual model ERV T are formally presented in Sections 2 and 3, respectively.
The various reasoning services for temporal conceptual modeling are defined in Section 4 and their equivalence is proved.
That reasoning in presence of dynamic constraints is undecidable is proved in Section 5.
Section 6 makes final conclusions and mention an interesting open problem.
2.
The Temporal Description Logic In this Section we introduce the ALC F description logic [16, 1, 9] as a the tense-logical extension of ALC.
Basic types of ALC F are concepts and roles.
A concept is a description gathering the common properties among a collection of individuals; from a logical point of view it is a unary predicate ranging over the domain of individuals.
Inter-relationships between these individuals are represented by means of roles, which are interpreted as binary  C, D  -  A| >| [?
]| !C | CuD | CtD | [?
]R.C | [?
]R.C | 3+ C | 2+ C |  (atomic concept) (top) (bottom) (complement) (conjunction) (disjunction) (exist.
quantifier) (univ.
quantifier) (Sometime in the Future) (Every time in the Future)  AI(t) >I(t) [?
]I(t) (!C)I(t) (C u D)I(t) (C t D)I(t) ([?
]R.C)I(t) ([?
]R.C)I(t) (3+ C)I(t) (2+ C)I(t)  [?]
= = = = = = = = =  [?
]I [?
]I [?]
[?
]I \ C I(t) C I(t) [?]
D I(t) C I(t) [?]
D I(t) {a [?]
[?
]I | [?
]b.RI(t) (a, b) = C I(t) (b)} {a [?]
[?
]I | [?
]b.RI(t) (a, b) [?]
C I(t) (b)} {a [?]
[?
]I | [?
]v > t.C I(v) (a)} {a [?]
[?
]I | [?
]v > t.C I(v) (a)}  Figure 1.
Syntax and Semantics for the ALC F Description Logic relations over the domain of individuals.
According to the syntax rules of Figure 1, ALC F concepts (denoted by the letters C and D) are built out of atomic concepts (denoted by the letter A) and atomic roles (denoted by the letter R).
Tense operators are added for concepts: 3+ (sometime in the future) and 2+ (always in the future).
Furthermore, while tense operators are allowed only at the level of concepts--i.e.
no temporal operators are allowed on roles--we will distinguish between so called local--RL--and global--RG--roles.
Let us now consider the formal semantics of ALC F .
A temporal structure T = (Tp , <) is assumed, where Tp is a set of time points and < is a strict linear order on Tp --T is assumed to be isomorphic to either (Z, <) or (N, <).
An ALC F temporal interpretation over T is a triple of the form .
I = hT , [?
]I , *I(t) i, where [?
]I is non-empty set of objects (the domain of I) and *I(t) an interpretation function such that, for every t [?]
T , every concept C, and every role R, we have C I(t) [?]
[?
]I and RI(t) [?]
[?
]I x [?
]I .
Furthermore, if R [?]
RG, then, [?
]t1 , t2 [?]
T .RI(t1 ) = RI(t2 ) .
The semantics of concepts is defined in Figure 1--note that the operator 2+ is the dual of 3+ , i.e.
2+ C [?]
!3+ !C.
A knowledge base (KB) in this context is a finite set S of terminological axioms of the form C v D. An interpretation I satisfies C v D if and only if the interpretation of C is included in the interpretation of D at all time, i.e.
C I(t) [?]
DI(t) , for all t [?]
T .
A knowledge base S is satisfiable if there is a temporal interpretation I which satisfies every axiom in S; in this case I is called a model of S. S logically implies an axiom C v D (written S |= C v D) if C v D is satisfied by every model of S. In this latter case, the concept C is said to be subsumed by the concept D in the knowledge base S. A concept C is satisfiable, given a knowledge base S, if there exists a model I of S such that C I(t) 6= [?]
for some t [?]
T , i.e.
S 6|= C v [?].
3.
Temporal Conceptual Modeling In this Section, the temporal EER model ERV T is briefly introduced.
ERV T supports valid time for entities, attributes, and relationships in the line of T IME ER [10] and ERT [15], while supporting dynamic constraints for entities as presented in MADS [14].
ERV T is able to distinguish between snapshot (see the consensus glossary [11] for the terminology used) constructs--i.e.
each of their instances has a global lifespan-- temporary constructs--i.e.
each of their instances have a limited lifespan--or implicitly temporal constructs--i.e.
their instances can have either a global or a temporary existence.
Two temporal marks, S (snapshot) and VT (valid time, i.e.
temporary), are introduced in ERV T to capture such temporal behavior.
Dynamic constructs capture the object migration from a source entity to a target entity.
If there is a dynamic extension between a source and a target entity (represented in ERV T by a dotted link labeled with DEX) models the case where instances of the source entity eventually become instances of the target entity.
On the other hand, a dynamic persistency (represented in ERV T by a dotted link labeled with PER) models the dual case of instances persistently migrating to a target entity (for a complete introduction on ERV T with a worked out example see [3]).
ERV T is equipped with both a linear and a graphical syntax along with a model-theoretic semantics as a temporal extension of the EER semantics [6].
Presenting the ERV T linear syntax, we adopt the following notation: given two sets X, Y , an X-labeled tuple over Y is a function from X to Y ; the labeled tuple T that maps the set {x1 , .
.
.
, xn } [?]
X to the set {y1 , .
.
.
, yn } [?]
Y is denoted by hx1 : y1 , .
.
.
, xn : yn i, and T [xi ] = yi .
In the following definition we refer to Figure 2 to show the visual syntax associated to the various ERV T constructs.
Definition 3.1 (ERV T Syntax).
An ERV T schema is a tuple: S = (L, REL , ATT, CARD , ISA, DISJ , COVER, S, T, KEY, DEX, PER), such that L is a finite alphabet partitioned into the sets: E (entity symbols), A (attribute symbols), R (relationship symbols), U (role symbols), and D (domain symbols).
We will call the tuple (E, A, R, U, D) the signature of the schema S. E is further partitioned into: a set E S of snapshot entities (the S-marked entities in Figure 2), a set E I of implicitly temporal entities (the unmarked entities in Figure 2), and a set E T of temporary entities (the VT-marked entities in Figure 2).
A similar partition applies to the set R. ATT is a function that maps an entity symbol in E to an Alabeled tuple over D, ATT(E) = hA1 : D1 , .
.
.
, Ah : Dh i. REL is a function that maps a relationship symbol in R to an U-labeled tuple over E, REL(R) = hU1 : E1 , .
.
.
, Uk : Ek i, and k is the arity of R. CARD is a function E x R x U 7- N x (N [?]
{[?]})
denoting cardinality constraints.
If REL(R) = hU1 : E1 , .
.
.
, Uk : Ek i, then CARD (E, R, U ) is defined only if U = Ui and E = Ei , for some i [?]
{1, .
.
.
, k}.
We denote with CMIN (E, R, U ) and CMAX (E, R, U ) the first and second component of CARD .
If not stated otherwise, CMIN is assumed to be zero, and CMAX is assumed to be [?].
In Figure 2, CARD (TopManager, Manages, man) = (1, 1).
ISA is a binary relationship ISA [?]
(E x E) [?]
(R x R).
ISA between relationships is restricted to relationships with the same arity.
ISA is visualized with a directed arrow, e.g.
Manager ISA Employee in Figure 2.
PaySlipNumber(Integer) Salary(Integer)  VT  emp  Name(String)  Employee S  Works-for VT  S  (1,n) act Manager  VT  Project  ProjectCode(String)  prj (1,n)  Resp-for S  (1,1) prj AreaManager  TopManager  man (1,1)  org  Manages  OrganizationalUnit S  DEX d  Department S  InterestGroup  Figure 2.
An ERV T diagram are binary relations over 2E x E, describing disjointness and covering partitions, respectively.
DISJ is visualized with a circled "d" and COVER with a double directed arrow, e.g.
Department, InterestGroup are both disjoint and they cover OrganizationalUnit.
S , T are binary relations over E x A containing, respectively, the snapshot and temporary attributes of an entity.
Furthermore, if hE, Ai [?]
S, T, then A is between the attributes in ATT(E) (see S , T marked attributes in Figure 2).
KEY is a function that maps entity symbols in E to their key attributes, KEY(E) = A.
Furthermore, if KEY(E) = A, then A is between the attributes in ATT(E).
Keys are visualized as underlined attributes.
Both DEX and PER are binary relations over E x E describing the dynamic evolution of entities2 .
DEX and PER are visualized with dotted directed lines labeled with DEX or PER, respectively (e.g.
AreaManager DEX TopManager).
DISJ , COVER  The model-theoretic semantics associated with the ERV T modeling language adopts the snapshot3 representation of abstract temporal databases and temporal conceptual models [7].
Following this paradigm, the flow of time T = hTp , <i, where Tp is a set of time points (or chronons) and < is a binary precedence relation on Tp , is assumed to be isomorphic to either hZ, <i or hN, <i.
Thus, a temporal database can be regarded as a mapping from time points in T to standard relational databases, with the same interpretation of constants and the same domain.
Definition 3.2 (ERVS T Semantics).
Let S be an ERV T schema, and BD = Di [?
]D BDi be a set of basic domains such that BDi [?]
BDj = [?]
for i 6= j.
A temporal database state B(t) for the schema S is a tuple B = (T , [?
]B [?]
[?
]B ), D, * B B such that: [?]
is a nonempty set disjoint from [?]
D; S B is the set of basic domain values used in = [?]
[?
]B Di D Di [?
]D B the ac[?]
BD --we call [?]
the schema S such that [?
]B i Di Di tive domain; *B(t) is a function such that for each t [?]
T , every domain symbol Di [?]
D, every entity E [?]
E, every relationship R [?]
R, and every attribute A [?]
A, we have: 2 3  For ISA relations, we use the notation E1 ISA E2 instead of hE1 , E2 i [?]
ISA.
Similarly for DISJ, COVER, DEX, PER.
The snapshot model represents the same class of temporal databases as the timestamp model [12, 13] defined by adding temporal attributes to a relation [7].
B(t)  B(t) Di = [?
]B [?]
[?
]B , RB(t) is a set of U-labeled tuDi , E B B(t) ples over [?]
, and A [?]
[?
]B x [?
]B D. B is a legal temporal database state if it satisfies all of the integrity constraints expressed in the schema: B(t)  * For each E1 , E2 [?]
E, if E1 ISA E2 , then, E1 * For each R1 , R2 [?]
R, if  B(t) R1 ISA R2 , then, R1  B(t)  [?]
E2 [?]
.
B(t) R2 .
* For each E [?]
E, if ATT(E) = hA1 : D1 , .
.
.
, Ah : Dh i, then, e [?]
E B(t) - ([?
]i [?]
{1, .
.
.
, h}, [?
]!ai .
he, ai i [?]
B(t) B(t) Ai [?]
[?
]ai .he, ai i [?]
Ai - ai [?]
[?
]B Di ).
* For each R [?]
R, if REL(R) = hU1 : E1 , .
.
.
, Uk : Ek i, then, r [?]
RB(t) - (r = hU1 : e1 , .
.
.
, Uk : ek i [?]
[?
]i [?]
B(t) {1, .
.
.
, k}.ei [?]
Ei ).
In the following, we adopt the convention: hU1 : e1 , .
.
.
, Uk : ek i [?]
he1 , .
.
.
, ek i, and r[Ui ] [?]
r[i] to denote the Ui /i-component of r. * For each cardinality constraint CARD (E, R, U ), then, e [?]
E B(t) - CMIN (E, R, U ) <= #{r [?]
RB(t) | r[U ] = e} <= CMAX(E, R, U ).
* For each snapshot entity E [?]
E S , then, 0 e [?]
E B(t) - [?
]t0 [?]
T .e [?]
E B(t ) .
* For each temporary entity E [?]
E T , then, 0 e [?]
E B(t) - [?
]t0 6= t.e 6[?]
E B(t ) .
* For each snapshot relationship R [?]
RS , then, 0 r [?]
RB(t) - [?
]t0 [?]
T .r [?]
RB(t ) .
* For each temporary relationship R [?]
RT , then, 0 r [?]
RB(t) - [?
]t0 6= t.r 6[?]
RB(t ) .
* For each entity E [?]
E with a snapshot attribute Ai , i.e.
hE, Ai i [?]
S, then, B(t) B(t0 ) (e [?]
E B(t) [?]
he, ai i [?]
Ai ) - [?
]t0 [?]
T .he, ai i [?]
Ai .
* For each entity E [?]
E with a temporary attribute Ai , i.e.
hE, Ai i [?]
T, then, B(t) B(t0 ) (e [?]
E B(t) [?
]he, ai i [?]
Ai ) - [?
]t0 6= t.he, ai i 6[?]
Ai .
* For E, E1 , .
.
.
, En [?]
E, - If {E1 , .
.
.
, En } DISJ E, then, [?
]i [?]
{1, .
.
.
, n}.Ei ISA E[?]
B(t) B(t) [?
]j [?]
{1, .
.
.
, n}, j 6= i.Ei [?]
Ej = [?].
- If {E1 , .
.
.
, En } COVER E, then, Sn B(t) [?
]i [?]
{1, .
.
.
, n}.Ei ISA E [?]
E B(t) = i=1 Ei .
2.
Schema satisfiability reduces to entity liveness satisfiability;  * For each E [?]
E, A [?]
A such that KEY(E) = A, then, hE, Ai i [?]
S--i.e.
a key is a snapshot attribute--and [?
]a [?]
B(t) [?
]B | he, ai [?]
AB(t) } <= 1.
D .#{e [?]
E * For each E1 , E2 [?]
E, B(t)  - [?
]t1 > t.e [?]
E2  B(t)  - [?
]t0 > t.e [?]
E2  - If E1 DEX E2 , then, e [?]
E1 - If E1 PER E2 , then, e [?]
E1  B(t1 )  ;  B(t0 )  .
4.
Reasoning on Temporal Models Reasoning tasks over a temporal conceptual model include verifying whether an entity, relationship, or schema are satisfiable, whether a subsumption relation exists between entities or relationships, or checking whether a new schema property is logically implied by a given schema.
The model-theoretic semantics associated with ERV T allows us to formally define these reasoning tasks.
We start with the formal definition of the relevant reasoning services in a temporal schema as presented in [3].
Based on this formal characterization we can prove the first results of this paper concerning reasoning in ERV T : a) Subsumption and satisfiability reasoning services relative to entities are mutually reducible to each other; b) Satisfiability problems relative to relationships are mutually reducible; c) Satisfiability of relationships reduces to satisfiability of entities and viceversa; d) Logical implication is the more general service.
Definition 4.1 (Reasoning in ERV T ).
Let S be an ERV T schema, E [?]
E an entity, and R [?]
R a relationship.
The following are the reasoning tasks over S: 1.
E (R) is satisfiable if there exists a legal temporal database state B for S such that E B(t) 6= [?]
(RB(t) 6= [?
]), for some t [?]
T ; 2.
E (R) is liveness satisfiable if there exists a legal temporal database state B for S such that [?
]t [?]
T .[?
]t0 > 0 0 t.E B(t ) 6= [?]
(RB(t ) 6= [?
]), i.e.
E (R) is satisfiable infinitely often; 3.
E (R) is globally satisfiable if there exists a legal temporal database state B for S such that E B(t) 6= [?]
(RB(t) 6= [?
]), for all t [?]
T ; 4.
S is satisfiable if there exists a legal temporal database state B for S that satisfies at least one entity in S (B is said a model for S); 5.
E1 (R1 ) is subsumed by E2 (R2 ) in S if every legal temporal database state for S is also a legal temporal database state for E1 ISA E2 (R1 ISA R2 ); 6.
A schema S0 is logically implied by a schema S over the same signature if every legal temporal database state for S is also a legal temporal database state for S0 .
We now prove that reasoning services (1-5) relative to entities and knowledge bases are mutually reducible to each other.
Proposition 4.2.
There is a mutual reducibility between the reasoning services (1-5) relative to entities in ERV T .
Proof Proving the mutual reducibility between satisfiability and subsumption in ERV T can be done similarly to [5].
Then, in the following we prove that given an ERV T schema S: 1.
Entity satisfiability reduces to schema satisfiability;  3.
Entity liveness satisfiability reduces to entity global satisfiability; 4.
Entity global satisfiability reduces to entity satisfiability.
(1) We prove that given an entity E0 [?]
E, then, E0 is satisfiable w.r.t.
S iff a new schema S0 is satisfiable.
S0 is obtained by adding to S the schema in figure 3(a), where >, E1 , E2 are new entities such that [?
]E [?]
E.E ISA >, and R is a new binary relationship.
"=" Let S0 be satisfiable, then, S0 has a model B (which is a model for S, too) such that [?
]t [?]
T .[?
]e [?]
[?
]B .e [?]
>B(t) (by definition of schema satisfiability and by construction of > as superclass of all entities in S0 ).
Because > is a snapshot entity, then, [?
]t [?]
T .e [?]
>B(t) .
Since E1 , E2 form a disjoint covering of >, and E1 , E2 B(t0 ) are both temporary, then, [?
]t0 [?]
T .e [?]
E1 .
Finally, because E1 totally participates in R, then, [?
]e0 [?]
0 B(t0 ) [?
]B .
(he, e0 i [?]
RB(t ) [?]
e0 [?]
E0 ).
Then, E0 is satisfiable w.r.t.
S. "=" Let E0 be satisfiable w.r.t.
S, then, S has a model B(t ) B such that [?
]t0 [?]
T .[?
]e0 [?]
[?
]B .e0 [?]
E0 0 .
We now 0 0 0 construct a model B for S .
Let B and B coincide on all constructs in S, and additionally, for all t [?]
T : S S 0 * >B (t) = v[?
]T E[?
]E E B(v) *  B0 (t) E1 B0 (t)  * E2  =    0  >B (t) [?]
0  if t = t0 otherwise B0 (t)  = >B (t) \ E1  B0 (t)  0  * RB (t) = {he, e0 i | e [?]
E1  }  0  It is easy to check that B is a model for S0 , then, S0 is satisfiable.
(2) We prove that a given schema S is satisfiable iff an entity is liveness satisfiable w.r.t.
a new schema S0 .
S0 is obtained by adding to S the schema in figure 3(b), where >1 , >2 , E1 , E2 are new entities and R is a new binary relationship.
Furthermore, {E | E [?]
E} COVER >2 .
In particular, we prove that S is satisfiable iff >1 is liveness satisfiable w.r.t.
S0 .
"=" Let >1 be liveness satisfiable w.r.t.
S0 .
Then, S0 has a model, B, such that [?
]t [?]
T .[?
]t0 > t.[?
]o [?]
B(t0 ) [?
]B .o [?]
>1 .
Since >1 is a snapshot entity, then, B(t) o [?]
>1 , for all t [?]
T .
Because E1 , E2 are a disjoint covering of >1 and they are both temporary, then, B(t) [?
]t [?]
T .o [?]
E1 .
Because E1 totally participates in R, B(t) then, [?
]e [?]
[?
]B .
(ho, ei [?]
RB(t) [?]
e [?]
>2 ).
Then, >2 is a satisfiable entity and, because of the covering constraint, S is satisfiable.
"=" Let S be a satisfiable schema and B a model for S. We now show how to build a model, B 0 , for S0 such that >1 is liveness satisfiable.
B 0 agrees with B on all constructs in S, and additionally, for all t [?]
T : S B0 (t) B(v) * >1 = v[?
]T >2 Note that, because by assumption S is satisfiable, then, >2 is satisfiable while >1 contains always at least one element (i.e., it is globally, and then liveness, satisfiable).
>  >1  S  d  E2  d  E1  VT  S  (1,n)  E0  R  VT  E2  (a)  VT  E1  (1,n) VT  R  >2  (b)  Figure 3.
Reductions: (a) From Entity Sat to Schema Sat; (b) From Schema Sat to Entity Liveness Sat.
* Let t0 [?]
T an arbitrary time such that [?
]e0 [?]
B(t0 ) [?
]B .e0 [?]
> then: 2 B0,(t) 0 B (t) >1 if t = t0 E1 = [?]
otherwise 0  B (t)  * E2  0  B (t)  = >1  0  B (t)  \ E1  B0 (t)  0  * RB (t) = {he, e0 i | e [?]
E1 0  }  0  Then, B is a model of S such that >1 is liveness satisfiable.
(3) We prove that given an entity E0 [?]
E, then, E0 is liveness satisfiable w.r.t.
S iff an entity is globally satisfiable w.r.t.
a new schema S0 .
S0 is obtained by adding to S the new entity E1 as showed in figure 4(a).
We prove that E0 is liveness satisfiable w.r.t.
S iff E1 is globally satisfiable w.r.t.
S0 .
"=" Let E1 be globally satisfiable w.r.t.
S0 .
Then, S0 B(t) has a model, B, such that [?
]t [?]
T .[?
]o [?]
[?
]B .o [?]
E1 .
Then, given the dynamic extension constraint between E1 and E0 , E0 is liveness satisfiable.
"=" Let E0 be liveness satisfiable w.r.t.
S. Then, S has a model, B, such that [?
]t [?]
T .[?
]t0 > t.[?
]e [?]
[?
]B .e [?]
B(t0 ) E0 .
We now extend B to E1 , such that for all t [?]
T : *  B(t) E1  B  0  = {e [?]
[?]
| [?
]t > t.e [?]
B(t0 ) E0 }  Then, B is a model of S0 such that E1 is globally satisfiable.
(4) We prove that given an entity E0 [?]
E, then, E0 is globally satisfiable w.r.t.
S iff an entity is satisfiable w.r.t.
a new schema S0 .
S0 is obtained by adding to S the schema in figure 4(b), where E1 is new snapshot entity and R is a new binary relationship.
"=" Let E1 be satisfiable w.r.t.
S0 , then, S0 has a B(t) model B such that [?
]o [?]
[?
]B .o [?]
E1 , for all t [?]
T (by construction of E1 as a snapshot entity).
Since E1 totally participates in R, then, [?
]e [?]
[?
]B .ho, ei [?]
RB(t) [?]
e [?]
B(t) E0 .
Since this must be true at all time, then, E0 is globally satisfiable w.r.t.
S. "=" Let E0 be globally satisfiable w.r.t.
S. Then, S B(t) has a model, B, such that [?
]t [?]
T .[?
]e [?]
[?
]B .e [?]
E0 .
0 0 We now construct a model, B , for S such that E1 is satisfiable.
B 0 agrees with B on all constructs in S, and additionally, for all t [?]
T : S B0 (t) B(v) * E1 = v[?
]T E0 * R  B0 (t) 0  = {ho, ei | o [?]
B0 (t) E1  [?]e[?]
B(t) E0 }  0  Then, B is a model of S such that E1 is satisfiable.
2  We are now able to prove that satisfiability problems for relationships are reducible to the same problems for entities and viceversa.
Proposition 4.3.
There is a mutual reducibility between the reasoning services (1-4) relative to both relationships and entities in ERV T .
Proof We only prove that satisfiability of relationships can be reduced to satisfiability of entities and viceversa.
The other mutual reductions easily follow from analogous results proved in Proposition 4.2.
"R SAT reduces to E SAT."
We can verify whether a relationship R is satisfiable in S by adding a new entity, say AR such that: (a) AR ISA E, with E an arbitrary entity participating in the relationship, and (b) AR totally participates in the relationship.
Then, R is satisfiable if and only if AR is satisfiable.
"E SAT reduces to R SAT."
We can verify whether an entity E is satisfiable in S by adding a new relationship, say RE such that: (a) RE is a binary relationship with both arguments restricted to E; (b) E totally participates in RE .
Easily follows that E is satisfiable if and only if RE is satisfiable.
2 Finally, we show that all the reasoning problems can be reduced to a logical implication problem.
Logical implication accounts for checking properties of a schema whenever they can be expressed in the ERV T schema language.
In particular, checking whether an entity E is satisfiable can be reduced to logical implication by choosing S0 = {E ISA A, E ISA B, {A, B} DISJ C}, with A, B, C arbitrary entities.
Then, E is satisfiable iff S 6|= S0 .
Given the result of Proposition 4.2, then the reasoning services (1-5) for entities are reducible to logical implication.
Furthermore, given two relationships R1 , R2 , checking for sub-relationship can be reduced to logical implication by choosing S0 = {R1 ISA R2 }.
This shows that logical implication is the most general reasoning service.
5.
Reasoning on ERV T is Undecidable We now show that reasoning on full ERV T is undecidable.
The proof is based on a reduction from the undecidable halting problem for a Turing machine to the entity satisfiability problem w.r.t.
an ERV T schema S. We apply ideas similar to [9] (Sect.
7.5) to show undecidability of certain product of modal logics.
The proof can be divided in the following steps: 1.
Definition of the halting problem; 2.
Reduction of the halting problem to concept satisfiability problem w.r.t.
an ALC F KB; 3.
Reduction of concept satisfiability w.r.t.
an ALC F KB to entity satisfiability w.r.t.
an ERV T schema.
E1  DEX  E0  (a)  E1  (1,n) S  R  E0  (b)  Figure 4.
Reductions: (a) From Entity Liveness Sat to Entity Global Sat; (b) From Entity Global Sat to Entity Sat.
The second step has been chosen as an intermediate step to better understand the halting problem reduction by using the concise ALC F linear syntax.
Then, the final step will show how ERV T is able to capture the ALC F axioms used in the reduction.
Halting problem We show here a formal representation of the halting problem for Turing machines as presented in [9].
A single-tape right-infinite deterministic Turing machine M is a triple hA, S, ri, where: A is the tape alphabet (b [?]
A stands for blank); S is a finite set of states with the initial state, s0 , and the final state, s1 ; r is the transition function, r : (S - {s1 }) x A - S x (A [?]
{L, R}).
A Configuration of M is an infinite sequence: hPS, a1 , .
.
.
, ai-1 , hsi , ai i, .
.
.
, an , b, .
.
.i, where, PS 6[?]
A is a symbol marking the left end of the tape, ai [?]
A, and si [?]
S is the current state.
The cell hsi , ai i is the active cell.
All the cells to the right of an are blank.
Since a transition function can only modify the active cell and its neighbors we introduce the instruction function, d, defined on triples in (A[?
]{PS})x((S -{s1})xA)xA, such that:  hai , hs0 , a0j i, ak i if r(s, aj ) = hs0 , a0j i    0 0    hhs , ai i, aj , ak i if r(s, aj ) = hs , Li and ai 6= PS d(ai , hs, aj i, ak ) = hPS, hs0 , aj i, ak i if r(s, aj ) = hs0 , Li     and ai = PS   hai , aj , hs0 , ak ii if r(s, aj ) = hs0 , Ri  A sequence hc0 , c1 , .
.
.
, ck , ck+1 , .
.
.i of configurations of M is said a computation of M if the state of c0 is s0 (the initial state), and, for all k, ck+1 is obtained from ck by replacing the triple centered around the active cell of ck by its d-image and living the rest unaltered.
We say that M halts, starting with the empty tape--i.e.
with starting configuration: hPShs0 , bi, b, .
.
.
, b, .
.
.i--if there is a finite computation, hc0 , c1 , .
.
.
, ck i, such that the state of ck is s1 (the final state).
Reasoning on ALC F is undecidable Using a reduction from the halting problem we now prove that reasoning involving an ALC F knowledge base is undecidable.
In [9] the undecidability of ALC F is proved using: (a) complex axioms--i.e.
axioms can be combined using Boolean and modal operators--(b) both global and local axioms--i.e.
axioms can be either true at all time or true at some time, respectively.
Since ERV T is able to encode just simple global axioms, we modify the proof presented in [9].
The following theorem proves that checking concept satisfiability w.r.t.
an ALC F KB made by just simple global axioms is an undecidable problem.
Proposition 5.1.
Concept satisfiability w.r.t.
an ALC F knowledge base is undecidable.
Proof Given a Turing machine, M = hA, S, ri, we construct an ALC F KB, say KBM , with a concept that is satisfiable w.r.t.
KBM iff the machine M does not halt.
We start by introducing some shortcuts.
The implication, C - D, is equivalent to the concept expression !C t D. Given two concepts C, D we define next(C, D) as the following axiom: C v 3+ D u !3+ 3+ D. This axiom says that whenever o [?]
C I(t0 ) , then, o [?]
DI(t0 +1) [?]
[?
]t 6= t0 .o 6[?]
C I(t) .
Let C, D1 , .
.
.
, Dn concepts, discover(C, {D1 , .
.
.
, Dn }) is defined as the conjunction of the following axioms: C v D1 t .
.
.
t Dn D1 v C u !D2 u .
.
.
u !Dn ... Dn-1 v C u !Dn i.e., there is a disjoint covering between C and D1 .
.
.
Dn .
Let A0 = A [?]
{PS} [?]
(S x A).
With each x [?]
A0 we introduce a concept Cx .
We also use concepts Cs , Cl , Cr to denote the active cell, its left and right cells, respectively.
The concept S1 denotes the final state.
The halting problem reduces to satisfiability of C0 .
Extra concepts C, D1 , D2 , D3 , will be also used.
R is a global role.
KBM contains the following axioms: C0 v CPS u 3+ Chs0 ,bi discover(C, {Cx | x [?]
A0 }) > v [?
]R.> next(CPS , D1 ) next(D1 , D2 ) Chs0 ,bi v D1  (1) (2) (3) (4) (5) (6)  Chs0 ,bi v 2+ Cb discover(Cs , {Chs,ai | hs, ai [?]
S x A}) next(Cl , Cs ) next(Cs , Cr ) next(Cr , D3 ) CPS v Cl t 3+ Cl Cl v Ca - [?
]R.Ca0 Cs v Cb - [?
]R.Cb 0 Cr v Cg - [?
]R.Cg 0 Ca v (!Cl u !Cs u !Cr ) - [?
]R.Ca , [?
]a [?]
A [?]
{PS} discover(S1, {Chs1 ,ai | a [?]
A [?]
{PS}}) Cs v !S1  (7) (8) (9) (10) (11) (12) (13) (14) (15) (16) (17) (18)  with axioms (13-15) for each instruction d(a, b, g) = ha0 , b 0 , g 0 i.
We now prove that C0 is satisfiable w.r.t.
KBM iff M has an infinite computation starting from the empty tape.
"=" Let C0 be satisfiable, then, [?
]hx0 , t0 i [?]
[?
]I x T .x0 [?]
I(t) I(t0 ) I(t ) C0 .
Then, by axiom (1), x0 [?]
CPS 0 , and [?
]t > t0 .Chs0 ,bi .
We now show that t = t0 + 1.
Indeed, if Chs0 ,bi is true, then, I(t)  by axiom (6), D1 must also be true, i.e.
x0 [?]
D1 .
On the other hand, by axiom (4), CPS is true at just one point in time and D1 is true next time and only there (by axiom (5)), I(t ) I(t +1) i.e.
x0 [?]
D1 0 .
Thus, t = t0 + 1, x0 [?]
CPS 0 , x0 [?]
I(t0 +1) I(t) Chs0 ,bi , and, by axiom (7), [?
]t > t0 + 1.x0 [?]
Cb .
FurtherI(t +1)  more, by axiom (8), x0 [?]
Cs 0 , while, by axioms (9-12), I(t ) I(t +2) x0 [?]
Cl 0 , x0 [?]
Cr 0 .
Because by axiom (2), for all  Top  D  S  d  C  D  C  (a)  D1  D2  Dn (b)  Figure 5.
Encoding axioms: (a) C v !D; (b) C v D1 t .
.
.
t Dn .
I(t)  t [?]
T there is at most one x [?]
A0 such that x0 [?]
Cx , then, the sequence hhx0 , t0 i, hx0 , t0 + 1i, .
.
.i represents the starting configuration of M. Now, by axiom (3) and the assumption that R is global, [?
]x1 [?]
[?
]I .[?
]t [?]
T .hx0 , x1 i [?]
RI(t) (we call x1 R-successor of x0 ).
Let hx0 , x1 , x2 , .
.
.i be a chain of I(t ) R-successors satisfying axiom (2).
Since x0 [?]
CPS 0 , then, by axioms (13) and (16), and the definition of the instruction I(t ) function, d, xi [?]
CPS 0 , for all i.
Then, given the axioms (12- 16), the chain of R-successor, hx0 , x1 , x2 , .
.
.i, represents a computation of M. Finally, axioms (17-18) guarantee that M never halts.
"=" Conversely, suppose that M is a Turing machine and hc0 , .
.
.
, ck , .
.
.i its infinite computation starting with the .
empty tape.
We construct a model I = hT , [?
]I , *I(t) i of KBM such that C0 is satisfiable.
In particular, we fix T = hN, <i4 , [?
]I = N, RI = sucN (the successor function over N), I(0) I(j) C0 = {0}, and C0 = [?
], for all j > 0.
Furthermore, [?
]j [?]
N:  1.
Axioms involving discover are mapped using disjoint and covering hierarchies in ERV T .
2.
Axioms of the form C v D, with C, D atomic concepts are encoded as C ISA D. 3.
For each axiom of the form C v !D we construct the hierarchy in Figure 5(a).
4.
For each axiom of the form C v D1 t .
.
.
t Dn we introduce a new entity, D, and then we construct the hierarchy in Figure 5(b).
5.
Axioms of the form C v [?
]R.D are mapped together with the axiom > v [?
]R.> by introducing a new subrelationship, RC , and considering R as a functional role5 .
Figure 6(a) shows the mapping where R is a snapshot relationship to capture the fact that R is a global role in KBM .
6.
For each axiom of the form C v 2+ D (C v 3+ D) we use a persistency (dynamic extension) constraint: C PER D (C DEX D).
I(j)  * Cx = {i [?]
N | the jth cell of ci contains x}, for all x [?]
A0 I(j)  * Cs *  I(j) Cl I(j)  * Cr  * C I(j) I(j)  * D1  I(j)  * D2  I(j)  * D3  7.
Axioms of the form next(C, D) are mapped by using the dynamic extension constraint to capture that C v 3+ D. To capture that C v !3+ 3+ D we rewrite it as C v 2+ 2+ !D, which, in turn, is encoded by the following set of axioms: C v 2+ C1 C1 v 2+ C2 C2 v !D Figure 6(b) shows the portion of the ERV T diagram that maps next axioms.
= {i [?]
N | the jth cell of ci is the active one} I(j+1)  = Cs  I(j-1)  = Cs S I(j) = x[?
]A0 Cx I(j-1)  = CPS  I(j-1)  = D1  I(j-1)  = Cr S I(j) * S1I(j) = a[?
]A Chs1 ,ai .
It is easy to verify that I is a model of KBM where C0 is satisfiable.
2  Reducing ALC F concept sat to ERV T entity sat We now show how to capture the knowledge base KBM with an ERV T schema, SM .
The mapping is based on a similar reduction presented in [5] for capturing ALC axioms.
For each atomic concept and role in KBM we introduce an entity and a relationship, respectively.
To simulate the universal concept, >, we introduce a snapshot entity, Top, that generalizes all the entities in SM .
Additionally, the various axioms in KBM are encoded in ERV T as follows:  The above reductions are enough to capture all axioms in KBM .
Indeed, axioms (13-15) have the form: C v !C1 t [?
]R.C2 .
They can be split by introducing new concepts C 1 , C 2 as follows: C v C1 t C2 C 1 v [?
]R.C1 C 2 v !C2 We proceed in a similar way to encode axioms (16) which have the form: Ca v Cl t Cs t Cr t [?
]R.Ca , and the axiom (12).
We are now able to prove the main result of this paper.
Theorem 5.2.
Reasoning in ERV T using persistency and dynamic constructs is undecidable.
Proof Proving that the above reduction from KBM to SM is true can be easily done by checking the semantic equivalence between each ALC F axiom and its encoding (for a similar proof see [5]).
Then, the concept C0 is satisfiable w.r.t.
KBM iff the entity C0 is satisfiable w.r.t.
SM .
Thus, because 5  4  A similar proof holds if T = hZ, <i.
Considering R as a functional role does not change the ALC F undecidability proof.
Top  S  R  S  (1,1)  Top  S  d  C  (1,1)  RC  D  C  PER  C1  PER  C2  D  DEX  (a)  (b)  Figure 6.
Encoding axioms: (a) C v [?
]R.D and > v [?
]R.>; (b) next(C, D).
of Proposition 5.1, the halting problem can be reduced to reasoning in ERV T .
2 [4]  6.
Conclusions We formally discussed the relevant reasoning problems for temporal conceptual models.
We distinguished between six different reasoning services: (a) Entity, relationship and schema satisfiability; (b) Liveness and global satisfiability for both entities and relationships; (c) Subsumption for either entities or relationships; (d) Logical implication between schemas.
While the problems (a-c) have been shown to be reducible to each other, checking whether a schema logically implies another schema has been shown to be the more general reasoning service.
We then investigated the complexity of reasoning on temporal models and we found that such problem is undecidable as soon as the schema language is able to distinguish between temporal and atemporal constructs (in particular, whether the language captures temporal relationships) and has the ability to represent dynamic constraints between entities.
We finally mention an interesting open problem which will be matter of a future work.
Does reasoning on ERV T become decidable if we drop dynamic constraints?
Without dynamic constraints it is possible to encode ERV T using a combination between the description logic ALCQI and the epistemic modal logic S5.
Decidability results have been proved for the logic ALC S5 [9].
But, it is still an open problem whether this result holds for the more complex logic ALCQI S5 .
[5] [6]  [7]  [8] [9]  [10]  [11]  [12]  Acknowledgments I would like to thank Diego CAlvanese, Enrico Franconi, Sergio Tessaris and Frank Wolter together with the anonymous referees for enlightening comments on earlier drafts of the paper.
[14]  References  [15]  [1] A. Artale and E. Franconi.
A survey of temporal extensions of description logics.
Annals of Mathematics and Artificial Intelligence, 30("1-4"), 2001.
[2] A. Artale and E. Franconi.
Temporal ER modeling with description logics.
In Proc.
of the International Conference on Conceptual Modeling (ER'99).
Springer-Verlag, Novembre 1999.
[3] A. Artale, E. Franconi, and F. Mandreoli.
Description logics for modelling dynamic information.
In J. Chomicki, R. van der  [13]  [16]  Meyden, and G. Saake, editors, Logics for Emerging Applications of Databases.
Lecture Notes in Computer Science, Springer-Verlag, 2003.
A. Artale, E. Franconi, F. Wolter, and M. Zakharyaschev.
A temporal description logic for reasoning about conceptual schemas and queries.
In S. Flesca, S. Greco, N. Leone, and G. Ianni, editors, Proceedings of the 8th Joint European Conference on Logics in Artificial Intelligence (JELIA-02), volume 2424 of LNAI, pages 98-110.
Springer, 2002.
D. Berardi, A. Cali, D. Calvanese, and G. De Giacomo.
Reasoning on UML class diagrams.
Technical Report 11-03, 2003.
D. Calvanese, M. Lenzerini, and D. Nardi.
Unifying class-based representation formalisms.
J. of Artificial Intelligence Research, 11:199-240, 1999.
J. Chomicki and D. Toman.
Temporal logic in information systems.
In J. Chomicki and G. Saake, editors, Logics for Databases and Information Systems, chapter 1.
Kluwer, 1998.
R. Elmasri and S. B. Navathe.
Fundamentals of Database Systems.
Benjamin/Cummings, 2nd edition, 1994.
D. Gabbay, A.Kurucz, F. Wolter, and M. Zakharyaschev.
Manydimensional modal logics: theory and applications.
Studies in Logic.
Elsevier, 2003.
H. Gregersen and J. Jensen.
Conceptual modeling of timevarying information.
Technical Report TimeCenter TR-35, Aalborg University, Denmark, 1998.
C. S. Jensen, J. Clifford, S. K. Gadia, P. Hayes, and S. J. et al.
The Consensus Glossary of Temporal Database Concepts.
In O. Etzion, S. Jajodia, and S. Sripada, editors, Temporal Databases - Research and Practice, pages 367-405.
SpringerVerlag, 1998.
C. S. Jensen and R. T. Snodgrass.
Temporal data management.
IEEE Transactions on Knowledge and Data Engineering, 111(1):36-44, 1999.
C. S. Jensen, M. Soo, and R. T. Snodgrass.
Unifying temporal data models via a conceptual model.
Information Systems, 9(7):513-547, 1994.
S. Spaccapietra, C. Parent, and E. Zimanyi.
Modeling time from a conceptual perspective.
In Int.
Conf.
on Information and Knowledge Management (CIKM98), 1998.
C. Theodoulidis, P. Loucopoulos, and B. Wangler.
A conceptual modelling formalism for temporal database applications.
Information Systems, 16(3):401-416, 1991.
F. Wolter and M. Zakharyaschev.
Satisfiability problem in description logics with modal operators.
In Proc.
of the 6 th International Conference on Principles of Knowledge Representation and Reasoning (KR'98), pages 512-523, Trento, Italy, June 1998.