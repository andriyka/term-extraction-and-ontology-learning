On the Expressivity of RoCTL* John Mc Cabe-Dansteda, Tim French, Mark Reynolds The University of Western Australia Computer Science and Software Engineering {john,tim,mark}@csse.uwa.edu.au  Abstract  Sophie Pinchinat Campus Universitaire de Beaulieu IRISA Sophie.Pinchinat@irisa.fr  such as "even with n additional failures" to be built up by chaining n simple unary Robustly operators together.
RoCTL* was proposed to model robustness in concur-  The RoCTL* Obligatory operator is similar to the Oblig-  rent systems.
RoCTL* extended CTL* with the addition  atory operator in Standard Deontic Logic (SDL), although  of Obligatory and Robustly operators, which quantify over  in RoCTL* the operator quantifies over paths rather than  failure-free paths and paths with one more failure respec-  worlds.
SDL has many paradoxes.
Some of these, such  tively.
Whether RoCTL* is more expressive than CTL* has  as the aGentle Murderera paradox spring from the inade-  remained an open problem since the RoCTL* logic was  quacy of SDL for dealing with obligations caused by acting  proposed.
We use the equivalence of LTL to counter-free  contrary to duty such as aIf you murder, you must murder  automata to show that RoCTL* is expressively equivalent  gentlya.
Contrary-to-Duty (CtD) obligations are important  to CTL*; the translation to CTL* provides the first model  for modeling a robust system, as it is often important to  checking procedure for RoCTL*.
However, we show that  state that the system should achieve some goal and also that  RoCTL* is relatively succinct as all satisfaction preserving  if it fails it should in some way recover from the failure.
translations into CTL* are non-elementary in length.
Draft:  RoCTL* can represent CtD obligations by specifying that  May 19, 2009  the agent must ensure that the CtD obligation is met even if a failure occurs.
For further discussion of CtD obligations and motivations for RoCTL*, see [11].
The obligatory op-  1.
Introduction  erator, as well as some uses of the robustly operator, are easy to translate into CTL* [17].
Logic  When RoCTL* was originally proposed [11], it had  (RoCTL*) [11] is an extension of CTL* introduced to  The  Robust  Full  Computation  Tree  represent issues relating to robustness and reliability in  two accessibility relations, a success and failure transition.
However we may equivalently define RoCTL* with a single  systems.
It does this by adding an Obligatory operator and  accessibility relation if we add a violation atom v to indi-  a Robustly operator.
The Obligatory operator specifies how  cate that the previous transition was a failure transition (this  the systems should behave by quantifying over paths in  new definition was first used in [17]).
Under this definition,  which no failures occur.
The Robustly operator specifies  the RoCTL* models are CTL models, albeit with a special  that something must be true on the current path and similar paths that "deviate" from the current path, having at most  violation atom not used in RoCTL* formulas.
In this pa-  one more failure occurring.
This notation allows phrases  in CTL* formulas, then we can express every RoCTL* for-  per we show that if we allow the violation atom to occur mula into an equivalent CTL* formula.
Although we will  a This Project is supported by the Australian Governmentas International Science Linkages program  expose the violation atom, we do not extend the model, in 1  reliability.
However their logic reasons about reliability us-  particular we do not add atoms to the model.
The addition of the Robustly operator and temporal  ing probabilities rather than numbers of failures, and their  operators to Deontic logic allows RoCTL* to deal with  paper does not contain any discussion of the relationship  Contrary-to-Duty obligations.
SDL is able to distinguish  of their logic to Deontic logics.
Like our embedding into  what ought to be true from what is true, but is unable to  QCTL*, Aldewereld et al.
[1] uses a Viol atom to represent  specify obligations that come into force only when we be-  failure.
However, their logic also uses probability instead of  have incorrectly.
For example, SDL is inadequate to represent the obligation aif you murder, you must murder gen-  failure counts and is thus suited to a different class of problems than RoCTL*.
None of these logics appear to have an  tlya [10].
Addition of temporal operators to Deontic logic  operator that is substantially similar to the Robustly opera-  allows us to specify correct responses to failures that have  tor of RoCTL*.
occurred in the past [23].
However, this approach alone  Diagnosis problems in control theory [14, 2] also deals  is not sufficient [23] to represent obligations such as aYou  with failures of systems.
Diagnosis is in some sense the  must assist your neighbour, and you must warn them iff you  dual of the purpose of the RoCTL* logic, as diagnosis re-  will not assist thema.
In RoCTL* these obligations can be  quires that failure cause something (detection of the failure)  represented if the obligation to warn your neighbour is ro-  whereas robustness involves showing that failure will not  bust but the obligation to assist them is not.
cause something.
Other approaches to dealing with Contrary-to-Duty obli-  The translation we will present in this paper results in a  gations exist.
Defeasible logic is often used [18], and logics of agency, such as STIT [3], can be useful as they can allow  formula that is satisfied on a model iff the original formula  obligations to be conditional on the agentas ability to carry  all the CTL* model checkers, decision procedures and so  out the obligation.
forth for RoCTL*.
is satisfied on the same model.
This means that we can use  This paper provides some examples of robust systems  We will then show that although all RoCTL* formulas  that can be effectively represented in RoCTL*.
It is easy  can be translated into CTL*, the length of the CTL* formula  to solve the coordinated attack problem if our protocol is  is not elementary in the length of the RoCTL* formula.
allowed to assume that only n messages will be lost.
The  Hence some properties can be represented much more succinctly in RoCTL* than CTL*.
logic may also be useful to represent the resilience of some economy to temporary failures to acquire or send some resource.
For example, a remote mining colony may have in-  2.
Definitions  teracting requirements for communications, food, electricity and fuel.
RoCTL* may be more suitable than Resource  2.1.
RoCTL-Structures and Trees  Logics (see e.g.
[6]) for representing systems where a failure may cause a resource to become temporarily unavail-  Definition 1.
We let V be our set of variables.
The set V  able.
This paper presents a simple example where the only  contains a special variable v. A valuation g is a map from  requirement is to provide a cat with food when it is hungry.
a set of worlds A to the power set of the variables.
The  A number of other extensions of temporal logics have  statement p a g(w) means roughly athe variable p is true at  been proposed to deal with Deontic or Robustness is-  world wa.
sues [4, 16, 13, 1, 21].
Each of these logics are substantially different from RoCTL*.
Some of these logics are de-  Definition 2.
We say that a binary relation R on S is serial  signed specifically to deal with deadlines [4, 13].
An Agent  (total) if for every a in S there exists b in S such that aRb.
Communication Language was formed by adding Deontic and other modal operators to CTL [21]; this language does  Definition 3.
A structure M = (A, R, g) is a 3-tuple con-  not explicitly deal with robustness or failures.
Hansson and  taining a set of worlds A, a serial binary relation R on A, a  Johnsson [13] proposed an extension of CTL to deal with  valuation g on the set of worlds A.
2  Definition 4.
We call an D-sequence D = hw0 , w1 , .
.
.i of  follows:  worlds a fullpath iff for all non-negative integers i we have M, D  N D iff M, DaL1  D  wi Rwi+1 .
For all i in N we define DaLi to be the fullpath hwi , wi+1 , .
.
.i, we define Di to be wi and we define Da$?i to  M, D  DU D iff aiaN s.t.
M, DaLi  D and  be the sequence hw0 , w1 , .
.
.
, wi i.  ajaN j < i =a M, DaLj  D M, D  AD iff aDaSF (D0 ) M, D  D  Definition 5.
We say that a fullpath D is failure-free iff for  M, D  OD iff aDaS(D0 ) M, D  D  all i > 0 we have v a / g (Di ).
We define SF (w) to be the  M, D  ND iff aDaI'(D) M, D  D and M, D  D  set of all fullpaths starting with world w and S(w) to be the set of all failure-free fullpaths starting with w. We call a  The definition for >, p, AZ and aSS is as we would expect from  CTL structure a RoCTL structure iff S(w) is non-empty for  classical logic.
The intuition behind the N operator is that it  every w a A.  quantifies over paths that could result if a single error was introduced; the deviations only have at most one failure not on the original path, and they are identical to the original  Definition 6.
For two fullpaths D and D we say that D is an  path until this failure occurs.
i-deviation from D iff Da$?i = Da$?i and DaLi+1 a S(Di+1 ).
We say that D is a deviation from D if there exists a non-  Definition 7.
We say that a function D from formulas to  negative integer i such that D is an i-deviation from D. We  formulas is satisfaction preserving iff for all M, D and D it  define a function I' from fullpaths to sets of fullpaths such  is the case that M, D  D aa M, D  D (D).
that where D and D are fullpaths, D is a member of I'(D) iff  We will now define a tree.
A tree is similar to a structure,  D is a deviation from D.  but a tree need not be serial, and each node only has one parent.
We see that S (D0 ) a I'(D) a SF (D0 ).
Where p varies  Definition 8.
We say T = (A, R, g) is a V-labelled tree,  over V, we define RoCTL* formulas according to the fol-  for some set V, iff  lowing abstract syntax 1.
A is a non-empty set of nodes D := > | p | AZD | (D aSS D) | (DU D) | N D | AD | OD | ND .
2. for all x, y, z a A if (x, z) a R and (y, z) a R then x = y.
A formula that begins with A, AZA, O, AZO, p or AZp is called a state formula.
For consistency with [11], we  3. there does not exist any cycle x0 R AV AV AV Rx0 through R.  do not consider a formula that explicitly contains v to be  4. there exists a node x such that for all y a A, if y 6= x  a RoCTL* formula, although our translation into CTL*  there exists a sequence xRx1 R AV AV AV Ry through R.  works equally well for such formulas.
The >, AZ, aSS, N, U 5. the valuation g (or labeling) is a function from A to 2V ,  and A are the familiar atruea, anota, aanda, anexta, auntila  that is for each w a A, g (w) a V.  and aall pathsa operators from CTL.
The abbreviations aL, a", F , G, W , E a and a are defined as in CTL* logic.
Definition 9.
We define the height of a finite tree T =  As with Standard Deontic Logic (SDL) logic, we define  (A, R, g) as follows: root is a function from trees to nodes  P aA AZOAZ.
Finally, we define the dual 4 of N as the ab-  such that root (T ) is the root of the tree T .
height (T ) =  breviation a aA AZNAZ.
We call the O, P , N, a operators  heightR (root (T )) where heightR is a function from A to  Obligatory, Permissible, Robustly and Prone respectively.
N such that for all x a A, we let heightR (x) be the smallest  We define truth of a RoCTL* formula D on a fullpath  non-negative integer such that heightR (x) > heightR (y)  D = hw0 , w1 , .
.
.i in a RoCTL-structure M recursively as  for all y such that (x, y) a R. 3  Definition 10.
We say C = hAC , RC , gC i is a subtree of  Every node, in the run of an SAA on an input structure  T = (A, R, g) iff there exists w a A such that AC is the  M , represents a world of M .
However, a world w in the  subset of A reachable from w and RC and gC are the frag-  input structure M may occur many times in a run.
Where  ments of R and g on AC respectively.
We say C is a di-  a non-deterministic automata would non-deterministically  rect subtree of T = (A, R, g) if C is a subtree of T and  pick a next state, a SAA non-deterministically picks a con-  (root (T ) , root (C)) a R.  junction of elements of the form (, q) and (aS, q); alternatively we may define SAA as deterministically picking a  2.2.
Automata  Boolean combination of requirements of this form, see for example [15].
Alternating automata can also be thought of  Definition 11.
A BAzchi automaton A = (IL, S, S0 , I', F )  as a type of parity game, see for example [12].
An element  contains  of the form (, q)/(aS, q) indicates for every/some child u of the current world w of the input structure M , a run on M  IL: set of symbols (alphabet)  must have a branch which follows u and where q is the next  S: finite set of automaton states  state.
S0 : set of initial states a S I' : a transition function a (S A IL A S)  Definition 13.
A parity acceptance condition F of an au-  S  F : A set of accepting states a 2  tomata (IL, S, S0 , I', F ) is a map from S to N. We say that  a  We call the members of IL words.
Unlike a path through  parity condition accepts an infinite path if the largest inte-  a structure, each transition of a path through an automa-  ger n, such that F (q) = n for some q that occurs infinitely  e  0 ton is labelled with an element e of IL.
We say s0 a  e1  often on the path, is even.
ena1  s1 a AV AV AV a sn is a path of A if for all 0 a$?
i < n the tuple hsi , ei , si+1 i is in I'.
The label of the path is  Definition 14.
A symmetric alternating automata (SAA) is  he0 , e1 , .
.
.
, en i.
Let Lp,q (A) be the set of all labels of  a tuple (IL, S, S0 , I', F ) where IL, S and S0 are defined as in  paths through A from p to q.  BAzchi automata, and I' : a transition function a (S A IL A 2{,aS}AS )  A run D of A is a path starting at a state in S0 .
We say an infinite run is accepting if a state in F occurs infinitely  We define the the acceptance condition F of an SAA  often in the run.
to be a parity acceptance condition, but note that we can  In this paper, IL = 2IS , for some set of state formulas  express BAzchi parity conditions as parity acceptance condi-  IS.
Given a fixed structure M = (A, a, g) and path D, we  tions.
The SAA accepts a run iff every infinite path through  let gIS (Di ) = {D : D a IS aSS M, DaLi  D} and gIS (D) =  the run satisfies F .
hgIS (D0 ), gIS (D1 ), .
.
.i.
Note that IS consists solely of state  A run R = hAR , RR , gR i of the SAA on a V-labelled  formulas so gIS (D0 ) = gIS (D0 ) if D0 = D0 .
input structure M is an AAS-labelled tree structure.
Where  Definition 12.
A counter-free automaton is an automaton  gR (root (R)) = (w, q), it is the case that q a S and w =  such that for all positive integers m, states s a S and words  root (M ).
For every wR in Ar , where (w, q) = gR (wR ) and e = g (w), there exists some set X a 2{,aS}AS such  u in ILa , if um a Ls,s then u a Ls,s [7].
that (wR , e, X) a I' and  Above we have defined linear automata.
These are sufficient for the proof of expressive equivalence of RoCTL*  1.
For each r a S such that (, r) a X, for each u such  and CTL*.
However, in the proof that RoCTL* is relatively  that wRu there must exist uR such that wR RuR and  succinct, we will use tree automata.
We will define a type of tree automata called a symmetric alternating automata  (u, r) a gR (uR ).
(SAA) (see e.g.
[15]), these are a subclass of alternating  2.
For each r a S such that (aS, r) a X, for some u such  automata, and can also be referred to as just alternating au-  that wRu there must exist uR such that wR RuR and  tomata (see e.g.
[24]).
(u, r) a gR (uR ).
4  3.
Examples  Let D = hv, v, .
.
.i.
We see that M, D  p. We see that S(u) = {hu, v, v, .
.
.i}.
Hence M, D  ON p and it follows  In this section a number of examples are presented.
The  that M, D  AZOAZN p and so M, D  AZON AZp.
first example examines the difference between the formula N OD and the formula ON D. The second example shows  Hence M, D  (ON p aSS AZN Op) and so M, D 2 (ON D a N OD) where D = p. Likewise M, D   how RoCTL* may be used to specify a robust network pro-  (N OAZp aSS AZON AZp), so M, D 2 (N OD a ON D) where  tocol.
Then an example of feeding a cat will be introduced  D = AZp.
to explain how we may reason about consequences of po-  Example 16.
In the coordinated attack problem we have  lices.
These examples will frequently use the N/a operator  two generals X and Y .
General X wants to organise an  to form the pair ON.
In the final example we use the simple  attack with Y .
A communication protocol will be presented  formula O(4F e a F w) which nests N/a in a less trivial  such that a coordinated attack will occur if no more than  way.
one message is lost.
Example 15.
Here is an example of a simple Contrary-to-  AG (sX a ON rY ): If X sends a message, Y should re-  Duty obligation.
This provides a counter example to both  ceive it at the next step.
ON D a N OD and N OD a ON D.  AG (AZsX a AZN rY ): If X does not send a message now,  ON (Gp): You should commit to the proper decision.
Y will not receive a message at the next step.
N O (GAZp a" Gp): Once you have made your decision, you  AG(fX a AGfX ): If X commits to an attack, X cannot  must stick with it.
withdraw.
It is consistent with the above that we do not make the  AG(fX a AZsX ): If X has committed to an attack, it is too  proper decision (N AZp).
Once we have made the wrong  late to send messages.
decision we cannot satisfy Gp, so we must stick with the A (AZfX W rX ): X cannot commit to an attack until X has  wrong decision GAZp.
Hence, in this case, both ON (Gp)  received plans from Y  and N O(GAZp) are true.
Likewise ON (GAZp) and N O(Gp) are false.
This demonstrates how obligations can change  Similar constraints to the above also apply to Y .
Below we  with time in RoCTL*.
We will now give an example of a  add a constraints requiring X to be the general planning the  structure M = (A, R, g) that satisfies these formulAS:  attack A (AZsY W rY ): General Y will not send a message until Y  A = {u, v, w, w0 },  has received a message.
R = {(u, v), (v, v), (u, w0 ) , (w0 , w) (w, w)} , g(v) = {p} ,  g(w) = g (u) = a,  No protocol exists to satisfy the original coordination prob-  g(w0 ) = {v} .
lem, since an unbounded number of messages can be lost.
Here we only attempt to ensure correct behaviour if one or  v{p}  fewer messages are lost.
u  A (sX U rX ): General X will send plans until a response is  w0 {v}  received.
w  AG (rX a fX ): Once general X receives a response, X will commit to an attack.
Let D be the fullpath hu, w, w, .
.
.
i corresponding to making the wrong decision.
We see that M, DaL1  AZp, so  A (AZrY W (rY aSS (sY aSS N sY aSS N N fY ))): Once general  M, DaL1  OAZp and M, DaL1  AZOp.
Thus M, D  N OAZp  Y receives plans, Y will send two messages to X and  and M, D  N AZOp.
It follows that M, D  AZN Op.
then commit to an attack.
5  Having the formal statement of the policy above and the se-  be derived, indicating that following a policy requiring us  mantics of RoCTL* we may prove that the policy DE is con-  to always attempt to fill the cat bowl ensures that we will  sistent and that it implies correct behaviour even if a single  not starve the cat even if we make a single mistake.
Thus  failure occurs:  following this simpler policy is sufficient to discharge our original obligation.
DE a ONF (fX aSS fY ) .
Example 18.
Say that a bit ought to flip at every step, but might fail to flip at any particular step.
This may be rep-  Indeed, we have shown that such issues can be decided  resented with the RoCTL* statement AGO (b a AZN b) aSS  in finite time [19] .
AG4 (b a N b), which is satisfied by the following model:  For a more thorough specification of the Coordinated Attack problem, see for example [20, 22].
.
{}  {b}  Example 17.
We have a cat that does not eat the hour after it has eaten.
If the cat bowl is empty we might forget to fill  {v}  it.
We must ensure that the cat never goes hungry, even if  {b, v}  we forget to fill the cat bowl one hour.
At the beginning of the first hour, the cat bowl is full.
We have the following variables:  Then we may derive the following statements:  b aThe cat bowl is full at the beginning of this houra  ON((b aSS N b) a N G (b a AZN b)) If a single failure occurs, and the bit fails to flip at the next step, it will  d aThis hour is feeding timea  flip continuously from then on.
We can translate the statements above into RoCTL* stateONF G (b a AZN b) Even if a single failure occurs, there  ments:  will be time at which the bit will flip correctly from 1.
AG(d a AZN d): If this hour is feeding time, the next  then on.
is not.
However, we will not be able to derive OF NG (b a AZN b), 2.
AG((d a" AZb) a aN AZb): If it is feeding time or the  as this would mean that there was a time at which a failure  cat bowl was empty, a single failure may result in an  could not cause the bit to miss a step.
empty bowl at the next step Example 19.
We define a system that will warn the user if 3.
AG((AZd aSS b) a N b): If the bowl is full and it is not  the system enters an unsafe state:  feeding time, the bowl will be full at the beginning of the next hour.
1.
AGON s: The system should always ensure that the system reaches a safe state by the next step.
4.
ONG (d a b): It is obligatory that, even if a single failure occurs, it is always the case that the bowl must  2.
AG(s a N AZe): If the system is in a safe state an error  be full at feeding time.
e will not occur at the next step.
5. b: The cat bowl starts full.
3. s aSS AZe: The system starts in a safe state with no error.
Having the formalised the policy it can be proven that the  4.
AG(AZs a N w): If the system is in an unsafe state,  policy is consistent and that the policy implies ONGON b,  the system will warn the user at the next step.
indicating that the bowl must be filled at every step (in case we forget at the next step), unless we have already failed  We may prove that if an error e almost occurs, the system  twice.
The formula AGON b a ONG (d a b) can also  will finally warn the user, i.e.
O(4F e a F w).
6  Example 20.
Say that we have wireless sensor and a base  ways have power (NGD).
As with the A operator in CTL*,  station.
Upon detecting some event, the wireless sensor will  NGD a GND is valid in RoCTL* but GND a NGD is not.
activate and send three packets to the base station.
The base station will not know that the wireless sensor sent data if all  4.
Expressivity  three packets were lost.
Thus an error will be reported iff the base station receives either one or two packets.
This can  We will define a translation of 4D into CTL*, for any  be formalised as  CTL* formula D. We will first translate D into counter-free  s aSS N s aSS N N s aSS N N N GAZs: The sensor will send three  BAzchi automata A, we will then define a function D4 from  packets.
automata to automata such D4 (A) is equivalent to 4D, and  AG (s a ON r aSS AZs a N AZs): If a packet is sent, it  translate D4 (A) into CTL*.
This allows us to recursively  should be received at the next step.
If it is not sent it will  translate any RoCTL* formula into an equivalent CTL* for-  not be received.
mula.
AZN ((r aSS N r aSS N N r) a" GAZr) a N N N e: An error  4.1  will be detected if some packets, but not all three, are re-  CTL* and LTL  ceived.
Theorem 22.
A language L is definable in LTL iff L is ac-  It follows that ON (4F eU AZs), indicating that it is ro-  cepted by some counter-free BAzchi automaton [7].
bustly true that if an additional failure occurs, an error could be detected.
In this example a failure may not indicate a  It is well known that we can express a CTL* formula as  packet being dropped, e.g.
it has not been specified whether  an LTL formula over a path, where that path includes state  the packet arrives corrupted.
Thus the system cannot de-  formula as atoms; this is commonly used in model checking  tect all failures.
In RoCTL* it is impossible to specify that  [8, 9, 5].
From the above theorem we can also express this  a failure will have an effect.
At best we can specify that  LTL formula as a BAzchi automaton.
it is always possible for a failure to be detected.
However,  Formally, for any CTL* formula D there exists a set  we can specify that some particular effect will be detected.
of state formulas IS and a counter-free automaton A =  For example, we can express the statement aEven if two or  (2IS , S, S0 , I', F ) such that A accepts gIS (D) iff M, D  D.  fewer packets are lost, either all packets arrive or an error is  We say an automaton A = (2IS , S, S0 , I', F ) is equivalent to  detecteda as  a formula D iff  ONNN ((r aSS N r aSS N N r) a" F e) .
(aM,D M, D  D) aa (A accepts gIS (D)) .
Example 21.
Say a system has a battery that can sustain  Definition 23.
Let A be a function from CTL* formulas to  the system for a single step, even if a failure occurs (the  counter-free BAzchi automata such that A (D) is equivalent to  fuse blows).
Let D represent athe system has power now  D. Likewise let Aa1 be a function from counter-free BAzchi  and at the next stepa.
Then, even if a single failure occurs,  automata of the form A = (2IS , S, S0 , I', F ) to CTL* formu-  it will always be the case that even if a deviating event oc-  las, such that we have D  Aa1 (A) iff A accepts gIS (D).
curs the system will have power now and at the next step (OGND).
It would not follow that even if a single failure  4.2  Construction of D4 (A) from A.  occurred the system would always have power (ONGD); the battery power would only last one step after the fuse  In this section we define the function D4 from counter-  blew.
If we also specified that the fuse was an electronic  free BAzchi automata to automata as follows.
The intention is  fuse that automatically reset, then if a single failure occurs,  that if A is equivalent to D, then D4 (A) will be equivalent to    4D.
For any counter-free automata A = 2IS , S, S0 , I', F ,    it is the case that D4 (A) = 2IS4 , S4 , S0 , I'4 , F4 where  the system would only have to rely on battery power for one step.
Then, if the fuse only blows once then system will al7  1.
IS4 = IS aS I" where I" = {Ds : s a S} and Ds is the  If s = sF then every word u is in Ls,s .
If s 6= sF then  following state formula for each s in S:  every path from s to s in D4 (A) is also a path from s to s in A, and A is counter-free.
  E Aa1 2IS , S, {s} , I', F aSS N N GAZv  4.3  Recursive Translation Function  Ds is roughly equivalent to saying aif we are in state s, We can now translate a RoCTL* formula D into a CTL*  we can deviate herea.
formula c (D) using the recursively defined function c:  2.
We add a state sF indicating that there existed an accepting deviation from this path and so we shall accept  c(D aSS D)  =  c (D) aSS c (D)  c(AZD)  =  AZc(D)  c(AD)  =  Ac (D)  c(OD)  =  A (N GAZv a c (D))  c(N D)  =  N c(D)  is possible and remain in that state regardless of the  c(DU D)  =  c(D)U c(D)  input along the current path.
That is, I'4 it the minimal  c(ND)  =  AZf4 (AZD)  relation satisfying:  f4 (D)  =  Aa1 (D4 (A (D))) .
regardless of further input.
This input relates to the original path rather than the deviation and is thus irrelevant.
As such, S4 = S aS sF and F4 = F aS sF .
3.
I'4 is the relation that includes I' but at each state also gives the option to branch into sF when a deviation  (a) For every tuple hs, e, ti in I' and set I a 2I" the  4.4  tuple hs, e aS I, ti is in I'4 .
This is to ensure that  Proof of Correctness  wherever gIS (D) is a run of A, it is also the case  Lemma 25.
For all structures M , fullpaths D and CTL*  that gIS4 (D) is a run of D4 (A).
The use of I  formulas D, it is the case that M, D  Aa1 (D4 (A (D))) iff  is only required because I'4 has to deal with the  M, D  4D.
atoms in I", which are not in gIS4 (D) but not in     Proof.
As above, let A = 2IS , S, S0 , I', F be A (D); let   IS  D4 (A) = 2 4 , S4 , S0 , I'4 , F4 be the automaton con-  gIS (D).
(b) For each s a S and each e4 a 2IS4 such that  structed from A, and let D4 = Aa1 (D4 (A (D))).
Ds a e4 we have hs, e4 , sF i in I'4 .
Fix a structure M .
We will write M, D  D as D  D.  (c) For each e4 in 2IS4 we have hsF , e4 , sF i in I'4 .
(a=) Say that D  4D.
Case 1: D  D; then A accepts gIS (D).
Thus D4 (A)  To understand (1) above, say we have read i symbols from the current path D, and are in state s. Clearly    if 2IS , S, {s} , I', F accepts DaLi then then A accepts  accepts gIS4 (D) (see 3a above).
Thus D  D4 .
D. As an i-deviation D would share the prefix Da$?i , if   IS  2 , S, {s} , I', F accepts DaLi then A accepts D. The  ger i such that Da$?i = Da$?i and DaLi+1 is failure free.
Hence hgIS (D0 ) , gIS (D1 ) , .
.
.i a L (A).
Thus there exists a se-  N N GAZv ensures that Ds is satisfied only on paths that de-  quence of states s0 , s1 , .
.
.
such that s0  viate here, i.e.
that are i-deviations.
is an accepting run for A.
It is easy to show that si a    gIS (Di+1 ) si+1 a AV AV AV is an accepting run of 2IS , S, {si } , I', F .
 Thus DiaLi  Aa1 2IS , S, {si } , I', F .
As DaLi+1 is fail-  Case 2: D 2 D; then there exists a path D  D and inte-  gIS (D0 )  a s1  gIS (D1 )  a AVAVAV gIS (Di )  The items (b) and (c) above allow us to ignore all further input on the current path if we can satisfy D on a deviation.
ure free DaLi  N N GAZv, hence we have  Lemma 24.
The automaton D4 (A) is counter-free.
  E Aa1 2IS , S, {si } , I', F aSS N N GAZv  Proof.
Recall that a counter-free automaton is an automaton such that for all states s a S and words u in ILa , if um a Ls,s then u a Ls,s .
From 3a above, s0 8  gIS4 (D0 )  a  s1  gIS4 (D1 )  a  = AVAVAV  Dsi a gIS4 (Di ) .
gIS4 (Dia1 )  a  si  is a path through D4 (A).
As Dsi a gIS4 (Di ) it fol   lows from 3b above that si , gIS4 (si ) , sF a I'4 .
Also  we will call (h, l)-utrees, where h represents the height h  hsF , e4 , sF i a I'4 for all e4 in 2IS .
As Da$?i = Da$?i it fol-  and l is the number of bits per label.
We will show that the  lows that s0  gIS4 (D0 )  a  s1  gIS4 (D1 )  a  We will do this by taking a class of labeled trees which  number #(h, l), of pairwise non-isomorphic (h, l)-utrees,  AV AV AV is an accepting run for  is non-elementary in h. We will then present asuffixa and aprefixa encodings of utrees into RoCTL-structures, and  D4 (A).
Thus D  Aa1 (D4 (A)) = D4 .
(=a) Say that M, D  D4 .
Thus there is an accepting run s0  gIS4 (D0 )  a  Case 1: s0  s1  gIS4 (D1 )  a  gIS (D0 )  a  gIS (D1 )  a  s1  will define a function u such that u(T, T 0 ) = M where  AV AV AV for D4 (A).
M is the structure that results when the prefix encoding of  AV AV AV is an accepting run for  T is joined/followed by the suffix encoding of T 0 .
For each  A.
Then D  D and so D  4D.
gIS (D0 )  a  Case 2: s0  gIS (D1 )  a  s1  positive h and l we define a RoCTL* formula f (h, l) such  AV AV AV is not an accept-  that for any pair of utrees T and T 0 of height h it is the case  ing run for A.
Thus the automaton must eventually enter state sF , so the run has a prefix of the form s0 gIS4 (D1 )  gIS4 (Dia1 )  gIS4 (Di )  that u(T, T 0 ) satisfies f (h, l) iff T, T 0 are isomorphic.
For  gIS4 (D0 )  a  an automaton that accepts the tree-unwinding of u(T, T 0 )  We know  iff T and T 0 are isomorphic, once the automaton has read  from the definition of D4 above that Dsi a gIS4 (Di ).
 Thus DiaL1  E Aa1 (IL, S, {si } , I', F ) aSS N N GAZv and  the prefix encoding, the state of the automaton must give  so there exists a path D such that Da$?i = Da$?i , DaLi+1 is  morphic equivalence classes T fell into.
As #(h, l) is non-  failure-free and DaLi  Aa1 (IL, S, {si } , I', F ).
It follows  elementary in h, the number of states in the automata must  that hIL, S, {si } , I', F i accepts DaLi and so there exists an  also be non-elementary in h. Since there are elementary  a  s1  AVAVAV  a  g(Di )  accepting run si a si+1 g(D0 )  g(D1 )  s0 a s1 a AV AV AV  g(Dia1 )  a  si  g(Di+1 )  a  a  sF .
us enough information to determine which of #(h, l) iso-  translations of CTL* into automata, we will conclude that  AV AV AV .
We see that the path  there is no elementary translation of RoCTL* into CTL*.
si through D4 (A) is also a path  through A.
Thus g(D0 )  Definition 27.
We define isomorphism on finite labelled  g(D1 )  g(Di )  s0 a s1 a AV AV AV si a si+1 is a run of A.  g(Di+1 )  a  trees recursively.
We say that T = (A, R, g) and T 0 = AVAVAV  (A0 , R0 , g 0 ) are isomorphic if g (root (T )) = g 0 (root (T 0 ))  0 and  there exist orderings C = C1 , .
.
.
, C|C| and C = 0 C10 , .
.
.
, C|C| of the direct subtrees of T and T 0 respec-  States in F occur in finitely often in  si , si+1 , .
.
.
and hence this run is an accepting run of A.  tively such that Ci and Ci0 are isomorphic for all i a [1, |C|].
Hence D  D. As D is a deviation from D it follows that  We define utrees below such that all (h, l)-utrees have  D  4D.
the same number of direct subtrees, which are pairwise nonTheorem 26.
There exists a satisfaction preserving trans-  isomorphic.
For any pair T, T 0 of (h, l)-utrees, this ensures  lation function from RoCTL* to CTL*.
that if there is a direct subtree of T that is not isomorphic  Proof.
Using Lemma 24 it is easy to show that the transla-  to any subtree of T 0 , there must also be a direct subtree of  tion function c from Section 4.3 is well defined, and from  T 0 that is not isomorphic to any subtree of T .
This makes it  Lemma 25 it is easy to show that c is satisfaction preserv-  easier to test whether a pair of utrees are isomorphic.
ing.
Definition 28.
We define the concept of a utree recursively.
We fix an infinite enumerated set VD = {b1 , b2 , .
.
.}.
A tree T = hA, R, gi consisting of a single node n is a (0, l)-  5.
Succinctness  utree iff g(n) a Vl where Vl = {b1 , b2 , .
.
.
bl }.
We let In the previous section we showed that a satisfaction pre-  # (h, l) be the number of pairwise non-isomorphic (h, l)-  serving translation from RoCTL* to CTL* exists.
In this  utrees; then a tree T is a (h + 1, l)-utree iff g(root (T )) = a  section we will show that any satisfaction preserving trans-  and T has b# (h, l) /2c direct subtrees, which are pairwise  lation is non-elementary in the length of the formulas.
non-isomorphic (h, l)-utrees.
9  Example 29.
Here is an example (1, 2)-utree.
We use a11a  I{  as shorthand for b1 , b2 and a01a as shorthand for b2 .
tion of a direct subtree of the tree we were describing.
The current world also encodes the  n1  label of this subtree.
I}  n2 {01}  This atom indicates that we begin the descrip-  n3 {11}  This atom indicates that we are ending the description of some tree.
tC  Lemma 30.
The function # (h, l) is at least (h + 1)-  This indicates that the description of the subtree C starts here.
This is not used in function  exponential in l.  f below.
It is only included to allow sections of the encoding to be easily and unambiguously referenced in the proof of correctness.
Proof.
We see that the number of pairwise non-isomorphic (0, l)-utrees is 2l .
From the definition of utrees where n = 2 b# (h, l) /2c,  Hk n!
of a tree of height k, we are at a node of height  n n 2 2!2!
n.n a 1 .
.
.
n2 .
.
.
2.1  n  n 2 .
.
.
.
.2.1 2 .
.
.
.
.2.1  n (n a 1) .
.
.
n2 + 1 n  aL 2( 2 ) n .
.
.
.
.2.1 2  k. Thus I{ aSS H3 means we are beginning the  # (h + 1, l) aL nC = =  The current input character describes the start  n  =  definition of a tree of height 3 and I} aSS H3 means we are ending the definition of a tree of height 3. .
The final world in the prefix encoding is wZ ; the prefix en-  Thus when # (h, l) is j-exponential in l, it is the case that  coding is not a transition structure as wZ has no successor.
# (h + 1, l) is (j + 1)-exponential in l. As # (0, l) is one  Example 31.
Below we present the prefix encoding of the  exponential in l it follows from induction that # (h, l) is at  utree T from Example 29.  least (h + 1)-exponential in l.  w0 {I{ , H1 , tT }  Algorithm 1 can be used to describe the structure of a tree  w1 {I{ , H0 , 01, t(n2 ,a,{n2 7a01}) }  using a string of a{a and a}a characters; strictly speaking for each must iterate over the subtrees in some order, but  w2 {I} , H0 }  the ordering chosen is unimportant and will not be defined here.
E.g.
a{}a represents a tree with a single node, and  w3 {I{ , H0 , 11, t(n3 ,a,{n3 7a11}) } w4 {I} , H0 }  a{{}{}}a represents a tree where the root has two root nodes as successors.
w5 {I} , H1 }  Algorithm 1 PrintTree(T ) 1: Print a{a 2: for each direct subtree D of T : PrintTree() 3: Print a}a  wZ Algorithm 2 T2prefix(T ) 1: (g, i):=T2g(T ,a,0) 2: A := domain (g) aS {wZ } 3: a := {(wja1 , wj ) : j a [1, i)} aS (wi , wZ ) 4: return(A, a, g)  Algorithms 2 and 3 for outputting the prefix encoding prefix (T ) of T are similar.
The function prefix is from utrees to labelled trees where each node has degree of at tree, the prefix encoding also uses the following atoms as  We now define the suffix encoding suffix (T ) of a tree  T = AT , RT , g T .
In addition to the atoms used in the la-  labels, where h is the height of the tree and k a [0, h].
belling of the input tree T , the suffix encoding uses: the  most one.
In addition to the atoms used to label the input  10  g(w) = g S (w) if w a AS , g (w) = g P (w) if w a AP ,  Algorithm 3 T2g(T ,g,i)  1: AT , RT , g T :=T 2: g[wi ]:={I{ , Hheight(T ) , tT } aS g T (root (T )); i++ 3: for each direct subtree C of T: (g, i):=T2g(C,g,i) 4: g[wi ]:={I} , Hheight(T ) }; i++ 5: return(g, i)  R = RS aS RP aS {(wZ , root (T 0 ))}.
Definition 34.
We say that a structure M satisfies a formula D iff there exists a path D such that M, D  D. Definition 35.
Let us define a function f as follows from pairs of natural numbers to RoCTL* formulas:  violation atom v from RoCTL*; and HkF for k in [0, h] which is used to indicate the height of the current node  f (0, l) =  in the tree, much like Hk is used in the prefix encoding.
 	 Let N = n1 , .
.
.
, n|N | be the set of nodes in the tree  ^  bi a F H0F aSS bi    aSS  ia[1,l]  ^  T .
Let N 0 bena numbered o set such that |N | = |N 0 |; 0 0 0 that is N = n1 , .
.
.
, n|N | .
Then for all trees T , if  AZbi a F H0F aSS AZbi    ia[1,l]  f (k, l) =  (A, R, g) = suffix (T ) we have 1.
A = N aS N 0 aS {nZ }     I{ aSS Hka1 a 4f (k a 1, l) U I} aSS Hk  aSS F HkF aSS I{ aSS Hk  Recall that F D is shorthand for (>U D), and as such  2.
R is the minimal relation satisfying: R a RT ,  M, D  F D aa ai M, DaLi  D.  and {(ni, n0i ) , (n0i , nZ ) , (nZ , nZ )} a R, for all i a  The intuition behind f is that a path D through  [1, |N |].
u (T, T 0 ) = hA, R, gi can correspond to both a subtree of T and a subtree T 0 ; if tC a g (D0 ) then D starts at the be-  3. the valuation g is the valuation satisfying g(ni ) =  ginning of the prefix encoding of some subtree C of T , and  {v}; g (nZ ) = a and g (n0i )  =  if n0C 0 is in D then D corresponds to some subtree C 0 of T 0 .
n F g T (ni ) aS Hheight  o  RT  (ni )  The formula f (0, l) is satisfied if the labels of C and C 0  .
match, so f (0, l) is satisfied iff C and C 0 are isomorphic  Example 32.
Below we present the suffix encoding of the  leafs.
A deviation from the current path can only have one  utree from Example 29.  additional failure, and hence only one additional edge.
So, where n0C 0 is in D, then for each subtree D0 of T 0 satisfying  n1 {v}  height (D0 ) = height (C) a 1 there exists a deviation from D containing n0D0 iff D0 is a direct subtree of C 0 .
As such,  n3 {v}  n2 {v}  4f (0, l) is satisfied exactly on those paths that correspond to subtrees C and D0 such that C has a direct subtree iso-  n01 {H1F } n02 {01, H0F }  morphic to D0 .
We use this intuition and recursion to prove the following lemma.
n03 {11, H0F }  Lemma 36.
For any integers u and l, if T and T 0 are (u, l)utrees then u (T, T 0 ) satisfies f (u, l) iff T and T 0 are iso-  nZ  morphic.
Definition 33.
We let u (T, T 0 ) be the model that re-  Proof.
For each subtree C of T , let wC be the world that is  sults when we join the prefix encoding of T to the suf-  the beginning of the suffix encoding of C, or more formally  0  0  the world where tC is true.
For any path, D we define DaLC  fix encoding of T by adding (wZ , root (T )) to R. For mally, where AP , RP , g P is the prefix encoding of T  and AS , RS , g S is the suffix encoding of T 0 , it is the 0  case that u (T, T ) = (A, R, g) where A = A  P  such that DaLC = DaLi where Di = wC .
(=a) Say that u (T, T 0 ) , D T  f (u, l) for some D T .
S  We see that D0T = w0 as f (u, l)  I{ aSS Hu .
We define D C  aSA , 11   AT , R T , g T .
recursively for each subtree C of T .
Say we have defined the path D C for some subtree C such that u (T, T 0 ) , D C   Likewise let nC be the node that is the root of the sub-  f (k, l) where k is the height of C. Then for each direct  tree C. We define D C recursively as follows: let D T be  C DaLD   4f (k a 1, l) and thus  the fullpath starting at w0 that passes through n00 ; that is,  C there must exist a deviation from DaLD satisfying f (ka1, l), D we call this deviation D .
D T = hw0 , .
.
.
, wZ , nT , n0T , nZ , nZ , .
.
.i.
Say that D is  subtree D of C, we see that  0  the direct subtree of C, then where  n0C 0  We see that for each C there is a unique C such that is in the path D C .
In the following paragraph we will show  D C = hwC , .
.
.
, wD , .
.
.
, wZ , nT , .
.
.
, nC , n0C , nZ , nZ , .
.
.i  that for each subtree C and direct subtree D of C, we can we let  C produce D D from DaLD by replacing n0C 0 with nD0 n0D0 , and  hence that D0 is a direct subtree of C 0 .
Consider where D first world in D in both D  C  D  D  deviates from  not in D  C  C DaLD .
D D = hwD , .
.
.
, wZ , nT , .
.
.
, nC , nD , n0D , nZ , nZ , .
.
.i .
Say ny is the  and that nx is the last world  C In other words, we produce DaLD from D C by pruning ev-  and D .
From the definition of deviations we  C erything prior to wD , and D D from DaLD and replacing n0C  D  D see that DaLn is failure-free and y 0 must be nB .
Since D D  F HkF D it follows that HkF a g (n0B );  so the next world on D  D  with nD , n0D .
This remains a full path, since D is a direct  where k is the height of  subtree of C, and so nD is a child of nC .
Note also that D D  from the structure of the  C is a deviation from DaLD .
suffix encoding it is clear that B is a direct subtree of A, As each  If height (C) = 0 it is easy to verify that D C  f (0, l), 	  	  as g (wC ) aS H0F = g (nC ) aS H0 , tC , I{ .
For C of  parent has a height greater than that of its direct subtrees, it  height k, it is likewise easy to see that D C  F HkF .
Assume  and height (A) = k + 1 and thus follows that n  C0  n0C 0 ,  F Hk+1  in  g (n0A ).
C  is the only world in D such that  F Hk+1  a  that D C  f (k a 1, l) for all C of height k a 1 [expand].
and hence it follows that nx = nC 0 .
Now consider C of height k. It is easy to show that  Consider D of height 0.
The path D D is of the form dLT  dLs _  D C  dL I{ aSS Hka1 a   hwD , .
.
.
, wZ , nT , .
.
.
, nC 0 , nD0 , n0D0 , nZ , nZ , .
.
.i  D 0  It is easy to show that D and D are isomorphic.
For each   tD dL, U I} aSS Hk .
is child of C  By assumption D D  f (ka1, l), and D D is a deviation from  C, we choose C 0 such that n0C 0 is in the full path D C .
Say  C C DaLD , so DaLD  4f (k a 1, l).
Thus  0  that for every D of height k it is the case that D and D are isomorphic.
Consider C of height k + 1.
We have shown that for each direct subtree D of C, it is the case that D0  DC   is a direct subtree of C 0 .
As C must have the same height     I{ aSS Hka1 a 4f (k a 1) U I} aSS Hk .
Thus D C  f (k, l).
By induction u (T, T 0 ) , D T  f (u, l).
F as C 0 (otherwise the requirement that D  F Hk+1 would  not be satisfied), C 0 and C have the same number of direct subtrees, each of height k. We have show previously that  Example 37.
In Lemma 36 above, we proved that  0  for each direct subtree D of C, it is also the case that D is  u (T, T 0 ) , D T  f (u, l) for some D T iff T and T 0 are iso-  a direct subtree of C 0 .
By assumption, each pair D, D0 are  morphic.
Using T as the tree in Example 29, let  isomorphic, and so C, C 0 are isomorphic.
By induction T D 0 = hw0 , .
.
.
, wZ , n1 , n01 , nZ , .
.
.i  and T 0 are isomorphic.
(a=) Say that T 0 and T are isomorphic.
Clearly suf-  D 1 = hw1 , .
.
.
, wZ , n1 , n2 , n02 , nZ , .
.
.i  fix encodings of T 0 and T will also be isomorphic, and  D 2 = hw3 , .
.
.
, wZ , n1 , n3 , n03 , nZ , .
.
.i  so u (T, T 0 ) satisfies f (u, l) iff u (T, T ) does.
Thus we can assume without loss of generality that T = T 0 =  be paths through u (T, T ).
We see that D 1 and D 2 sat12  0 isfy f (0, 2).
As D 1 and D 2 are deviations from DaL1 and 0 DaL3  respectively, it is the case that  0 DaL1  and  0 DaL3  There are a number of translations of Al-calculus into al-  satisfy  ternating automata, Wilke gives a simple translation that  4f (0, 2).
Thus wherever I{ aSS H0 is true, it is also the  does not assume that the tree has any particular struc-  0  case that 4f (0, 2) is true; hence u (T, T ) , D  f (1, 2).
ture [24].
The states in the resulting automata are subfor-  Definition 38.
We say an automaton A accepts a structure  mulas of the Al-calculus formula.
Hence the translation into alternating automata is linear.
M iff the tree unwinding of M is a member of L (A).
Lemma 39.
For any arbitrary h, l a N, let A =  The translation via Al-calculus above is sufficient for this  (IL, S, S0 , I', F ) be an SAA such that for any pair T, T 0 of  paper.
There are translations that result in more optimised  (h, l)-utrees A accepts u (T, T 0 ) iff T and T 0 are isomor-  model checking and decision procedure results [15].
phic; then 2|S| aL # (h, l).
 	 Proof.
Let T1 , T2 , .
.
.
, T#(h,l) be a set of pairwise  Corollary 41.
For all fixed h aL 1, there is no function e  non-isomorphic (h, l)-utrees.
For each i, let Ri  which is less than (h a 1)-exponential, such that the length |Dl | of the shortest CTL* formula Dl aA f (h, l) satisfies  =  hARi , gRi , RRi i be an accepting run of A on u (Ti , Ti ); let  |Dl | < e (l) for all l.  Qi be the set of all states that the automata is in after read-  Proof.
Say e exists.
Since Dl aA f (h, l) then there ex-  ing the prefix encoding of Ti ; formally let Qi a S be the  ists a fullpath D T starting at w0 through u(T, T 0 ) such that  set of states such that for all q a S we have q a Qi iff there  u(T, T 0 ), D T  Dl iff T and T 0 are isomorphic.
As e is less  exists wR a ARi such that (root (Ti ) , q) a gRi (wR ).
Re-  than (h a 1)-exponential, from Theorem 40 the size of the  call that root (Ti ) is the beginning of the suffix encoding of  SAA is less than h-exponential in l. From Lemma 39, we have 2n aL # (h, l) where n is the  u (Ti , Ti ).
Say that Qi = Qj for some i 6= j.
Let Aq be shorthand  size of the automata, and from Lemma 30 we know that  for (IL, S, {q} , I', F ).
In the next paragraph we will define a  # (h, l) is (h + 1)-exponential in l. Hence 2n is at least  run  Rji  with the prefix from the run Rj and the suffix from  (h + 1)-exponential in l, and so n is at least h-exponential  Ri .
in l. By contradiction no such e exists.
Since all infinite paths of the run Ri are accepting, we see that for each q a Q , the relevant subtree Rsuffix of R is an i  Corollary 42.
For all fixed h aL 2, there is no function  i  i,q  e which is less than (h a 2)-exponential such that for all  accepting run for Aq on the suffix encoding of Ti .
Let Rji be  RoCTL* formulas D with at most h nested 4 (or N), the  the tree that results when we replace the subtree beginning at w with Rsuffix , for each q a Q = Q and w a A R  i,q  i  j  R  length |D| of the shortest CTL* formula D equivalent to D  Ri  is no more than e (|D|).
satisfying gRj (wR ) = (root (Tj ) , q).
It is easy to show that Rji is an accepting run of A on u (Tj , Ti ).
However  Proof.
This follows from the above corollary, and the fact  we have assumed that Ti is not isomorphic to Tj , and so A  that f (h, l) has at most h nested 4 and |f (h, l)| a  does not accept u (Tj , Ti ).
By contradiction Qi 6= Qj for  O (h + l).
S  any i, j a [1, # (h, l)] such that i 6= j.
As each Qi a 2 ,  Theorem 43.
There is no satisfaction preserving transla-  we can conclude from the pigeon hole principle that 2|S| aL  tion from RoCTL* to CTL* that is elementary in the length  # (h, l).
of the formula.
Theorem 40.
Given a CTL* formula D we can construct an  Obvious from the above Corollary; if there were an i-  SAA AD with a number of states that is singly exponential  exponential translation of RoCTL* into CTL* for any i a  in the length of D.  N there would be an i-exponential translation of RoCTL* formulas with i + 3 nested 4 operators.
Proof.
Dam provides a translation of CTL* formulas into  We see that the only non-classical operators in f (h, l)  equivlent Al-calculus.
The nodes are sets of formulas, so  are positively occurring a, U and F .
Since F D is short  this is a singly exponential translation.
13  hand for >U D we see that alternations between positively  las.
While in other logics non-elementary blowup is fre-  occurring U and 4 are sufficient to produce non-elementary  quently the result of unbounded alternations between posi-  blowup.
By slightly modifying f , we can similarly demon-  tive and negative occurrences of the same operator, we do  strate that alternation between positively occurring N and U  not need to alternate between 4 and N to demonstrate non-  are also sufficient to produce non-elementary blowup.
For example the following f 0 contains only operators equiva-  elementary blow up.
Indeed, the only non-classical opera-  lent to negatively occurring U , where W is the weak until W operator and H F a i HiF :  We may modify f slightly so that it only contains positively  tors in the function f were positively occurring U and 4. occurring U and N. RoCTL* is known to be decidable, but without a known  f 0 (0, l) =  ^  bi a G H F a H0F aSS bi    aSS  elementary upper bound.
Our succinctness result shows that  ia[1,l]  ^  a full translation into CTL* or Tree Automata cannot reAZbi a G H F a H0F aSS AZbi    sult in elementary decision procedures.
The question still  ia[1,l]  f 0 (k, l) =  remains as to whether some other elementary decision pro-     I{ aSS Hka1 a 4f 0 (k a 1, l) W I} aSS Hk  aSS F HkF aSS I{ aSS Hk  cedure can be found for RoCTL*.
The discovery of such a procedure would be interesting, as this would be the first modal logic which was elementary to decide but had only  Since there is no elementary translation of f and f 0 into  non-elementary translations into tree automata.
CTL*, there is also no elementary translation of AZf and AZf 0 into CTL*.
References [1] H. Aldewereld, D. Grossi, J. Vazquez-Salceda, and  6.
Conclusion  F. Dignum.
Designing normative behaviour by the use of landmarks.
In Agents, Norms and Institutions for Regulated  We have shown that all RoCTL* formulas can be expressed as an equivalent CTL* formula.
This translation  Multiag.
Syst., Utrecht, The Netherlands, Jul 2005.
[2] A. Arnold, A. Vincent, and I. Walukiewicz.
Games for syn-  can also be used to translate RoBCTL* [17] formulas into  thesis of controllers with partial observation.
TCS, 303(1):7a  BCTL* formulas.
Once translated into CTL* formula we  34, 2003.
[3] N. Belnap.
Backwards and forwards in the modal logic of  can use any of the standard methods for model checking, so  agency.
Philos.
Phenomen.
Res., 51(4):777a807, Dec 1991.
[4] J. Broersen, F. Dignum, V. Dignum, and J.-J.
C. Meyer.
De-  this result provides us with a model checking procedure for RoCTL*.
As with CTL*, the model checking problem for  signing a Deontic Logic of Deadlines, volume 3065/2004 of  RoCTL* is linear with respect to the size of the model [8].
Classes of RoCTL* formulas with bounded N-complexity  LNCS, pages 43a56.
Springer, 2004.
[5] E. M. Clarke, E. A. Emerson, and A. P. Sistla.
Automatic  have linear translations into CTL*.
Thus as with CTL* the  verification of finite-state concurrent systems using tempo-  model checking problem is also singly exponential [8] with  ral logic specifications.
ACM Trans.
Program.
Lang.
Syst.,  respect to the length of these formulas , and satisfiability is doubly exponential.
Multiple nestings of N (or 4) with-  8(2):244a263, 1986.
[6] M. de Weerdt, A. Bos, H. Tonino, and C. Witteveen.
A re-  out any form of alternation can also be translated to CTL*  source logic for multi-agent plan merging.
Annals of Math.
without increasing the complexity of the translation over a  and AI, 37(1-2):93a130, January 2003.
[7] V. Diekert and P. Gastin.
First-order definable languages.
single N operator.
In J. Flum, E. GrA$?del, and T. Wilke, editors, Logic and  We have not shown the exact complexity of the transla-  Automata: History and Perspectives, volume 2 of Texts in  tion.
However we will attempt to show that there is roughly  Logic and Games, pages 261a306.
Amsterdam University  a single exponential blowup per alternation between a (or N) and U ; never-the-less we expect model checking to be  Press, 2008.
[8] J. Edmund M. Clarke, O. Grumberg, and D. A. Peled.
Model  practical for some useful subclasses of RoCTL* formu-  Checking.
MIT Press, 1999.
14  [9] E. A. Emerson and C.-L. Lei.
Modalities for model checking  [23] L. W. N. van der Torre and Y. Tan.
The temporal analysis of  (extended abstract): branching time strikes back.
In POPL  Chisholmas paradox.
In T. Senator and B. Buchanan, editors,  a85: Proc.
12th ACM SIGACT-SIGPLAN symp.
on Princi-  Proc.
14th Nation.
Conf.
on AI and 9th Innov.
Applic.
of AI  ples of programming languages, pages 84a96, New York,  Conf., pages 650a655.
AAAI Press, 1998.
[24] T. Wilke and C. albrechts-universitt Zu Kiel.
Alternating  NY, USA, 1985.
ACM.
tree automata, parity games, and modal Al-calculus, 2000.
[10] J. W. Forrester.
Gentle murder, or the adverbial samaritan.
J.
Philos., 81(4):193a7, April 1984.
[11] T. French, J. C. Mc Cabe-Dansted, and M. Reynolds.
A Temporal Logic of Robustness, volume 4720 of LNCS, pages 193a205.
2007.  http://dx.doi.org/10.1007/  978-3-540-74621-8_13.
[12] E. GrA$?del, W. Thomas, and T. Wilke.
Automata, Logics, and Infinite Games: A Guide to Current Research.
2002.
LNCS, Vol.
2500 http://www.springer.com/computer/ book/978-3-540-00388-5.
[13] H. Hansson and B. Jonsson.
A logic for reasoning about time and reliability.
Formal Aspects of Computing, 6(5):512a535, 1994.
[14] T. JASron, H. Marchand, S. Pinchinat, and M.-O.
Cordier.
Supervision patterns in discrete event systems diagnosis.
In 8th Internat.
Workshop on Discrete Event Syst., pages 262a268, July 2006.
[15] O. Kupferman and M. Y. Vardi.
An automata-theoretic approach to reasoning about infinite-state systems.
In Proc CAVa00, LNCS, volume 1855, pages 36a52.
Springer, 2000.
[16] W. Long, Y. Sato, and M. Horigome.
Quantification of sequential failure logic for fault tree analysis.
Reliab.
Eng.
Syst.
Safe., 67:269a274, 2000.
[17] J. C. McCabe-Dansted.
A tableau for RoBCTL*.
In S. HAslldobler, C. Lutz, and H. Wansing, editors, JELIA, volume 5293 of LNCS, pages 298a310.
Springer, 2008.
[18] L. T. McCarty.
Defeasible deontic reasoning.
Fundam.
Inform., 21(1/2):125a148, 1994.
[19] J. C. Mc Cabe-Dansted, T. French, and M. Reynolds.
A temporal logic of robustness, RoCTL*.
Technical re-  port, UWA, 2007. http://www.csse.uwa.edu.au/ ~john/papers/RoCTL07.pdf.
[20] A. Pancones.
The coordinated attack and the jealous  amazons.
http://www.dsi.uniroma1.it/~asd3/ dispense/attack+amazons.pdf.
[21] A. Rodrigo and A. Eduardo.
Normative pragmatics for agent communication languages.
In Perspect.
Concept.
Model.
(LNCS), volume 3770, pages 172a181.
Springer, 2005.
[22] F. van der Grijn.
(im)possibility of a coordinated attack.
Technical report, University of Amsterdam, June 2004. http://www.illc.uva.nl/Publications/ ResearchReports/X-2004-05.text.pdf.
15