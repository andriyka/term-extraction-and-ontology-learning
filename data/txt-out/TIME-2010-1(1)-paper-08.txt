2010 17th International Symposium on Temporal Representation and Reasoning  Towards Temporal Controllabilities for Workflow Schemata Carlo Combi and Roberto Posenato Department of Computer Science, University of Verona (Italy) strada le Grazie 15, I-37134 Verona, Italy e-mail: {carlo.combi,roberto.posenato}@univr.it for each task are known, the actual duration of a task is known only at run time, after the agent executed it.
Therefore, checking controllability is stronger than verifying the consistency of workflow temporal constraints [2], [4].
In other words, each task duration cannot be imposed or decided by the WfMS that can only schedule all the tasks assuming that task durations respect their allowed ranges; hence, it is necessary to know if some schedule is possible before the start of the execution.
After having introduced and discussed in [6] temporal controllability for the basic workflow patterns, in this paper we (i) first extend the execution strategy proposed in the context of temporal constraint networks, to deal with the execution of business processes in a more suitable way; (ii) then, we focus on subtle and new issues arising when we consider the overall controllability of a workflow schema that may involve several different workflow execution paths.
We discuss different kinds of controllability and propose a new algorithm to check the (different kinds of) controllability of an overall workflow schema.
We then show that the presence of several controllable alternative execution paths in a workflow schema does not guarantee that the overall workflow schema is controllable.
Abstract--The modelling and management of temporal constraints over business processes has received some attention in the past years.
Recently, we have introduced and discussed the concept of controllability for workflow schemata modelling real world business processes: controllability, originally introduced in the AI community for temporal constraint networks, refers to the capability of executing a workflow for all possible durations of all tasks.
In this paper, we first extend the execution strategy proposed by Morris, Muscettola and Vidal in the context of temporal constraint networks, to deal with the execution of business processes in a more suitable way.
Then, we discuss and propose a new algorithm to deal with the (dynamic) controllability of an overall workflow schema, where several, possibly disjoint, execution paths are possible, due to the presence of alternative paths in the workflow schema.
We show that the presence of several controllable alternative execution paths in a workflow schema does not guarantee that the overall workflow schema is controllable.
Keywords-temporal conceptual workflow design; controllability; temporal constraint networks.
I. I NTRODUCTION Organisations use workflow management systems (WfMSs) to streamline, automate, and manage business processes that depend on information systems and human resources [1].
Many business processes have different kinds of temporal restrictions such as a limited duration of single tasks or activity deadlines w.r.t.
either the beginning of the workflow or a specific time point in the control flow.
Generally, time violations lead to some form of exception handling, thus increasing the complexity of business process management.
Therefore, a WfMS should provide the process manager with the necessary information about a process, its time restrictions, and its actual time requirements.
In the last decade some proposals have been made to represent and manage different temporal aspects of workflows as temporal constraints and deadlines both at design time and at run time [2], [3], [4], [5], [6].
Recently, we have introduced the concept of controllability for temporal workflows [6]: controllability has been proposed and studied in the AI community working on temporal constraint networks [7], [8] and, in the workflow context, it refers to the capability of executing a workflow for all possible durations of all tasks.
Indeed, durations of tasks cannot be imposed by WfMSs: even though the minimum and the maximum durations 1530-1311/10 $26.00 (c) 2010 IEEE DOI 10.1109/TIME.2010.17  II.
R ELATED W ORK Two different research directions have to be considered: i) in the area of business process modelling and workflow management systems, some efforts have been devoted to the study of temporal aspects in representing and managing workflows (i.e., business processes) and their component activities (i.e., tasks); ii) in the AI-related area of temporal constraints, some studies addressed the issues related to constraint satisfiability when some temporal constraints are related to time distances between point-based events that are not under control, i.e., they happen freely according to the given constraints.
In the first research direction, in [2], Eder et al.
introduce the Timed Workflow Graph (TWG ) that represents temporal properties of tasks.
TWG is a directed acyclic graph in which nodes are activities and oriented edges are control flows, allowing one to represent temporal constraints as upper and lower bounds for the end of a task w.r.t.
either the start of the workflow or the end of any previous task.
In [4], 129  i.e., O(n4 ), w.r.t.
the number of STNU nodes [9].
In [10], Hunsberger highlights some issues in the approach proposed by Morris and Muscettola and proposes a stronger definition of dynamic execution strategies that fixes these problems and puts the checking algorithm on a more solid theoretical foundation.
Marjanovic et al.
define a conceptual model that distinguishes different temporal constraints for a workflow schema: "basic temporal constraint", "limited duration constraint", "deadline constraint" and "interdependent temporal constraint".
A basic temporal constraint limits the expected duration of a single task.
A limited duration constraint is an upper bound for the duration of the workflow execution.
An interdependent temporal constraint limits the time distance between two tasks in a workflow schema.
In [5], Combi et al.
propose a temporal conceptual workflow model that enhances the expressiveness of previous proposals in representing temporal constraints, such as those related to tasks and task connectors.
The model by Bettini et al.
[3] is quite different from the previous ones and can be considered as the first attempt to merge the afore-mentioned research directions on temporal workflow models and on temporal constraint networks.
In [3], a workflow graph represents any task of a workflow by two nodes, corresponding to the starting and the ending instant of the considered task, respectively.
Every edge in the workflow graph represents the temporal distance between two nodes: any edge label is an interval representing the allowed time distances between the connected nodes.
Moreover, the authors introduce the concept of free schedule: a schedule is free when it is possible to statically fix the start times of all tasks without constraining their durations and satisfying all the given constraints, before the beginning of the execution.
A polynomial algorithm (O(n4 ) where n is the number of nodes) is then provided to check the existence of a free schedule.
Free schedules resemble the concept of controllability, that has been mainly investigated by Morris, Muscettola, and Vidal [7], [8], in the AI area of temporal constraint networks for planning.
Assuming that a temporal planner has to manage the likely uncertainty about the duration of processes, Vidal et al.
propose an extension of the Simple Temporal Network, the Simple Temporal Network With Uncertainty (STNU ), where edges, i.e., constraints, are divided into two classes: contingent links and requirement links.
Contingent links represent processes of uncertain duration, where finish timepoints (i.e., STNU nodes) are decided by Nature within the limits imposed by the bounds defined on the contingent links.
Requirement links represent all the other processes whose finish timepoints are controlled by the agents that execute processes.
Informally, Controllability refers to the capability of specifying all the timepoints controlled by agents, satisfying all the requirement and contingent links.
In particular, dynamic controllability ensures that it is possible to specify at runtime the timepoints controlled by agents only by knowing the duration of the already happened contingent links, without preventing any possible duration of the future contingent links [7].
Several algorithms have been proposed to check the dynamic controllability of a constraint network [8]; eventually, Morris showed that in the framework of STNU the checking controllability algorithm is polynomial,  III.
BACKGROUND In our model, the specification of a (structured) workflow is given by a workflow schema, a directed graph (also called workflow graph) where nodes correspond to activities and edges represent control flows that define activity dependencies on the order of execution [5], [6].
There are two different types of activity: task and connector.
Tasks represent elementary work units that will be executed by external agents.
They are graphically represented by a rounded box and each task has, at least, the mandatory attribute duration specifying the allowed temporal spans for its execution.
The value (i.e., the range) of duration of a task cannot be modified by the WfMS .
Connectors represent internal activities executed by the WfMS to achieve a correct and coordinated execution of tasks.
They are graphically represented by diamonds and each of them has the mandatory attribute duration specifying the temporal spans allowed to the WfMS for executing it.
The value of a connector duration can be modified at run time to guarantee the right coordination, and the effective duration is decided by the WfMS .
There are two kinds of connectors: split and join.
Split connectors are nodes with one incoming edge and two or more outgoing edges: after the execution of the predecessor, (possibly) several successors have to be considered for the execution.
The set of nodes that can start their execution is given by the kind of split connector.
A split connector can be: Total, Alternative or Conditional.
Join connectors are nodes with two or more incoming edges and one outgoing edge only.
A join connector can be either And or Or.
Control flow is an oriented edge that connects two activities: the first activity (predecessor of the second one) must be finished before starting the execution of the second one.
Every edge has a temporal property, delay, that denotes the allowed times that can be spent by the WfMS for possibly delaying the enactment of the second activity according to the given temporal constraints.
Each workflow can contain exactly one Start node and one End node without any temporal attribute, graphically represented by a circle with one ingoing/outgoing edge, respectively.
Due to conditional and alternative flows, not all the cases (i.e., executions) of a workflow schema perform exactly the same set of tasks.
We group workflow cases into workflow paths (wf-paths) in accordance with the activities actually executed.
Therefore, a wf-path can be regarded as a workflow subgraph in which all alternative or conditional connectors have exactly one successor.
Allowed durations/delays are expressed by ranges like [MinD, MaxD] Granularity where 0 <= MinD <= MaxD <= [?]
and  130  E[p, q]E  S[p, q]S  Granularity stands for the time unit used to express the given  constraint.
If the workflow designer does not set a duration, we assume the duration value to be [1, +[?]]
MinG, where MinG is the finest granularity managed by the WfMS .
We do not admit 0 as value of MinD for durations/delays at MinG to underline that no activity can be executed without time consumption.
Moreover, we assume min(ute) as MinG when it is not explicit in a range specification.
For sake of simplicity, here we will not consider temporal constraints expressed at different granularity and related conversion issues.
Besides the basic temporal constraints, our conceptual model allows the expression of several other kinds of temporal constraints as the relative constraints.
A relative constraint limits the time distance (duration) between the starting/ending instants of two non-consecutive workflow activities expressed according to the following pattern: hIF i[MinD, MaxD]hIS i Granularity, where (i) hIF i marks which instant of the First activity to use (hIF i = Shactivityi | Ehactivityi as the starting/ending execution instant, respectively; the subscript can be omitted if it is clear from the context.
); (ii) hIS i marks the instant for the Second activity in the same way; (iii) [MinD, MaxD] Granularity represents the allowed range for the time distance between the two instants hIF i and hIS i.
We assume that -[?]
<= MinD <= MaxD <= [?].
In general, a WfMS performs a wf-path assigning tasks to agents and executing connectors, observing structural constrains and temporal ones.
We say that a workflow schema is controllable if the WfMS is able to perform any wf-path satisfying all relative constraints, all delays, all connector durations without setting (allowed) task durations involved in the wf-path .
Analysing the structure of workflow schemata, it is straightforward to verify that (i) if a workflow schema does not contain any total connector, then each wf-path is represented as one graph-path (sequential path) and (ii) if the workflow schema contains at least one total connector, then at least one wf-path is represented as two or more graph-paths (parallel paths).
The problem of controllability checking arises when there is at least one relative constraint that involves two or more tasks.
In [6] we discussed how to check the controllability of all patterns that can be present in sequential paths or in parallel ones.
Here, we summarise the results in Fig.
1 and Fig.
2.
Fig.
1 shows two fundamental sequential patterns and the most frequently derived one.
In pattern (a) the composition of the task duration and of the delay has to comply with the relative constraint.
Duration of task T1 cannot be modified: the WfMS can only decide the duration of delay, after T1 is executed.
In order to verify whether it is possible to guarantee that the relative constraint can be satisfied for every possible T1 duration, it is sufficient to verify whether the range [p - y1 , q - x1 ] [?]
[u, v].
Pattern (b) is similar to (a), but the task duration is still unknown when the WfMS has to decide the duration of the delay.
In order to guarantee that  T1  [u, v]  T2 [x2 , y2 ] [?]
[p - y1 , q - x1 ]  T1  [x1 , y1 ]  [u, v]  T2 [x2 , y2 ] [?]
[p - x2 , q - y2 ]  [x1 , y1 ]  (a)  (b) S[p0 , q0 ]S [u, v] T1 T2 [x2 , y2 ] [?]
[p - x2 - y1 , q - y2 - x1 ]  S[p, q]E  [x1 , y1 ]  (c) Figure 1.
Three sequential patterns with a relative constraint.
Patterns are significant whether 0 <= p <= q.
In (c) the relative constraint S[p0 , q0 ]S (dotted) is induced by S[p, q]E  the relative constraint can be satisfied for every possible T2 duration, it is necessary to impose a stronger condition on the delay range: the restricted valid range is [p - x2 , q - y2 ] [?]
[u, v].
Pattern (c) is the common propagation of a relative constraint.
The relative constraint has the form ST1 [p, q]ET2 and we want to analyse how it is propagated to the edge T1-T2.
The controllability check can be done in two steps.
In the first step, a new relative constraint between ST1 and ST2 is defined, and its temporal range is determined by applying the rule of pattern (b).
If the induced relative constraint is not empty, in the second step, the controllability of T1 duration and the edge delay w.r.t.
the new constraint is verified by applying pattern (a).
If all steps are successfully performed, the pattern is controllable.
In general, given a wf-path , the controllability analysis requires checking the controllability of all temporal constraints (i.e., between any pair of nodes).
To determine all temporal constraints, it is sufficient to transform the wf-path into the equivalent instance of Simple Temporal Problem (STP ) and apply an all-pairs shortest path algorithm, as FloydWarshall [11]: the consistency check determines the minimal satisfiable temporal constraint between any pair of nodes of the network if the original network admits them.
There are four possible cases w.r.t.
the result of STP consistency check: (i) the consistency check fails, (ii) the new constraint ranges are equal to the corresponding old ones, (iii) at least one task range has been restricted, and (iv) only non-task range(s) has (have) been restricted.
In (i) and (iii) cases, the wf-path is not controllable, in (ii) case the controllability analysis is completed and the wf-path is called pseudo-controllable, and in (iv) case it is necessary to check the controllability of new ranges and, then, to apply the all-pairs shortest path algorithm again, in order to verify if the stable state has been reached.
Regarding parallel paths, there are four basic parallel patterns, each containing a relative constraint as in Fig.
2.
In pattern (d) the composition of duration of T1 and of the relative constraint results in the derived constraint A[u, v]ET1 = A[x1 - q, y1 - p]ET1 as a generalisation of sequential pattern (a), although here the direction of A[u, v]ET1 is reversed.
Pattern (e) is the most interesting one.
Due to lack of space, we cannot report all the analysis made in [6].
Here we note only that: (i) if q < 0 then it is sufficient to choose  131  T1  T1 A[p, q]E  A[u, v]E  [x1 - q, y1 - p]  S[p, q]A  let p0 = p + x2  [x1 , y1 ]  [x1 , y1 ]  h[not possible], [y1 - q0 , x1 - p0 ]i  A [x2 , y2 ] B  (h)  p >= 0 -[u, v] = [y1 - q, x1 - p] p < 0 [?]
q >= 0 -[u, v] = hET 1 , y1 - qi hET 1 , y1 - qi =[min{y1 - q, ET 1 }, ET 1 - p] y1 - q <= x1 -hET 1 , y1 - qi = [y1 - q, ET 1 - p]  let p0 = p + y2  h[not possible], [y1 - q0 , x1 - p0 ]i  [x1 , y1 ]  [x1 , y1 ]  A [x2 , y2 ] B hET 1 ,ti =[min{t, ET 1 }, [?]]
hET 1 ,t - y2 i =[min{t - y2 , ET 1 }, [?]]
(f)  [x1 , y1 ]  ) p0 <= 0 otherwise  h[ET 1 , ET 1 - p], [y1 - q, ET 1 - p]i  T2 [x2 , y2 ]  T1  (k) Figure 3.
Augmented wait constraint and its regression through a edge or connector (h) and through a task (k).
hET 1 ,ti hET 1 ,t - x2 i  T1  q0 = q + x2  h[ET 1 , ET 1 - p0 ], [y1 - q0 , ET 1 - p0 ]i  (e) hET 1 ,ti  h[ET 1 , ET 1 - p], [y1 - q, ET 1 - p]i  otherwise  q < 0 -[u, v] = [x1 - q, y1 - p]  T1  hET 1 ,t - y2 i  [x1 , y1 ]  ) p0 <= 0  A  A Useful only for propagation  (d)  h[ET 1 , ET 1 - p0 ], [y1 - q0 , ET 1 - p0 ]i  S[u, v]A  T1  q0 = q + y2  T2 [x2 , y2 ]  too:  hET 1 ,ti =[min{t, ET 1 }, [?]]
hET 1 ,t - x2 i =[min{t - x2 , ET 1 }, [?]]
h[ET 1 , ET 1 - p], [y1 - q, ET 1 - p]i  (g)  This augmented wait constraint has to be translated in one of the following constraints in order to check the pseudocontrollability:  Figure 2.
Four parallel patterns with a relative constraint.
We remember here that p <= q.
The dotted edges are induced relative constraints by the composition of the given relative constraint and the T1 duration.
For sake of simplicity, we put A in the labels of relative constraints, as A could represent either a starting or an ending instant of an activity.
In (f) and (g) the relative constraints are wait constraints  [y1 - q, y1 - p] if y1 - q <= x1 [x1 , y1 - p] otherwise  a suitable value in the range [x1 - q, y1 - p] (depending on the T1 duration) as delay of the edge T1-A to control the pattern, (ii) if p >= 0, it is sufficient to fix the delay of T1A to be [y1 - q, x1 - p] to have the controllability, (iii) if p < 0 and q >= 0, it is not possible to set a single range to guarantee the controllability but it is necessary to set a new constraint (wait constraint) between the start of T1 and A that is conditioned by the end of T1.
The wait constraint has the special label hET 1 , y1 - qi that means: A could occur either when (1) "T1 has ended (and within |p| time units)" or when (2) "y1 - q time units have elapsed since the start of T1 and T1 has not yet finished" (if A does not occur when condition (2) holds, the following end of T1 will trigger condition (1)).
Sometimes the wait constraint can be simplified: if (y1 - q) <= x1 , then a lower bound can be set because condition (2) is always verified before the end of T1: so the constraint can be represented as [y1 - q, ET 1 + |p|].
Morris et al.
proposed a method, called regression, to propagate wait constraints to other links.
In [6], we discussed how to adapt such regression to the context of workflow patterns, as summarised in Fig.
2-(f)-(g), for the regression through a connector and through a task, respectively.
We want to propose a regression for the augmented wait constraint in order to allow the system to start an event under a wait not just at the first possible time point but at one time point of a range.
The overall idea is to propagate the upper bound (ET 1 - p) of the augmented wait constraint through the regression.
As for the regression through a connector, depicted in Fig.
2-(f), the wait constraint between the start of the task and point B becomes h[ET 1 , ET 1 - p], [y1 - q, ET 1 - p]i while the wait between the start of the task and point A becomes h[ET 1 - x2 , ET 1 - p - x2 ], [y1 - q - y2 , ET 1 - p - x2 ]i.
Since x2 >= 0, ET 1 - x2 is a non sense because we cannot consider a time instant before the unknown end of the task, and thus it is necessary to increase the bound to ET 1 .
For the same reason, if p0 = p + x2 > 0, we cannot consider the upper bound ET 1 - p0 : in that case we have to consider x1 - p0 instead of ET 1 - p0 since x1 is the minimum value that ET 1 can assume.
It is important to underline that y1 - q - y2 <= x1 - p0 , otherwise there would be a negative cycle on ST1 .
Therefore, to set the upper bound of the augmented wait constraint after the regression, we have to consider only one condition: if p0 = p + x2 <= 0, then the upper bound is ET 1 - p0 , otherwise it is x1 - p0 .
Fig.
3-(h) shows the new representation of this wait constraint.
As for the regression through a task, depicted in Fig.
2-(g), the wait constraint between the start of the task T1 and the end of task T2 becomes h[ET 1 , ET 1 - p], [y1 - q, ET 1 - p]i while the wait between the start of the task T1 and the start of T2  IV.
E XTENDING THE WAIT S EMANTICS FOR W F - PATH In the proposal by Morris, Muscettola, and Vidal, the semantics of the wait constraint is that the "waiting" time point must be executed as soon as the wait condition holds (i.e., either a suitable number of time units has elapsed since the start of the "waited" task or the "waited" task ended).
In the workflow domain, "waiting" time points could correspond to the end of the execution of some internal workflow activities, such as the evaluation of conditions for routing or assignments of tasks to agents, that could require some time: thus, it becomes interesting to state explicitly the maximum delay the WfMS has at disposal for executing the "waiting" time point after that the wait condition became true.
In order to make more clear the Morris' wait constraint hET 1 , y1 - qi, it is well-timed to consider the upper bound  132  becomes h[ET 1 - y2 , ET 1 - p - y2 ], [y1 - q - x2 , ET 1 - p - y2 ]i in order to consider the possibility that T2 lasts its maximum duration.
Since y2 >= 0, ET 1 - y2 is a non sense because we cannot consider time instant before the unknown end of the task, therefore it is necessary to increase the bound to ET 1 .
For the same reason, if p0 = p + y2 > 0, we cannot consider the upper bound ET 1 - p0 : in that case we have to consider x1 - p0 instead of ET 1 - p0 .
Fig.
3-(k) shows the new representation of this wait constraint.
Function controllabilityCheck(G) Input: G: workflow graph to analyse.
Output: the controllability of G and a possibly new set of ranges for activities/delays.
// Initial wf-paths controllability check  foreach (wf-path p [?]
G) do R = ranges in p; (status, R) =pathControllabilityCheck(p, R); if (status == 'Non Controllable Path') then return ('Non Controllable Wf', 0) / end // All wf-paths are controll., determine the kind of controll.
V. C ONTROLLABILITY OF W ORKFLOW S CHEMATA  (status, R) =controllabilityCheck(G, Start); if (status =='Strongly Controllable') then return ('Strongly Controllable Wf', R);  Now we can analyse some issues when we need to verify the controllability of the overall workflow schema.
In this case we have consider all the possible wf-paths together.
As we will discuss in detail, it turns out that the controllability of each wf-path in isolation does not guarantee the controllability of the overall schema.
Before we discuss the different kinds of controllability, we introduce a preliminary concept, i.e., that of prefix of an activity/edge, to group together wf-paths having some common set of initial activities and edges.
Definition 5.1 (activity/edge prefix): A prefix of a given activity/edge y is the set of all the wf-paths that have the same successor for each alternative or conditional connector that precedes y.
An activity x precedes an activity y if either it belongs to the predecessors of y or precedes an activity of this set.
Hereinafter a prefix of a given activity/edge y is represented by the path notation specifying the common part that wfpaths of the prefix share.
This way, it is straightforward to define a partial order  among prefixes according to the lexicographical order induced by this notation.
For example, considering prefixes T1-T3 and T1-T3-T4, it holds T1-T3  T1-T3-T4, as depicted in Fig.
8.
It is worth noting that for any prefixes a, b s.t.
a  b the wf-paths of b belong to a too, i.e., a [?]
b .
We distinguish three kinds of controllability for a workflow schema: strong, weak, and history-dependent controllability.
Strong controllability refers to the fact that it is possible to derive a common range for durations of each connector/edge ensuring the controllability of each wf-path of the workflow schema.
In this case any derived duration range does not prevent any possible future evolution of the workflow execution, i.e., the duration range guarantees the controllability of all the wf-paths of any prefix of the considered connector/edge.
Moreover, the derived duration range does not depend on the specific execution flow followed to reach the considered connector/edge (i.e., the history): indeed, the range is common to all the different prefixes of the considered connector/edge.
Thus, strong controllability requires two different properties for each connector/edge: i) the controllability for any possible future execution flow, and ii) the independence of controllability from the past execution flow.
// Determine the  join connectors to analyse  JoinSet = {x | x is the last Join in a wf-path }; foreach (x [?]
JoinSet) do (status, R) =controllabilityCheck(G, x); if (status =='Strongly Controllable') then return ('History-Dependently Controllable Wf', R) end return ('Weakly Controllable Wf', 0); / Figure 4.
Algorithm to check the controllability of a workflow graph  While the first property is non-negotiable, the second one could be relaxed allowing a temporal range that depends on the past execution but without affecting the controllable execution of the remaining workflow schema.
This leads us to the concept of history-dependent controllability: a workflow schema is history-dependently controllable if each connector/edge has (possibly) different duration ranges for different prefixes: for each prefix, the given duration range is common to all the wf-paths of that prefix.
In this case the duration range of a connector/edge could depend on the executed tasks (i.e., the history), but does not prevent the WfMS to execute any possible future task.
If the property of being able to follow any possible future execution of the workflow schema is not guaranteed, we could have a workflow schema composed by several wf-paths controllable in isolation where some controllable execution could be prevented at run time: we call this property weak controllability.
The algorithm controllabilityCheck(G) we propose determines whether a given workflow schema G is controllable, its kind of controllability, and duration ranges for connectors/edges (duration ranges of tasks must be leaved unchanged).
Figure 4 shows the pseudo-code of the proposed algorithm: the algorithm verifies that each single wf-path is controllable in isolation and then executes controllabilityCheck(G, Start), to verify whether there is a common range for each connector/edge for all the wf-paths.
If it is the case, then the workflow schema is strongly controllable and the derived ranges have to be used at run time.
Otherwise, the algorithm verifies whether the workflow schema is history-dependently controllable: it considers the (possibly several) last Or-joins of the workflow schema.
Or-  133  Function controllabilityCheck(G, root)  Function buildControllableRanges(S, R)  Input: G: a workflow graph; root: activity from which to start the analysis Output: the controllability type of G and a new set of ranges for activities and delays P = set of all prefixes of root; // R p = array of ranges of activities/edges present in prefix p foreach prefix [?]
P do // Initialise all Rprefix Build Rprefix considering original temporal ranges in G; end do foreach {prefix | Rprefix 6= null} do R0prefix = Rprefix ;// Save last found solution end foreach {prefix [?]
P} do  Input: S: set of wf-paths; R: collection of connector/edge temporal ranges Output: the status and a new set of temporal ranges for connectors/edges do R0 = R; foreach connector T c present into any wf-paths do c range = of c ranges present into wf-paths; end foreach edge dTpresent into any wf-paths do d range = of d ranges present into wf-paths; end R = collection of these new ranges; foreach wf-path p [?]
S do (status, R) = pathControllabilityCheck(p, R); if (status == 'Non Controllable Path') then return ('Non Controllable Path Found', 0) / end if (at least one range in R is empty) then return ('Empty Range Found', 0) / while (at least one range in R has changed w.r.t.
R0 ); return ('Controllable Ranges Found', R)  // Check if the prefix is strongly controllable  (status,Rprefix)=buildControllableRanges(prefix,Rprefix); if (status 6= 'Controllable Ranges Found') then // It is necessary to evaluate another root return ('Non Strongly Controllable', 0); / end foreach {a|a is a conn./edge[?
]a precedes root} do // Determine the controll.
range for a among prefixes P0 = {p0 | p0 is prefix of a}; foreach prefix0 T [?]
P0 do Rprefix0 [a]= of all a ranges in wf-paths[?
]prefix'; if (Rprefix0 [a] == 0) / then return ('Non Strongly Controllable', 0); / foreach {prefix00 | prefix0  prefix00 } do /* Propagate the new range to all prefixes greater than prefix'  Figure 6.
Function pathControllabilityCheck(p, R) Input: p: wf-path , R: set of connector/edge temporal ranges Output: the controllability status and, possibly, the new set of temporal ranges for connectors and delays do R0 = R; Execute Floyd-Warshall on the distance graph corresponding to p with ranges in R; if (p is not consistent) then return ('Non Controllable Path', 0) / Determine new ranges in R applying all possible constraint reductions and wait regressions on p; if ([?]
empty range [?]
R [?]
[?]
task range modified) then return ('Non Controllable Path', 0) / while (at least one range in R has changed w.r.t.
R0 ); return ('Controllable Path', R)  */  Rprefix00 [a] = Rprefix0 [a]; end end end while ([?]
prefix of activity/edge b | Rprefix [b] 6= R0prefix [b]); return ('Strongly Controllable', [?
]prefix Rprefix ); Figure 5.
Algorithm to check the controllability of a set of wf-paths  Algorithm to check the controllability of a prefix  joins are considered as they are responsible of varying the number of prefixes (i.e., histories) of all activities following them.
Starting from the last Or-joins, indeed, we verify that for each connector/edge of each prefix there is a suitable range not preventing any possible future execution path.
This range could be different according to the considered prefix and ranges related to different prefixes could even be disjoint.
To do this check, controllabilityCheck(G) uses controllabilityCheck(G, root).
Figure 7.
Algorithm to check the controllability of a wf-path  to derive a common duration range for each of their prefixes.
If it is possible, we are able to conclude that the workflow schema is history-dependently controllable.
The derivation of these duration ranges may require to execute several times buildControllableRanges(prefix, R p ) (depicted in Fig.
6) until a fixpoint is reached: indeed, the change of a duration range for a connector/edge may produce other range changes for wf-paths containing the considered connector/edge.
These changes, in their turn, require that the controllability of modified wf-paths has to be checked again (through pathControllabilityCheck(p, R) depicted in Fig.
7) and it may induce further changes in the duration ranges of connectors/edges.
The algorithm controllabilityCheck(G, root), shown in Fig.
5, firstly determines the prefixes of passed activity root.
For each prefix, it verifies the strong controllability: if a prefix is strongly controllable, then every connector/edge in the prefix has a duration range common to all the wfpaths of the prefix itself.
If all the prefixes are strongly controllable, then it is possible to verify whether every connector/edge preceding root has a duration range, possibly depending on the previously executed activities, that does not prevent any future execution path: in other words, we verify whether it is possible for these connectors/edges  If the check of history-dependent controllability fails, then the workflow schema is weakly controllable: this kind of controllability is not completely appreciable by the WfMS , as it does not guarantee that any execution of the workflow  134  [2,2] min  C1  derived ranges).
Having reached the start of the workflow schema, we can say that the overall workflow schema is history-dependently controllable.
[1,1] min  T1 [1,1] min  VI.
D ISCUSSION AND C ONCLUSIONS  T2  [2,6] min  [4,6] min  C2  [1,1] min  In this paper we discussed the issues arising when we deal with controllability of workflow schemata; in particular, we introduced three different kinds of controllability for a workflow schema and proposed an algorithm to check them.
As for the complexity of the algorithm, it results that the overall complexity is exponential w.r.t.
the order of the workflow graph.
In more details, the time complexity of pathControllabilityCheck(p, R) is O(n3 ) (time complexity of Floyd-Warshall algorithm) times the maximum number of iterations of the do-while cycle.
Such maximum number, even though in our experimental tests it results to be around the number 4, is limited by the maximum extension of temporal ranges present into path p (MaxRange).
Therefore, the time complexity of pathControllabilityCheck(p, R) is pseudo-polynomial w.r.t.
the size of p, and MaxRange, i.e., O(n3 MaxRange).
Similarly, since buildControllableRanges(S, R) makes a limited number of operations on the results of path controllability check, its time complexity can be determined by multiplying the time complexity of pathControllabilityCheck(p, R) by the number of possible wf-paths of S and by maximum number of iterations of the do-while cycle: O(n3 |S| MaxRange).
As regards controllabilityCheck(G, root), the complexity can be estimated by multiplying the complexity of buildControllableRanges by the number of possible prefixes of root and by the number of iterations of the do-while cycle.
The number Kroot of possible prefixes of root is given by counting all possible flows from Start to root.
As in the previous case, the number of iterations of the do-while cycle is limited by the maximum extension of temporal ranges present into wf-paths of prefixes of root (MaxRange).
Thus the overall complexity of controllabilityCheck(G, root) can be expressed as O(Kroot |Sroot | n3 MaxRange2 ) where Sroot is the average cardinality of prefixes of root, observing that the product Kroot |Sroot | corresponds to the total number of wf-paths of all prefixes of root.
Denoting by w the number of wfpaths of the graph, it holds that Kroot |Sroot | <= w and so the controllabilityCheck(G, root) complexity can be approximated as O(w n3 MaxRange2 ).
Finally, the time complexity of controllabilityCheck(G) is given by the order of complexity of controllabilityCheck(G, root) multiplied by the dimension of JoinSet.
An estimation of the (worst-case) dimension of JoinSet is given assuming that the last join connectors are on a parallel path (each on a different branch) and their degree is 2: in this case the dimension of JoinSet is less than the half of the number of wf-paths of the graph.
Therefore the time complexity is O(w2 n3 MaxRange2 ).
It's worth to note that the number of wf-paths w <= 2c (a + 1) j , where c is the total number of conditional connectors and a = max{|al ?
|}  [1,2] min  S[22,27]E min  [1,1] min  T3 [2,7] min  [1,1] min S[17,27]E min  C3 [1,1] min  [1,1] min  T4  T5  [3,8] min  [1,1] min  [5,7] min  C4  [1,1] min  [1,2] min  S[15,34]E min  Figure 8.
An example of workflow schema.
Duration ranges for C3 are left to the default values of [1, +[?]]
C1 and  schema will terminate correctly: for example, the duration allowed and used for a connector could led the WfMS to exclude a possible wf-path that results, instead, to be necessary to conclude the case in the right way.
A.
Examples To give a flavour of how our algorithms work, let us consider the workflow schema depicted in Fig.
8.
It is composed by five tasks and by four connectors.
The connectors determine four different wf-paths: T1-T3-T4, T1T3-T5, T2-T3-T4, and T2-T3-T5.
It is possible to verify that the workflow schema is not strongly controllable: indeed, as it will be clear at the end of this discussion, it is not possible to find a common duration range for connector C3 that guarantees the controllability for each wf-path .
Therefore, the algorithm has to verify the history-dependent controllability starting with the analysis of prefixes of the last connector of workflow schema, i.e., C4.
C4 has four prefixes, each of them containing a single wf-path .
Fig.
9 shows the derivation of duration ranges for the four prefixes, firstly.
With these new ranges, the algorithm determines the ranges for connectors and edges preceding C4 w.r.t.
their own prefixes.
In particular, it is interesting to observe the derivation of duration ranges for C3 prefixes and C1 ones (connectors C3 and C1 are the only ones having different duration ranges on different wf-paths).
Fig.
9 shows then the derived ranges for C3 considering prefixes T1-T3 and T2-T3, respectively.
C3 has a common range for each of its prefixes, [1, 10]min for T1-T3 and [1, 8]min for T2-T3, guaranteeing the controllability.
Moving up to connector C1, there is only one prefix (Start in Fig.
9) containing all the wf-paths; the algorithm verifies that the intersection among the C1 duration ranges of all the prefixes of C4 considering the new derived range for C3 assures the controllability of each wf-path (and there are no changes in the previously  135  C1 [2,2] min  C1  [1,3] min  [2,2] min  T1  C1  [1,4] min  C1  [1,4] min  T1  [2,6] min  [1,2] min  S[22,27]E min  [4,6] min  [1,1] min  C2  C2  [1,2] min  [1,1] min  [1,1] min  T3  T3  T3  T3  [2,7] min  [2,7] min  [2,7] min  [1,1] min  [1,1] min  [1,1] min  C3  [1,10] min  [1,13] min  [1,1] min  [1,1] min  T5  T4  [3,8] min  [5,7] min  [3,8] min  [1,1] min  C4  C4  [1,2] min  [1,1] min  [1,8] min  [1,12] min  T5 C4  [1,1] min  [1,2] min  S[15,34]E min  T1-T3-T5  [1,1] min [5,7] min  C4 [1,2] min  S[15,34]E min  T1-T3-T4  C3 S[17,27]E min  [1,1] min  [1,2] min  S[15,34]E min  [1,1] min  C3  T4  [1,1] min  [1,2] min  [1,1] min  [2,7] min  C3 [1,1] min  C2 [1,2] min  [1,1] min  T2  [4,6] min  [1,1] min  C2  [1,1] min  T2  [2,6] min  [1,1] min  [1,6] min  [1,1] min  S[15,34]E min  T2-T3-T4  T2-T3-T5  C1  C1 [2,2] min  [1,1] min  T2  T2  C2 [1,2] min  [1,2] min  [1,1] min  S[22,27]E min  T3  [1,1] min  [2,7] min  T3  [1,1] min  [1,1] min  [2,7] min  T3  [1,1] min  [2,7] min  [1,1] min  (  [1,10] min  [1,1] min [1,1] min  T4  T5  [3,8] min  [5,7] min  [1,1] min  C4  [1,1] min  [1,2] min  [1,8] min  T4 [3,8] min  [1,1] min  C4  [5,7] min  [1,1] min  S[15,34]E min  T2-T3  [1,1] min  T4 [3,8] min  [1,8] min  for T2  S[17,27]E min  [1,1] min  C4  [1,1] min  T5 [5,7] min  [1,1] min  [1,2] min  [1,2] min  S[15,34]E min  T1-T3  [1,1] min  T5 S[17,27]E min  C3  [1,10] min for T1  C3 C3 [1,1] min  [1,1] min  C2  [1,1] min  [1,2] min  C2  [4,6] min  [1,1] min  [4,6] min  T1  S[22,27]E min  [1,1] min  T1 [2,6] min  [1,3] min  [2,6] min  [1,1] min  [1,3] min  [2,2] min  C1 [1,4] min  S[15,34]E min  Start  Figure 9.
C4 prefixes (T1-T3-T4, T1-T3-T5, T1-T2-T4 and T1-T2-T5 ones), C3 prefixes (T1-T3 and T2-T3 ones) and C1 prefix (Start prefix) with controllable ranges.
The bold ranges are modified by the controllability algorithm w.r.t.
the original ones.
C2 has the same prefixes of C3  [6] C. Combi and R. Posenato, "Controllability in temporal conceptual workflow schemata," in BPM, ser.
LNCS, U. Dayal, J. Eder, J. Koehler, and H. A. Reijers, Eds., vol.
5701.
Springer-Verlag, 2009, pp.
64-79.  is the maximum among the out degrees of the alternative connectors.
R EFERENCES [1] Object Management Group (OMG), "Business process definition metamodel (bpdm), Beta 1," http://www.omg.org, 2007.
[7] T. Vidal and H. Fargier, "Handling contingency in temporal constraint networks: from consistency to controllabilities," J. Exp.
Theor.
AI, vol.
11, no.
1, pp.
23-45, 1999.
[2] J. Eder, W. Gruber, and E. Panagos, "Temporal modeling of workflows with conditional execution paths," in DEXA, ser.
LNCS, M. T. Ibrahim, J. Kung, and N. Revell, Eds., vol.
1873.
Springer-Verlag, 2000, pp.
243-253.
[8] P. H. Morris and N. Muscettola, "Temporal dynamic controllability revisited," in AAAI, M. M. Veloso and S. Kambhampati, Eds.
AAAI Press, 2005, pp.
1193-1198.
[9] P. Morris, "A structural characterization of temporal dynamic controllability," in CP, ser.
LNCS, F. Benhamou, Ed., vol.
4204.
Springer-Verlag, 2006, pp.
375-389.
[3] C. Bettini, X. S. Wang, and S. Jajodia, "Temporal reasoning in workflow systems," Distributed and Parallel Databases, vol.
11, no.
3, pp.
269-306, 2002.
[4] O. Marjanovic and M. E. Orlowska, "On modeling and verification of temporal constraints in production workflows," Knowl.
Inf.
Syst., vol.
1, no.
2, pp.
157-192, 1999.
[10] L. Hunsberger, "Fixing the semantics for dynamic controllability and providing a more practical characterization of dynamic execution strategies," in TIME, C. Lutz and J.-F. Raskin, Eds.
IEEE, 2009, pp.
155-162.
[5] C. Combi, M. Gozzi, J. M. Juarez, B. Oliboni, and G. Pozzi, "Conceptual modeling of temporal clinical workflows," in TIME.
IEEE, 2007, pp.
70-81.
[11] R. Dechter, I. Meiri, and J. Pearl, "Temporal constraint networks," Artif.
Intell., vol.
49, no.
1-3, pp.
61-95, 1991.
136