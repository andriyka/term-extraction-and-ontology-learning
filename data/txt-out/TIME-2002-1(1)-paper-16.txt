On the Operational Semantics of Timed Rewrite Systems JeEreEmie Blanc  Rachid Echahed  Jeremie.Blanc@imag.fr  Rachid.Echahed@imag.fr  Laboratoire LEIBNIZ a Institut IMAG, CNRS 46, avenue Felix Viallet, F-38031 Grenoble, France  Abstract  time.
We assume given a canonical signal or clock, noted R EF which serves as a reference for other signals.
We propose an efficient operational semantics for a new class of rewrite systems, namely Timed Rewrite Systems.
This class constitute a conservative extension of first-order conditional term rewrite systems together with time features such as clocks, signals, timed terms, timed atoms and timed rules.
We define first Timed Rewrite Systems and illustrate them through some examples.
A naive approach to the operational semantics is very costly in space.
We propose, for a large class of programs, an improved calculus with a linear space complexity.
Finally, we show how our framework compares to related work.
In general, operator definitions within a timed rewrite system or program may depend on time.
Thus, at each instant , of R EF, a new rewrite system consisting of operator definitions is updated in the same way as in data-flow languages.
We obtain then, a stream of rewrite systems, .
At any instant , constitutes a classical rewrite system which may be used as usual, e.g., simplification of expressions or resolution of goals.
    fi      fi             fi            fi  In order to make easier the description of such timed rewrite systems, we enrich first-order terms by a temporal operator which is used to refer to past definitions.
For example the expression is meant three seconds before now and the to add the value of value of at the current instant.
On the other hand, we also enrich classical atoms by allowing the use of the box and diamond modal operators over intervals.
A timed atom , respectively , holds iff the atom holds at every instant, respectively at one instant at least, of the time interval .
The rewrite rules we consider in this paper have the following general shape when where the term can be timed, and are conjunctions of possibly timed atoms or equations.
The role of tails is to filter at every instant, , the rewrite rules that constitute the rewrite system .
    %  %  Rewrite Systems constitute the foundation of several declarative (functional and/or logic) programming languages.
They benefit from several analysis and proof techniques as well as efficient implementations.
However, such term or graph rewrite systems fail to specify in a natural way real-world applications where time should be described.
Consider for instance the boolean operator Alarm with the following profile device sort bool such that Alarm(device) is true whenever device has been broken for the last ten seconds.
Unfortunately, such simple programs cannot be described rigorously using classical rewrite systems.
In this paper, we define timed rewrite systems as a class of rewrite systems which allows one to specify declaratively applications where the notion of time, should it be qualitative or quantitative, is involved.
Our approach is new and departs from the proposals already made in order to add time into some declarative languages such as tcc [12], Templog [1], and Chronolog [14].
Roughly speaking, a timed rewrite system is provided with user-defined and incoming signals like in synchronous languages, e.g.
[7].
A signal is a stream of pairs (ticks, values) that happen over         1.
Introduction      ,      '              !  "
  $  %    '  $  )  %    ,  $  $  $  -  .
-  /  1  /  1  1  .
2    3  4  8  :  6  4  6  <  >  @  B  E  C  F  H  3  1    I  K  "    M  N      O    fi    The rest of the paper is organized as follows.
The next section introduces timed rewrite systems.
Then, we briefly sketch a first semantics based on labelled transition systems the details of which can be found in [4].
Our intention is to define efficient and realistic programs which may be interactive and reactive.
For that, we describe in section 4 an optimised operational semantics.
In section 5, we compare our proposal to related work and conclude the paper.
Due to lack of space, proofs have been omitted as well as some formal definitions.
The missing definitions and proofs could be consulted in a more detailed version [3].
Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE  2.
Timed Rewrite Systems A  We define a timed rewrite system or program as a pair where is a timed first order signature and is a set of timed conditional rewrite rules.
A timed first order signature is a triple where is a set of sorts, is an -sorted family of signals -sorted family of timed operators.
stands and is an for the set of non empty strings over .
We assume that contains at least the sort of booleans, bool, and the sort of naturals, nat.
The meaning of a signal in our approach is very close to the ones introduced in some synchronous languages, , noted S e.g., [7, 5].
A signal S of sort is a stream of operator denotations.
These denotations are associated implicitly to some instants over time.
These instants constitute a set called ticks of S. Hence, our notion of time is linear and multi-form.
Every signal S is associated to a boolean operator noted S which is equal to true on the ticks of the considered signal S. The family contains a distinguished signal we call refnat.
More precisely, erence signal of profile R EF R EF is the finest signal i.e.
for all signals S in , the ticks of S are mapped into those of R EF.
At the beginning, the value of R EF is 0, then it increments by one at each instant.
Its value may be useful as a clock which gives the number of the current instant.
Starting from a timed signature, we introduce the notion of timed terms in order to take into account the atemporizationa of operators thanks to the presence of signals.
The definition of an operator, say , may change at every instant.
We refer to a past definition of an operator by using a special temporal operator denoted at which extends the pre operator of Lustre [5] and $ operator of Signal [7].
We write S to refer to the operator at the instant corresponding to ticks of signal S before the current instant.
In general, we can use several at-expressions to define the right instant in the past of an operator.
For that we use timed operator expressions or toe for short, as deS where fined below: is an operator, is a positive natural number, S is a signal, is a toe.
The toes of the form S are called past toes.
Timed terms extend classical ones by referring to past definitions of operators.
They are defined as follows : where is a variable, is a natural number ( ), is a toe and are well-sorted timed terms.
Formulas in are timed conditional rewrite rules of the when where following form: is a first order term, is a timed term, and are possibly empty conjunctions of timed atoms.
is called head, body and tail.
If is of the form , we say that the considered timed condi  P  R  T    W  Y  T  W  R  [  ]  _  [  [  [    ]    _  `  [                 a  c            a  b      !
$  A  A  A  A  y  A  A  A  A  A  >  y  A  A  A         A  A  A  o  A  A  A  A  A  A  A  A  A  >     1  o  A  A  A     A  o  A  A  A  o  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  >  A  A  A  A  >     o  A  o  A  A  A  c  h  A     1     A  A    !
!
A  A    fi  A   fi  A         fi  O  AA  3  A  A  AV  1  h    A  A  ]    A  h  ]    A     A  e    A  tional rewrite rule defines .
A timed atom is either an equation == where and are two timed terms, .. which holds whenever the timed a formula is true at least once during the interval , atom or a formula .. which holds whenever the is true at every instant of the interval .. timed atom .
Atoms of the form .. (respectively, .. ) are called past-box atoms (respectively, pastdiamond atoms).
and stand either for the symbol or for the symbol indicating if the bounds are included or not in the interval, and and represent pairs noted S where is a non null natural number and S is a signal.
We also use anowa as a particular form of to indicate the current instant.
The role of tails is to filter the rewrite rules to be considered at each instant.
A timed program generates an infinite sequence of classical (atemporal) rewrite , also called stores in the sequel, as depicted in systems, Figure 1.
Intuitively, at each instant , includes all the rewrite rules such that when is in and holds at .
We write to note that atom holds in the classical rewrite system .
A timed operator is atemporal or static, if is defined classically without any reference to timed syntactic entities.
Otherwise, is called dynamic.
Notice that a classical term rewrite systems consists only of atemporal operator definitions.
Below we give some toy examples in order to illustrate our framework.
    b  A  Figure 1.
Store Generation      A  [      ... A  `  [     ...  Y  `  1    fi  h  h  h  h  !
P  l  b  b  h  o          $  !
l  Example 1 In this example, we give two different definitions of Fibonacci function.
This function is often used to show the abilities of synchronous languages.
In our framework, we can define Fibonacci function either by following synchronous style (fib1) or a pure declarative style (fib2).
However, fib1 is a timed operator whose value will change during the execution whereas fib2 is an atemporal operator.
h  !
l    P      b  v     b  o  l                  !
$  l  v    y  y  {  $  |     |  }  '  l            y  y  {  1. fib1 2. fib1 3. fib1  W    3  4  8  :  6  4  6  <  >  A  1  O  K      I  K    O     h    y          K  K    c    I  K  {  AL    1. fib2(0) 2. fib2(1)      y    AL  1  O    AL  A  A  0 when R EF == 0 1 when R EF == 1 at ( R EF ) fib1 + at ( == true when R EF   $      0 1  2  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE  A$?
R EF ) fib1  A   A'  Az  A  3. fib2(x)  fib2(x-1) + fib2(x-2)   AS  and is the result of the elimination of toes and past atoms in w.r.t.
instant .
is not defined on S , then we If consider = .
In addition, if is not defined on S , then is replaced by an atom noted FALSE which is always false.
If the disjunction is empty then we consider is replaced by FALSE too.
The case of the past-box atoms, S .. S , is similar to past-diamond atoms: disjunctions become conjunctions and the atom FALSE becomes an atom noted TRUE which is always true.
contains neither the definitions of the inNotice that troduced operators, nor the definitions of the incoming sigconsists to comnals.
The second stage which leads to plete with additional rewrite rules defining the newly introduced operators and incoming signals.
The third stage consists in filtering the timed rewrite rules.
If a timed rewrite rule when C of is such that holds, then occurs in ; otherwise is erased.
is built stepwise according to a certain stratification of timed operators in .
is in which the definitions of the timed constants (i.e.
timed operators without arguments) have been simplified.
All these stages are performed under the following assumptions: Requirement 1 The tails of each timed rewrite rule of a given stratum are expressed through the operators of lower strata.
Requirement 2 Simplification of timed constants must , at each instant.
At each instant, the be terminating in definition of a timed function (i.e.
timed operator with arguments) must not depend on a past definition of .
AL      1  == true AL  <      O  y        !
      !
    S  A  !
A    A  A  $  1  A  A    Example 2 In this example, we consider the case of a controller which has to decide automatically whether an item, sliding over a belt, is to be discarded (because of any fault) or not.
A decision concerning an item is taken when the item arrives at a particular position, , detected by a laser ray (laser3 ).
An item is to be discarded if a fault is detected (!reject == true) while the item was sliding between two parand .
The controller detects an item ticular positions entering position (resp. )
thanks to a laser ray laser1 (resp.
laser2).
Below we give a definition of the constant discard item whose value is computed every time an item reaches position , i.e.
a tick of signal laser3 occurs.
A    A        !
  O  y        !
    !
A  A    c        1    !
  A  A  !
  ,  AZ  AZ  We assume in the sequel that a timed rewrite system is given with signature .
As depicted in generates a stream of Figure 1, a run of a program stores, .
In this section, we give a brief overview of a first semantics based on a labelled transition system.
The details of this semantics can be found in [4].
To each instant , corresponds a state of such a transition system which contains, among other technical entities, a classical term rewrite system .
Roughly speaking, the computation of is done in four stages: , , and .
is obtained from by replacing all toes and past atoms by classical (atemporal) terms.
A past toe S is replaced by a new operaof the form tor noted where denotes the absolute instant corresponding to S with respect to instant .
such that We can define a function S .
When a past toe S S , is of the general form we proceed likewise by iterating recursively the function to obtain the instant correspondS S .
Whenever less than ing to ticks of S occurred since the beginning of the execution, is not defined for S .
Then, S the timed rewrite rule in which the past toe occurs is eliminated.
The elimination of a past atom, = S S say , of the form consists in replacing by a disjunction [    ]    _  Y      fi       fi            fi  A           Adeg  l  Aa    3.
Labeled Transition System R  A  Adeg  _  A    A  A  o  AZ  l  -  ,    AZ    AS    !
$    false laser1 .. laser2 !reject == false when !laser3 == true A      A  A  discard item  $  A    true laser1 .. laser2 !reject == true when !laser3 == true ,  !
    c         A  ,    o  AS      '  -    A  !
  1    .
         1  AS  discard item         AS  y       AS  O       AS      AS  AS       Adeg    h    Adeg  h  h    fi  fi      The execution model of a timed program can be given by a labelled transition system the state of which are pairs where is the store computed at instant and , called history, consists of the stores computed before .
Elements of are used to bring into the definitions , of the form of the new operators, introduced in with .
The transitions of the labelled transition sys-  A     A   AZ    AZ    Adeg  R    AZ  A      h  A       A'    !
$        !
$      y        !
      !
    O  y    !
  O  y        !
          !
        !
      !
             /  A          !
{  {  $  y        !
            !
{  {  A   !
       1  R                  !
$  o      !
A  !
A  A  A  o  A   As  A   Az  At  Az  At  A  Az  A'  !
A  Az  A  =   Y  `  In this section, we propose some sufficient conditions under which we can develop an operational semantics using a bounded space memory.
As in the previous section, we will show how current stores are generated following , , and .
four stages,  h  1  A       A   4.
Actual Operational Semantics    A'  where  fi  $  A          !
As  A     A   `  2  h  1  .
A  A  c     A   1  1  A  Y  $    A   fi              $  !
A   `      O  A  a  A      $  !
A      R  !
  A'  Al  tem are of the form where consists of the definition of the incoming signals.
The history being not bounded, the definition of the labelled transition system as sketched above is not realistic.
So, we propose in the following section a new tractable semantics.
A    h  R  $         AZ  AZ  A      O    A   A       A    A   A,  A    fi    A    Y  A       P  fi  A  h  Al    A   A     A  A,  A    Aa       O  y        !
      !
    !
  S  A  A      $  ,   A    =  AZ  A    AZ  3  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE    Adeg    Aa  A  The first stage generates a timed program without any reference to toes or past atoms just like .
The differis that the past toes such as = S ence with are replaced by a new operator noted S of the same profile as and the past atoms of the form S .. S or S .. S , are replaced by equations where is a new boolean operator.
The calculus of the definition of will be possible at every instant, if the following requirement is verified by .
      AZ  AZ  A  at  AZ  l  A,              !
  $    !
h  $          P  !
A  A  o  A  P  P     y  y  .
A      !
P  A  A  A  A  A  A  A A  8  A  AL  at AL  A  A B  A A  A  A  B  A  if A  A  AA  AV  AL  A  A$?
AL        o  A  A   o     A  A  B  -  h     A  A  A     !
A  Al  1    if = 0 8  A  h  P  !
A  A  o  B  A B  A  B  S A  A  AS  AS  ASS  F  3  6  A"  A   P  A A  A  8 A  A  1  y  y  A  A,  Al    I  y  A  AL    A B  at  1  A,  A$?
A B  A A  A  A  A  B  A AV AA  if A  A  AL  AL  A A$?
Al  AL  A B  A  A B  S AS  1  A,  8  AS  :  AS A  A"  Al  1  where stands for the complete definition of at the previous in which we replace all the timed operators instant without temporal annotation and different from by new and [ ] is the memory operators of the form S at instant .
of the past toe AS  AT  8  AL  A  AT  Requirement 3 Every past atom of the form S .. S or S .. S is closed (i.e.
it contains no free variable) and is such can be decided in a sensible computational duration that at each instant.
-  1  o  1    !
  A  A  !
o  AV  A        A  A  .
o      !
A  A  !
o  A  A  A  A  A  AT  A  A  B  A  B  A  B  A  A  A  1  AT  AL  8  8  AL  A  A  AT  F  A  Figure 2.
Past toe memory rules  In the following, we call new operators the operators and in .
Note that the past toes of the form S S are transformed into S where is S , and the past atom of the form are transformed into where is .
So, all the new operators are of the form S , or where is an operator and an atom.
A    AZ  1  A,  l  Al  A,                $  !
        A  !
A  A          $  A,  $  !
A  h  Al  h  A,          !
A  A  $  h  l  Al  of sets of !
h        A,  new operator is a queue (FIFO) of length ... ].
rewrite rules defining noted [  Al  h  "  "  a  A  "  Al  Az  /  /  1  should contain at each instant, a set of rewrite rules from which we can define the new operator S .
For that, we require that past toe memories satisfy the following invariant.
S be a past toe.
Assume Definition 2 Let = =[ ].
The invariant for that is the following assertion: aFor all , if at least ticks of signal S have occurred since instant 0, is the definition of , ticks of S ago, otherwise is emptya.
A  .
P  /  1  .
P  P  Az  1  A  A  /  "  P  1  A  A,  .
Al    I  y  A,    .
Al    I  y    /  A,  -  /          !
$  h  Al  A,  .
Al  1  1  A,  h  Al  Example 3 The application of the first stage to the specification of fib1 given in Example 1 has the following result: contains the timed rewrite rules , and .
1 and 2 are copied without any change from the timed program because they contain neither past toes, nor past atoms.
On the other hand, is the transformation of 3 into  l      A  A  |  A  "          !
$      A  "    !
$  h  Al  h  A    "             a    AZ  ,    A  A    a  A,  1  Adeg  Aa  ,    |  A    A,  A,  !
Al      "    h    "  A  In order to preserve the invariant, we give in Figure 2 the inference rules to be applied on past toe memories at every instant.
Since the past toes are not defined at the first instant, the verify the invariant.
memories initialized by Rule at and Rule at The two other inference rules Rule at are rules which update the past toe memories in a rather straightforward manner according to the cases whether a , tick of signal S occurs or not at the previous instant i.e., whether S .
All the sets are finite since Requirement 2 is verified.
The addition of a temporal annotation to the operators of does not change the value which represents .
It allows one to make the distinction in which represents the value of between at some instant and in which represents the current value of i.e.
the value of at instant .
  at ( R EF ) fib1 + at ( 3a.
fib1 when R EF == true   A  R EF ) fib1  A  AL  A$?
A  A  AL  AL  Example 4 In the same way as in the latter example, the rewrite rules defining discard item given in Example 2 becomes: discard item  true laser1 .. laser2 !reject == true == true when !laser3 == true  A  A  AL  A  A    '  $      AL  <    A    ,  $        fi  discard item  false laser1 .. laser2 !reject == false == true when !laser3 == true  A    A  A  A     A  AV  P  A    $  ,  P  e  AL  AL  <  A   A    I  y    As  As  A   h  A'  A  A  A,  A  A   AZ    AZ  Generation of consists in adding to the rewrite rules defining the new operators and the incoming signals.
Now, we show how the rules concerning the new operators are synthesized.
We tackle at first the new operators of the S corresponding to past toes.
For such form a new operator, we associate a past toe memory, denoted , defined as follows.
S Definition 1 Let = S be a past toe and be the current instant.
The past toe memory at for the A,          !
$  h  A   |  A    !
$  h  A  A  h    A$?
A  A  A$?
  |  h  A  A  A      Example 5 Consider the memory associated to the new operator at ( R EF ) fib1 occurring in the timed rewrite rule, say 3a, of Example 3.
Figure 3 indicates all the states of the memory associated to the new operator at ( R EF ) fib1 for the instant 0 until 3.
From instant 1, at is always applied because !R EF == true is always true.
At each  A    AZ  A  a    h    h  A    AV  A    Al  l  |  R  A  A  A    Al  A  A    h    4  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE      A  $  Definition 3 Let and be two instants less than .
Assume .
and belong to the same interval iff A    Rule   Memory state  at at at at   ,    A          '    $  A  A,  $  A  A,  A    A    $  A  A  $  fib1 == 0 fib1 == 1 Aa  A  A,  Aa  Al  Aa  Al  Aa        1. either Al  A   A   A  R EF A  A  A   A      O  y       !
      !
    S A  !
A   R  such that Al  A  A    A    fi    ,      A    $  A     AV  A'  A'  P  P  e  %    O      A    AV P  A"  S    2. or    A %  R     A  fi  ,      A  A'  O         AV     and for all instants S .
A    Az  A  .
P  A'    A   A     A    Al  A  A  }    e  |    A  A'    P  (with ) and for all instants S and  A    A  fi  Figure 3.
States of    A  fib1 == 0 fib1 == 1 fib1 == 1  Aa    A    '    R  A  A'  P  A  R  such that A    A    P  %  e    O      Az    A   A  A  Az  3. or does not exist (i.e., not enough S ticks) and for all instants such that , S and S .
Az    A  A  fi  R  A  A  A  A  A  A    fi    AV  A'  Az  A  A  Az  A  S Az  A  S  A  S  Az  Az  A  S  A  S  S  S  S  S  %    O    P     AV    P  P    A'      A'  e    P  A'    A  e  %    O      A  A  In the previous definition, item (1) suggests to partition according to the ticks of S or S .
That is the interval to say, such that the consists of all the instants which coincide set with a tick of S or S in the interval .
Item (2) suggests according to the ticks of S .
to partition the interval such That is to say, that the set consists of all the instants which .
Whenever coincide with a tick of S in the interval is not defined, item(3) suggests to partition the interval according to the ticks of S or S .
, defined In the sequel we consider that the intervals, by Definition 3 are numbered from the most recent to the oldest as depicted in Figure 4.
Thus, is the index of the interval which has the form where is an instant of the past, i.e.
.
We will denote by , and the is of indices of the following intervals of the partition: the form , is of the form and is of the form where and are instants of .
interWe can show (see [3]) that at most the last vals, say, are sufficient to compute the truthvalue of the past atom .
In practice, we introduce a data structure called past atom memory and denoted , which allows us to evaluate at every instant.
Informally, this data structure intervals of the partition deencodes either the last fined above as well as the evaluation of for every interval, , of the considered partition.
S .. S be a past Definition 4 Let = atom and be the current instant.
The past atom memory at is a triple of sequences of truth values of a 3-valued logic ( -true-, -false-, u -undefined-).
We represent a past atom memory by the following figure:      A  A  Az  Az      A  Az A /     /  	  /    /    /    /    /  / /    A     Aa      A      A    A  A  P      A    A       A       A    A          A  A            A    {    A        {  Al       A  A    A    A       Figure 4.
Interval partition  A    A  '  A       Aa  P      A    A    A       A    '  '       A    A        A    A            {    '  A    A       A  '    A  A               For a memory [ ] associated to a past toe = S which verifies the invariant, the definition of is in which we replace the timed operator by the S .
Since the memory verifies the new operator invariant at every instant, the calculus of the definition of is always possible.
Now, we consider how it is possible to compute the truthvalues of past atoms within a bounded space.
We illustrate our algorithm on the case of formulas, , of the form S .. S .
Recall that, according to the semanis tics given in the previous section, the truth-value of equal to the disjunction where (resp. )
is the absolute instant corresponding to S (resp.
S ).
is not bounded, and so is The length of the number of elements occurring in the disjunction .
To overcome this issue, we propose a way to split the interval into subintervals so that the computation of the value of becomes feasible using be a partition of a bounded space memory.
Let .
We associate a constant for every interval .
corresponds to the value .
The value of B is thus equal to .
Such a partition changes over time and should be available at every instant.
Hence, we should keep preparing the forthcoming partitions.
Our proposal consists in partitionas follows: ing at every instant , the interval "  l        l    "  !
$  a  A  "  "  h  a          !
$  h  A  A  A  A  A  >  A  A   A   A,  A'               !
A  A     A   1  A   As  A'  A         !
A    A        2    A  A      A   1  A   !
A,  A,  Al    A       2  |  AV  )  A  !
A    1  A  A  A  A  A  A  A  >  A     |  AV  *    v    v     Y    !
A  ,  )  -    A    As  A'  As  A  !
A    A   /    )  A    2  A'    R          )  '  A    2     A    a    A     2  A  A  Al    a  A  1     A  I  1    A,  O    O  2  A'  A  $  A  /  Al    I  A      A  .
A    A  A      Az  A  A  A     A     '  !
A,  2    $    A  As  A  1      I  %  A  A     $  A  A       O  1  Al      $  Az  A  Al  $  `    A,  A  A    A       '  2  A  Az    '  !
1  A   As  A'  A     A   A   ,  A  A    A  1  As  Adeg  A    A  A    2  1  A  ,    ,  l  A  $  A    A  Al  A    2  ,  A  h  A,  A  A    "  A      A  A  "     {    Al     instant, we can verify that element is the definition of fib1 two instants ago, and element is the definition of fib1 at the previous instant.
A      Al  |  AV         As      ./ 01  *    As                Az  *  *       A  `    a  A a  v        v  v    Az  A  `  A  a a  v       v v    Az  A A  A  A  `  a a  A         A  '    *   v  v  The interpretation of elements , , is defined by the following invariant over the data structure .
    A  A  A    5  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE  |  AV  Az        Definition 5 Let = S S be a past atom and be the past atom memory for at .
Let be the interval partition at .
The invariant for is the conjunction of the following assertions:     1  1  .
A  !
A  !
A  P   *  1  A   A       Az  Az  /  2 As       A   ` `  As  A  a  9  :  ; a  a ;   a     A  A  1      Aa  2  %    |  AV    if and    2     A,  A,  2  Al      v  !  "
     v    !
,  v    is not defined is defined,  $  v    A  2  !  "
    A !
,  $  A    |  AV  P  2     1. a(if  is defined and , then        %    $  $  or (if      O  $  "      !
v   A ,  is not defined.
$  A       v  A  A      -  2  P  A  A  P    AZ          v  !
    ,    A  2  A  A  2  2    The calculus of the definition of the new operator B generated from the past atom B can easily be performed usis B ing Definition 6.
The definition which we add to true if the truth value of B is true.
Otherwise, we add B false.
is the disjunction of the truth value of on the interval , if begins with a tick of S and otherwise, and if begins with a tick of S and otherwise.a P    A  1  v  O  is not defined and    *  2    v  if  1      A  2  ,  v  2  Example 7 Consider the memory of  A  P    A  -  laser1 ..     .
2. a  Y    *  iff $    P  v P  v  A    ,  u.a P     A  laser2 !reject == true    ,  A     v    v    given in Example 6.
= 2 and = 1.
Thus, the truth value of 2  v    v  !  "
    ,  ,  $    A  2  Example 6 Consider Example 4 and suppose that the ticks of laser1 happened only at the instants 5, 11 and 16, the ticks of laser2 happened only at 7 and 14, a tick of laser3 happened only at 12. laser2 = 14.
Thus, the interval partition is .
Since the interval partition has to be verified, the memory for laser1 .. laser2 !reject == true must be: A    O  y        !
      !
    Aa  4  A  A    ,  ,  4  3    ,  A  A,  A  ,  6  A  is  6  ,  '  A  A,  A  ,  ,  ,    A  ,  A    $  laser1 .. ,    laser2 !reject == true ,  A  , i.e., true.
*  A  A    A  ./  ,  is updated at each inWe focus now on the way stant.
In Figure 5, we give the inference rules which are initialises the data applied at each instant.
Rule structure with undefined values.
Rule is applied whenever both signal ticks of and are absent.
In this case, interval is augmented by one instant, and thus the new value is equal to the value of at the previous instant augmented -using the operator- by the current value of , say .
Rule is a bit technical.
Informally, Rule is applied whenever a tick of signal octo the right, and no tick of curs, shifts to next tick of the signal S happened at the previous .
Consider, for instance, the situation as depicted in Figure 4.
Assume that moves to the left bound of interval .
In the new interval partition the previous intervals and are unified.
and indicates the indices of such intervals to be unified.
The new data corresponding to the unified interval is , and .
Rule is used given by whenever the three other rules cannot be applied.
It creates a new interval, initialises the corresponding values, namely , and , and shifts all triples one step to the left.
In this case, the values of the preceding instant corresponding th interval are lost.
to the  A,  AL  AL  A    $  Al  A        ,  "  .
      !
  01  |  AV  .
  '  $    .
  ,  $     ,  -  ,  (1) -    A       2  *  -  ,  A  From the definition of , it is easy to compute at each instant the indices and by using the sequences and and then deduce the value of from the sequence .
We give in Definition 6 a formal definition of the computation of the value of .
For that, we introduce first a couple of technical definitions.
We note by where N, , and is either or , the lowest index over such that there are exactly occurrences of in .
Roughly speaking, is the index of the interval beginning with S where stands for the current instant.
Symmetrically, is the index of the interval beginning with S .
The formal calculus of the truth value of the past atoms uses an operation, say , of the 3-valued logic.
We note , the unique extension of the boolean disjunction where u is the identity.
S S be a past atom Definition 6 Let = be the past atom memory for at instant and which verifies the invariant (Definition 5).
The value of is defined by   |  v  *  1  1  A    *  v    v          !
  $  v  !
v    !
Adeg    !  )
  A'     !
v  2  !  "
        !
,         O  y        !
      !
    v  "        v  ,    O  y        !
      !
              A  !
!
A  A  Az   *  A    Az       A  /  As  /    A   !  )
!
A  .
    .
  A  .
  $  :  ;  a  ; a  9  :  ;    01    a   ;     A    v  if are defined.
2  !  "
    !
  v   ,  $  and  A  v    v  -  -  -  ,  ,  -    A  2  !  "
    !
A ,  ,  $  `  9      $  $  As  a  .
./  A        v      1    `    1  P  A'  Example 8 Consider Example 7.
At 16, a tick of laser1 occurs.
Thus, at 17, the rule cannot be applied.
In the same way, no tick of laser2 occurs at 16.
Thus, at 17, the rule cannot be applied.
Hence, at 17, the rule is applied to and transforms the past atom memory into  A    2          A  AV  v    1  |  v       A  A            1  .
v  A'     *  8  1    A  $  8  *  `    A  !
A'  $        8    !
A    `  A  !
<  ,  A'  $    2  )  *      !
2     $  A    A  2    ,  v  A  A    A    v    A  2      $  $  A  A  A    A  Az  v  v  A    A    A  !
  .
    ,  '  v          Y    "  .
  1  !
A    I  v  2  *  8  AV  O        $  6  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE  $  store computation.
Afterwards, the updated memories verify their invariants, and thus permit a sound computation of for the instant .
consists of the timed rewrite rules of in addition to the definition of the incoming signals and the definition of the new operators which are calculated consists of the rewrite from their associated memories.
whose tail is either true or absent.
If all the rules in tails of the timed rewrite rules defining a timed operator are false, we define in by its remanent definition borrowed from the store of the previous instant.
The rules of or are obtained from in the same way as by simplifying the rules.
The soundness of this actual operational semantics is stated in following.
A  A  if  A A  A  A  ./  01  A  u u u A  A  A  A  A  A  u u u  u u u A  A  A  AS  A      AZ    A  A  =  = 01  Az  A  A  AZ    = ./  8  ?
AZ  A  A A  A  A  A    A  A  Az  A A  A  A  ?
Adeg  A  AS AS  A  AS  A A  A    A  A  A  Az  A  A A  A  ?
AS  AS AS  A  A  A A  A  AL  A A  A  A  = =  =  =  C  ./ 01  Az A  AZ  h  A  ?
A    A A  A  A  A  A  A  A  C  Az  Adeg  h  A  A A  A  A  ?
AS  A AS  AS  A  A  A  AS  A A  A  A  C  Az  A A  A  A A  ?
A  AS AS  A  AS  A  A  A  AS  A  A    AL  if AA  AV  AL  AL AA  A  S A$?
A  AS  AS  ASS  F  3  6  A"  A  AL  D  and A  A  S A$?
A  AS  AS  ASS  F  3  6  A  AL  A  =  A"  8  A  = ./  AV  E =  E =  E =  A  A  = E  01  Az  A'  A  A' A'  AL A'  ?
?
A  ?
A A  A  A  A  A A  A A  E E  E  A  A  E  Az  ( -2)  A A  A  A' A  A' A  A' A  AL A'  A  fi    A   Adeg    Aa  ?
?
AS  A  Aa  ?
AS  A  AS AS  AS AS  A A  A  A  A  A A  A A  E  E  E  A  A  E  Az  A A  A  A A'  A A'  ?
AS  AL A'  A  ?
AS  A  AS  AS  AS AS    A  A  Theorem 1 Let be a timed rewrite system satisfying requirements 1, 2 and 3.
At each instant , for all timed operators , in and in represent the same operation.
A  A  A  A A  A A  = ./  A A'  ?
=  E =  E =  E  =  A  A  = E  C =  01  Az  A'  A  A' A'  AL A'  ?
?
A  ?
A  A A  A  A  A  A A  A A  A  A  C E E E    Az  A   A A  A' A  A' A  AL A'  A A  A  A  ?
?
?
  AS AS  A  AS  AS AS  AS  A A  A  A  A  A A  A A  A  A  C E E E  Az  h  A A  A  A A'  A A'  AL A'  A  A  ?
?
AS  ?
AS  A  AS  AS AS  AS  A A  A  A A  A,  h  Aa  Al    Aa  h  A AL  if AA  AV  is defined  AL  A  S A$?
8  : A  A  A  AS  AS A  A"  D  A  F  B  A"  AL  AS A  D  AS  A  D  E  A  A  A  A H  AS  A  A  F  B  A"  AL  A AS  D  =  AS  A'  A A  D  D  AS AS  I  D  A H  5.
Conclusion and Related work  A  L A  N A  D  E  u and  A'  ?
AS  A  O  A  A  8  A  AL  A  =  =  =  ./  01  Az  A  ?
A  A  A  A  A  We gave the broad outlines of a new kernel framework allowing conservative extensions of declarative rule-based programs with time.
We proposed an efficient operational semantics so that we can tackle real-world applications.
The implementation of our formalism is under progress and will be available soon.
Synchronous languages are specially designed for reactive programming [8].
The most representative synchronous languages are Lustre [5], Signal [7] and Esterel [2].
All of them are based on the notion of signal and enable to compile programs into finite state automata.
However, these languages do not handle new abstract data types or functions as signals.
Moreover, they do not provide powerful temporal operators such as and over intervals.
The closest languages to our formalism are the declarative ones, namely Lustre and Signal.
The primitives of theses languages can be easily expressed in our formalism.
As for Esterel, it rather offers an imperative style of programming and, as in our semantics, its signals are remanent unlike Lustre and Signal.
Note that the compilation into a finite automaton is possible in our case too whenever the considered applications do not need more expressive machines.
The absence of time notion in ccp has led to the development of a new synchronous paradigm tcc [12] based on ccp and preserving its good properties.
We share with tcc the principle of a very expressive evolving store.
However, the way of expressing the store changes is completely different.
In tcc, the stores are generated from processes and the process algebra is orthogonal to the formalism expressing formulas of the stores.
Moreover, these formulas are  A  A  Az  A  A  A  A  ?
AS  AS  A  AS  A A  A  A  A  A  Az  A  A  A  A  ?
AS  AS  A  AS  A  A  A  A  P  otherwise  A  A  A  A  = ./  =  C =  01  Az A  AL  A  ?
A A  A A  A  A  A  C  Az  AL  A  A  A  A  ?
AS  AS  A  A  AS  A  A  A  A  A  C  Az  AL  A  A  A  AS  A  =  A  ?
AS  A  AS  A  A  C  C  where stands for the truth value of in , for the in and for the truth value truth value of S in .
So, is true iff a tick of S occurred at of S is true iff a tick of S the previous instant, and symmetrically, occurred at the previous instant.
AA  AV  AL  A  >  A  A  AS  C  AL  AA  8  A  AS  AV  AL  A  :  AS  A  A  A"  AS  C  AL  AV  AA  AL  A  8  A  AS  :  AS  A  A  A"  A  AS  C  A  A  AS  Figure 5.
Past atom memory rules  -  .
A  = 14.
Thus, at 17, the interval partition is ; ; ; ; .
Since laser1 = 16, the invariant is still verified.
Now, suppose that, at 16, a tick of laser2 happens instead of a tick of of laser1.
At 16, the rule cannot = be applied.
On the other hand, since 1, = and u, the rule is applied and transforms the past atom memory into the one depicted in laser2 = 16.
Thus, at 17, (1).
the interval partition is ; ; ; .
laser1 = 11, the invariSince ant is still verified.
        O  y        !
      !
    laser2  ,    Aa  A  ,  S  4  $    ,  A  A    6  ,  '  A  A  Aa  ,  3  Al  Al  A  ,  4  ,  ,      O  y        !
      !
      A  A    ,  ,  6  A      ,  ,    S  .
$    ,  v    $  v    A  2     v  *  !  "
    ,  ,  $  P     A  -  T    A    O  y        !
      !
    ,  ,    Aa  A  4  ,  A    O  y        !
      !
    A  $  ,  S  $    A              .
A    6  ,  '  A  A  ,  ,  ,  6  A  Aa  ,  3  Al  Al    ,  S  $  The rules given in Figure 2 and Figure 5 must be applied to the corresponding memories at each instant , before the   7  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE  References  atemporal and not remanent.
Thus, the data transmission from an instant to another is performed explicitly by the combinator next of the process algebra.
The timed rewrite system, we propose, is data-oriented.
The mechanisms of data transmission, which are hidden from the user, could be rather complicated in the case of past atoms and they could manipulate definitions of operators which is not possible in tcc.
A problem of tcc inherited from ccp is the negative information detection.
At each instant, tcc may only detect an absence of information at the end of the store computation, and thus the reaction is put back one instant later.
A solution was presented in [13].
The new paradigm is called Default Timed cc and enables to detect an absence of information and to react instantaneously.
In compensation, the programs need to be verified statically to avoid causality loops, whereas it was not necessary for tcc programs (aparadox-freea property of [12]).
Our store is a well-defined stratified rewrite system which may be adapted to a large scope of constraint.
A boolean function may stand for a predicate solving the NOT problem in the logic programming paradigm and thus the negative information problem of ccp.
On the other hand, ntcc [11] extends tcc by adding non-determinism.
This paradigm has, among others, two operators noted !
and .
!P means aP will be always true in the current store and in the future onesa, P means aP will be true in the current store or in some future onea.
From a logic point of view, !
and are the respective duals in the future of our operators and .
From a procedural point of view, !
and can be considered as behavior generators, whereas and are behavior testers.
!
and can be applied just to a specific interval of time in future.
However, this interval is expressed using the base time unit: no other granularity is provided.
[1] M. Abadi and Z.
Manna.
Temporal logic programming.
J. of Symbolic Computation, 8(3):277a295, September 1989.
[2] G. Berry and G. Gonthier.
The Esterel programming language: Design, semantics and implementation.
Science of Computer Programming, 19(2), 1992.
[3] J. Blanc and R. Echahed.
Synchronous functional logic programming.
Technical report, Laboratoire Leibniz, 2001. available at http://wwwleibniz.imag.fr/PMP/TIME/Timed-programs.ps.
[4] J. Blanc and R. Echahed.
Timed term rewrite systems.
ENTCS, (64), 2002.
URL: http://www.elsevier.nl/locate/entcs/volume64.html.
[5] C. Dumas-Canovas and P. Caspi.
A PVS proof obligation generator for Lustre programs.
In 7th Int.
Conf.
on Logic for Programming and Automated Reasoning, volume 1955 of LNAI, 2000.
[6] D. Gabbay.
Modal and Temporal Logic Programming, chapter 6, pages 197a237.
Academic Press, 1987.
[7] P. L. Guernic, T. Gautier, M. L. Borgne, and C. L. Maire.
Programming real time applications with signal.
Proceedings of the IEEE, 79(9), 1991.
[8] N. Halbwachs.
Synchronous programming of reactive systems.
In Computer Aided Verification (CAVa98), LNAI 1427, pages 1a16, 1998.
[9] C. Liu and M. A. Orgun.
Dealing with multiple granularity of time in temporal logic programming.
J. of Symbolic Computation, 22(5 and 6):699a720, 1996.
[10] M. A. Orgun and W. Ma.
An overview of temporal and modal logic programming.
In D. M. Gabbay and H. J. Ohlbach, editors, First Int.
Conf.
on Temporal Logic, LNAI 827, pages 445a479, July 1994.
[11] C. Palamidessi and F. Valencia.
A temporal concurrent constraint programming calculus.
Report RS-01-20, BRICS, University of Aarhus, June 2001.
[12] V. Saraswat, R. Jagadeesan, and V. Gupta.
Constraint Programming, volume 131 of the NATO Advanced Science Institute Series, Series F: Computer and System Sciences, chapter Programming in Timed Concurrent Constraint Languages.
Springer Verlag, 1994.
[13] V. A. Saraswat, R. Jagadeesan, and V. Gupta.
Timed default concurrent constraint programming.
Journal of Symbolic Computation, 22(5 a 6):475 a 520, Nov a Dec 1996.
[14] K. Zhang and M. A. Orgun.
Parallel execution of temporal logic programs using dataflow computation.
In Int.
Conf.
on Computing and Information, pages 812a830, 1994.
W  X  W  -  .
W  -  .
W  Another class of programming languages related to our formalism is the temporal logic programming languages.
An interesting overview is presented in [10].
The meaning of atemporala for languages like Templog [1] and Temporal Prolog of Gabbay [6] is not the same as the one in the synchronous world.
The time is indeed represented in a constraint system and does not constraint temporally the execution of the program.
So, the causality of the condition in formulas is not preserved in these extensions of the logic programming, whereas it is in our paradigm.
On the other hand, these languages have the temporal operators (always) and (eventually) but without scope over some time interval.
Chronolog is a data-flow temporal logic language [14] designed to do efficient computation.
However, this language only manages one clock.
Since the need for a multi-granular time is very important in temporal programming, Chronolog(MC) [9] has been developed.
Nevertheless, this language is not synchronous.
-  .
8  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIMEa02) 1530-1311/02 $17.00 AS 2002 IEEE