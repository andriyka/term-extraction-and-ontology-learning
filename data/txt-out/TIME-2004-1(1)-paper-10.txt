Using Temporal Logics of Knowledge in the Formal Verification of Security Protocols Clare Dixon, Mari-Carmen FernaEndez Gago, Michael Fisher and Wiebe van der Hoek Department of Computer Science University of Liverpool, Liverpool L69 7ZF, United Kingdom FAX: E MAIL: WWW:  (+44) 151 79 43715  {C.Dixon,M.C.Gago,M.Fisher,wiebe}@csc.liv.ac.uk http://www.csc.liv.ac.uk/{Eclare,Emari,Emichael,Ewiebe}  Abstract Temporal logics of knowledge are useful for reasoning about situations where the knowledge of an agent or component is important, and where change may occur in this knowledge over time.
Here we use temporal logics of knowledge to reason about security protocols.
We show how to specify the NeedhamSchroeder protocol using temporal logics of knowledge and prove various properties using a resolution calculus for this logic.
1 Introduction Improved communication infrastructures encourage parties to interchange more and more sensitive data, such as payment instructions in e-commerce, strategic information between commercial partners, or personal information in, for instance, medical applications.
Issues such as authentication of the partners in a protocol, together with the confidentiality of information therefore become increasingly important: cryptographic protocols are used to distribute keys and authenticate agents and data over hostile networks.
Although the protocols used often look very intricate, many examples are known of sensitive applications that were acrackeda and had to be furnished with new, aimproveda protocols.
It is obvious that in such informationsensitive applications as above, one prefers to formally prove that certain information can not be eavesdropped by unwanted third parties.
The application of logical tools to the analysis of security protocols was pioneered by Burrows, Abadi and Needham.
In [1] and [10] specific epistemic logics, collectively referred to as BAN logics, are proposed to deal with authentication issues.
At the same time, standard epistemic logics ([12, 18]) have been applied successfully to reason about communication protocols, cf.
the derivation of the alternating bit protocol in [14] or, more recently, the analysis of TCP [22]).
In such an analysis, an epistemic language is useful in order to express that some receiver indeed knows some message at a specific state of the protocol, or that a sender knows that the receiver knows the message.
In this setting, contrary to the security framework of BAN, the implicit assumption is always that the network is not hostile.
In spite of the potential, more recent work on epistemic logic has mainly focused on theoretical issues such as variants of modal logic, completeness, and derived notions such as distributed knowledge and common knowledge.
Logics of knowledge are useful for specifying systems where statements such as If John knows his own private key and John receives a message encrypted in his public key then John knows the contents of the message 1  are required.
Statements such as the above represent static situations, in other words they describe the state of the knowledge within the world, but not how this knowledge evolves.
For this, we incorporate temporal logic.
Temporal logics have been shown to be useful for specifying dynamic systems that change over time [16].
By combining temporal and epistemic logics, we provide a logical framework in which systems requiring both dynamic aspects and informational aspects relating to knowledge can be described.
This is particularly important in security protocols, where one wants to ensure that certain knowledge is obtained over time or, at least, that ignorance of potential intruders persists over the whole run of the protocol.
Such temporal logics of knowledge have been used in the specification and verification of distributed and multi-agent systems [8, 13, 18], in analysing security protocols [23, 9], and in characterising knowledge games such as the muddy children problem [4].
The logic, KL(n) , that we consider here is the fusion of a linear time temporal logic (comprising finite past and infinite future) with the multi-modal logic S5 (see, for example, [12] for more details about this logic).
In order to prove that a particular property ' follows from a problem specification , for example a security protocol, where both ' and are formulae of KL(n) we must prove that ` ) '.
Since we carry out proofs using clausal resolution for temporal logics of knowledge [3, 4], which is a refutation method, we actually check that the combination of and :' is unsatisfiable.
This resolution calculus uses a translation to a normal form in order to separate modal and temporal components, a novel resolution method applied to the temporal part and modal resolution rules applied to the modal part.
Information is carried between the two components using clauses containing only literals.
Given the above background, in this paper, we bring together specification using temporal logics of knowledge and verification using clausal resolution, and apply these to the problem of formally analysing security protocols.
In order to show how such protocols can be specified and verified, we consider one very well known protocol, namely the Needham-Schroeder protocol [20].
This protocol has been widely studied with particular problems uncovered via formal analysis, for example [17].
The paper is structured as follows.
In Section 2 we describe the Needham-Schroeder protocol.
In Section 3 we give the syntax and semantics of a linear-time temporal logic of knowledge and in Section 4 we present a clausal resolution method for this logic.
In Section 5 we show how the Needham-Schroeder protocol can be specified in this logic.
2 The Needham-Schroeder protocol with public keys The Needham-Schroeder protocol with public keys [20] intends to establish authentication between an agent A who initiates a protocol and an agent B who responds to A.
The complete protocol consists of seven messages, but we focus on a simplified version consisting of only three messages.
The messages that we omit are those whereby the agents request other agentas public keys from a server.
Note that omitting these steps is equivalent to assuming that each agent always knows the othersa public keys.
The protocol can then be described as the three following steps: Message Direction Contents Message 1 A !
B : fNA ; Agpub key(B) Message 2 B !
A : fNB ; NA gpub key(A) Message 3 A !
B : fNB gpub key(B) Note that message contents of the form fX ; Y gpub key(Z ) represent messages containing both X and Y but then encrypted with Zas public key.
Elements of the form NX are special items of data, called nonces.
Typically, 2  agents in the protocol will generate their own unique nonce (often encrypted) which is, at least initially, unknown to all other agents.
Message 1: A sends B an encrypted nonce together with Aas identity, all encrypted with Bas public key.
Message 2: When B receives Message 1, it decrypts it to obtain NA .
Then B returns to A the nonce NA and generates another nonce of his own, NB , and sends it back, this time encrypted with Aas public key.
Message 3: When A receives Message 2, it returns Bas nonce, this time encrypted with Bas public key in order to prove Aas authenticity.
It would seem that A should be sure he is talking to B, since only B ashoulda be able to decrypt Message 1.
In the same way, B seems to be sure that he is talking to A since only A ashoulda be able to decrypt Message 2.
However, we will see later that this is not always the case.
3 Syntax and Semantics The logic, KL(n) , a temporal logic of knowledge we consider is the fusion of linear-time temporal logic with multi-modal S5.
We first give the syntax and semantics of KL(n) , where each modal relation is restricted to be an equivalence relation [15].
The temporal component is interpreted over a discrete linear model of time with finite past and infinite future; an obvious choice for such a flow of time is (N ; <), i.e., natural numbers ordered by the usual aless thana relation.
This logic has been studied in detail [15] and is the most commonly used temporal logic of knowledge.
3.1 Syntax Formulae are constructed from a set P = fp; q; r; : : : g of primitive propositions.
The language KL(n) contains the standard propositional connectives : (not), _ (or), ^ (and) and ) (implies).
For knowledge we assume a set of agents Ag = f1; : : : ng and introduce a set of unary modal connectives Ki , for i 2 Ag, where a formula Ki  is read as aagent i knows a.
For the temporal dimension we take the usual [11] set (always), U (until) and W of future-time temporal connectives h(next), (sometime or eventually), (unless or weak until).  }
The set of well-formed formulae of KL(n) , WFFK is defined as follows:     false, true and any element of P is in WFFK ; if A and B are in WFFK then so are (where i 2 Ag)  :A  }A  A_B A  A^B AU B  A)B AW B  Ki A hA  We define some particular classes of formulae that will be useful later.
Definition 1 A literal is either p, or :p, where p 2 P .
Definition 2 A modal literal is either Ki l or :Ki l where l is a literal and i 2 Ag.
Notation: in the following, l are literals, m are either literals or modal literals and D are disjunctions of literals or modal literals.
3  3.2 Semantics First, we assume that the world may be in any of a set, S, of states.
Definition 3 A timeline t, is an infinitely long, linear, discrete sequence of states, indexed by the natural numbers.
Let TLines be the set of all timelines.
Definition 4 A point q, is a pair q = (t; u), where t into t. Let Points be the set of all points.
2 TLines is a timeline and u 2 N is a temporal index  Definition 5 A valuation  , is a function  : Points  P Definition 6  !
fT ; Fg.
A model M, is a structure M = hTL; R ; : : : ; Rn ;  i, where: 1     TL  TLines is a set of timelines, with a distinguished timeline t0 ;     is a valuation.
Ri , for all i 2 Ag is the agent accessibility relation over Points, i.e., Ri Ri is an equivalence relation;   Points  Points where each  As usual, we define the semantics of the language via the satisfaction relation aj=a.
For KL(n) , this relation holds between pairs of the form hM ; pi (where M is a model and p is a point in TL  N ), and formulae in WFFK .
The rules defining the satisfaction relation are given below.
hM ; (t; u)i j= true hM ; (t; u)i 6j= false hM ; (t; u)i j= p hM ; (t; u)i j= :A hM ; (t; u)i j= A _ B hM ; (t; u)i j= hA hM ; (t; u)i j= A hM ; (t; u)i j= }A hM ; (t; u)i j= A U B hM ; (t; u)i j= A W B hM ; (t; u)i j= KiA  iff iff iff iff iff iff iff  iff iff  ((t; u); p) = T (where p 2 P ) hM ; (t; u)i 6j= A hM ; (t; u)i j= A or hM ; (t; u)i j= B hM ; (t; u + 1)i j= A 8u0 2 N ; if (u  u0) then hM ; (t; u0 )i j= A 9u0 2 N such that (u  u0 ) and hM ; (t; u0 )i j= A 9u0 2 N such that (u0  u) and hM ; (t; u0 )i j= B; and 8u00 2 N ; if (u  u00 < u0 ) then hM ; (t; u00 )i j= A hM ; (t; u)i j= A U B or hM ; (t; u)i j= A 8t0 2 TL: 8u0 2 N : if ((t; u); (t0 ; u0 )) 2 Ri then hM ; (t0 ; u0 )i j= A  For any formula A, if there is some model M and timeline t such that hM ; (t; 0)i j= A, then A is said to be satisfiable.
If for any formula A, for all models M there exists a timeline t such that hM ; (t; 0)i j= A then A is said to be valid.
Note, this is the anchored version of the (temporal) logic, i.e.
validity and satisfiability are evaluated at the beginning of time (see for example [5]).
As agent accessibility relations in KL(n) models are equivalence relations, the axioms of the normal modal system S5 are valid in KL(n) models.
The system S5 is widely recognised as the logic of idealised knowledge, and for this reason KL(n) is often termed a temporal logic of knowledge.
4  4 Resolution for Temporal Logics of Knowledge The resolution calculus is clausal requiring a translation to a normal form to separate modal and temporal components and to put formulae in a particular form.
A set of temporal resolution rules applied to the temporal part and modal resolution rules are applied to the modal part.
Information is carried between the two components using clauses containing literals.
Full details of resolution based proof methods for temporal logics of knowledge are given in [3, 4].
4.1 Normal Form Formulae in KL(n) can be transformed into a normal form SNF K (Separated Normal Form for temporal logics of knowledge).
For the purposes of the normal form we introduce a symbol start such that hM ; (t0 ; 0)i j= start.
This is not necessary but allows the normal form to be implications.
An alternative would be to let initial clauses (see Figure 1) be a disjunction of literals.
The translation to SNFK removes many of the temporal operators that do not appear in the normal form by rewriting using their fixpoint definitions.
Also the translation uses the renaming technique [21] where complex subformulae are replaced by new propositions and the truth value of these propositions is linked to the formulae they replaced in all states.
 operator, which allows nesting of K and  operators.
The To achieve this we introduce the i operator is defined in terms of the C (or common knowledge) and E (or everybody knows) operators.
We define E by E , i2Ag Ki  : The common knowledge operator, C, is then defined as the maximal  operator is defined as the maximal fixpoint of fixpoint of the formula C , E( ^ C) : Finally, the  ,  ): ( ^ C Thus we reason about reachable points from the initial point in the distinguished timeline t0 (where start is satisfiable), i.e.
the points we require in the proof.
V  4.1.1  Definition of the Normal Form  Formulae in SNFK are of the general form    ^  Tj  j  where each Tj , known as a clause, must be in one of the varieties described in Figure 1 where ka , lb , and l are literals and mib are either literals, or modal literals involving the Ki operator.
Thus a Ki clause (also known as a modal clause) may not contain modal literals Ki l1 and Kj l2 (or Ki l1 and :Kj l2 ) where i 6= j.
Each Ki clause involves literals, or modal literals involving the Ki operator where at least one of the disjuncts is a modal literal.
The outer a  a operator that surrounds the conjunction of clauses is usually omitted.
Similarly, for convenience the conjunction is dropped and we consider just the set of clauses Tj .
To apply the temporal resolution rule (see Section 4.2), one or more step clauses may need to be combined.
Consequently, a variant on SNFK called merged-SNFK ) [6], is also defined.
Given a set of step clauses in SNFK , any step clause in SNFK is also a clause in SNFK .
Any literal clause of the form true ) F is written into a merged- SNFK clause as true ) hF.
Any two merged-SNFK clauses may be combined to produce a merged-SNFK clause as follows A B (A ^ B)  ) ) )  hC hD h(C  ^ D)  where A and B are conjunctions of literals and C and D are conjunctions of disjunctions of literals.
5  start  ^g  )  _r b=1  ka  )  h  a=1  ^g  lb  _r  (an initial clause)  lb  (a step clause)  b=1  ka  ) }l  a=1  true true  ) )  _r  (a sometime clause) mib  (a Ki aclause)  lb  (a literal clause)  b=1 r  _  b=1  Figure 1: Clauses in SNFK 4.1.2  Translation to Normal Form  The translation to SNFK is carried out by renaming complex subformulae with new propositional variables and linking the truth of the subformula to that of the proposition at all moments.
Temporal operators are removed using their fixpoint definitions.
Classical and temporal equivalences (see for example [5]) are also used to get formulae into the correct format.
See [4, 7] for more details.
4.2 Resolution Rules The resolution rules presented are split into four groups: those concerned with initial resolution, modal resolution, step resolution and temporal resolution.
As well as the resolution rules presented, simplification and subsumption also takes place.
So for example the step clause a ) h(b _ b _ c) is automatically rewritten as a ) h(b _ c).
Initial Resolution follows  An initial clause may be resolved with either a literal clause or an initial clause as  [IRES1]  true start start  ) ) )  _ l) (B _ :l) (A _ B) (A  [IRES2]  start start start  ) ) )  _ l) (B _ :l) (A _ B) (A  Modal Resolution During modal resolution we apply the following rules which are based on the modal resolution system introduced by Mints [19].
In the following we may only resolve two Ki clauses together if they relate to the same i, i.e.
we may not resolve a clause containing K1 with a clause containing K2 .
We may resolve a literal or modal literal and its negation or the formulae Ki l and Ki :l as we cannot both know something and know its negation.
[MRES1]  true true true  ) ) )  D_m D0 _ :m D _ D0  [MRES2]  6  true true true  ) ) )  D _ Ki l D0 _ Ki :l D _ D0  Next, as we have the T axiom, ` Ki p ) p, we can resolve formulae such as Ki l with :l (giving MRES3).
The rule MRES4 requires the function mod i (D0 ), defined below, and is justified due to the external Ki  operator), i.e, we distribute K into the second clause and operator surrounding each clause (due to the i resolve :Ki l with Ki l. The amod i a function ensures that during this distribution at most one Ki or :Ki operator applies to each literal due to the equivalences :Ki :Ki ' , Ki ' and :Ki Ki ' , :Ki ' in S5.
[MRES3]  ) ) )  true true true  D _ Ki l D0 _ :l D _ D0  [MRES4]  true true true  ) ) )  D _ :Ki l D0 _ l D _ mod i (D0 )  Definition 7 The function mod i (D), defined on disjunctions of literals or modal literals D, is defined as follows.
mod i (A _ B) = mod i (A) _ mod i (B) mod i (Ki l) = Ki l mod i (l) = :Ki :l mod i (:Ki l) = :Ki l Finally, we require the following rewrite rule to allow us to obtain the most comprehensive set of literal clauses for use during initial, step and temporal resolution [MRES5]  true true  ) )  L _ Ki l1 _ Ki l2 _ : : : L _ l1 _ l2 _ : : :  Here, L is a disjunction of literals.
Step Resolution aStepa resolution consists of the application of standard classical resolution to formulae representing constraints at a particular moment in time, together with simplification rules for transferring contradictions within states to constraints on previous states (standard simplification and subsumption rules are also applied).
The following resolution rules may be applied by resolving two step clauses or a step clause with a literal clause.
P ) h(A _ l) Q ) h(B _ :l) [SRES1] h(A _ B) (P ^ Q) )  [SRES2]  ) ) )  true Q Q  _ l) _ :l) h(A _ B)  (A  h(B  Once a contradiction within a state is found, the following rule can be used to generate additional literal clauses.
P ) hfalse [SRES3] true ) :P This rule states that if, by satisfying P, a contradiction is produced, then P must never be satisfied in any  :P moment.
The new constraint therefore represents Termination Each cycle of initial, modal or step resolution terminates when either no new resolvents are derived, or false is derived in the form of either start ) false or true ) false.
7  W  Temporal Resolution The temporal resolution rule is as follows, where we resolve a sometime clause, Q ) l, with a condition, nk=0 Ak , that implies :l in the next moment (known as a loop formula for :l).
n h :l k=0 Ak ) Q ) l  }  W  }n ^  )  Q  (  :Ai) W l  i=0  W  This resolvent states that once Q is satisfied then none of the Ai should be satisfied unless l is satisfied.
A systematic way of deriving nk=0 Ak from the set of step clauses such that  _n  Ak  )  h  :l  k=0  is described in [2] but is beyond the scope of this paper.
Translating the resolvent into SNFK we obtain the following clauses for each i where wl is a new proposition.
true ) :Q _ l _ :Ai true ) :Q _ l _ wl wl ) h(l _ :Ai ) wl ) h(l _ wl )  4.3 The temporal resolution algorithm Given any temporal formula 1.
Translate  to be shown unsatisfiable the following steps are performed.
into a set of SNFK clauses  s.  2.
Perform modal and step resolution (including simplification and subsumption) until either (a) true ) false is derived - terminate noting  unsatisfiable; or  (b) no new resolvents are generated - continue to step 3.  }
3.
Select an eventuality from the right hand side of a sometime clause within s , for example l. Search for loop formulae in :l and generate the appropriate resolvents.
If no new formulae have been generated try the next sometime clause otherwise (if new formulae have been generated) go to step 4.
If there are no eventualities for which new resolvents can be derived, go to step 5.
4.
Add the new resolvents to the clause-set and perform initial resolution until either (a) start ) false is derived - terminate noting  unsatisfiable; or  (b) no new resolvents are generated - continue at step 2.
5.
Perform initial resolution until either (a) start ) false is derived - terminate noting  unsatisfiable; or  (b) no new resolvents are generated -terminate declaring  8  satisfiable.
4.4 Correctness Firstly we can show that the transformation into SNF K preserves satisfiability.
Theorem 1 A KL(n) formula A is satisfiable if, and only if, 0 [Aa is satisfiable (where 0 is the translation into SNFK ).
Proofs analogous to those in [4, 7] will suffice.
Theorem 2 (Soundness) Let S be a satisfiable set of SNFK clauses and T be the set of clauses obtained from S by an application of one of the resolution rules.
Then T is also satisfiable.
This can be shown by showing an application of each resolution rule preserves satisfiability.
(see [4]) Theorem 3 (Completeness) If a set of SNFK clauses is unsatisfiable then it has a refutation by the temporal resolution procedure given in this paper.
This is carried out by constructing a graph to represent all possible models for the set of clauses.
Deletions in the graph represent the application of of the resolution rules.
An empty graph corresponds with the generation of false (see [4]).
5 Specifying the Needham-Schroeder Protocol in KL(n) In this section, we will use KL(n) to specify the Needham-Schroeder protocol.
In particular, we will provide axioms describing the key aspects of both the system and the protocol.
In order to do this we use the following syntactic conventions.
Let M1 and M2 be variables over messages, Key be a variable over keys and X ; Y ; : : : be variables over agents.
Moreover, for every agent, X, we assume there are keys pub key(X ) and priv key(X ), while in this protocol A and B are constants representing two specific agents.
We identify the following predicates:          send(A; Msg; Key) is satisfied if agent A sends message Msg encrypted by Key; rcv(A; Msg; Key) is satisfied if agent A receives message Msg encrypted by Key; Msg(M1 ) is satisfied if M1 is a message; val pub key(X ; V ) is satisfied if the value public key of X is V val priv key(X ; V ) is satisfied if the value public key of X is V val nonce(NA ; V ) is satisfied if the value of nonce NA is V contains(M1 ; M2 ) is satisfied if the message M2 is contained within M1 .
To simplify the description, we allow quantification and equality over the sets of agents, messages and keys.
As we assume a finite set of agents, messages and keys this logic remains essentially propositional.
There are a few general assumptions:     initially, only agent A knows the content of its own nonce NA and only B knows the content of its own nonce NB ; if agent A sends messages containing its nonce or Bas nonce they are encrypted with Bas public key; 9        if agent B sends messages containing its nonce or Aas nonce they are encrypted with Aas public key; messages sent are not guaranteed to arrive at the required destination; if a message does arrive at an agent, then that message must have been previously sent by an agent; knowledge of messages persists, i.e.
agents do not forget; if a message is received, and the receiver knows the private key required, then the receiver will know the content of the message;  We allow a simple representation of public and private keys in terms of the unary functions apub key(X )a and apriv key(X )a.
All agents know the public keys of all other agents, but each agentas private key is only known by that agent.
There is also an axiom below (Axiom 14) explaining that, if an agent receives a message, and that message is encrypted by a public key whose private key the agent knows, then the agent will then know the contents of the message.
5.1 Specifying Structural Assumptions We begin with various structural assumptions concerning keys and message contents.
1.
8X ; Key; M1 : send(X ; M1 ; Key) ) :contains(M1 ; priv key(X )) a agents will not reveal their private key to others pub key(X ; V1 ) , val pub key(X ; V1)a ^ priv key(X ; V2 ) , val priv key(X ; V2 )a ^ [val nonce(X ; V1 ) , val nonce(X ; V1)a a the public keys, private keys and nonces of all the agents remain the same during the protocol  2.
8X ; V1 ; V2 :  [val  [val  3.
8X ; Y ; V : (val pub key(X ; V ) ^ val pub key(Y ; V )) ) X a no two agents have the same public keys  =  Y)  4.
8Key; M1 : (send (A; M1 ; Key) ^ [contains(M1 ; NA ) _ contains(M1 ; NB )a) ) (Key = pub key(B)) a if agent A sends out messages containing NA or NB the messages must be encrypted with Bas public key.
5.
8Key; M2 : (send(B; M2 ; Key) ^ [contains(M2 ; NA ) _ contains(M2 ; NB )a) ) (Key = pub key(A)) a if agent B sends out messages containing NA or NB the messages must be encrypted with Aas public key.
5.2 Specifying Scenario Assumptions As we will be concerned with one particular scenario, namely the simple interaction between agents given above, we instantiate message contents, keys and names for this scenario.
10  6.
Msg(M1 ) , ((M1 = m1 ) _ (M1 = m2 ) _ (M1 = m3 )) a in this particular scenario, we just use three messages, m1 , m2 and m3 .
7.
8X ; Y ; Z :  , ((X = A) _ (X = NA )))^ , ((Y = NA ) _ (Y = NB )))^ (contains(m3 ; Z ) , (Z = NB )) a message m1 contains only NA and A, message m2 contains only NB and NA and message m3 contains only NB (contains(m1 ; X ) (contains(m2 ; Y )  8. start )  val priv key(A; av) ^ val priv key(B; bv ) ^ val priv key(C; cv )^ :val priv key(A; bv ) ^ :val priv key(A; cv ) ^ :val priv key(B; av)^ :val priv key(B; cv ) ^ :val priv key(C; av ) ^ :val priv key(C; bv )^ val pub key(A; a) ^ val pub key(B; b) ^ val pub key(C; c))^ :val pub key(A; b) ^ :val pub key(A; c) ^ :val pub key(B; a)^ :val pub key(B; c) ^ :val pub key(C; a)) ^ :val pub key(C; b))^ val nonce(NA ; an ) ^ val nonce(NB ; bn ) ^ val nonce(NC ; cn )^ :val nonce(NA ; bn ) ^ :val nonce(NA; cn ) ^ :val nonce(NB; an )^ :val nonce(NB ; cn ) ^ :val nonce(NC ; an ) ^ :val nonce(NC ; bn )^  5.3 Specifying Basic Knowledge Axioms We here specify the basic attributes of an agentas knowledge.
9. start ) 8X :(9V : KX val nonce(NX ; V )) ^ [8Y ; Z : (Y 6= X ) ) :KY val nonce(NX ; Z )a a initially agents only know their own nonces.
10.
8X : (9V :KX val priv key(Y ; V ) , (X  =  Y ))  a agents only know their own private keys  11.
8X : KX val pub key(A; a) ^ KX val pub key(B; b) ^ KX val pub key(C; c) a all agents know all the public keys.
gK  12.
8X ; N ; V : KX val nonce(N ; V ) )  X val  13.
8X ; Y ; V : KX val priv key(Y ; V ) ) they know  gK  nonce(N ; V ) a agents never forget nonces they know  X val  priv key(Y ; V )  a agents never forget private keys  5.4 Specifying Communication Axioms We now specify the communication between agents, and how this affects the agentas knowledge.
For conha, meaning in the previous g f venience, we allow the use of past-time temporal operators, in particular a de moment in time, and a  a, meaning at some time in the past.
These operators have the following semantics.  }
hM ; (t; u)i j= defghA hM ; (t; u)i j= } A  iff iff  u > 0 and hM ; (t; u  i j= A  1)  9 2 N such that (0  u0 < u) u0  11  and hM ; (t; u0 )i j= A  14.
8X ; M1 ; N1 g((Msg(M1 ) ^ contains(M1 ; N1 )) ) (9V1 KX val nonce(N1 ; V1 ) , g[K val nonce(N ; V ) _ (9Y :9V : rcv(X ; M ; pub key(Y )) ^ K val priv key(Y ; V ))a)) f e d  X X 1 1 1 a for all moments except the first moment if M1 is a message which contains N1 an agent knows the content of N1 either if it already knew the content of N1 , or if it received an encrypted version of M1 that it could decode.  }
15.
8X ; Key; M1 : rcv(X ; M1 ; Key) ) 9Y :  send(Y ; M1 ; Key) a if an agent receives a message, then there was some agent that previously sent that message 16.
8X ; Key; M1 ; N1 (send(X ; M1 ; Key) ^ contains(M1 ; N1 )  rcv(X ; M1 ; Key)  )  }  9V1 : KX val nonce(N1 ; V1 ) _  a if an agent sends a message M1 encrypted with Key, then it must either know the contents M1 or just be forwarding the encrypted message as a whole  Note that there is no axiom such as  send(: : : ) )  }rcv(: : :)  as messages cannot be guaranteed to be delivered.
However, we do have a related axiom (Axiom 15) which says that, if a message is received, then some other agent must have sent it previously.
5.5 Axioms in Normal Form We can translate all the above axioms into the normal form.
As an example, we will assume three agents A, B and C and translate axioms 6, 7, 9, 10, and 11, as in Fig.
2.
We can also write axiom 14 into normal form as follows for all agents X.
( h(Msg(M1 )  9V  (  1  ^ contains(M hK  X val  1 ; N1 )) ) nonce(N1 ; V1 )  ; N1 )) ) (9V1 hKX val nonce(N1 ; V1 )  ( h(Msg(M1 )  ^ contains(M  1  , ,  nonce(N ; V ) _ 9Y :9V rcv(X ; M ; pub key(Y )) ^ KX val priv key(Y ; V ))a))  [KX val  1  (  1  1  nonce(N ; V ) _ 9V :(rcv(X ; M ; pub key(A)) ^ KX val priv key(A; V ))_ 9V :(rcv(X ; M ; pub key(B)) ^ KX val priv key(B; V ))_ 9V :(rcv(X ; M ; pub key(C)) ^ KX val priv key(C; V )))a))  [KX val  1  (  1  1  1 1  We provide a version below where X is instantiated as B, M1 is instantiated as m1 , N1 is instantiated as NA and d1 , d2 , d3 , d4 , e1 , e2 , e3 , f1 , f2 ,and f3 are new propositions.
Note due to axiom 14 containing the , operator we must rename formulae below this using , rather than just ).
In the following d1 is a new name for the following d1  , (rcv(B; m ; pub key(A)) ^ (KB val priv key(A; av ) _ KB val priv key(A; bv ) _ KBval priv key(A; cv ))) 1  and similarly for d2 and d3 where A in the above are replaced by B and C respectively.
d4 is a new name for the disjunction of these formulae i.e.
d4 , d1 _ d2 _ d3 f1 is a new name for Bas knowledge that the value of NA is an i.e.
f1  , KB val nonce(NA ; an )  12  6a: 6b: 6c: 7a: 7b: 7c: 7d : 7e: 9a: 9b: 9c: 9d : 9e: 9f : 9g: 9h: 9i: 10a: 10b: 10c: 10d : 10e: 10f : 10g: 10h: 10i: 10j: 10k: 10l: 10m: 10n: 10o: 10p: 10q: 10r: 10s: 10t: 10u: 11a: 11b: 11c: 11d : 11e: 11f : 11g: 11h: 11i:  true ) Msg(m1 ) true ) Msg(m2 ) true ) Msg(m3 ) true ) contains(m1 ; A) true ) contains(m1 ; NA ) true ) contains(m2 ; NA ) true ) contains(m2 ; NB ) true ) contains(m3 ; NB ) start ) (KA val nonce(NA; an ) _ KA val nonce(NA ; bn ) _ KA val nonce(NA ; cn )) start ) (KB val nonce(NB; an ) _ KB val nonce(NB ; bn ) _ KB val nonce(NB ; cn )) start ) (KC val nonce(NC ; an ) _ KC val nonce(NC ; bn ) _ KC val nonce(NC ; cn )) start ) :KA val nonce(NB ; bn ) start ) :KA val nonce(NC ; cn ) start ) :KB val nonce(NA ; an ) start ) :KB val nonce(NC ; cn ) start ) :KC val nonce(NA; an ) start ) :KC val nonce(NB; bn ) true ) KA val priv key(A; av) _ KA val priv key(A; bv) _ KA val priv key(A; cv ) true ) KB val priv key(B; av) _ KB val priv key(B; bv) _ KB val priv key(B; cv ) true ) KC val priv key(C; av ) _ KC val priv key(C; bv ) _ KC val priv key(C; cv ) true ) :KA val priv key(B; av ) true ) :KA val priv key(B; bv ) true ) :KA val priv key(B; cv ) true ) :KA val priv key(C; av ) true ) :KA val priv key(C; bv ) true ) :KA val priv key(C; cv ) true ) :KB val priv key(A; av ) true ) :KB val priv key(A; bv ) true ) :KB val priv key(A; cv ) true ) :KB val priv key(C; av ) true ) :KB val priv key(C; bv ) true ) :KB val priv key(C; cv ) true ) :KC val priv key(A; av ) true ) :KC val priv key(A; bv ) true ) :KC val priv key(A; cv ) true ) :KC val priv key(B; av ) true ) :KC val priv key(B; bv ) true ) :KC val priv key(B; cv ) true ) KA val pub key(A; a) true ) KA val pub key(B; b) true ) KA val pub key(C; c) true ) KB val pub key(A; a) true ) KB val pub key(B; b) true ) KB val pub key(C; c) true ) KC val pub key(A; a) true ) KC val pub key(B; b) true ) KC val pub key(C; c)  Figure 2: Normal form translation of axioms 6, 7, 9, 10, and 11  13  where f2 and f3 are similarly defined except an is replaced by bn and cn respectively.
The right hand side of the implication becomes  9V  (  1  hK  X val  ,  nonce(N1 ; V1 )  (KX val  nonce(N1 ; V1 ) _ d4 ))  Removing the existential quantifier we obtain  ^ contains(M ; N )) ) (e _ e _ e )  ( h(Msg(M1 )  1  where e1  )(  hf  1  1  1  2  3  , (f _ d )) 1  4  and similarly for e2 and e3 where f1 is replaced by f2 and f3 respectively.
14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14  :e ^ :e ^ :e ) ) h(:Msg(m ) _ :contains(m ; NA )) (e ^ :f ^ :d ) ) h:f (e ^ f ) ) hf (e ^ d ) ) hf (e ^ :f ^ :d ) ) h:f (e ^ f ) ) hf (e ^ d ) ) hf (e ^ :f ^ :d ) ) h:f (e ^ f ) ) hf (e ^ d ) ) hf true ) :f _ KB val nonce(NA ; an ) true ) f _ :KB val nonce(NA ; an ) true ) :f _ KB val nonce(NA ; bn ) true ) f _ :KB val nonce(NA ; bn ) true ) :f _ KB val nonce(NA ; cn ) true ) f _ :KB val nonce(NA ; cn ) true ) :d _ d _ d _ d true ) d _ :d true ) d _ :d true ) d _ :d true ) :d _ rcv(B; m ; pub key(A)) true ) :d _ (KB val priv key(A; av ) _ KB val priv key(A; bv ) _ KB val priv key(A; cv ) true ) :rcv(B; m ; pub key(A)) _ d _ :KB val priv key(A; av ) true ) :rcv(B; m ; pub key(A)) _ d _ :KB val priv key(A; bv ) true ) :rcv(B; m ; pub key(A)) _ d _ :KB val priv key(A; cv ) true ) :d _ rcv(B; m ; pub key(B)) true ) :d _ (KB val priv key(B; av ) _ KB val priv key(B; bv ) _ KB val priv key(B; cv ) true ) :rcv(B; m ; pub key(B)) _ d _ :KB val priv key(B; av ) true ) :rcv(B; m ; pub key(B)) _ d _ :KB val priv key(B; bv ) true ) :rcv(B; m ; pub key(B)) _ d _ :KB val priv key(B; cv ) true ) :d _ rcv(B; m ; pub key(C)) true ) :d _ (KB val priv key(C; av ) _ KB val priv key(C; bv ) _ KB val priv key(C; cv ) true ) :rcv(B; m ; pub key(C)) _ d _ :KB val priv key(C; av ) true ) :rcv(B; m ; pub key(C)) _ d _ :KB val priv key(C; bv ) true ) :rcv(B; m ; pub key(C)) _ d _ :KB val priv key(C; cv ) (  1  2  3  1  1  1  1  4  1  4  2  2  1  4  2  2  2  3  1  1  1  2  1  2  4  3  2  4  3  3  3  3  3  4  3  1  1  2  2  3  3  4  1  2  4  1  4  2  4  1  3  1  1  1  1  1  1  1  1  2  1  2  1  2  1  2  1  2  3  1  3  1  3  1  3  1  3  14  3  Note further that the following is a consequence of axiom 15.
15a:  start ) :rcv(B; m1 ; pub key(B))  6 Verifying Properties of the Specification Once we have the above axioms relating to the specific scenario, we can attempt to prove various statements.
Refutations tend to be quite long, so we will only provide detail for the simpler examples.
6.1 Bas Knowledge on Receipt of NA The first example will capture the statement once B receives the nonce of A encoded by Bas public key then B knows the nonce of A This can be translated into KL(n) as (rcv(B; m1; pub  ) h9V : KB val nonce(NA ; V ))  key(B))  or removing the existential quantifier as follows.
(rcv(B; m1; pub  key(B)) )  h(K  B val  nonce(NA ; an ) _ KB val nonce(NA ; bn ) _ KB val nonce(NA ; cn ))  We will now show how to establish this using the resolution method outlined earlier.
To prove the above, we negate the statement and derive the following set of clauses.
p1: start p2: x p3: true p4: y p5: true p6: true p7: true  ) ) ) ) ) ) )  x  }y  :y _ rcv(B; m ; pub key(B)) 1  hz  :z _ :KBval nonce(NA ; an ) :z _ :KBval nonce(NA ; bn ) :z _ :KBval nonce(NA ; cn )  In the following we will need an instantiation of axiom 13 KB val priv key(B; bv ) )  hK  B val  priv key(B; bv )  which is translated into normal form as follows 13 13 13  p1 true true  ) hp ) :p _ KBval priv key(B; bv ) ) p _ :KBval priv key(B; bv ) 1  1  1  The proof takes place as follows.
15  p8: p9:  p10: p11: p12: p13: p14: p15: p16: p17: p18: p19: p20: p21: p22: p23: p24: p25: p26: p27:  ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )  true true true (e1 ^ d4 ) (e2 ^ d4 ) (e3 ^ d4 ) (e1 ^ d4 ^ y) (e2 ^ d4 ^ y) (e3 ^ d4 ^ y) true true true (:e1 ^ :e2 ^ :e3 ) (:e1 ^ :e2 ^ :e3 ) true true true true true true  p28: p29: p30:  :z _ : f :z _ : f :z _ :f h:z h:z h:z  [ax14; p5  1 2 3  hfalse hfalse hfalse  :e _ :d _ :y) :e _ :d _ :y) (:e _ :d _ :y) h:contains(m ; N ) A (  1  4  (  2  4  3  4  1  hfalse  _e _e ) _ e _ :d _ :y) (e _ :d _ :y) (:d _ :y) (:d _ :y) (:rcv(B; m ; pub key(B))_ :KBval priv key(B; bv ) _ :y) ) (:KBval priv key(B; bv ) _ :y) ) (:p _ :y) ) h:y  true true p1  (e1  2  (e2  3  3  3  4  4  4 2  1  1  MRES1a [ax14; p6 MRES1a [ax14; p7 MRES1a [ax14; p8 SRES2a [ax14; p9 SRES2a [ax14; p10 SRES2a [p4; p11 SRES1a [p5; p12 SRES1a [p6; p13 SRES1a [p14 SRES3a [p15 SRES3a [p16 SRES3a [ax6a; ax14 SRES2a [ax7b; p20 SRES2a [p21 SRES3a [p17; p22 MRES1a [p18; p23 MRES1a [p19; p24 MRES1a [ax14; p25 MRES1a [ax14; p26  MRES1a [p3; p27 MRES1a [ax13; p28 MRES1a [ax13; p29 SRES2a  we can apply the temporal resolution rule with clauses p30 and axioms 13 together giving p1  )  h  :y  for resolution with p2: p31: p32: p33: p34: p35: p36: p37: p38:  true true wy wy true true true true  p39: p40: p41: p42:  start start start start  ) ) ) ) ) ) ) )  :x _ y _ :p :x _ y _ wy h(y _ :p ) h(y _ w ) l :x _ y _ :KBval priv key(B; bv ) :x _ y _ KB val priv key(B; av ) _ KBval priv key(B; cv ) :x _ y _ val priv key(B; av ) _ val priv key(B; cv ) :x _ rcv(B; m ; pub key(B)) _ val priv key(B; av ) _val priv key(B; cv ) ) :x _ val priv key(B; av ) _ val priv key(B; cv ) ) :x _ val priv key(B; cv ) ) :x ) false 1  1  1  [p30; ax13; p2  TRESa TRESa [p30; ax13; p2 TRESa [p30; ax13; p2 TRESa [ax13; p31 MRES1a [ax10b; p35 MRES1a [p36 SRES5a [p30; ax13; p2  [p37; p3  MRES1a IRES1a [ax8; p39 IRES2a [ax8; p40 IRES2a [p1; p41 IRES2a [ax15a; p38  6.2 Cas Ignorance A key part of this protocol is that information is transferred between agents A and B without agent C ever being able to intercept sensitive information.
We can verify this by showing that, in the scenario above, C 16  will never know the value of Aas nonce, i.e.
8V : :KC value nonce(NA ; V ) Rather than giving a full refutation, we will indicate how this can be proved.
As axiom 14 states, for an agent (in this case C) to know the value of NA then either it knew it originally, or it received a message that contained it.
In the first case, agent C did not know the value of NA originally.
In the second case, by axioms 3 and 4, agents A and B only ever send out messages containing NA encrypted by pub key(B) or pub key(A), respectively.
Consequently, C can never know the value of NA .
6.3 Confirmation of Bas Knowledge Once A receives m2 (which, in turn, contains NA ) back, then it can infer that B knows NA , i.e.
rcv(A; m2 ; pub key(A)) )  hK  A KB NA )  Recall that axiom 15 states that if an agent receives a message, then there must have been a previous corresponding send.
Since A did not send the message, the only choice is  } send(B; m ; pub key(A)) _ } send(C; m ; pub key(A)) 2  2  However, in order to send a message, an agent must know the contents of that message.
Since we know (from above) that C doesnat know the value of NA , then C can not have sent the message.
Consequently, B must have sent the message and so A can infer that KB NA .
Form this, we can infer KA KB NA .
7 Loweas attack on the Protocol In the following section we describe an attack on the protocol as suggested by Lowe [17].
First we outline some general assumptions about the intruder.
The intruder is able to:-        overhear and intercept messages being passed in the system, decrypt messages that are encrypted with its own public key, then it can learn them, introduce new messages with the nonces it knows, replay any message he has seen, even if he was not able to decrypt it.
if the intruder cannot learn the message, then it can remember the encrypted part and can pass it to other agents.
Lowe considers a situation where A could run the protocol with an enemy C, then C could pretend is he A and could start a new run of the protocol with B [17].
The situation could be described as follows: Message Message 1 Message 2 Message 3 Message 4 Message 5 Message 6  Direction Contents A!C: (NA ; A)pub key(C) C(A) !
B : (NA ; A)pub key(B) B !
C(A) : (NA ; NB )pub key(A) C(A) !
A : (NA ; NB )pub key(A) A!C: (NB )pub key(C) C(A) !
B : (NB )pub key(B) 17  In message 1 A starts running the protocol with C, sending the nonce NA , encrypted with Cas public key.
In message 2 the intruder impersonates A (denoted above as C(A)) to start a run of the protocol with B, sending the same nonce that A sent before but encrypted with Bas public key.
Then B replies by sending a new nonce NB to C, but it encrypts it with Aas public key (message 3).
C cannot decrypt the message, but it forwards it to A in order to obtain NB (message 4).
In message 5 A sends NB to C with Cas public key, therefore he now knows NB .
Then he returns NB to B making him believe that the protocol has been correctly run with A.
However, now A, B and C all know the nonces NA and NB .
In the previous set of axioms this attack is disallowed due to axiom 4, i.e.
A is only allowed to send messages containing NA or NB enctypted in Bas public key.
If axiom 4 is not present, then agent A is permitted to send out a message containing NA with a public key different from that of B. Consequently, we are not then able to prove 8V : :KC value nonce(NA ; V ) and so we cannot be sure that B, and only B, knows NA .
8 Concluding Remarks We have used a combination of non-classical logics, in particular the fusion of linear time temporal logic with the multi-modal logic S5 (representing knowledge) to represent and reason about security protocols.
In particular we have specified the Needham-Schroeder Protocol using temporal logics of knowledge giving axioms relating to communication mechanisms, knowledge etc.
We have proved various properties of this specification by using a resolution calculus for this logic and briefly discussed a well known attack on this protocol.
Future work involves the specification and verification of other protocols in this logic.
The consideration of further protocols would also help us identify other suitable combinations of temporal and modal logics.
We would like to develop tools to carry out the verification of the required properties.
At the moment we have a prototype resolution theorem prover for the single modal version of temporal logics of knowledge but this needs extending to deal with the multi-modal case in order to prove theorems automatically.
Further, we would like to develop programs that animate the reason for proof failure to assist the designers of protocols to detect flaws.
References [1] M. Burrows, M. Abadi and R. Needham, A Logic of Authentication, ACM Transactions on Computer Systems, vol.
8, p. 18a36, 1990.
[2] C. Dixon.
Temporal Resolution using a Breadth-First Search Algorithm.
Annals of Mathematics and Artificial Intelligence, 22:87a115, 1998.
[3] C. Dixon and M. Fisher.
Resolution-Based Proof for Multi-Modal Temporal Logics of Knowledge.
In S. Goodwin and A. Trudel, editors, Proceedings of TIME-00 the Seventh International Workshop on Temporal Representation and Reasoning, Cape Breton, Nova Scotia, Canada, July 2000.
IEEE Press.
[4] C. Dixon, M. Fisher, and M. Wooldridge.
Resolution for Temporal Logics of Knowledge.
Journal of Logic and Computation, 8(3):345a372, 1998.
[5] E. A. Emerson.
Temporal and Modal Logic.
In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 996a1072.
Elsevier Science Publishers B.V.: Amsterdam, The Netherlands, 1990.
18  [6] M. Fisher.
A Resolution Method for Temporal Logic.
In Proceedings of the Twelfth International Joint Conference on Artificial Intelligence (IJCAI), pages 99a104, Sydney, Australia, August 1991.
Morgan Kaufman.
[7] M. Fisher, C. Dixon, and M. Peim.
Clausal Temporal Resolution.
ACM Transactions on Computational Logic, 2(1):12a56, January 2001.
[8] M. Fisher and M. Wooldridge.
On the Formal Specification and Verification of Multi-Agent Systems.
International Journal of Cooperative Information Systems, 6(1), January 1997.
[9] J. Glasgow, G. MacEwen, and P.Panangaden.
A Logic to Reason About Security.
ACM Transactions on Computer Systems, 10(3):226a264, August 1992.
[10] L. Gong, R. Needham and R. Yahalom, Reasoning about Belief in Cryptographic Protocol Analysis, Proc.
IEEE Symp.
on Research in Security and Privacy, p. 234a248, 1990.
[11] D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi.
The Temporal Analysis of Fairness.
In Proceedings of the Seventh ACM Symposium on the Principles of Programming Languages, pages 163a173, Las Vegas, Nevada, January 1980.
[12] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.
Reasoning About Knowledge.
MIT Press, 1995.
[13] J. Y. Halpern.
Using reasoning about knowledge to analyze distributed systems.
Annual Review of Computer Science, 2, 1987.
[14] J.Y.
Halpern and L.D.
Zuck, A Little Knowledge Goes a Long Way: Simple Knowledge-Based Derivations and Correctness Proofs for a Family of Protocols, Proc.
6th ACM Symp.
on Principles of Distributed Computing, 1987, p. 268a280.
[15] J. Y. Halpern and M. Y. Vardi.
The Complexity of Reasoning about Knowledge and Time.
I Lower Bounds.
Journal of Computer and System Sciences, 38:195a237, 1989.
[16] Z.
Manna and A. Pnueli.
The Temporal Logic of Reactive and Concurrent Systems: Specification.
Springer-Verlag, New York, 1992.
[17] G. Lowe.
Breaking and Fixing the Needham-Schroeder Public-key Protocol Using csp and fdr.
In T. Margaria and B. Steffen, editors, Tools and Algorithms for the Construction and Analysis of Systems: second international workshop, TACAS a96, volume 1055 of Lecture Notes in Computer Science, pages 147a166.
Spinger, 1996.
[18] J.-J.
C. Meyer and W. van der Hoek.
Epistemic Logic for Computer Science and Artificial Intelligence, volume 41 of Cambridge Tracts in Theoretical Computer Science.
Cambridge University Press, 1995.
[19] G. Mints.
Gentzen-Type Systems and Resolution Rules, Part I: Propositional Logic.
Lecture Notes in Computer Science, 417:198a231, 1990.
[20] R.M.
Needham and M.D.
Schroeder.
Using Encryption for Authentication in Large Networks of Computers.
Communications of the ACM, 21:993a999, 1978.
[21] D. A. Plaisted and S. A. Greenbaum.
A Structure-Preserving Clause Form Translation.
Journal of Symbolic Computation, 2(3):293a304, September 1986.
19  [22] F. Stulp and R. Verbrugge, A knowledge-based algorithm for the Internet protocol TCP, to appear in the Bulletin of Economic Research, 2001.
Also at http://tcw2.ppsw.rug.nl/prepublications [23] P. Syverson.
Adding Time to a Logic of Authentication.
In Proceedings of the First ACM Conference on Computer and Communications Security, pages 97a101.
ACM Press, 1993.
20