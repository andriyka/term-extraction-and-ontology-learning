A Local Method for Prioritized Fusion of Temporal Information Mahat Khelfallah and BelaAaEd Benhamou Laboratoire des Sciences de laInformation et des SysteEmes LSIS - UMR CNRS 6168 Provence University CMI, TechnopoEle de ChaEteau Gombert 39, rue Joliot-Curie - 13453 Marseille - France.
{mahat,benhamou}@cmi.univ-mrs.fr Abstract Information often comes from different sources and merging these sources usually leads to the apparition of inconsistencies.
Fusion is the operation which consists in restoring the consistency of the merged information by changing a minimum of the initial information.
In this paper, we are interested in linear constraints prioritized fusion in the framework of simple temporal problems (STPs).
Priority expresses a preference relation between linear constraints and can represent either condZdence or quality degrees of the constraints, or the reliability of their sources.
We propose a local fusion method which we experiment on random prioritized STP instances.
1.
Introduction Information often comes from different sources and merging these sources usually leads to apparition of inconsistencies.
Fusion consists in restoring the consistency of the merged information by keeping a maximum of the initial information unchanged.
Information fusion is an important area in the artidZcial intelligence dZeld.
Several fusion methods have been proposed in the literature [12, 1, 8].
Most of them was done in the framework of propositional logic or other logic-based formalisms.
There are many dZelds or applications where the information can be represented by simple linear constraints.
For instance scheduling problems [7], some geographic information can be also expressed by linear constraints [9, 13, 5, 6].
In this paper, we are interested in the prioritized fusion of linear constraints in the framework of simple temporal problems (STPs).
Each STP is issued from a source of information.
We extend the formalism of STP to handle prioritized constraints.
Priority expresses a preference relation  between constraints.
It stems from two situations: (i) All the sources of information are equally reliable, thus all the STPs have the same priority.
But the constraints of each STP are ordered according to their quality or importance levels.
The consideration of all the STPs generates a total preordering on all the constraints.
(ii) Conversely, there is a total preordering between the sources of information according to their reliability or quality degrees.
This dedZnes a total preordering on the STPs.
However, the constraints of each STP have the same priority.
In both situations, merging all the STPs generates a prioritized STP which is probably inconsistent.
The restoration of its consistency has two main steps: the detection of its condZicts, and the elimination of these condZicts.
In [5, 6] revision methods of linear constraints have been proposed in the framework of a real-world geographic application (a dZooding application).
We extend in this paper what was proposed in [5, 6] by: (1) considering more general linear constraints since the dZooding problem was represented by a particular STP.
(2) All the STP constraints are subject to correction in this work whereas only constraints involving the origin variable were corrected when revising the dZooding problem.
(3) handling prioritized constraints.
In [2], a local handling of condZicts in inconsistent belief bases was investigated.
However, the local aspect concerned only the resolution of condZicts since an exhaustive identidZcation of the condZicts was performed, before ordering them according to indZuence relations dedZned on these condZicts and correcting them.
We shall see that the local handling in this paper concerns the identidZcation of condZicts as well as their elimination.
The rest of this paper is organized as follows.
In section 2, we recall some background on simple temporal problems STPs.
We present, in section 3, the fusion principle and we propose a fusion method in section 4.
This method is experimented on random instances of prioritized STPs, and the obtained results are given in section 5, before concluding in section 6.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  2.
Background  by S = (X , C) where X =    Xi and C is ob-  1a$?ia$?p  A Simple Temporal Problem (STP) S is dedZned by S = (X , C) where X is a dZnite set of variables X0 , ..., Xn , having continuous domains.
These variables represent temporal events (time points) and X0 usually represents the origin of time.
C is the set of constraints of the form Xj aXi a$?
aij dedZned on these variables, where aij is a scalar.
Each constraint expresses a distance between two temporal events.
Constraints of the form Xj a Xi aL aij can be also represented since Xj a Xi aL aij is equivalent to the constraint Xi a Xj a$?
aaij .
A tuple x = (x1 , ..., xn ) of real values is a solution of the STP S if the instantiation {X1 =x1 , ..., Xn =xn } satisdZes all its constraints.
The STP S is consistent if and only if it has a solution.
The STP S = (X , C) is associated with a directed edgeweighted graph, Gd = (X , Ed ), called its distance graph where X , the set of vertices, is the set of variables of the STP S, and Ed is the set of weighted arcs representing the set of constraints C. Each constraint Xj a Xi a$?
aij of C is represented by the arc i a j 1 , which is weighted by aij .
For more details see [4].
3.
Prioritized fusion of constraints Before addressing the prioritized fusion of the constraints of STPs, we extend the dedZnition of an STP by considering priorities.
First, we dedZne the notion of a prioritized set of constraints.
DedZnition 1 A prioritized set of constraints is a set C of constraints which is partitioned into r strata C 1 , .
.
.
, C r (i.e., C = C 1 aS .
.
.
aS C r , and ai, j, i = j: C i aS C j = a), where all the constraints of each strata C i have the same priority and have a higher priority than the constraints of C j for each j such that i < j a$?
r. A prioritized STP S is dedZned by S = (X , C) where X is a set of variables and C a set of prioritized constraints.
When different (prioritized) STPs are merged condZicts could appear even if each of the considered (prioritized) STPs is consistent separately.
Let S1 = (X1 , C1 ),.
.
., Sp = (Xp , Cp ) be p (prioritized) STPs obtained from different sources.
We can distinguish two situations: aV In the dZrst one, we merge p prioritized STPs which have the same priority (reliability degree) such that for each prioritized STP Si = (Xi , Ci ), the set of constraints Ci is stratidZed into r strata Ci1 , .
.
.
, Cir .
Let S be the prioritized STP obtained from the aggregation of the p prioritized STPs S1 , .
.
.
, Sp and dedZned 1 For  simplicity a vertex Xi of the graph Gd is denoted by its index i.  tained by aggregating the prioritized set of constraints C1 , .
.
.
, Cp .
C is partitioned into r  strata C 1 , .
.
.
, C r where each set of constraints C i = Cji .
1a$?ja$?p  aV In the second situation, there is a total preordering between the p STPs but the constraints of each STP Si have the same priority.
Let S be the prioritized STP obtained from the union of the p STPs Si with respect to the preordering dedZned on  them.
S is dedZned by S = (X , C) where X = Xi and C is 1a$?ia$?p  stratidZed into  r (r a$?
p) strata C 1 , .
.
.
, C r where each Ci = Cj .
Sj has the priority i In both situations, the aggregation of the p (prioritized) STPs generates the prioritized STP S. With no lost of generality, we suppose in the sequel that S contains at most one constraint between each ordered pair of variables2 .
If the prioritized STP S is consistent, the fusion is done.
Otherwise, its consistency has to be restored.
Example 1 (Inspired from [4]as example) We have two persons Nana and Sissi which go to work every morning, and we have two scenarii.
The dZrst one informs us that: Nana leaves home before 7:05, and arrives at work between 7:20 and 7:30.
Sissi leaves home at most 5 mn after Nana does so and arrives at work at least 10 mn before Nana.
The second scenario states that: It takes to Nana at most 10 mn to get at work, whereas it takes to Sissi between 10 and 20 mn to get at work, and Nana arrives at work at most 5 mn after Sissi leaves home.
Information of each scenario can be represented by an STP.
Let S1 be the STP representing the dZrst scenario, and S2 be the STP representing the second one.
Let X1 , X2 , X3 , X4 be the variables representing the temporal events aNana leaves homea, aNana arrives at worka, aSissi leaves homea and aSissi arrives at worka respectively.
Let X0 be the variable representing the time 7:00 a.m.
The information aNana leaves home before 7:05a can be represented by the constraint X1 a X0 a$?
5. aNana arrived at work between 7:20 and 7:30a is represented by 20 a$?
X2 a X0 a$?
30, and so on.
We obtain the STPs S1 and S2 such that: S1 = (X1 , C1 ) where X1 = {X0 , X1 , X2 , X3 , X4 } and C1 = {X1 a X0 a$?
5 , X2 a X0 a$?
30 , X0 a X2 a$?
a20 , X3 a X1 a$?
5 , X4 a X2 a$?
a10}, and S2 = (X2 , C2 ) where X2 = {X1 , X2 , X3 , X4 } and C2 = {X2 a X1 a$?
10 , X4 a X3 a$?
20 , X3 a X4 a$?
a10 , X2 a X3 a$?
5}.
The 2 If there are two constraints X a X a$?
a i j ij and Xi a Xj a$?
bij in the prioritized STP S such that aij < bij , then only the constraint Xi a Xj a$?
aij is considered in S.  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  STPs S1 and S2 are consistent separately.
We suppose that the dZrst scenario is more reliable than the second one, thus the constraints of S1 have higher priority than the ones of S2 .
The aggregation of S1 and S2 gives the prioritized STP S = (X , C) where X = X1 aS X2 = {X0 , X1 , X2 , X3 , X4 } and C = C1 aS C2 = {X1 a X0 a$?
5 , X2 a X0 a$?
30 , X0 a X2 a$?
a20 , X3 a X1 a$?
5 , X4 a X2 a$?
a10 , X2 aX1 a$?
10, X4 aX3 a$?
20, X3 aX4 a$?
a10, X2 aX3 a$?
5} such that the constraints of C1 have the priority 1which is the highest and the constraints of C2 have the priority 2.
The priority notion is not involved in the distance graph.
The distance graph dedZnition of a prioritized STP remains the same as the one of classical STPs.
Throughout this paper, we will manipulate the prioritized STP S instead of the (prioritized) STPs S1 , .
.
., Sp .
Let n , m and r be respectively the number of variables, the number of constraints and the number of priorities of the prioritized STP S. The prioritized STP S is dedZned by S = (X , C) such that C = C 1 aS .
.
.
aS C r , where C i , 1 a$?
i a$?
r, is the set of constraints of priority i.
We suppose that 1 is the highest priority and r is the lowest.
Let Gd be the distance graph associated with the prioritized STP S. Thus, n and m are also the number of vertices and the number of arcs of the distance graph Gd respectively.
Restoring the consistency of the prioritized STP S consists in detecting its condZicts, representing them and identifying a subset of constraints whose correction is sufdZcient to eliminate them.
We present in the following each of these steps.
3.1.
Detection of CondZicts The dZrst step of the fusion operation is the detection of condZicts of the prioritized STP S. The method which we propose is based on a variant of the following well known result.
Theorem 1 ([14, 11, 10]) An STP is consistent if and only if its corresponding distance graph does not contain negative circuits.
We can deduce from Theorem 1 that for restoring the consistency of an STP, we need to remove all the negative circuits of its distance graph.
Actually, it is sufdZcient to remove all the elementary negative circuits in the distance graph to restore the consistency of an STP.
This weakened the conditions of Theorem 1.
We extend this result to handle prioritized STPs.
We obtain the following theorem on which is based our fusion method.
Theorem 2 A prioritized STP is consistent if and only if its corresponding distance graph does not contain elementary negative circuits.
Proof 1 Let S be a prioritized STP, and let S  be an STP obtained from the prioritized S by ignoring the priorities of S. S and S  have the same distance graph, let Gd be this distance graph.
The STP S  is consistent if and only if it has a solution x which satisdZes all its constraints.
It is clear that a solution x of the STP S  is also a solution of the prioritized STP S, since S and S  have the same set of constraints.
This implies that S is consistent if and only if S  is consistent.
On the other hand, the STP S  is consistent if and only if Gd does not contain negative circuits (Theorem 1).
Thus, we can conclude that the prioritized STP S is consistent if and only if its distance graph Gd does not contain negative circuits.
If S is consistent then Gd does not contain any negative circuit, and in particular, it does not contain any elementary negative circuit.
Conversely, if Gd does not contain any elementary negative circuit, then Gd does not contain any negative circuit.
hence, the STP S  is consistent (Theorem 1), and the prioritized STP S is consistent.
The presence of elementary negative circuits in Gd means that the prioritized STP S contains condZicts.
A condZict is dedZned as follows.
DedZnition 2 Let S be a prioritized STP and Gd be its distance graph.
A condZict of S is a pair (D, d) where D is an elementary negative circuit of the distance graph Gd and d is the distance3 of the circuit D. Now, we dedZne the CondZict-Detection function which detects condZicts of the distance graph.
The CondZictDetection function is an extension of the Bellman-Ford algorithm which computes the shortest paths of a graph [3].
The main idea is to compute for each pair (i, j) of vertices the shortest path from i to j in the distance graph Gd .
In particular, when i = j, the function computes the shortest circuit visiting the vertex i.
In fact, the CondZict-Detection function computes the condZicts, of the distance graph, having the minimum circuit length.
The CondZict-Detection function is given in Algorithm 1.
It consists in two steps.
First, it constructs a matrix mat(0) (0) whose elements are pairs dedZned by: matij = (pij , dij ) where pij represents a path of length 1 from i to j in Gd , and dij is the distance of the path pij .
The initialization step terminates by copying the matrix mat(0) in the matrix mat.
The second step is a loop which computes the shortest paths between each pair (i, j) of vertices.
At each iteration l of the awhilea loop, a call to the Shortest-Path-Extension function given in Algorithm 2 is made to compute the shortest paths of length l between each pair of vertices.
The loop stops either when a condZict is detected or when the length of the computed paths reaches n. 3 The  distance of a path is the sum of its arc weights.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  Algorithm 1 CondZict Detection Function CondZict-Detection(Gd): a set of condZicts Var mat(0) , mat: matrices of pairs (path,distance) Conf : a set of condZicts Begin { Initialization } Conf := a l := 2 for i, j := 1 to n do if there is an arc i a j in Gd weighted by aij (0) then matij := ((i, j), aij ) (0) else if i = j then matij := (a, a) (0) else matij := (a, 0) (0) mat := mat { Path extension and condZict detection } while l a$?
n and Conf = a do begin mat := Shortest-Path-Extension(mat(0), mat, Conf ) l := l + 1 end CondZict-Detection := Conf End  The Shortest-Path-Extension function is based on the following: a shortest path pij of length l from i to j is composed by a shortest path pik of length l a 1 from i to k and an arc from k to j.
When the Shortest-Path-Extension function is called at the iteration l in the loop of the CondZictDetection function, it takes as arguments: mat(0) the initial matrix of pairs (path,distance) corresponding to the distance graph Gd , mat the matrix of pairs (path,distance) corresponding to the shortest paths of length l a 1 in Gd .
It returns the matrix mat corresponding to the shortest paths of Gd of length l. In particular, matii will contain a negative circuit of length l including the vertex i, if it exists.
Furthermore, the detected negative circuits are elementary and are added to Conf .
The Shortest-Path-Extension function returns in Conf the set of condZicts whose negative circuits are of length l. If Conf = a, then there is no negative circuit of length l in Gd .
Now, We evaluate the complexity of the Shortest-PathExtension function.
The initialization phase is performed in O(n2 ).
The second phase consists in three loops.
Each iteration of the internal loop can be done in O(n) since both the path and the distance tests are done in a constant time and path concatenation is done in O(n).
Thus, the second phase can be performed in O(n4 ).
Therefore, the time complexity of the Shortest-Path-Extension function is O(n4 ) in the worst case.
Algorithm 2 Shortest Path Extension Function Shortest-Path-Extension(mat(0), mat, Var Conf ): the extended matrix of (path,distance) Var mat the extended matrix of (path,distance) Begin { Initialization } for i, j := 1 to n, i = j do matij := (a, a) for i := 1 to n do matii := (a, 0) { Extension of the paths of mat } for i, j := 1 to n do for k := 1 to n do (0) if (matik .path = a and matkj .path = a and (0) matik .distance + matkj .distance < matij .distance) then begin (0) p := matik .path aV matkj .path (0) d := matik .distance + matkj .distance  matij := (p, d) if (i = j) then Conf := Conf aS matii end Shortest-Path-Extension := mat End  Now, we evaluate the complexity of the CondZictDetection function.
The initialization phase can be performed in O(n2 ).
In the second phase, the function performs at most n a 1 iterations, and the complexity of each of them is identical to the complexity of the Shortest-PathExtension function which is O(n4 ).
Therefore, the complexity of the CondZict-Detection function is O(n5 ) in the worst case.
Now, we can prove some properties of the Shortest-PathExtension and CondZict-Detection functions.
Proposition 1 The Shortest-Path-Extension function applied to the matrix mat corresponding to the shortest paths of length l in Gd detects at least one elementary negative circuit if and only if it exists one of length l + 1 in Gd .
Proof 2 Let mat(0) be the matrix of pairs (path,distance) corresponding to the distance graph Gd , and mat be the matrix of pairs (path,distance) representing the shortest paths of Gd of length l. Let mat = Shortest-PathExtension(mat(0),mat,Conf ) where Conf is the set of detected condZicts.
The shortest path pij from i to j of length l + 1 of Gd is dedZned by pij = M in1a$?ka$?n (pik aV (k a j)), where M in is a function which selects the path having the minimal distance, pik is the shortest path of length l from i to k of Gd , and (k a j) is an arc of Gd .
This implies that the elements of mat represent really the shortest paths of length l + 1 of Gd .
We can prove now the dZrst statement of the proposition.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  (a) If the Shortest-Path-Extension function applied to the matrix mat corresponding to the shortest paths of length l in Gd detects at least one elementary negative circuit, then there exists at least one vertex i included in a negative circuit of length l + 1.
(a) Suppose that there is an elementary negative circuit Di of length l + 1 including a vertex i of Gd .
Let d (d < 0) be the distance of Di .
Since matii = (pii , dii ) represents the shortest path pii of length l + 1 from i to i and its distance dii , then the circuit pii is shorter than the circuit Di , and consequently dii < d < 0.
This means that the circuit pii is negative also.
Thus, the Shortest-Path-Extension function detects at least one negative circuit, if it exists.
Furthermore, the negative circuits detected by the Shortest-Path-Extension function are elementary.
This can be trivially proved since the function is applied the extend the shortest paths of length l only if there are no negative circuits of length l such that l a$?
l. Proposition 2 states that when the CondZict-Detection function does not detect any negative elementary circuits in the distance graph Gd the prioritized STP S is consistent.
Proposition 2 The prioritized STP S is consistent if and only if the CondZict-Detection function, applied to its distance graph Gd , does not detect any condZict.
Proof 3 (a) If the prioritized STP S is consistent then its distance graph Gd does not contain any elementary negative circuit (by Theorem 2).
In particular, Gd does not contain any elementary negative circuit of length l, 2 a$?
l a$?
n. Thus, the repeated application of the Shortest-PathExtension function does not detect any negative circuit, and the CondZict-Detection function does not detect any condZict.
(a) If the CondZict-Detection function does not detect any condZict, then the Shortest-Path-Extension function has been applied until l = n and for each length, no condZict was detected (i.e., Conf = a).
This means that there is no negative circuit of length l, 2 a$?
l a$?
n in Gd (by Proposition 1).
Therefore, there is no elementary negative circuit in Gd , hence the prioritized STP S is consistent.
3.2.
Representation of condZicts Each condZict of the prioritized STP S is identidZed by a tuple (D, d) where D is an elementary negative circuit of the distance graph Gd and d is the distance of D. We recall that each arc i a j in Gd , weighted by aij , represents the constraint cij : Xj a Xi a$?
aij of the prioritized STP S. We dedZne now the notion of condZicting constraint.
DedZnition 3 Let S = (X , C) be a prioritized STP, Gd its distance graph, and Conf the set of condZicts of S. A constraint cij a C is a condZicting constraint if and only if there  5  0  1  (c1,2 , 2) a20 10  30  5 5  2  20 a10  (c0,1 , 1)  (c2,0 , 1)  (c1,3 , 1)  (c3,2 , 2)  3 a10  (c4,3 , 2)  4  a.
The distance graph  (c2,4 , 1)  b.
The hypergraph of conflicts  Figure 1.
The distance graph and the hypergraph of condZicts of the prioritized STP S dedZned in Example 1  is a condZict c = (D, d) in Conf such that the arc i a j belongs to the elementary negative circuit D of Gd .
Let Conf Const be the function which associates to each condZict c = (D, d) the set of its condZicting constraints.
That is, Conf Const(c) = {cij a C : i a j is an arc of D}.
The set of the detected condZicts Conf is represented by a vertex-weighted hypergraph Hc = (V, Ec ) where V is the set of vertices corresponding to the  set of all condZictConf Const(c), ing constraints dedZned by: V = caConf  and Ec is the set of hyperedges dedZned as follows: each hyperedge e represents a condZict c of Conf such that e represents the condZicting constraints of the condZict c, i.e., e = Conf Const(c).
Thus Ec = {Conf Const(c) : c a Conf }.
Each vertex cij of Hc is weighted by k, where k is the priority of the constraint cij , i.e., cij a C k .
Hc is called the hypergraph of condZicts of the prioritized STP S. Let V 1 , .
.
.
, V r be a partition of the set of vertices V such that: v a V i if the weight of the vertex v in the hypergraph Hc equals i.
Example 2 The distance graph of the prioritized STP S dedZned in Example 1 is represented in Figure 1.a.
The elementary negative circuit {(0,1),(1,2),(2,0)} shows a condZict between the constraints c0,1 , c1,2 and c2,0 .
This adds the hyperedge {(c0,1 , 1), (c1,2 , 2), (c2,0 , 1)} in the hypergraph of condZicts.
By considering all the elementary negative circuits of the distance graph of Figure 1.a, we obtain the hypergraph of condZicts of Figure 1.b.
Each vertex of the hypergraph is a constraint which is weighted by its priority.
3.3.
IdentidZcation of a subset of constraints to correct Removing all the detected condZicts needs correcting some constraints involved in them.
At least one condZicting  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  constraint of each detected condZict has to be corrected.
In other words, the intersection of the set of the corrected constraints and the set of condZicting constraints of each condZict is not empty.
Therefore, the subset of corrected constraints is a transversal of the hypergraph of condZicts Hc of the prioritized STP S. Minimizing change when restoring the consistency of a prioritized STP S amounts to minimizing the number of corrected constraints of C 1 (having the highest priority), then the number of corrected constraints of C 2 , and so on.
We recall the dedZnition of a transversal before dedZning the notion of prioritized transversal.
DedZnition 4 Let H = (V, E) be a hypergraph.
T is a transversal of the hypergraph H if T a V and for each hyperedge e of E, T aS e = a.
Now, we dedZne a preference relation on the transversals of a vertex-weighted hypergraph.
DedZnition 5 Let H = (V, E) be a vertex-weighted hypergraph where V = V 1 aS.
.
.aSV r such that the vertex v a V i if v is weighted by i in H. Let T1 and T2 be two transversals of the hypergraph H. T1 is preferred to T2 if (i) ai, 1 a$?
i a$?
r such that |T1 aS V i | < |T2 aS V i |, and (ii) aj, 1 a$?
j < i, |T1 aS V j | = |T2 aS V j |.
DedZnition 6 Let H = (V, E) be a vertex-weighted hypergraph.
Tp is a prioritized transversal of the hypergraph H if (i) Tp is a transversal of H, and (ii) for each transversal T of H, T is not preferred to Tp .
Example 3 The hypergraph of condZicts shown in Figure 1.b has many transversals.
For instance T ={(c2,0, 1), (c4,3 , 1)}.
It has one prioritized transversal Tp ={(c1,2 , 2), (c3,2 , 2)}.
Algorithm 3 Prioritized Transversal procedure Procedure Prioritized-Transversal(Hc = (V, Ec ),T , W , Var Tp ) Begin if Ec = a then Tp := T else if V = W then begin select a vertex v from V a W Prioritized-Transversal (Hc , T, W aS {v}, Tp ) V := V a {v} Ec := Ec a {e : e a Ec and e  v} if (Tp = a or T aS {v} is preferred to Tp ) then Prioritized-Transversal (Hc , T aS {v}, W, Tp ) end End  We dedZne the Prioritized-Transversal procedure (Algorithm 3) to compute a prioritized transversal of the hypergraph of condZicts Hc .
The search space of this procedure is a binary tree.
At each node of this tree, a vertex is either considered in the current partial transversal T , or not considered then it is put in the set W .
This procedure does not enumerate systematically all the possible transversals of the hypergraph of condZicts to dZnd a prioritized one.
Indeed, it prunes the branches of the search tree leading to partial transversals T which are not preferred to the current prioritized transversal Tp .
The Prioritized-Transversal procedure is called with the parameters Hc = (V, EC ) which is the hypergraph of condZicts, T the current partial transversal, W the set of non considered vertices and Tp the current prioritized transversal of the hypergraph Hc which the procedure returns.
Initially, T = W = Tp = a.
To evaluate roughly the complexity of the PrioritizedTransversal procedure, let nc and mc be respectively the number of vertices and the number of hyperedges of the hypergraph of condZicts Hc .
The search space is bounded by 2nc which is the number of all the possible transversals.
The selection of a vertex v a V a W can be performed in O(nc ), and the removal of the hyperedges incident to v is performed in O(mc ).
Testing if the current partial transversal T aS {v} is preferred to the current prioritized transversal Tp can be done in O(r).
Since r < nc , then the complexity of the Prioritized-Transversal algorithm is O((mc + nc )2nc ) in the worst case.
Example 4 The application of the Prioritized-Transversal procedure to the hypergraph of condZicts shown in Figure 1.b returns the prioritized transversal Tp = {(c1,2 , 2), (c3,2 , 2)}.
3.4.
Correction of the condZicting constraints Now, we shall see how to perform the corrections.
Let c = (D, d) be a condZict of the prioritized STP S. The elimination of the condZict c needs the elimination of its associated elementary negative circuit D. This implies the correction of at least one of the constraints involved in D, i.e., at least one of the constraints of Conf Const(c) is corrected.
The following proposition shows how this correction is done.
Proposition 3 Let S be a prioritized STP and c = (D, d) be a condZict of S. Let cij : Xj a Xi a$?
aij be a condZicting constraint of c (cij a Conf Const(c)).
Replacing the constraint cij : Xj a Xi a$?
aij by the constraint Xj a Xi a$?
aij a d eliminates the condZict c. Proof 4 Let c = (D, d) be a condZict, and let cij : Xj aXi a$?
aij be a condZicting constraint of c, cij a Conf Const(c).
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  The circuit D has a negative distance d, and replacing the constraint Xj aXi a$?
aij by the constraint Xj aXi a$?
aij a d, will make this distance equal to zero.
Hence the negative circuit D is eliminated and the condZict c is corrected.
Example 5 In Figure 1, the elementary negative circuit {(0,1),(1,2),(2,0)} whose distance is -5 identidZes the condZict ({(0,1),(1,2),(2,0)},-5) between the constraints X1 a X0 a$?
5 (representing the fact that Nana leaves home before 7:05), X2 a X1 a$?
10 (representing the fact that it takes less than 10 mn to Nana to get at work) and X0 a X2 a$?
a20 (representing the fact that Nana arrives at work after 7:20).
This condZict can be removed by replacing the constraint X2 a X1 a$?
10 by the constraint X2 a X1 a$?
15 (it takes to Nana less than 15 mn to get work instead of 10 mn).
The following proposition states that a condZict is eliminated if and only if one of its condZicting constraints is corrected.
Proposition 4 Let S be an inconsistent prioritized STP and c = (D, d) be a condZict of S. The condZict c is eliminated if and only if at least one of its condZicting constraints cij a Conf Const(c) is corrected with respect to Proposition 3.
Proof 5 Let S be an inconsistent prioritized STP and c = (D, d) be a condZict of S. (a) Suppose that the condZict c = (D, d) is eliminated.
This implies that the negative circuit D is eliminated, i.e., its distance is changed from negative to positive.
This is done by changing at least the weight of one of its arcs.
In other words, by correcting, at least, one constraint cij of Conf Const(c).
(a) The correction of a constraint cij a Conf Const(c) makes the condZict circuit D positive.
Hence, the condZict c = (D, d) is eliminated.
When correcting a constraint no new condZicts are generated and the following theorem states that the correction of the constraints corresponding to a transversal of the hypergraph of condZicts representing the detected condZicts, eliminates these condZicts.
Theorem 3 Let S be an inconsistent prioritized STP and let Conf be a set of detected condZicts of S. Let Hc be the hypergraph of condZicts representing the set Conf .
The condZicts of Conf are removed from the prioritized STP S if and only if the constraints corresponding to a transversal of the hypergraph of condZicts Hc are corrected.
Proof 6 Let S be an inconsistent STP and let Conf be the set of detected condZicts of S. Let Hc be the hypergraph of condZicts representing Conf .
(a) Suppose that all the condZicts of Conf are removed.
Let Cr be the subset of constraints corrected when removing the condZicts of Conf .
Each condZict c of Conf is removed by the correction of, at least, one of its condZicting  constraints, that is a constraint of Conf Const(c) (Proposition 4).
This means that Cr aS Conf Const(c) = a for each condZict c a Conf .
However, Conf Const(c) = e where e is the hyperedge representing the condZict c in Hc .
Then, Cr aS e = a for each hyperedge e of the hypergraph of condZicts Hc .
Thus Cr is a transversal of the hypergraph of condZicts Hc .
(a) Suppose that Cr is a transversal of the hypergraph of condZicts Hc and all its corresponding constraints are corrected.
This means that for each hyperedge e of Hc , e aS Cr = a.
However, each hyperedge e of Hc represents the set of condZicting constraints of a condZict c of Conf , i.e., e = Conf Const(c).
This implies that for each condZict c of Conf , at least one condZicting constraint of c is corrected (because Cr aS Conf Const(c) = a).
Hence, each condZict c is eliminated (by Proposition 4).
We conclude that the correction of all the constraints corresponding to Cr eliminates all the condZicts of Conf .
4.
Local prioritized fusion algorithm Since the number of elementary negative circuits of the distance graph of a prioritized STP is potentially high, the exhaustive detection of condZicts can be impossible.
A local handling of the problem seems to be a good alternative to this problem.
That is, if the condZicts are detected and corrected bundle by bundle, the complexity of the fusion operation decreases.
On other hand, if a detected condZict c, of the prioritized STP S, involves for instance a constraint cij , and if this constraint participates in another not yet detected condZict c , then the correction of the constraint cij could eliminate the condZict c .
The Local Prioritized Fusion function, sketched in Algorithm 4, consists in detecting a bundle of condZicts, then in eliminating them by correcting the condZicting constraints corresponding to a prioritized transversal of the hypergraph of condZicts.
It repeats these operations until the restoration of the consistency.
Theorem 4 The Local Prioritized Fusion algorithm, applied to the prioritized STP S, terminates and restores the consistency of S. Proof 7 Let S be a prioritized STP.
The number of condZicts of S is dZnite and the correction of constraints cannot generate new ones.
At each iteration of the Local-PrioritizedFusion algorithm, the CondZict-Detection function detects a subset of condZicts.
The elimination of these condZicts is guaranteed by the correction of the constraints of a prioritized transversal Tp of the hypergraph of condZicts Hc representing the detected condZicts (see Theorem 3).
This implies that at each iteration, the total number of condZicts  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  Algorithm 4 Local Prioritized Fusion Function Local-Prioritized-Fusion(S prioritized STP): a consistent prioritized STP Begin Construct Gd the distance graph of S Conf := Detection-CondZict(Gd) repeat Construct Hc the hypergraph of condZicts corresponding to Conf Tp := a Prioritized-Transversal(Hc , a, a, Tp ) Correct the constraints corresponding to the prioritized transversal Tp Conf := Detection-CondZict(Gd) until Conf = a Local-Prioritized-Fusion := S End  decreases, until the elimination of all condZicts.
The algorithm stops when no condZicts are detected by the CondZictDetection function.
This implies that there is no condZict in the prioritized STP S (Proposition 2).
Therefore, the LocalPrioritized Fusion function terminates and restores the consistency of the prioritized STP S. To evaluate the complexity of the Local-PrioritizedFusion algorithm, we proceed step by step.
Let mc be the number of condZicts of the prioritized STP S. This number is bounded by the number of possible elementary circuits of the distance graph Gd which is itself bounded n  n!
Akn where Akn = (nak)!
.
The complexity of the by k=2  CondZict-Detection function is O(n5 ), and the construction of the distance graph is in O(nm).
Now, we evaluate the complexity of each iteration.
Since the number of detected condZicts at each iteration is at most n and each condZict can involve at most n condZicting constraints, the construction of the hypergraph of condZicts Hc corresponding to Conf is in O(n2 ).
The prioritized transversal Tp of the hypergraph  of condZicts Hc is computed in O((mc + nc )2nc ) where mc is the number of handled condZicts and nc is the number of condZicting constraints.
The number mc is bounded by n because at most n condZicts are handled in each iteration and nc is bounded by n2 .
Thus, the Prioritized transversal 2 search is performed in O(n2 2n ) in the worst case.
The correction of the constraints of Tp is performed in O(n) since at most n constraints can be corrected.
Therefore, each it2 eration is performed in O(n2 2n ) in the worst case.
The Local Prioritized Fusion algorithm performs at most mnc it2 erations.
Therefore, its complexity is O(mc n2n ) in the worst case.
5.
Experimental results The local prioritized fusion algorithm presented in this paper is implemented in C and tested on randomly generated prioritized STPs.
The program runs on a P4 with 2.2 MHz and 512 MB of RAM.
Generation of random prioritized STPs is based on three parameters: the number of variables n, the number of priorities (strata) r, and the constraint density d which is the ratio of the number of constraints to the number of possiof constraints .
The tightness of ble constraints, d = number n(na1) the constraints is represented by the interval [-50,50] where the constraint weights are generated.
A sample of 50 problems is generated for each tuple (n, r, d) and the measures are taken in average.
The experimental results obtained by the application of the Local Prioritized Fusion algorithm on random prioritized STP instances are shown in Table 1.
A dash (-) means that the algorithm did not answer after running 2 hours.
We can see in Table 1 that when the density grows, the number of condZicts grows.
This increases the number of corrected constraints, the number of iterations and the CPU time.
The fusion algorithm becomes faster as the number of considered priorities increases even though the number of detected condZicts, the number of corrected constraints and the number of iterations increase.
This can be explained by the speed up of the prioritized transversal search when there are many strata.
As expected, the number of corrected constraints when only one stratum is considered is the smallest.
This is due to minimal change policy.
In the same spirit, when the number of considered priorities increases, the number of corrected constraints having the highest priority decreases.
We can see that the method fuses in reasonable time problems having 30 variables with a small density (d = 0.2), but reaches its limit on higher densities.
6.
Conclusion In this paper, we investigated the prioritized fusion of Simple Temporal Problems STPs.
That is, giving a set of prioritized STPs to fuse, we considered the prioritized STP S resulting from their union.
If S is consistent, then the fusion is done.
Otherwise, the consistency of S has to be restored.
We presented a principle of a prioritized fusion on which is based the local prioritized fusion method which we proposed.
Two justidZcations motivate the local strategy.
The dZrst one is the high complexity of the exhaustive detection of the condZicts.
The second justidZcation is related to the condZict nature.
If a bundle of condZicts is detected and corrected, this could eliminate not yet detected condZicts.
This speeds up the fusion operation.
In future, we can improve the local prioritized fusion algorithm efdZciency by considering a agooda transversal  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  # priorities  r=1  r=5  r = 10  # condZicts # corrected const # corrected const.
# corrected const.
# iterations CPU time (s) # condZicts # corrected const # corrected const.
# corrected const.
# iterations CPU time (s) # condZicts # corrected const # corrected const.
# corrected const.
# iterations CPU time (s)  highest prior.
lowest prior.
highest prior.
lowest prior.
highest prior.
lowest prior.
n = 10 Density 0.2 0.5 0.8 1 23 43 1 14 25 1 14 25 1 14 25 2 8 11 0 0 0 1 25 47 1 15 32 0 0 0 1 6 11 2 8 12 0 0 0 1 22 48 1 13 13 0 0 0 1 4 5 2 8 13 0 0 0  0.2 42 23 23 23 11 0 44 29 0 13 12 0 47 28 0 7 12 0  n = 20 Density 0.5 0.8 160 232 92 144 92 144 92 144 21 26 33 120 197 292 141 219 2 9 42 57 27 35 1 7 204 325 150 251 0 1 23 34 28 38 3 7  n = 30 Density 0.2 0.5 142 68 68 68 19 416 187 123 0 47 24 135 192 130 0 22 24 127 -  0.8 -  Table 1.
Experimental results obtained by the application of the Local-Prioritized-Fusion algorithm on random prioritized STP instances  rather than a prioritized one.
We also hope to extend this work to handle disjunctive temporal problems.
References [1] S. Benferhat, D. Dubois, and H. Prade.
Some syntactic approaches to the handling of inconsistent knowledge bases: A comparative study part 1: The dZat case.
Studia Logica, 58:17a45, 1997.
[2] S. Benferhat and L. Garcia.
Handling locally stratidZed inconsistent knowledge bases.
Studia Logica, 70:77a104, 2002.
[3] T. Cormen, C. Leiserson, and R. Rivest.
Introduction to Algorithms.
MIT Press, Cambridge, Massachusetts, 1990.
[4] R. Dechter, I. Meiri, and J. Pearl.
Temporal constraint networks.
ArtidZcial Intelligence, 49:61a95, 1991.
[5] M. Khelfallah and B. Benhamou.
Geographic information revision based on constraints.
In Proc.
of the 14th European Conference on ArtidZcial Intelligence, ECAIa04, pages 828a 832, 2004.
[6] M. Khelfallah and B. Benhamou.
Two revision methods based on constraints: Application to a dZooding problem.
In Proc.
of the 7th Int.
Conf.
of ArtidZcial Intelligence and Symbolic Computation AISCa04, volume 3249 of LNAI, pages 265a270, 2004.
[7] R. Kolisch and R. Padman.
An integrated survey of deterministic project scheduling.
Omega, 29:249a272, 2001.
[8] S. Konieczny, J. Lang, and P. Marquis.
Distance based merging: A general framework and some complexity results.
In Proc.
of the 8th Int.
Conf.
on Principles of Knowledge Representation and Reasoning (KRa02), pages 97a108, 2002.
[9] G. Kuper, G. L. Libkin, and J. Paradaens, editors.
Constraint Databases.
Springer-Verlag, 2000.
[10] C. Leiserson and J. Saxe.
A mixed-integer linear programming problem which is efdZciently solvable.
In Proc.
of the 21st annual Allerton conference on Communications, Control, and Computing, pages 204a213, 1983.
[11] Y. Lia and C. Wong.
An algorithm to compact a vlsi symbolic layout with mixed constraints.
In IEEE Trans.
Computer-Aided Design of Integrated Circuits and Systems, volume 2, pages 62a69, 1983.
[12] J. Lin and A. Mendelzon.
Dynamic Worlds: From the Frame Problem to Knowledge Management, volume 12 of Applied Logic Series, chapter Knowledge Base Merging by Majority.
Kluwer, 1999.
[13] P. Rigaux, M. Scholl, and A. Voisard.
Spatial Databases with Application to GIS.
Morgan Kaufmann, 2002.
[14] R. Shostak.
Deciding linear inequalities by computing loop residues,.
Journal of ACM, 28(4):769a779, 1981.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE