Tableaux for Temporal Logics of Knowledge: Synchronous Systems of Perfect Recall or No Learning Clare Dixon, ClaEudia Nalon, Michael Fisher Department of Computer Science The University of Liverpool, Liverpool L69 7ZF, UK fclare,claudia,michaelg@csc.liv.ac.uk Abstract The paper describes tableaux based proof methods for temporal logics of knowledge allowing interaction axioms between the modal and temporal components.
Such logics can be used to specify systems that involve the knowledge of processes or agents and which change over time, for example agent based systems or knowledge games.
The interaction axioms allow the description of how knowledge evolves over time and makes reasoning in such logics theoretically more complex.
Completeness arguments for the tableaux are discussed.
1 Introduction We describe a tableau-based proof method for temporal logics of knowledge allowing interaction axioms between the modal and temporal parts.
Temporal logics of knowledge have been used for the specification and verification of distributed and multi-agent systems [8, 10, 18], analysing security protocols [24, 9], knowledge games such as the muddy children problem [3] etc.
Tableau based proof methods involve the systematic construction of a structure, for a formula ', from which a model for ' can be obtained.
To show a formula ' valid the tableau algorithm is applied to :'.
If the resultant structure is empty then :' is unsatisfiable and ' valid.
The logic we consider is linear time temporal logic with finite past and infinite future combined with the modal logic S5, allowing the interactions synchrony and perfect recall and synchrony and no learning [6, 13, 14, 15].
Such interactions allow us to consider how knowledge evolves over time.
For example, for certain classes of systems, interaction occurs between knowledge and time so that, for example, statements such as aif an agent knows that in the next moment p holds then, in the next moment, the agent knows p holdsa  are valid.
Systems with this property have been termed as synchronous with no forgetting, or unbounded memory or perfect recall [6, 13, 14, 15].
For other systems we may want the converse of this.
Systems with this property are known as synchronous with no learning [6, 13, 14, 15].
For many of the interactions described in the literature [14, 15] this increases the complexity of the logic (sometimes dramatically) even for the single agent case.
Thus, proof methods for such systems are even rarer than those for the basic logic of time and knowledge (i.e.
the fusion of these logics).
Unusually for tableau systems our method uses a satisfiability preserving translation into a normal form, SNF K , for temporal logics of knowledge.
This normal form removes all temporal operators apart from g(in the next moment in time) and } (sometime in the future) and the resulting clauses hold in all states.
We extend this normal form slightly and due to the structure of the clauses obtained we can easily add new clauses resulting from the explicit application of the axiom for synchrony and perfect recall or synchrony and no learning.
This ensures the constraints of the particular interaction axiom are added to the clauses in the normal form before the construction of the tableau itself.
The tableau construction is similar to that for temporal logics of knowledge (see for example [3]) but due to the translation to normal form, which removes many of the temporal operators and requires formulae to be in a particular form, we require the definition of fewer alpha and beta rules.
Further, complex deletion or expansion rules are not required to satisfy the grid-like synchrony and perfect recall or no learning requirement as we have explicitly applied this information earlier in the method.
As part of the completeness proof we show we can construct models from non-empty tableau constructions.
The structure of the paper is as follows.
In Section 2 we give the syntax and semantics of KL a temporal logic of knowledge and define the synchrony and perfect recall and synchrony and no learning restrictions.
In Sec-  tion 3 we define the normal form SNFK and its extensions ESNFSP R and ESNFSNL .
In Section 4 we show how to translate any temporal logic of knowledge formula into SNFK , ESNFSP R and ESNFSNL .
In Section 5 we present tableau algorithms for the single agent case of systems of synchrony and perfect recall and synchrony and no learning.
Examples are given in Section 6 and proofs of correctness of our algorithms are given in Section 7.
Finally we present conclusions, discuss related work and mention future work in Section 8.
We first give the syntax and semantics of a logic KL, a temporal logic of knowledge where the modal relation K is restricted to be an equivalence relation [15].
The temporal component is interpreted over a discrete linear model of time with finite past and infinite future; an obvious choice for such a flow of time is N ; < , i.e., natural numbers ordered by the usual aless thana relation.
This logic has been studied in detail [15] and is the most commonly used temporal logic of knowledge.  )
2.1 Syntax  =  Formulae are constructed from a set P fp; q; r; : : :g of primitive propositions.
The language KL contains the standard propositional connectives : (not), _ (or), ^ (and) and ) (implies).
For knowledge we introduce a unary modal connective K , where a formula K is read as athe agent knows a.
For the temporal dimension we take the usual set of future-time temporal connectives g(next), } (sometime or eventually), (always), U (until) and W (unless or weak until).
The set of well-formed formulae of KL, WFFK is defined as follows:   false , true and any element of P is in WFFK ;  if A and B are in WFFK then so are :A, A _ B , A ^ B , A ) B , KA, }A, A, A U B , A W B , gA. A literal is either p, or :p, where p 2 P .
A modal literal is either Kl or :Kl, where l is a literal.
2.2 Semantics First, we assume that the world may be in any of a set, A timeline t, is an infinitely long, linear, discrete sequence of states, indexed by the natural numbers.
Let TLines be the set of all timelines.
A point q , is a pair q t; u , where t 2 TLines is a timeline and u 2 N is a temporal index into t. Let Points be the set of all points.
A  S , of states.
=( )   T L  TLines is a set of timelines, with a distinguished timeline t0 ;   R is the agent accessibility relation over P oints, i.e., R  P oints  P oints where R is an equivalence relation;    is a valuation.
As usual, we define the semantics of the language via the satisfaction relation aj a.
For KL, this relation holds between pairs of the form hM; q i (where M is a model and q is a point in T L  N ), and formulae in WFFK .
The rules defining the satisfaction relation are given below (we omit many propositional connectives as they are standard).
=  2 Syntax and Semantics  (  : P oints  P !
fT; F g. A = hT L; R; i, where:  valuation  , is a function  model M , is a structure M  hM; (t; u)i j= true hM; (t; u)i 6j= false hM; (t; u)i j= p iff ((t; u); p) = T (where p 2 P ) hM; (t; u)i j= :A iff hM; (t; u)i 6j= A hM; (t; u)i j= A _ B iff hM; (t; u)i j= A or hM; (t; u)i j= B hM; (t; u)i j= gA iff hM; (t; u + 1)i j= A hM; (t; u)i j= A iff 8u0 2 N ; if (u  u0 ) then hM; (t; u0 )i j= A hM; (t; u)i j= }A iff 9u0 2 N such that (u  u0 ) and hM; (t; u0 )i j= A hM; (t; u)i j= A U B iff 9u0 2 N such that (u0  u) and hM; (t; u0 )i j= B; and 8u00 2 N ; if (u  u00 < u0 ) then hM; (t; u00 )i j= A hM; (t; u)i j= A W B iff hM; (t; u)i j= A U B or hM; (t; u)i j= A hM; (t; u)i j= KA iff 8t0 2 T L; 8u0 2 N ; if ((t; u); (t0 ; u0)) 2 R then hM; (t0; u0)i j= A For any formula A, if there is some model M and timeline t such that hM; t; i j A, then A is said to be satisfiable.
If for any formula A, for all models M there exists a timeline t such that hM; t; i j A then A is said to be valid.
Note that validity and satisfiability are evaluated at the beginning of time.
Informally, this corresponds to the point at which computations (for which we are interested in proving properties) would start.
( 0) = ( 0) =  Definition 1 Systems with synchrony and perfect recall are those such that for all points r; n , if r; n ; s; m 2 R then r; n ; s; m 2 R and m n.  1))  (( ) (  ( +1) (( +1) ( )) =  +  Definition 2 Systems with synchrony and no learning are those such that for all points r; n , if r; n ; s; m 2 R then r; n ; s; m 2 R and m n.  ((  ( ) (( ) ( + 1)) =  + 1) (  ))  We denote the logics that capture the class of (single agent) systems with synchrony and perfect recall as KLSP R and with synchrony and no learning as KLSNL .
We sometimes abbreviate the expression synchrony and perfect recall by SPR and synchrony and no learning by SNL.
It has been shown that the usual axiomatisations of propositional reasoning, knowledge (i.e.
S5 modal logic), linear-time temporal logic plus the axiom  ` K g' ) gK' give a sound and complete axiomatisation for systems of synchrony and perfect recall [14].
Similarly the usual axiomatisations of propositional reasoning, knowledge, linear-time temporal logic plus the axiom  This is not necessary but allows the normal form to be implications.
The translation to SNFK removes many of the temporal operators that do not appear in the normal form by rewriting them using their fixpoint definitions.
Also the translation uses the renaming technique [20] where complex subformulae are replaced by new propositions and the truth value of these propositions is linked to the formulae they replaced in all states.
In linear time temporal logic this is achieved by ensuring that such formulae are in the scope of a operator, i.e.
they hold at all reachable states.
For tem operator, poral logics of knowledge we introduce the which allows nesting of K , and always in the past operators to achieve a similar result.
First we define the always , as in the past operator,  hM; (t; u)i j= A iff 8u0 2 N ; then hM; (t; u0 )i j= A and then let  A ,  ` gK' ) K g' give a sound and complete axiomatisation for systems of synchrony and no learning [14].
In the single agent case the complexity of the validity problem for synchrony and perfect recall is double exponential time, and for synchrony and no learning is EXPSPACE.
For more than one agent each problem is nonelementary [15].
3 A Normal Form for Temporal Logics of Knowledge Due to the complexity of these logics we first translate formulae into a normal form, SNF K , which has the property that for any formula ' is satisfiable if and only if its translation into SNFK is satisfiable.
Further, we give extensions to SNFK required for the tableau constructions for systems of synchrony and no learning and synchrony and perfect recall.
3.1 Normal Form Formulae in KL can be transformed into a normal form SNFK (Separated Normal Form for temporal logics of knowledge).
SNF was described in [7] for linear-time temporal logics and was extended for temporal logics of knowledge, SNFK , in [3].
The form of SNFK we give here is more restricted than in [3] as there initial, step and modal clauses may have disjunctions on the right hand side and step, sometime and modal clauses may have conjunctions on the left hand side.
For the purposes of the normal form we introduce a symbol start such that  hM; (t0 ; 0)i j= start :  (0  u0  u)  if  Finally, the of  A^  A:   operator is defined as the maximal fixpoint   ,   ( ^ K   ):  3.2 Definition of the Normal Form  V   Tj Formulae in SNFK are of the general form j where each Tj , known as a clause, must be in one of the varieties described below.  )
l k ) gl k ) }l k ) m _r true ) lb  start  b=1  (initial clause) (step clause) (sometime clause) (modal clause) (literal clause)  where k , l and lb are literals and m are modal literals.
The outer a  a operator and conjunction that surrounds clauses is usually omitted and we consider just the set of clauses Tj .
To apply the tableau algorithm, additional forms of step clauses are allowed.
A SPR step clause is of the form  K  _g a=1  _r ka ) gK lb  !
b=1  and a SNL step clause is of the form  :K :  ^g a=1  ^r ka ) g:K : lb b=1  !
A formula is in Extended SNFK for Synchrony and Perfect Recall, ESNFSP R , if it is in SNFK or it is a SPR step clause.
A formula is in Extended SNFK for Synchrony and No Learning, ESNFSNL , if it is in SNFK or it is a SNL step clause.
Informally, we add additional step clauses, SPR and SNL step clauses (given above) to which the synchrony and perfect recall (respectively synchrony and no learning) axiom has been applied.
Due to the translation into normal form, SNFK clauses hold at all states, denoted by the external  operator.
Due to the properties of the  operator (see [4]) for any clause C , KC must also hold in each state.
Thus for synchrony and perfect recall, for each step clause (and additional clauses we must construct from the step clauses), we distribute the K operator applied to clauses over the implication.
On the right hand side of the resultant formula the sequence of K and g operators exactly matches the left hand side of the synchrony and perfect recall algorithm, so it can be applied.
The argument for synchrony and no learning is similar except we use the contrapositive of the step clauses and axiom.
Rather than just applying this process of distributing the K operator over implication and applying the relevant axiom to step clauses only we must apply it to particular combinations of step clauses.
This process is described in more detail below.
First we take non-empty subsets of the step clauses and disjoin (respectively conjoin) the left and right hand sides to form disjunctive (respectively conjunctive) step clauses (see Section 4.2).
Thus for systems of synchrony and perfect recall, for a step or disjunctive step clause or the form ' ) g , we distribute an external K due to the  operator over the implication, i.e.
from K ' ) g to K' ) K g and apply the SPR axiom (K g ) gK) to the right hand side obtaining K' ) gK .
For synchrony and no learning the axiom is gK ) K g and we take the contrapositive :K g ) : gK which is equivalent to :K g ) g:K.
For any step or conjunctive step clause ' ) g , take the contrapositive : g ) :'.
Distributing an external K , K : g ) :' , over the implication we obtain K : g ) K :'.
Again taking the contrapositive we obtain :K :' ) :K : g , and we apply the contrapositive of the axiom to the right hand side to obtain :K :' ) g:K : .
Further, as any sometime formula, }l, is equivalent to l _ g}l we add additional step and literal clauses such that when the additional SPR or SNL step clauses are added, this accounts for the application of the relevant axiom to this equivalence.
So for any sometime clause k ) }l we rename }l by a new proposition e}l , giving k ) e}l  (  (  and add  e}l  ) }l .
equivalence above) of  )  )  To capture the unwinding (i.e.
the  }l we add the clausal form of the  ) l _ ge}l to the clause set.
following e}l  4 Translation into the Normal Form The translation to SNFK is carried out by renaming complex subformulae with new propositional variables and linking the truth of the subformula to that of the proposition at all moments.
Temporal operators are removed using their fixpoint definitions.
Classical and temporal equivalences (see for example [5]) are also used to get formulae into the correct format.
See [3, 7] for more details.
Example As a small example we show how K gp ^ : gKp is translated into SNFK .
First we rename the formula by new proposition x and obtain the clauses  1: 2:  ) x ) K gp ^ : gKp  start  x  The conjunction in clause 2 is split giving  3: 4:  x x  ) K gp ) : gKp  The subformulae gp from clause 2 is renamed by a new proposition y .
The right hand side of clause 4 is rewritten as the equivalent formula g:Kp and :Kp from the rewritten version of clause 4 is renamed by new proposition z .
5: 6: 7: 8:  x y x z  ) ) ) )  Ky gp gz :Kp  Clauses 1,5a8 are in the normal form SNF K .
4.1 Replacement of Sometime Clauses Let T be a set of SNFK clauses and R  of sometime clauses in T .
For each k ) }l k ) }l by e}l ) }l and add  true  t}l  true  T  be the set  2 R replace  ) :k _ e}l ) ge}l ) t}l _ :e}l _ l:  (T ).
Let the new set of clauses be Rep  4.2 Addition of Clauses to form ESNFSP R and ESNFSNL  ( )  Let Rep T be a set of SNFK clauses where the sometime clauses have been replaced and new step and literal  ( )  clauses added as described in Section 4.1 and S  Rep T be the set of step clauses in Rep T .
The set of disjunctive clauses of Rep T , Dis Rep T (respectively conjunctive clauses of Rep T , Con Rep T ) is the set of clauses  _ h  ( ) ( )  kh  )  f_ lj  ( ) ( ( )) ( ( )) ^  j  h  such that for each subset X of S , X  kh  )  Alpha Rules    ^ :( _ )  !
^ f lj  Beta Rules    j  _ ) :( ^ }  6= ;,      each kh is on the left hand side of a step clause in X ;    there is no l on the right hand side of a step clause in X without a corresponding lj .
each lj is on the right hand side of a step clause in X ;  )  (  ( ))  (  ( ( ( ))) ( ( )) (  (  ( )))  Here we present tableau based decision procedures for the logics KLSP R and KLSNL .
That is, given a formula ' of KLSP R or KLSNL the algorithms will decide whether ' is valid or not for the respective logic.
Tableau is a refutation method, i.e.
to show ' is valid we negate ' and try to construct a structure from which a model can be constructed.
If the structure constructed is empty it means that the negated formula is unsatisfiable and therefore ' is valid.
If the structure is non-empty it can be used to construct a model for the negation of the formula, i.e.
:' is satisfiable and ' is not valid.
   Definition 3 A set of formulae, , is proper, denoted proper , if and only if false 62 and if ' 2 then :' 62 .
Definition 4 Let T be a set of formulae.
The set is defined as next T f' j g' 2 T g:  ( )=  Definition 5 Let  T    next(T )  be a set of formulae.
The set is defined as possible :K'; T  possible(:K'; T ) ( ) = f:'g [ f j K 2 T g [ fK j K 2 T g [ f:K j :K 2 T g: Definition 6 Let T be a set of formulae.
The set know is defined as know T f j K 2 T g [ fK j K  T g [ f:K  ( )=  j :K 2 T g  :true :false  ( ))  5 Tableau Algorithms  ()   A K ::  ( ))  (  (T ) 2  1  : :   2  : : ^ g}  Delta Rules  there is no k on the left hand side of a step clause in X without a corresponding kh ;  Simplify Dis Rep T or Con Rep T and remove any clauses whose right hand side is equivalent to true.
The set of SPR step clauses for Dis Rep T , SP R Dis Rep T , and the set of SNL step clauses for Con Rep T , SNL Con Rep T , are given in Figure 1.
1 2  : :  A1    false true  Figure 2.
Tableau Rules Next we provide alpha and beta rules with which to apply to formulae in ESNFSP R or ESNFSNL .
These are given in Figure 2.
This set is smaller than what is required for temporal logics or combined temporal and modal logics because due to the translation to SNFK most temporal operators (except g and }) have been removed and clauses are in a restricted form.
The last group of rules, we have called delta rules, have just one consequence.
Then we construct the Propositional Tableaux for a set of KL formulae and ESNFSP R clauses (respectively for a set of KL formulae and ESNFSNL clauses).
This involves satisfying the set of ESNFSP R or ESNFSNL clauses by applying beta rules and then applying alpha, beta or delta rules to the resultant formulae.
For any modal formula K' (or :K') occurring on the right hand side of a modal clause, or left hand side of a SPR step clause or SNL step clause we add either K' or its negation (or equivalent, where ::K' is associated with K').
Finally any sets that contain false or a formula and its negation are deleted.
5.1 Construction of Propositional Tableau Propositional tableaux are constructed from a set, T , of ENSFSP R or ENSFSP R clauses.
Remove any initial clauses from T .
Let 0 be a set of formulae and F f 0 g. The construction of the set of propositional tableau for F and T is as follows.
  =   1.W Satisfying literal clauses.
For each literal clause true r Wb=1 lb in T , for each 2 F let F F n f g [ f  f  r l gg b=1 b    =    )  [  9 8 0 1 = < _ !
_ _ _ SP R(Dis(Rep(T ))) = K kh ) gK  lj A j kh ) g lj 2 Dis(Rep(T )) ; : h j j h 9 8 1 0 = < ^ ^ !
g ^ A ^ SNL(Con(Rep(T ))) = :K : lj j kh ) g lj 2 Con(Rep(T )) kh ) :K : ; : j  h  j  h  Figure 1.
SPR and SNL Step Clauses 2.
Adding modal formulae and satisfying step, sometime or modal clauses.
  for each step clause in  T  of the form  k  ) gl for each   2 F , let F = F nfg[f [f:kgg[f [fk; glgg.
  for each sometime clause in T of the form e}l ) }l for each 2 F , let F F n f g [ f [ f:e}l gg [ f [    =        fe}l ; }lgg.
 For each modal clause in T of the form k ) Kl for each  2 F , let F = Fnfg[f[fKlgg[f[f:k; :Klgg.
 For each modal clause in T of the form k ) :Kl, for each  2 F , let F = F n fg [ f [ f:Klgg [ f [ f:k; Klgg.
 For each SPR step clause in T of the form K' ) gK for each  2 F let F = F nfg[f [fK'; gK gg[ f [ f:K'gg.
 For each SNL step clause in T of the form :K :' ) g:K : for each  2 F let F = F n fg [ f [ fK :'gg [ f [ f:K :'; g:K : gg.
3.
Applying alpha and beta rules.
2  is an  formula let F = F n fg [ f [ f1 ; 2 gg (b) If ' 2  is an  formula let F = F n fg [ f [ f1 gg [ f [ f2 gg (c) If ' 2  is an A formula let F = Fnfg[f [fA1gg 4.
Deleting sets that are not proper.
Delete any  2 F such (a) If '  that proper  () is false.
Note that step 2 is the equivalent of both applying beta formulae to modal or SPR (SNL) step clauses and ensuring K' or :K' is added to each propositional tableau constructed for clauses with K' on the left or right hand side.
Explicitly adding K' or :K' to the propositional tableau for modal or SPR/SNL clauses containing K' or :K' prevents us from having to return to previously constructed states to add modal formulae.
For example, consider a modal clause k ) Kl.
This clause might be satisfied in the state we are currently constructing, state s, by  adding :k to the label of the state.
Take some state s0 in the same equivalence class as s where k is forced to hold (for example to satisfy the formula :K :k in s).
To satisfy the above modal clause Kl must also be added to the label of s0 .
As s and s0 are in the same equivalence class then s should also contain Kl and there is no guarantee of this without returning to s to explicitly add Kl.
For step and sometime clauses we only explicitly add formulae with future time commitments ( gl, }l) when we have to, i.e.
when the left hand side of the clause is satisfied.
=(  )  :  ( )  Definition 7 A structure H is a tuple H S; E; G; ; L where: S is a set of states; E is a set of equivalence classes; G  S  E is a set of state equivalence class pairs;   G  G is a binary relation on G; and L S !
P KL takes each state and labels it with a set of temporal logic of knowledge formulae.
Definition 8 If H = (S; E; G; ; L) is a structure, (s; e) 2 G where s 2 S and e 2 E , and  is the reflexive transitive closure of  then }l is resolvable in H from (s; e) (notation resolvable(}l; (s; e); H ) if there exists (s0 ; e0) 2 G such that ((s; e); (s0 ; e0 )) 2   and l 2 L(s0 ).
Next we show how to construct a tableau for a formula '.
If we want to show ' valid we negate, apply the algorithm to :' and if the algorithm returns unsuccessful then :' is unsatisfiable and ' is valid.
5.2 Tableau for Synchrony and Perfect Recall or No Learning Given the formulae '0 of KLSP R or KLSNL to be shown satisfiable, perform the following steps.
1.
Translate into normal form formulae in normal form.
0 ('0 ).
Let T0 be the set of  2.
For each sometime clause in T0 replace the sometime clause and add new step and literal clauses as described in Section 4.1 giving Rep T0 .
( )  3.
For  synchrony  and  perfect  recall  construct  Dis(Rep(T0)) and SP R(Dis(Rep(T0))).
Let T = Rep(T0) [ SP R(Dis(Rep(T0))).
For synchrony and no learning construct Con(Rep(T0 )) and SNL(Con(Rep(T0 ))).
Let T = Rep(T0 ) [ SNL(Con(Rep(T0))).
    4.
Construct where l 2 iff start ) l 2 T and construct the set of propositional tableau F for and T .
Call these the initial states of the tableau.
For each i 2 F repeat steps (5)a(7) below, until none apply and then apply step (8).
    tableau applied to '0 is successful then '0 is satisfiable, otherwise if the tableau is unsuccessful then '0 is unsatisfiable.
6 Examples Example 1.
First we show that the axiom for synchrony and perfect recall K gp ) gKp is valid in KLSP R .
We negate and show the negation is unsatisfiable i.e.
the tableau algorithm applied to K gp ^ : gKp is unsuccessful.
First we translate to the normal form obtaining  S = E = G =  = L = ;.
For some member 0 2 F add a new state s to S , labelled by L(s) = 0 , and add e to E and (s; e) to G where e is a new equivalence  start  5.
Let  x y x z  class.
Call e the initial equivalence class.
6.
Satisfying :K' formulae.
( )  ()  () =  For any state s; e labelled by formulae L s , where L s is proper and a propositional tableau, for each formula of the form :K 2 L s create the set of formulae P:K possible :K ; L s .
For each P:K construct F , the set of propositional tableaux for P:K and T .
For each memL s00 then add ber 0 2 F if 9s00 2 S such that 0 00 0 s ; e to G, otherwise add a new state s to S , labelled by 0 , and add s0 ; e to G. L s0  () ( ))  (   ( ) ( )=   = ( )  (  )  7.
Creating  successors.
( )  ()  ()  For any state s; e labelled by formulae L s , where L s is proper and a propositional tableau, if g 2 L s create the set of formulae next L s .
Construct F the set of propositional tableaux for and T .
For each member 0 2 F if 9s00 2 S such that 0 L s00 and s00 ; e00 2 G then add s; e ; s00 ; e00 to  , otherwise add a new state s0 to the set of states S , and new equivalence class e0 to E 0 and add s0 ; e0 to G and s; e ; s0 ; e0 where L s0 to  .
=    (( ) ( ( )=  ( ( ))  = ( )  ))  (  )  8.
Contraction.
Delete any state-equivalence class pair  ()  (  (( ) (  )  ))  The tableau algorithm is termed successful if and only if at least one of the initial states remains undeleted.
If the  x Ky gp gz :Kp  where x, y and z are new propositions (step 1 of the synchrony and perfect recall tableau algorithm).
Let us call this set of clauses T .
Next we would replace any eventualities (step 2 of the synchrony and perfect recall tableau algorithm) but there are none.
Using step 3 of the algorithm we construct Dis T and SP R Dis T which are respectively  ( )  (  ( ))  fy ) gp; x ) gz; x _ y ) g(p _ z )g and  fKy ) gKp; Kx ) gKz; K (x _ y) ) gK (p _ z )g; adding the latter to T .
Next (step 4) we construct propositional tableau from F fxg.
Let  =  B = fx; Ky; y; gp; gz; gKpg:  The set of propositional tableaux (having deleted any non proper sets) for fxg and T are:  fB [ fKp; :z; Kx; gKz; K (x _ y); gK (p _ z )g; B [ fKp; :z; Kx; gKz; :K (x _ y)g; B [ fKp; :z; :Kx; K (x _ y); gK (p _ z )g; B [ fKp; :z; :Kx; :K (x _ y)g; B [ f:Kp; Kx; gKz; K (x _ y); gK (p _ z )g; B [ f:Kp; Kx; gKz; :K (x _ y)g; B [ f:Kp; :Kx; K (x _ y); gK (p _ z )g; B [ f:Kp; :Kx; :K (x _ y)g g  (s; e) where L(s) such  2 that exists } :resolvable(} ; (s; e); H ); or (b) there exists 2 L(s) such that is of the form g and (s0 ; e0 ) 2 G such that ((s; e); (s0 ; e0 )) 2  ; or (c) there exists 2 L(s) such that is of the form :K and (s0 ; e) 2 G such that : 2 L(s0 ).
until no further deletions are possible.
Delete any s 2 S and (s; ) 2 L such that there is no (s; e) 2 G. (a) there  ) ) ) ) )   =( )  =  ()=  Pick one of these, and let S fsg, L s , feg and G s; e .
When we construct  successors to any states labelled by these sets of formulae they will contain fp; z; Kpg, from applying next to B , as well as other formulae.
Constructing propositional tableau for  E  =  any set of formulae containing this set will include :Kp, from applying the modal clause expansion rules (step 2 of the construction of propositional tableau algorithm) to the clause z ) :Kp.
This set contains both Kp and :Kp which is improper.
Hence, any  successors to states labelled by the above sets of formulae will be deleted and the initial states will all be deleted.
So the tableau algorithm is unsuccessful as the tableau constructed from each initial state is empty.
So K gp ^ : gKp is unsatisfiable and K gp ) gKp is valid.
Example 2.
The axiom for systems of synchrony and no learning is gKp ) K gp.
We negate to obtain gKp ^ :K gp and show the output from the KLSNL tableau algorithm is unsuccessful.
First we translate into normal form obtaining  start  x y x z  ) ) ) ) )  x  gy Kp :K :z g:p  f  () =  ()  This result can be established in a similar manner to that for the translation into the normal form from linear-time temporal logic [7] of that for the fusion of temporal logic and knowledge [3], with some additional arguments that the newly added clauses preserve satisfiability.
Theorem 10 The tableau algorithm applied to 0 , a formula of KLSP R (respectively KLSNL ), returns successful, if and only if 0 is KLSP R (respectively KLSNL ) satisfiable.
Proof [Sketch] By Theorem 9 we show that the translation to normal form preserves satisfiability.
Next, given a successful tableau we show how to use the tableau to construct a model.
For synchrony and perfect recall this involves showing for any two states s0 ; e0 , s00 ; e0 in the same equivalence class where one (say s0 ; e0 ) has a predecessor, s; e , we can add  relations to the tableau providing a predecessor to s00 ; e0 in the same equivalence class as s; e which preserves the required properties of the tableau.
From this extended tableau construction we can construct timelines in which satisfy all eventualities, and reconstruct the modal relation such that formulae of the form :K' are satisfied and we obtain the required model structure for synchrony and perfect recall .
For synchrony and no learning we construct several timelines (from an equivalence class) together and show each satisfies all eventualities.
Finally we must show that for states at times greater than 0 with no predecessors we can construct predecessors that satisfy the set of ESNF SNL clauses.
This argument depends on the fact that the set of ESNFSNL clauses constructed from a KLSNL formula is a particular form with newly introduced propositions on the left hand side of clauses (or in the case of literal clauses each having a negated newly introduced propositional variable on the right hand side).
To show that unsuccessful tableau applied to 0 means 0 is unsatisfiable we again use Theorem 9 to show the translation to normal form preserves satisfiability.
We show each step in the tableau algorithm preserves satisfiability and that an improper set of formulae is unsatisfiable.
The construction of an unsuccessful tableau means there was a chain of deletions from an improper node, back to the initial node meaning the original formula was unsatisfiable.
Termination must occur because the application of the tableau rules to the set of normal form formulae result in a finite set of formulae.
Eventually when constructing  successors we must generate a state labelled by formulae we have constructed before.
  (  where x, y and z are new propositions.
Let this set be T .
Next we construct Con T and then SNL Con T which is  ( )  Theorem 9 Let  be a well-formed formula in KLSP R (reV SNL  spectively KL ) and   i Ti where Ti is the set of clauses translated into ESNFSP R (respectively ESNFsnl ).
is satisfiable in KLSP R (respectively KLSNL ) if and only if   is satisfiable in KLSP R (respectively KLSNL ).
(  ( ))  :K :x ) g:K :y :K :z ) g:Kp :K :(x ^ z ) ) g:K :(y ^ :p) g  and add the latter to T .
Following step 4 of the tableau algorithm for KLSNL we construct the set of propositional tableau for fxg and T .
Each of these contains  fx; gy; :K :z; g:Kp; :K :x; g:K :yg  in addition to other formulae to satisfy the remaining clauses in T .
For any of these propositional tableau when we construct the  successor (step 7 of the tableau algorithm) they will contain fy; :Kp; :K :y g. To satisfy the clause y ) Kp, the set will also contain Kp.
As both :Kp and Kp are both in this state every  successor of an initial state is improper, therefore each initial state is deleted and the tableau is unsuccessful.
Thus gKp ^ :K gp is unsatisfiable and gKp ) K gp valid.
7 Correctness We now show that the tableau algorithms presented above are correct.
Due to lack of space we merely outline the proof arguments.
The full proofs are in [4].
As the tableau algorithms work on formulae in normal form we first show that translation to SNF K and then, that the addition of clauses to form ESNFSP R or ESNFSNL preserves satisfiability.
(  )( )  )  ( )  ( )  (  )  8 Conclusions, Related and Future Work We have presented a sound, complete and terminating tableau for the single agent case of synchrony and prefect recall and synchrony and no learning.
Such interactions are necessary if we want to allow knowledge to evolve over time.
Allowing interaction between knowledge and time makes the complexity of the logic high.
Thus, as well as a detailed study of complexity of the method, we need to devise strategies for efficient construction of the tableau to avoid the worst case complexities where possible.
For example taking subsets of step clauses to construct SPR or SNL clauses is an exponential procedure.
To avoid having to do this exponential construction in every case, we could investigate the following:    apply the SPR or SNL axiom to single step clauses, construct the tableau and see whether we obtain an empty tableau, if so we are done; otherwise    construct the full set of SPR or SNL step clauses and update the tableau already constructed.
For the examples in Section 6 we would have derived an empty tableau from just applying the relevant axiom to the individual step clauses.
Similarly, while constructing the propositional tableau it may be possible to add what we need and fill in the details later.
Future work involves both the investigation of such strategies, and the use of case studies to see which interactions occur commonly in real world problems.
An interaction corresponding to the synchrony and perfect recall axiom has been highlighted as desirable during work with the developers of the multi-agent specification language KARO [26].
We intend to extend the ideas developed in this paper on the single agent version of the logics, to the multi-agent version of this logic, and to other axioms suggested in [12], unique initial state, perfect recall and no learning (without synchrony) [25].
However this will need some thought as for the extension to non-synchronous versions of these systems it is not obvious how to add clauses to the normal form to ensure models are of the correct form and the multi-agent versions of the synchronous logics will require the addition of more complex clauses.
Complete axioms systems and complexity of the satisfiability for a combination of propositional linear and branching time temporal logics with multi-modal S5 allowing a variety of interactions are considered [6, 12, 14, 15].
Resolution based proof methods for the single agent cases of synchrony and perfect recall are given in [2], and for synchrony and no learning [19].
A tableau based proof method for the fusion of PTL plus either S5 or KD45 is given in [28].
This is essentially  the combination of tableau methods for propositional linear time temporal logics [27] and that for the modal logics S5 and KD45 [11].
It does not require the translation to any particular normal form.
The work on proof methods for BDI-logics given in [21, 22] give a tableau based proof method for the fusion of either linear or branchingtime (CTL or CTL*) with the modal logics KD45 for belief, and KD for desire and intention.
We presented tableau algorithms (without the use of normal forms or explicit application of the interaction axioms) for temporal logics of knowledge with synchrony and perfect recall or synchrony and no learning in [1] but these were later found to be unsound, prompting this work.
The papers [17, 23] give tableaux for linear time temporal logics combined with description logics.
The restrictions on domains such as expanding, or constant are similar to the imposition of interactions we use here.
In [16] a method for constructing tableau for first-order temporal logics is given.
Here, the use of surrogates is similar to the translation to the normal form used in this paper.
Acknowledgements This work was partially supported by EPSRC research grant GR/M44859/02 and a CAPES studentship.
References [1] C. Dixon and M. Fisher.
Tableaux for Synchronous Systems of Knowledge and Time with Interactions.
In G. Grahne, editor, Proceedings of the Sixth Scandinavian Conference on Artificial Intelligence (SCAI), August 1997.
[2] C. Dixon and M. Fisher.
Clausal Resolution for Logics of Time and Knowledge with Synchrony and Perfect Recall.
In H. Wansing and F. Wolter, editors, Proceedings of ICTL-00 the Third International Conference on Temporal Logic, Leipzig, Germany, October 2000.
[3] C. Dixon, M. Fisher, and M. Wooldridge.
Resolution for Temporal Logics of Knowledge.
Journal of Logic and Computation, 8(3):345a372, 1998.
[4] C. Dixon, C. Nalon, and M. Fisher.
Tableaux for Logics of Time and Knowledge with Interactions Relating to Synchrony.
Submitted, 2003.
[5] E. A. Emerson.
Temporal and Modal Logic.
In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 996a1072.
Elsevier Science Publishers B.V.: Amsterdam, The Netherlands, 1990.
[6] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.
Reasoning About Knowledge.
MIT Press, 1995.
[7] M. Fisher, C. Dixon, and M. Peim.
Clausal Temporal Resolution.
ACM Transactions on Computational Logic, 2(1):12a56, January 2001.
[8] M. Fisher and M. Wooldridge.
On the Formal Specification and Verification of Multi-Agent Systems.
International Journal of Cooperative Information Systems, 6(1), January 1997.
[9] J. Glasgow, G. MacEwen, and P.Panangaden.
A Logic to Reason About Security.
ACM Transactions on Computer Systems, 10(3):226a264, Aug 1992.
[10] J. Y. Halpern.
Using reasoning about knowledge to analyze distributed systems.
Annual Review of Computer Science, 2, 1987.
[11] J. Y. Halpern and Y. Moses.
A guide to completeness and complexity for modal logics of knowledge and belief.
Artificial Intelligence, 54(3):319a379, April 1992.
[12] J. Y. Halpern, R. van der Meyden, and M. Vardi.
Complete axiomatizations for reasoning about knowledge and time.
Submitted for publication, 1999.
[13] J. Y. Halpern and M. Y. Vardi.
The Complexity of Reasoning about Knowledge and Time: Extended Abstract.
In Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing, pages 304a315, Berkeley, California, May 1986.
[14] J. Y. Halpern and M. Y. Vardi.
The Complexity of Reasoning about Knowledge and Time: Synchronous Systems.
Technical Report RJ 6097, IBM Almaden Research Center, San Jose, California, April 1988.
[15] J. Y. Halpern and M. Y. Vardi.
The Complexity of Reasoning about Knowledge and Time.
I Lower Bounds.
Journal of Computer and System Sciences, 38:195a 237, 1989.
[16] R. Kontchakov, C. Lutz, F. Wolter, and M. Zakharyaschev.
Temporalizing tableaux.
To appear in Studia Logica, 2003.
[17] C. Lutz, H. Sturm, F. Wolter, and M. Zakharyaschev.
Tableaux for temporal description logic with constant domains.
In Automated Reasoning (LNAI volume 2083), pages 121a136.
Springer Verlag, 2001.
[18] J.-J.
C. Meyer and W. van der Hoek.
Epistemic Logic for Computer Science and Artificial Intelligence, volume 41 of Cambridge Tracts in Theoretical Computer Science.
Cambridge University Press, 1995.
[19] C. Nalon, C. Dixon, and M. Fisher.
Resolution for synchrony and no learning: Preliminary report.
In Proceedings of the 8th International Workshop on Logic Language, Information and Computation WoLLICa2001, 2001.
[20] D. A. Plaisted and S. A. Greenbaum.
A StructurePreserving Clause Form Translation.
Journal of Symbolic Computation, 2(3):293a304, September 1986.
[21] A. S. Rao.
Decision Procedures for Propositional Linear-Time Belief-Desire-Intention Logics.
In M. Wooldridge, K. Fischer, P. Gmytrasiewicz, N. R. Jennings, J. P. MuEller, and M. Tambe, editors, IJCAI95 Workshop on Agent Theories, Architectures, and Languages, pages 102a118, MontreEal, Canada, August 1995.
[22] A. S. Rao and M. P. Georgeff.
Decision procedures for BDI logics.
Journal of Logic and Computation, 8(3):293a342, 1998.
[23] H. Sturm and F. Wolter.
A tableau calculus for temporal description logic: the expanding domain case.
Journal of Logic and Computation, 2002.
[24] P. Syverson.
Adding Time to a Logic of Authentication.
In Proceedings of the First ACM Conference on Computer and Communications Security, pages 97a 101.
ACM Press, 1993.
[25] R. van der Meyden.
Axioms for Knowledge and Time in Distributed Systems with Perfect Recall.
In Proceedings of the Ninth IEEE Symposium on Logic in Computer Science, pages 448a457, 1994.
[26] B. van Linder, W. van der Hoek, and J.J. Ch.
Meyer.
Formalising abilities and opportunities of agents.
Technical Report UU-CS-1998-08, Department of Computer Science,Utrecht University, Centrumgebouw Noord, Padualaan 14, De Uithof, 3584 CH Utrecht, 1998.
[27] P. Wolper.
The Tableau Method for Temporal Logic: An Overview.
Logique et Analyse, 110a111:119a136, June-Sept 1985.
[28] M. Wooldridge, C. Dixon, and M. Fisher.
A TableauBased Proof Method for Temporal Logics of Knowledge and Belief.
Journal of Applied Non-Classical Logics, 8(3):225a258, 1998.