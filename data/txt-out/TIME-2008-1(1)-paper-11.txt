Practical First-Order Temporal Reasoning Clare Dixon, Michael Fisher, Boris Konev and Alexei Lisitsa Department of Computer Science, University of Liverpool, Liverpool, United Kingdom {C.Dixon, M.Fisher, B.Konev, A.Lisitsa}@csc.liv.ac.uk  Abstract  and typically lead to undecidability problems if applied to liveness properties.
Thus, there is need for an approach that can tackle the verification of parameterised systems in a complete and decidable way, and also to tackle a wider class of system, incorporating asynchrony, communication delay, etc.
In this paper we introduce a new first-order temporal logic, FOTLX, that allows us to achieve this.
This logic combines previous work on the specification and verification of parameterised systems using monodic temporal logic [15] with more recent work on efficient temporal logics [11].
We show that the complexity of reasoning in FOTLX is lower than in unrestricted monodic first-order temporal logic.
The resulting formalism is new, and now allows us to describe, and verify properties of, a wide and important class of parameterised systems.
The verification of concurrent systems often comes down to the analysis of families of finite-state automata, for example of the form given in Fig.
1(a).
In describing such automata, both automata-theoretic (such as model checking) and logical approaches may be used.
Recently, a propositional, linear-time temporal logic with improved deductive properties has been introduced [10, 11], providing the possibility of practical deductive verification in the future.
The essence of this approach is to provide constraints between key propositions.
These constraints state that exactly one proposition from an subset of propositions can be true at any moment in time.
Thus, the automaton given in Fig.
1(a) can be described by the clauses given in Fig.
1(b), which are implicitly in the scope of a ' ' ('always in the future') operator.
Here ' g' is a temporal operator denoting 'at the next moment' and 'start' is a temporal operator which holds only at the initial moment in time.
The inherent assumption is that at any moment in time exactly one of sa , sb , st or sw holds.
With improved complexity results for such logics then the properties of any finite collection of such automata can be tractably verified using this propositional exactly-one temporal logic [10].
This naturally leads to the question of whether the exactly-one approach can be extended to first-order tem-  In this paper we consider the specification and verification of infinite-state systems using temporal logic.
In particular, we describe parameterised systems using a new variety of first-order temporal logic that is both powerful enough for this form of specification and tractable enough for practical deductive verification.
Importantly, the power of the temporal language allows us to describe (and verify) asynchronous systems, communication delays and more complex liveness and fairness properties.
These aspects appear difficult for many other approaches to infinite-state verification.
1.
Introduction The verification of infinite-state systems, particularly parameterised systems comprising of arbitrary numbers of identical processes, is increasingly important.
Practical problems of an open, distributed nature often fit into this model.
In assessing the reliability of these systems, formal verification is clearly desirable and so several approaches have been developed.
Two of the most popular are model checking for parameterised and infinite state-systems [1, 2] and constraint based verification using counting abstractions [8, 9, 13], but both suffer problems.
Within the model checking approach, formulae are translated into a B uchi transducer.
Techniques from regular model checking are then used to search for models.
This approach has been applied to several algorithms verifying safety properties and some liveness properties.
However, the logic LTL(MSO), considered in [1], is not recursively enumerable; so regular model checking is incomplete.
Constraint-based approaches [9] provide complete procedures for checking safety properties of broadcast protocols.
However, these approaches have theoretically non-primitive recursive upper bounds for decision procedures (although they work well for small examples), are not suitable (or, have not been used) for asynchronous systems with delayed broadcast, 1  model of time).
The signature of FOTL (without equality and function symbols) consists of a countably infinite set of variables x0 , x1 , .
.
.
, a countably infinite set of constants c0 , c1 , .
.
.
, a non-empty set of predicate symbols P , P0 , .
.
.
, each with a fixed arity >= 0, the propositional operators [?
], !, [?
], the quantifiers [?
]xi and [?
]xi , and the temporal oper('always in the future'),  ('eventually in the fuators ture'), g ('at the next moment'), and U ('until').
The set of formulae of FOTL is defined as follows: [?]
is a FOTL formula; if P is an n-ary predicate symbol and t1 , .
.
.
, tn are variables or constants, then P (t1 , .
.
.
, tn ) is an atomic FOTL formula; if ph and ps are FOTL formulae, then so are !ph, ph [?]
ps, [?
]xph, [?
]xph, ph, ph, gph, and ph U ps.
We also use [?
], [?
], and = as additional operators, defined using [?
], !, and [?].
Free and bound variables of a formula are defined in the standard way, as well as the notions of open and closed formulae.
Given a formula ph, we write ph(x1 , .
.
.
, xn ) to indicate that all the free variables of ph are among x1 , .
.
.
, xn .
As usual, a literal is either an atomic formula or its negation.
Intuitively, FOTL formulae are interpreted in first-order temporal structures which are sequences M of worlds, M = M0 , M1 , .
.
.
with truth values in different worlds being connected via temporal operators.
More formally, for every moment of time n >= 0, there is a corresponding first-order structure, Mn = hD, In i, where D is a non-empty set and In is an interpretation of predicate and constant symbols over D. We require that the interpretation of constants is rigid.
Thus, for every constant c and all moments of time i, j >= 0, we have Ii (c) = Ij (c).
A (variable) assignment a is a function from the set of individual variables to D. We denote the set of all assignments by V. The truth relation Mn |=a ph in a structure M, is defined inductively on the construction of ph, see Fig.
2 for details (the semantics of Booleans is standard and is omitted from the figure).
M is a model for a formula ph (or ph is true in M) if, and only if, there exists an assignment a such that M0 |=a ph.
A formula is satisfiable if, and only if, it has a model.
A formula is valid if, and only if, it is true in any temporal structure M under any assignment a.  sb  st  sa  sw  1.
2.
3.
4.
5.  start = st st = g(st [?]
sa ) sb = gst sa = gsw sw = g(sw [?]
sb )  Figure 1.
Finite-State Automaton (a) and its Propositional Temporal Specification (b)  poral logics and, if so, whether a form of tractability still applies.
In such an approach, we can consider infinite numbers of finite-state automata (initially, all of the same structure).
Previously, we have shown that FOTL (without explicit exactly-one constraints) can be used to elegantly (but with inherent complexity) specify such a system, simply by assuming the argument to each predicate represents a particular automaton [15].
Thus, in the following sa (x) is true if automaton x is in state sa : 1.
2.
3.
4.
5.  start = [?
]x.st (x) [?]x.
(st (x) = g(st (x) [?]
sa (x))) [?]x.
(sb (x) = gst (x)) [?]x.
(sa (x) = gsw (x)) [?]x.
(sw (x) = g(sw (x) [?]
sb (x)))  The contributions of this paper are the introduction of an exactly-one version of monodic first-order-temporal logic, the related complexity result and its application to a sophisticated process model.
This allows us to not only specify broadcast protocols between synchronous components [13], but also to specify asynchronous systems with communication delays.
We show that such a process model can be faithfully represented in FOTLX, making it possible to practically verify its properties.
Thus, in summary, we here tackle the problem of specifying and verifying parameterised systems by introducing a new temporal logic formalism.
This logic not only allows us to describe, and prove properties about, a wider range of system, but also allows us to do so with improved complexity over previous temporal logic approaches.
2.2.
Monodicity and Monadicity  2.
FOTLX  The set of valid formulae of FOTL is not recursively enumerable.
Furthermore, it is known that even "small" fragments of FOTL, such as the two-variable monadic fragment (where all predicates are unary), are not recursively enumerable [24, 20].
However, the set of valid monodic formulae is known to be finitely axiomatisable [26].
2.1.
First-Order Temporal Logic The language of First-Order (descrete, linear time) Temporal Logic, FOTL, is an extension of classical first-order logic by temporal operators for a discrete linear model of time (isomorphic to , that is, the most commonly used  Definition 1 An FOTL-formula ph is called monodic if, and only if, any subformula of the form T ps, where T is one of  N  2  Mn |=a true Mn |=a start Mn |=a P (t1 , .
.
.
, tm )  iff iff  Mn |=a [?
]xph  iff  Mn |=a [?
]xph  iff  Mn |=a gph Mn |=a ph  iff iff  Mn |=a ph Mn |=a (ph U ps)  iff iff  Mn 6|=a false n=0 hIna (t1 ), .
.
.
Ina (tm )i [?]
In (P ), where Ina (ti ) = In (ti ), if ti is a constant, and Ina (ti ) = a(ti ), if ti is a variable Mn |=b ph for every assignment b that may differ from a only in x Mn |=b ph for some assignment b that may differ from a only in x Mn+1 |=a ph there exists m >= n such that Mm |=a ph for all m >= n, Mm |=a ph there exists m >= n, such that Mm |=a ps and, for all i [?]
, n <= i < m implies Mi |=a ph Mn |=a (ph U ps) or Mn |=a ph.
N  Mn |=a (ph W ps)  iff  of monadic monodic first-order temporal logic, makes this approach difficult to use for larger applications [16, 15].
2.3.
Exactly-One Restrictions An additional restriction we make to the above logic involves implicit exactly-one constraints over predicates.
Such restrictions were introduced into propositional temporal logics in [10], where the correspondence with B uchi automata was described, and generalised in [11].
In both cases, the decision problem is of much better (polynomial even in the first case) complexity than that for the standard, unconstrained, logic.
However, in these papers only propositional temporal logic was considered.
We now add such an exactly-one constraint to monodic FOTL.
The set of predicate symbols P = {P0 , P1 , .
.
.
}, is now partitioned into a set of exactly-one subsets, X1 , X2 , .
.
., Xn , with one unconstrained set N such that 1. all Xi are disjoint with each other, 2.
N is disjoint with every Xi , n [ Xj [?]
N , and 3.
P = j=1  4. for each Xi , exactly one predicate within Xi is satisfied (for any element of the domain) at any moment in time.
Figure 2.
FOTL semantics  Example 1 Consider two exactly-one sets, X1 = {P1 , P2 } and X2 = {P4 , P7 , P8 }.
Then for any element of the domain, a, exactly one of P1 (a) or P2 (a) must be satisfied and exactly one of P4 (a), P7 (a) or P8 (a) must be satisfied.
g, ,  (or ps1 T ps2 , where T is one of U , W ), contains at most one free variable.
We note that the addition of either equality or function symbols to the monodic fragment generally leads to the loss of recursive enumerability [26, 7, 18].
Further, even with its recursive enumerability, monodic FOTL is generally undecidable.
To recover decidability, the easiest route is to restrict the first order part to some decidable fragment of firstorder logic, such as the guarded, two-variable or monadic fragments.
We here choose the latter, since monadic predicates fit well with our intended application to parameterised systems.
Recall that monadicity requires that all predicates have arity of at most '1'.
Thus, we use monadic, monodic FOTL [6].
The resolution theorem-prover TeMP [21] provides a a practical approach to proving monodic temporal formulae.
In the past, TeMP has been successfully applied to problems from several domains [16], in particular, to examples specified in the temporal logics of knowledge (the fusion of propositional linear-time temporal logic with multi-modal S5).
From this work it is clear that monodic first-order temporal logic is an important tool for specifying complex systems.
However, it is also clear that the complexity, even  2.4.
Normal Form Every monodic FOTLX formula can be translated to a normal form in a satisfiability preserving way using a renaming and unwinding technique which substitutes nonatomic subformulae and replaces temporal operators by their fixed point definitions as described, for example, in [14].
A monodic temporal problem in Divided Separated Normal Form (DSNF) [6] is a quadruple hU, I, S, Ei, where: 1. the universal part, U, is a finite set of arbitrary closed first-order formulae; 2. the initial part, I, is, again, a finite set of arbitrary closed first-order formulae; 3. the step part, S, is a finite set of step clauses of the form P1 (x) [?]
.
.
.
Pk (X) = gQ1 (x) [?]
.
.
.
[?]
Ql (x), where Pi and Qj are unary predicate symbols; 3  4. the eventuality part, E, is a finite set of eventuality clauses of the form L(x), where L(x) is a unary literal.
Proof Similar to [3], Proposition 6.2.9.
  Proof [of Theorem 1, Sketch] For simplicity of presentation, we assume the formula contains no propositions.
Satisfiability of a monodic FOTL formula is equivalent to a property of the behaviour graph for the formula, checkable in time polynomial in the product of the number of different predicate colours and the size of the graph, see [6], Theorem 5.15.
For unrestricted FOTL formulae, the size of the behaviour graph is double exponential in the number of predicates.
We estimate now the size of the behaviour graph and time needed for its construction for FOTLX formulae.
A predicate colour, g, is a set of unary literals such that for every predicate P (x) from the set of all predicates X1 [?].
.
.
, [?
]Xn [?
]N , either P (x) or !P (x) belongs to g. Let G be a set of predicate colours and r be a map from the set of constants, const(P), to G. A pair hG, ri is called a colour scheme.
Nodes of the behaviour graph are colour schemes.
Na Clearly, there are no more than 2O(N1 *N2 *...*Nn *2 ) different colour schemes.
However, not every colour scheme is a node of the behaviour graph: a colour scheme C is a node if, and only if, a monadic formula of first-order (non-temporal) logic, constructed from the given FOTLX formula and the colour scheme itself, is satisfiable (for details see [6]).
A similar first-order monadic condition determines which nodes are connected with edges.
So, the size of the formula is polynomial.
By Lemma 3, satisfiability of monadic first-order formulae can be decided in determinisNa tic 2O(N1 *N2 *...*Nn *2 ) time.
Overall, the behaviour graph, representing all possible models, for an FOTLX formula can be constructed in Na 2O(N1 *N2 *...*Nn *2 ) time.
  In what follows, we will not distinguish V between a finite set of formulae X and the conjunction X of formulae within the set.
With each monodic temporal problem, we associate the formula I [?]
U [?]
[?
]xS [?]
[?]xE.
Now, when we talk about particular properties of a temporal problem (e.g., satisfiability, validity, logical consequences etc) we mean properties of the associated formula.
To translate a formula into the normal form, we recursively rename each innermost open subformula x(x), whose main connective is a temporal operator, by Px (x), where Px(x) is a new unary predicate, and rename each innermost closed subformula z, whose main connective is a temporal operator, by pz , where pz is a new propositional variable.
The translation linearly increases the size of the formula--full details can be found e.g.
in [14].
While renaming introduces new, unconstrained predicates and propositions, practical problems stemming from verification are nearly in the normal form, see Section 3.
2.5.
Complexity First-order temporal logics are notorious for being of a high complexity.
Even decidable sub-fragments of monodic first-order temporal logic can be too complex for practical use.
For example, satisfiability of monodic monadic FOTL logic is known to be EXPSPACE-complete [19].
However, imposing exactly-one restrictions we obtain better complexity bounds.
Theorem 1 Satisfiability of monodic monadic FOTLX formulae (in the normal form) can be decided in Na 2O(N1 *N2 *...*Nn *2 ) time, where N1 ,.
.
.
, Nn are cardinalities of the sets of exactly-one predicates, and Na is the cardinality of the set of the unconstrained predicates.
3.
Parameterised Systems Next we present a model suitable for the specification of both synchronous and asynchronous systems (protocols) with (possibly) delayed broadcast and give its faithful translation into FOTLX.
This shows that the logic developed does indeed achieve what we intended.
In addition, given the improved complexity results of the previous section, we believe this approach provides a route towards the practical verification of temporal properties of such infinite state systems.
A parameterised finite state machine based model, suitable for the specification and verification of protocols over arbitrary numbers of processes was defined in [13, 8].
Essentially, this uses a family of identical, and synchronously executing, finite state automata with a rudimentary form of communication: if one automaton makes a transition (an action) a, then it is required that all other automata simultaneously make a complementary transition (reaction) a.
In [15] we translated this automata model into monodic FOTL  Corollary 2 If the number, n, of sets of exactly-one predicates and the cardinality, Na , of the set of unconstrained predicates is fixed, satisfiability of FOTLX formulae can be decided in deterministic exponential time (which is an improvement compared to the EXPSPACE complexity of the general case).
Before we sketch the proof of this result, we show how the exactly-one restrictions influence the complexity of the satisfiability problem for monadic first-order (non-temporal) logic.
Lemma 3 Satisfiability of monadic first-order formulae can be decided in NTime(O(m * N1 * N2 * .
.
.
* Nn * 2Na )), where m is the length of the formula, and N1 ,.
.
.
, Nn , Na are as in Theorem 1.
4  An element G [?]
QMG x (S [?]
{idle})n x E is said to be a global configuration of the machine.
A run of a global machine MG is a possibly infinite sequence hs1 , s 1 , E1 i .
.
.
.
.
.
hsi , s i , Ei i .
.
.
.
.
.
of global configurations of MG satisfying the properties (1)-(6) listed below.
In this formulation we assume si = hsi1 , .
.
.
, sin i and s i = hs1i , .
.
.
, sni i.  and used automated theorem proving in that logic to verify parameterised cache coherence protocols [9].
The model assumed not only synchronous behaviour of the communicating automata, but instantaneous broadcast.
3.1.
Process Model We now describe both the asynchronous model, and the delayed broadcast approach.
Definition 2 (Protocol) A hQ, I, S, t i, where  protocol,  P  is  a  1. s1 [?]
I n ("initially all automata are in initial states"); 2.
E1 = [?]
tuple  i  ("initially there are no messages transit");  3.
[?]i.
hs , s , si+1 i [?]
tMG can fire");  * Q is a finite set of states;  i  ("an arbitrary automaton  4.
[?
]a [?]
SM .
[?]i.
[?]j.
((sji = a) = [?]k.
[?
]l >= i.
(skl = a)) ("delivery to all participants is guaranteed");  * I [?]
Q is a set of initial states; * S = SL [?]
SM [?]
SM , where  5.
[?
]a [?]
SM .
[?]i.
[?]j.
[(sji = a) = (a [?]
Ei ) [?]
[?]k.
ski = a)] ("one can receive only messages kept by the environment, or sent at the same moment of time ")  SL is a finite set of local actions; SM is a finite set of broadcast actions, i.e.
"send a message";  In order to formulate further requirements we introduce the following notation:  SM = {s | s [?]
SM } is the set of broadcast reactions, i.e.
"receive a message";  Senti = {a [?]
SM | [?]j.
sji = a} Delivered k =   [?
]i <= k. (a [?]
Senti ) [?]
a [?]
SM ([?]l.
(i < l < k) - a 6[?]
Sentl ) [?]
([?]j.[?]l.
(i <= l <= k) [?]
(sjl = a))  * t [?]
Q x S x Q is a transition relation that satisfies the following property [?
]s [?]
SM .
[?
]q [?]
Q.
[?
]q ' [?]
Q. hq, s, q ' i [?]
t i.e., "readiness to receive a message in any state".
Further, we define a notion of global machine, which is a set of n finite automata, where n is a parameter, each following the protocol and able to communicate with others via (possibly delayed) broadcast.
To model asynchrony, we introduce a special automaton action, idle 6[?]
S, meaning the automaton is not active and so its state does not change.
At any moment an arbitrary group of automata may be idle and all non-idle automata perform their actions in accordance with the transition function t ; different automata may perform different actions.
Then, the final requirement the run should satisfy is 6.
[?]i.
Ei+1 = (Ei [?]
Senti ) - Deliveredi  This process model is quite expressive, capturing many interesting and useful systems.
In particular, it is rich enough to allow us to describe, for example, such diverse systems as cache coherence protocols, multi-agent swarms, and distributed atomic commitment protocols including the twoand three-phase commit protocols [17, 25] and their modifications [5, 4].
For the sake of space, however, we will only consider a simple asynchronous distributed consensus example, called the FloodSet protocol, in Section 3.3  Definition 3 (Asynchronous Global Machine) Given a protocol, P = hQ, I, S, t i, the global machine MG of dimension n is the tuple hQMG , IMG tMG , Ei, where * QMG = Qn  3.2.
Temporal Translation  * IMG = I n Given a protocol P = hQ, I, S, t i, we define its translation to FOTLX as follows.
For each q [?]
Q, introduce a monadic predicate symbol Pq and for each s [?]
S [?]
{idle} introduce a monadic predicate symbol As .
For each s [?]
SM we introduce also a propositional symbol ms .
Intuitively, elements of the domain in the temporal representation will represent exemplars of finite automata, and the formula Pq (x) is intended to represent "automaton x is in state q".
The formula As (x) is going to represent "automaton x performs action s".
Proposition ms will denote the fact  * tMG [?]
QMG x (S [?]
{idle})n x QMG is a transition relation that satisfies the following property hhs1 , .
.
.
, sn i, hs1 , .
.
.
sn i, hs'1 , .
.
.
, s'n ii [?]
tMG iff [?
]1 <= i <= n. ((si 6= idle = hsi , si , s'i i [?]
t )[?]
(si = idle = si = s'i )) .
* E = 2SM is a communication environment, that is a set of possible sets of messages in transit.
5  "message s is in transit" (i.e.
it has been sent but not all participants have received it).
Because of the intended meaning we define two exactly-one sets: X1 = {Pq | q [?]
Q} and X2 = {As | s [?]
S [?]
{idle}}.
All other predicates belong to the set of unconstrained predicates.
We define the temporal translation of P, called TP , as a conjunction of the formulae in Fig.
3.
Note that, in order to define the temporal translation of requirement (6) above, (on the dynamics of environment updates) we introduce the unary predicate symbol Receiveds for every s [?]
Sm .
When an automaton a receives message s, Receiveds (a) becomes true.
When Receiveds becomes true for all x, the message is delivered and is not in transit any more, that is, ms becomes false.
We now consider the correctness of the temporal translation.
This translation of protocol P is faithful in the following sense.
i0  i1  0  1  0 o0  o1  0  1 1  Figure 4.
Asynchronous FloodSet Protocol Process.
* the original protocol assumed instantaneous message delivery, while we allow arbitrary delays in delivery; and  Proposition 1 Given a protocol, P, and a global machine, MG , of dimension n, then any temporal model M1 , M2 , .
.
.
of TP with the finite domain c1 , .
.
.
cn of size n represents some run hs1 , s 1 , E1 i .
.
.
hsi , s i , Ei i .
.
.
of MG as follows: hhs1 , .
.
.
, sn i, hs1 , .
.
.
, sn i, Ei is i-th configuration of the run iff Mi |= Pq1 (c1 ) [?]
.
.
.
Pqn (cn ), Mi |= As1 (c1 ) [?]
.
.
.
Asn (cn ) and E = {s [?]
Sm | Mi |= ms } Dually, for any run of MG there is a temporal model of TP with a domain of size n representing this run.
* although the original protocol was designed to work in the presence of crash (or fail-stop) failures, we assume, for simplicity, that there are no failures.
Because of the absence of failures the protocol is simplified and, unlike the original, does not require "retransmission" of any value.
We will show later (in Section 3.5) how to include the case of crash failures in the specification (and verification).
Thus, the asynchronous FloodSet protocol is defined, informally, as follows.
Thus, given a parameterised system that fits into the above model, we can translate its specification (faithfully) into FOTLX.
* At the first round of computations, every process broadcasts its input bit.
3.3.
Example  * At every round the (tentative) output bit is set to the minimum value ever seen so far.
We here consider a variant of the FloodSet algorithm with alternative decision rule (in terms of [22], p.105) designed for solution of the Consensus problem.
The setting is as follows.
There are n processes, each having an input bit and an output bit.
The processes work asynchronously, run the same algorithm and use broadcast for communication.
(The process is described graphically in Fig.
4.)
The broadcast messages are guaranteed to be delivered, though possibly with arbitrary delays.
The goal of the algorithm is to eventually reach an agreement, i.e.
to produce an output bit, which would be the same for all processes.
It is required also that if all processes have the same input bit, that bit should be produced as an output bit.
The asynchronous FloodSet protocol we consider here is adapted from [22], the main differences being:  The correctness criterion for this protocol is that, eventually, the output bits of all processes will be the same (either '0' or '1').
Now we can specify the asynchronous FloodSet as a protocol hQ, I, S, t i, where: * Q = {i0 , i1 , o0 , o1 }; * I = {i0 , i1 }; * S = Sm [?]
Sm [?]
SL with Sm = {0, 1}, Sm = {0, 1}, SL = [?
]; and * the transition relation t = {hi0 , 0, o0 i, ho0 , 0, o0 i, ho0 , 1, o0 i, hi1 , 1, o1 i, ho1 , 0, o0 i, ho1 , 1, o1 i} .
3.4.
Verifying Properties of the Example  * the original protocol was synchronous, while our variant is asynchronous;  Now we have all the ingredients to perform the verification of parameterised protocols.
Given a protocol P, we 6  I.
Each automaton either performs one of the actions available in its state, or is idle: [[?]x.
Pq (x) - As1 (x) [?]
.
.
.
[?]
Ask (x) [?]
Aidle (x)], where {s1 , .
.
.
sk } = {s [?]
S | [?
]rhq, s, ri [?]
t }.
II.
Action effects (non-deterministic W actions): [[?
]xPq (x) [?]
As (x) - g hq,s,ri[?
]t Pr (x)] for all q [?]
S and s [?]
S.
[[?
]xPq (x) [?]
Aidle (x) - gPq (x)], for all q [?]
S III.
Effect of being idle: IV.
Initially there W are no messages in transit and all automata are in an initial state: start - [?
]x q[?
]I Pq (x).
V. All messages are eventually received (Guarantee of Delivery):  start - !ms for all s [?]
Sm and  [[?
]yAs (y) - [?
]xAs (x)], for all s [?]
Sm .
VI.
Only messages kept in the environment (in transit), or sent at the same moment of time can be received: [[?
]xAs (x) - ms [?]
[?
]yAs (y)] for all s [?]
Sm .
VII.
Finally, for all s [?]
Sm , we have the conjunction of the following formulae specifying the communication model: 1. start - [?]x.
!Receiveds (x) 2.
3.
[[?]x.
(As (x) [?]
![?]y.
Receiveds (y)) - gReceiveds (x)] [[?]x.
(Receiveds (x) [?]
![?]y.
Receiveds (y) - gReceiveds (x)]  5.
[[?]x.
(!
(As (x) [?]
Receiveds (x)) [?]
![?]y.
Receiveds (y)) - g!Receiveds (x)] [[?]x.
Receiveds (x) - g!ms ]  6.
[[?]x.
As (x) [?]
![?]y.
Receiveds (y) - gms ]  7.
[![?]x.
As (x) [?]
![?]y.
Receiveds (y) - (ms - gms )]  4.
Figure 3.
Temporal Specification of Abstract Protocol Structure.
can translate it into a temporal formula TP .
For the temporal representation, kh, of a required correctness condition, we then check whether TP - kh is a valid temporal formula.
If it is valid, then the protocol is correct for all possible values of the parameter (sizes).
Correctness conditions can, of course, be described using any legal FOTLX formula.
For example, for the above FloodSet protocol(s) we have a liveness condition to verify that eventually all processes will agree on '0' or will agree on '1': ([?]x.
o0 (x) [?]
[?]x.
o1 (x)).
Explicit bounds on delivery.
In the basic mode, no explicit bounds on delivery time are given.
To introduce bounds one has to replace the "Guarantee of Delivery" axiom by: [[?]y.
As (y) - [?]x.
As (x) [?]
gAs (x) [?]
.
.
.
[?]
gn As (x)] for all s [?]
Sm and some n (representing the maximal delay).
In [15], we considered a deterministic model with instantaneous delivery (that is, the explicit bounds case with n = 0).
3.5.
Variations of the model  Finite bounds on delivery.
One may replace the "Guarantee of Delivery" axiom with (for all s [?]
Sm ) the following: [[?]y.
As (y) - [?]x.
Receiveds (x)]  The above model allows us to introduce various extensions and the corresponding version of Proposition 1 still holds.
Guarded actions.
One can also extend the model with guarded actions, where actions can be performed depending on global conditions in global configurations.
Determinism.
The basic model allows non-deterministic actions.
To specify the case of deterministic actions only, one should replace the "Action Effects" axiom in Fig.
3 by the following variant (for all hq, s, ri [?]
t ):  Crashes.
One may replace the "Guarantee of Delivery" axiom by an axiom stating that only the messages sent by normal (non-crashed) participants will be delivered to all  [[?]x.
Pq (x) [?]
As (x) - gPr (x)] 7  participants.
(See [15] for examples of such specifications in a FOTL context.)
Returning to the FloodSet protocol, for example, one may consider a variation of the asynchronous protocol suitable for resolving the Consensus problem in the presence of crash failures.
We can modify the above setting as follows.
Now, processes may fail and, from that point onward, such processes send no further messages.
Note, however, that the messages sent by a process in the moment of failure may be delivered to an arbitrary subset of the non-faulty processes.
Then the FloodSet protocol considered above is modified by adding the following rule:  16th International Conference on Computer Aided Verification (CAV), volume 3114 of LNCS, pages 348-360.
Springer, 2004.
[2] P. A. Abdulla, B. Jonsson, A. Rezine, and M. Saksena.
Proving Liveness by Backwards Reachability.
In Proc.
CONCUR, volume 4137 of LNCS, pages 95-109.
Springer, 2006.
[3] E. Borger, E Gradel, and Yu.
Gurevich.
The Classical Decision Problem.
Springer, 1997.
[4] D. Chkliaev, J. Hooman, and P. van der Stock.
Mechanical Verification of Transaction Processing Systems.
In Proc.
3th International Conference on Formal Engineering Methods (ICFEM 2000), pages 89-97, IEEE, 2000.
[5] D. Chkliaev, P. van der Stock, and J. Hooman.
Mechanical verification of a Non-Blocking Atomic Commitment Protocol.
In Proc.
ICDCS Workshop on Distributed System Validation and Verification, pages 96-103, IEEE, 2000.
[6] A. Degtyarev, M. Fisher, and B. Konev.
Monodic Temporal Resolution.
ACM Transactions on Computational Logic, 7(1):108-150, January 2006.
[7] A. Degtyarev, M. Fisher, and A. Lisitsa.
Equality and Monodic First-Order Temporal Logic.
Studia Logica, 72(2):147-156, Nov. 2002.
[8] G. Delzanno.
Automatic Verification of Parameterized Cache Coherence Protocols.
In Proc.
12th International Conference on Computer Aided Verification (CAV), volume 1855 of LNCS, pages 53-68, 2000.
[9] G. Delzanno.
Constraint-Based Verification of Parametrized Cache Coherence Protocols.
Formal Methods in System Design, 23(3):257-301, 2003.
[10] C. Dixon, M. Fisher, and B. Konev.
Is There a Future for Deductive Temporal Verification?
In Proc.
International Symposium on Temporal Representation and Reasoning (TIME), pages 11-18, 2006.
IEEE CS Press.
[11] C. Dixon, M. Fisher, and B. Konev.
Tractable Temporal Reasoning.
In Proc.
International Joint Conference on Artificial Intelligence (IJCAI) pages 318-323.
AAAI Press, 2007.
[12] E. A. Emerson.
Temporal and Modal Logic.
In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 996-1072.
Elsevier, 1990.
[13] J. Esparza, A. Finkel, and R. Mayr.
On the Verification of Broadcast Protocols.
In Proc.
14th IEEE Symposium on Logic in Computer Science (LICS), pages 352-359.
IEEE CS Press, 1999.
[14] M. Fisher, C. Dixon, and M. Peim.
Clausal Temporal Resolution.
ACM Transactions on Computational Logic, 2(1):12-56, Jan. 2001.
[15] M. Fisher, B. Konev, and A. Lisitsa.
Practical Infinite-state Verification with Temporal Reasoning.
In Verification of Infinite State Systems and Security.
IOS Press, January 2006.
[16] M.-C. F. Gago, U. Hustadt, C. Dixon, M. Fisher, and B. Konev.
First-Order Temporal Verification in Practice.
Journal of Automated Reasoning, 34(3):295-321, 2005.
[17] J.
Gray.
Notes on Database Operating Systems.
Operating Systems: An Advanced Course, volume 60 of LNCS, pages 393-481.
Springer, 1978.
[18] I. Hodkinson.
Monodic Packed Fragment with Equality is Decidable.
Studia Logica, 72(2):185-197, 2002.
* At every round (after the first), a process broadcasts any value the first time it sees it.
The goal of the algorithm also has to be modified, so only non-faulty processes are required to eventually reach an agreement:   ([?]x.
Non-faulty(x) - o0 (x))[?]
.
([?]x.
Non-faulty(x) - o1 (x)) The above rules can be easily encoded in the model.
4.
Concluding Remarks In this paper, we have developed an exactly-one version of FOTL, providing: its syntax and semantics; conditions for decidability; and detailed complexity of the decision procedure.
As well as being an extension and combination of the work reported in both [6] and [11], this work forms the basis for tractable temporal reasoning over infinite state problems.
In particular, we have shown how the logic can capture quite a strong model of parameterised systems, incorporating more complex aspects of asynchrony and communication, and is also able to verify more sophisticated liveness and fairness properties.
Thus, in contrast to many other approaches [23, 9, 2], not only safety, but also liveness and fairness properties, can be verified through (complete) automatic deductive verification.
Finally, our future work involves exploring further the framework described in this paper, in particular the development of an implementation to prove properties of protocols in practice.
Further, we would like to see if we can extend the range of systems we can tackle beyond the monodic fragment.
We also note that some of the variations we might desire to include in Section 3.5 can lead to undecidable fragments.
However, for some of these variations, we have correct although (inevitably) incomplete methods, see [15].
We aim to explore these boundaries further.
References [1] P. A. Abdulla, B. Jonsson, M. Nilsson, J. d'Orso, and M. Saksena.
Regular Model Checking for LTL(MSO).
In Proc.
8  [19] I. Hodkinson, R. Kontchakov, A. Kurucz, F. Wolter, and M. Zakharyaschev.
On the Computational Complexity of Decidable Fragments of First-Order Linear Temporal Logics.
In Proc.
International Symposium on Temporal Representation and Reasoning (TIME), pages 91-98.
IEEE CS Press, 2003.
[20] I. Hodkinson, F. Wolter, and M. Zakharyashev.
Decidable Fragments of First-Order Temporal Logics.
Annals of Pure and Applied Logic, 106(1-3): 85-134, 2000.
[21] U. Hustadt, B. Konev, A. Riazanov, and A. Voronkov.
TeMP: A Temporal Monodic Prover.
In Proc.
2nd International Joint Conference on Automated Reasoning (IJCAR), volume 3097 of LNAI, pages 326-330.
Springer, 2004.
[22] N. Lynch.
Distributed Algorithms.
Morgan Kaufmann Publishers, San Mateo, CA, 1996.
[23] M. Maidl.
A Unifying Model Checking Approach for Safety Properties of Parameterized Systems.
In volume 2102 of LNCS, pages 311-323.
Springer, 2001.
[24] S. Merz.
Decidability and Incompleteness Results for FirstOrder Temporal Logic of Linear Time.
Journal of Applied Non-Classical Logics, 2:139-156, 1992.
[25] D. Skeen.
Nonblocking Commit Protocols.
In Proc.
SIGMOD International Conference on Management of Data, pages 133-142, ACM, 1981.
[26] F. Wolter and M. Zakharyaschev.
Axiomatizing the Monodic Fragment of First-Order Temporal Logic.
Annals of Pure and Applied Logic, 118(1-2):133-145, 2002.
9