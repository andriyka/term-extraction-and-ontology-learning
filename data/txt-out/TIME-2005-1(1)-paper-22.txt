Temporal Query Languages Expressive Power: TL vs. T- WHILE Nicole Bidoit, Matthieu Objois Laboratoire de Recherche en Informatique L.R.I.
UMR 8623 CNRS Batiment 490 - UniversitAS Paris Sud 91405 Orsay Cedex - FRANCE {bidoit,objois}@lri.fr  Abstract We investigate the expressive power of implicit temporal query languages.
The initial motivation was redZning the results of [1] and enrich them with comparison to TL [17].
Thus, we address two classes of temporal query languages: TL-like languages based on TL and T- WHILE-like languages based on WHILE.
We provide a two-level hierarchy (w.r.t.
expressive power) for these temporal query languages.
One of the contributions solves an open problem: the relative expressivity of TL and T- FIXPOINT [1, 11].
1  Introduction  In this paper we focus our attention on temporal databases and temporal query languages.
Two different representations of time are classically considered: the implicit framework dedZnes a temporal database as a dZnite sequence of instances; in the explicit framework, tuples in relations are timestamped.
It is now well-known that as far as representing time is concerned, the implicit and explicit representations of time are equally expressive.
However, as far as temporal query languages are concerned, the choice between implicit and explicit frameworks leads to different languages w.r.t.
expressive power.
With implicit time, the linear temporal logic TL and its extensions are the basic formalisms underlying query languages [8, 7].
When time is explicitly represented, queries are specidZed using the language TS - FO (or extensions) which is simply the relational calculus FO with timestamps.
As pointed out in [7], temporal logic and their extensions are especially attractive as query languages for temporal databases because of their simplicity and computational advantages.
Indeed, because the references to time are hidden, queries are formulated in an abstract, representationindependent way.
As far as computational complexity is concerned, [15] shows that the satisdZability problem for propositional TL is PSPACE-complete (whereas the same  problem for dZrst-order theory is non elementary [13]).
The work of [1] (see also [5]) gives new insight to the relative expressive power of TL and TS - FO as query languages: surprisingly enough1, dZrst order TL is strictly less expressive than TS - FO.
Subsequent research work [1, 11, 4] investigate query languages more expressive than TL.
More recently, [16] has proved (based on the techniques of [5]) that TS - FO is strictly more expressive than any dZxed-dimensional dZrstorder temporal logic.
This paper focuses on the implicit languages introduced in [1] where the authors investigate a classical way to extend FO in order to build implicit temporal languages.
These languages rely on traditional imperative mecanisms namely assignements, iterations (while statements) and temporal moves.
These languages further denoted T- WHILE-like languages are also extensions of WHILE introduced in [6] to capture recursive queries in the static framework.
In this paper, we address another class of temporal query languages called TL-like languages.
These languages can be viewed as extensions of TL [17, 11] or alternatively as extensions of FO with dZxpoint formulas [14, 6, 9, 10, 2].
[1] provides an expressive power hierarchy of temporal languages including TL, TS - FO, T- WHILE-like languages and their explicit counterparts.
Surprisingly enough [1, 11] do not address TL-like languages in their expressive power comparative study.
The work presented in this paper aims at contributing to the following open problem pointed out in [7]: aFixpoint temporal logic TL has been extensively used in program veridZcation, although only in the propositional case.
The dZrst order version of TL remains to be studied.
In particular, its relationship to T- WHILE (...) needs to be elucidated.a One of the main contributions of our paper is to enrich the expressive power hierarchy of [1] showing that the dZrst order indZationary extension of TL is strictly less expressive than T- FIXPOINT 2 which is roughly the indZationary TWHILE -like language with some non-indZationary features.
1 This 2 In  result stands in contrast with the propositional case.
the paper, this language is renamed T- WHILE 	.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  We also show that T- FIXPOINT is equivalent to the non indZationary T- WHILE which entails that T- FIXPOINT is not PTIME as claimed in [1].
The expressive power results presented in this paper shed new light on the impact of the features of the two classes of languages.
In the static case, each result holding for a WHILE -like language also holds for its FO dZxpoint counterpart.
Surprisingly enough, this symmetry is broken in the temporal framework: for instance, the indZationary TWHILE -like language with some non-indZationary features (already mentionned above as T- FIXPOINT) is strictly more expressive than its TL-like counterpart.
Another interesting impact of our results is that they highlight the frontier between querying static databases and querying temporal databases.
More precisely, part of our results relies on the assumption that the temporal instances under consideration are composed of at least two states as opposed to static ones composed of a single state.
The paper is organized as follows.
Section 2 is devoted to preliminaries and section 3 to the presentation of the implicit temporal languages whose comparative expressive power are investigated in section 4.
We conclude the paper in section 5 by discussing our results and addressing some open problems.
2  Preliminaries  We assume the reader familiar with both dZrst-order logic and temporal logic TL and with the usual dedZnitions of relation schema, database schema and instances.
We denote the arity of a relation schema  by  .
In the whole paper, we consider the database schemas  A"  fififi  and  A" fififi  and we assume a unique domain .
An implicit temporal instance over , is a dZnite sequence 	A"  fififi 	 of (dZnite) instances over .
For each    fi, 	 is called the state of at time point  .
The instance of the relation schema  at time point   is denoted by  fi.
The active domain of , denoted  , is the union of the active domains of the states 	 .
The well known aunsafe querya problem is solved here by restricting variables to range over the active domain of the input temporal database.
In the paper,  	A"  fififi 	 is a temporal instance of size  over ,  represents an unspecidZed tuple of variables whose arity is clear from the context, and  is a valuation of  ranging over  .
Let   A"  fififi  be a temporal instance of size  over  .
Merging the the database schema where instances and  leads to the instance denoted  over the , dedZned as A"  fififi  where for all database schema    fi: 1) for all   fi,  fi   	 fi  and 2) for all   fi,  fi    fi .
whose We denote A any temporal instance over states are all empty.
FO          fi  fi  fi    fi        3  Temporal query languages  In this section, we revisit the specidZcation of some of the languages introduced in [17, 1, 11] in order to better identify their features, and we also introduce new languages.
We proceed by introducing two classes of implicit temporal query languages, each one sharing the same paradigm: TL -like languages presented in section 3.1 are both extensions of TL and of FO dZxpoint and T- WHILE-like languages presented in section 3.2 are temporal extensions of WHILE.
Languages in a class differ by some features (e.g.
indZationism vs. non indZationism) leading to alternative query languages.
We now proceed to the presentation of the languages.
The main expressivity results are developed and discussed in section 4.
3.1  TL -like  languages  All query languages presented in this section are based on the TL language, introduced in the propositional case by Vardi in [17] and extended to the dZrst order case by Herr in [11].
These languages can also be seen as temporal extensions of the static query language FO dZxpoint, which has a long history: it has dZrst been considered over indZnite stuctures in [14], and afterward studied in the dZnite case (which is relevant to the database context) in [6, 9, 10, 12].
Syntax The syntax of TL-like languages over the is obtained by the formation rules for database schema FO , together with the following additional rules: if  is a formula then    and  are formulas.
suppose that  .
We call auxiliary schema any schema in .
We dedZne a (simultaneous) inductive operator for the auxiliary schemas.
Let A"  fififi  be formulas 3 .
Each formula fi has as over the database schema many free variables as the arity of  .
For all   fi, the -expression A"  fififi  fiAVA"  fififi  fi  can be used like a relation schema to build a formula A"  fififi  fiAVA"  fififi  fi .
The schemas A"  fififi  (resp.
AVA"  fififi  ) are called the checked (resp.
unchecked) auxiliary schemas of the -expression.
Note that -expressions can be nested.
Whether an auxilliary schema is checked or unchecked has an impact on the semantics of the language (see below).
Intuitively, the former (resp.
the latter) enforces the instance of the auxilliary schema to be used (resp.
ignored) when computing the semantics of a -expression.
          fi  E XAMPLE 3.1 Let  (resp.
A" , Az ) be a binary relation schema in (resp. )
and consider the formulas 4 : AA" AAz       fi 	        A"    	  ,      A"     	     Az  .
A"   A and A"   A can appear in the formula Afi for all   fi .
4 fi (resp.
 ) stands for fi  (resp.
fi ).
3 Both  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  The formula   fi     fi   is referred to as  fi   in the rest of the section.
Intuitively,  fi   computes a aback-and-forth temporal patha along the temporal instance, beginning with the value 	 (in the dZrst state).
Semantics The satisfaction of a formula   over at time point  fifi  given a valuation  , denoted fi fi      is dedZned as follows:  if   is obtained by a dZrst-order rule, fi fi      is dedZned as usual  if   is , fi fi      iff   fi and fi   fifi      if   is , fi fi      iff    and fi   fifi      if   is    fi fi      fi fi    , we dZrst need some preliminaries: let  A be the sequence of temporal instances of size  over fi dedZned by:   is the empty temporal instance    is the temporal instance dedZned for each time point  fifi  and each auxiliary schema  for  fifi  by:         fi fi     fi  a valuation.
Intuitively,     is the answer of the query   evaluated over   at time point  .
Next, the sequence fi   A is the one obtained from  A by projection over the checked auxiliary schemas 5  fi fi  .
Suppose that fi   A reaches a repetition , fi .
Intuand consider the least   such that fi     itively, the unchecked auxiliary relations are ahiddena when checking for a repetition.
Thus when   is   fi fi      fi fi    , we have fi fi      iff     , that is iff the tuple   belongs to the relation over  of the temporal instance  at time point .
If fi   A never reaches a repetition, we say that the semantics of both the -expression and the formula it appears in are undedZned.
E XAMPLE 3.2 The table below illustrates the above semantics using the  formula of example 3.1.
It gives a temporal instance for  and the sequence  A .
t  A A A A Afi A A A A    1    fi	   fi	         fi	    fi	    fi	    fi	    fi	    fi	   fi	   fi	   fi	       2  fi 	 fi fi	      fi	 fi  fi	 fi  fi	 fi   fi	 fi fi	  fi	 fi fi	  fi	 fi fi	         3  fifi	   fi	  fi	  fi	  fi	  fi	          fi	  fi	  fi	  fi	      The above computation reaches a repetition at iteration 6, because   .
Thus the evaluation of the instance over auxiliary schema  (resp.
 ) is   (resp.
 ); 5 We say that  	 Azareaches a repetitiona iff there exists 	  A" .
a sequence   Az  such that 	    hence the evaluation of  over the above temporal instance is    	fi fi 	fi fi 	fi .
Let   be obtained from  by declaring  unchecked:   fi          fi  .
The computation of   A is the same for both  and  , but such is not the fi case for the sequence   A .
Indeed, fi   A reaches a  A only contains the inrepetition at iteration 3, since fi  stance over the auxiliary schema  , and    	 .
Thus the evaluation of   over the above temporal instance is    fi fi .
Query languages We dedZne queries based on the formulas dedZned above exactly like for TL.
A query  is specidZed by a formula  and the answer of  over is obtained by evaluating  at time point 1:         fi fifi    fi  a valuation  Next, we use the notion of indZationary formulas.
A formula  fi is indZationary if, considering the sequence  A dedZned above,          for all  fifi .
Hence an indZationary formula is intuitively a acumulativea one.
We now dedZne four TL-like query languages based on the previous syntax and semantics.
1.
TL denotes the language without unchecked auxiliary schemas and where all formulas of -expressions are indZationary.
2.
TL denotes the language without unchecked auxiliary schemas and with arbitrary formulas.
3.
TL  denotes the language where auxiliary schemas can be checked or unchecked, and where all formulas of -expressions adedZninga some checked relations are indZationary.
4.
TL denotes the language where auxiliary schemas can be checked or unchecked, and with arbitrary formulas.
Note that, in all four languages, -expressions must contain obviously at least one auxiliary schema and moreover at least one auxiliary schema must be checked.
Repetition vs. limit The semantics of -expressions is dedZned using the repetition of the checked sequence fi   A .
Another classical way to dedZne such a seman tics is by using the limit of the sequence.
These two definitions lead to different semantics for TL  and TL , and they lead to equivalent query languages for TL and  TL.
Indeed, TL  repetition and TL limit (resp.
TL repetition and TL limit) are probably not equivalent query languages.
Hence, we beleive that only TL and TL would deserve to be called AT dZxpoint query languages At.
It is easy to show that in the static case, the repetition and limit dedZnitions lead to equivalent query languages for both the indZationary and non indZationary FOdZxpoint.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  Partial query languages There exists formulas belonging to TL and TL	 whose semantics is undedZned, but every TL AV and TL AV 	 formula admits a dedZned semantics.
The facts that on the one hand TL and TL	 are partial languages and on the other hand TLAV and TLAV 	 are total languages generalize the static case: recall that non indZationary FO dZxpoint is a partial query language and indZationary FO dZxpoint is a total query language.
3.2  T- WHILE -like  languages  All query languages presented in this section are based on the T- WHILE language introduced in [1].
T- WHILE is a temporal extension of the well-known WHILE query language for static databases [6] Syntax We assume w.l.o.g.
that the database schema includes (implicitly) two 0-ary schemas fi and fi 6 .
A program over is specidZed by a sequence of declarations followed by a sequence of instructions.
Declarations enable to specify some new relation schemas for programs, i.e.
schemas not in , called auxiliary schemas.
An auxiliary schema can be declared: shared or private, checked or unchecked.
Instances of auxiliary shared schemas are identical in all states of the temporal instance.
Intuitively, such a relation is common to all states of the database.
Instances of auxiliary private schemas can be different in the states of the temporal instance.
Declaring an auxiliary schema checked or unchecked has an impact on the semantics of the language.
Intuitively, the former (resp.
the latter) enforces the instance of the auxiliary schema to be used (resp.
ignored) when computing the semantics of a while statement.
From now on, we suppose that is the set of all auxiliary schemas.
The possible instructions of a program are: temporal moves left and right, assignment 	 fi  	, where  and   is a FO formula over with free variables 	.
iterator while  do fifi end, where  is a closed FO formula and fifi a sequence of instructions.
Clearly, while iterators can be nested.
             fi      E XAMPLE 3.3 Consider the following programs A" (over fi ) and Az (over fi  ) whose semantics are explained later on:        	  A": unchecked shared  ; while  fi do { right ;   fi    } end.
6  fi (resp.
fi) is a boolean whose value is fi only in the dZrst  (resp.
last) state of any temporal instance.
Az: checked shared  ;  	  fi 	   	 fi  ; while  fi do { right ;  	   fi   	       } end ; while   fi do { left ;  	   fi  	        } end.
Semantics The evaluation of a program over  is obtained considering a current time point, which is simply one of the time points of the instance .
A condZguration of a program is composed of: the current time point, the instances over all checked auxiliary schemas of in all states.
Note that when the evaluation starts, the current time point is the dZrst one and the instances of auxiliary schemas are empty in all states 7 .
left (resp.
right) decreases (resp.
increases) the current time point by 1.
If the current time point is the dZrst (resp.
last) one of the instance, then left (resp.
right) has no effect.
	 fi  	 changes the value of the instance over .
If  is private then  only changes in the current state (i.e.
the state at current time point); if  is shared then  changes in all states of the temporal instance.
When  achangesa, its new value is set to the answer of the query  	 evaluated at the current time point.
while  do fifi end executes all instructions of fifi until either  becomes false, or until the sequence of condZgurations observed after each execution of fifi reaches a repetition.
When both the current time point and the checked relations repeat, the computation terminates.
Recall that unchecked instances of auxiliary schemas do not belong to condZgurations, and thus are not taken into account when checking for a repetition.
If none of the conditions above is ever fuldZlled (i.e.
 never becomes false and the sequence of condZgurations never reaches a repetition), we say that the semantics of both the while statement and the program it belongs to are undedZned.
            E XAMPLE 3.4 We consider the programs of example 3.3.
For A" , the auxiliary schema  is boolean (i.e.
of arity 0).
When evaluated, the program executes   fi   in all states of the temporal instance, from left to right, starting from the dZrst state.
Thus the instance over  , whose initial value is  , returns the parity of the size of the temporal instance.
Note that there is no checked auxiliary schema in this program.
For Az , it can be shown that when the computation is dZnished the instance over  is the same as the evaluation of formula  from example 3.2.
       7 Thus, the initial value of boolean auxiliary schemas is 	  in all states.
In this paper, we take advantage of this fact by never initializing booleans with 	 .
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  Query languages We dedZne queries based on the programs dedZned above exactly like for the WHILE language, i.e.
by giving both a program and an auxiliary schema .
The answer of a query on  is the instance over at time point 1 output by the evaluation of over .
Note that can be either checked or unchecked in .
Next, we use the notion of indZationary assignment.
An assignment     is indZationary iff it adds all tuples which satisfy  to .
An indZationary assignment     is intuitively a acumulativea one and is equivalent to      .
We now dedZne four query languages based on the previous syntax and semantics.
1.
T- WHILE denotes the language without unchecked auxiliary schema and where all assignments are indZationary.
2.
T- WHILE denotes the language without unchecked auxiliary schema and with arbitrary assignments.
3.
T- WHILE 	 denotes the language where auxiliary schemas can be unchecked or checked, and where all assignments whose left-hand-side is a checked schema are indZationary.
4.
T- WHILE	 denotes the language where auxiliary schemas can be unchecked or checked, and with arbitrary assignments.
Note that one can specify programs of T- WHILE 	 and T- WHILE 	 with no checked auxiliary schemas.
Indeed one may write T- WHILE-like programs with no auxiliary schema at all.
This is the case of the following program which ends up setting the current time point to the last time point fi of the temporal instance: while  do right end.
About language names For the sake of our investigation and presentation, we choose different names for some of the languages introduced in [1].
The names given by us to the languages identify the features which are the key of the expressive power results provided in this paper.
Thus:  the language T- FIXPOINT of [1] is T- WHILE	 here,  the language T- WHILE of [1] is the same here,  the language called T- WHILE here was briedZy referred to as the apurely indZationary restrictiona of T- WHILE in [1].
Repetition vs. limit The semantics of the while statement is dedZned using the repetition of the sequence of condZgurations.
Another classical way to dedZne such a semantics is by using the limit of the sequence.
These two dedZnitions lead to different semantics for the languages T- WHILE 	 and TWHILE 	 , and they lead to equivalent query languages for T- WHILE  and T- WHILE .
Indeed, T- WHILE  	 firepetition limit (resp.
T WHILE repetition and fi fi and T- WHILE 	 	 T- WHILE 	 filimit) are probably not equivalent query languages.
Hence, we beleive that only T- WHILE and TWHILE would deserve to be called AT dZxpoint query languages At.
It is easy to show that in the static case, the repetition and limit dedZnitions lead to equivalent query languages for both WHILE and WHILE  .
Partial query languages There exists programs, belonging to T- WHILE , T- WHILE, T- WHILE 	 and T- WHILE	 whose semantics is undedZned.
Below we provide a program belonging to all four languages whose semantics is undedZned when the size of the temporal instance is greater than 3. right ; while  do left ; while 	  do  right ; right fi end ; end.
As opposed to TL-like languages, the fact that all TWHILE -like languages are partial query languages (even TWHILE  ) stands in contrast with the static case: recall that WHILE  is a total query language.
4  Expressive power results  This section begins with an introductory discussion.
Note that all TL-like and T- WHILE-like languages discussed in this section are strictly more expressive than TL.
T- WHILE 	 vs. T- WHILE In [1], the authors show that the equivalence T- WHILE 	  T- WHILE is aimprobablea.
Their proof proceeds to suppose that T- WHILE 	  T- WHILE.
is equivalent to T- WHILE Then in particular, T- WHILE 	 on temporal databases consisting of a single state, and hence WHILE  WHILE (because it is shown in [1] that auncheckeda schemas do not increase the expressive power of WHILE ).
However WHILE  WHILE is proved equivalent to PTIME  PSPACE in [3], which is unlikely.
The fact that in this paper we show T- WHILE 	  TWHILE should not be interpreted as a contradiction.
Indeed our proof considers temporal instances containing at least two states, whereas as pointed out above, the result in [1] is obtained by restricting temporal instances to static ones.
These two results (the unlikelyness of T- WHILE 	  T- WHILE for single state temporal instances and the proof of T- WHILE 	  T- WHILE for temporal instances of size at least 2) highlight an essential difference between static and temporal querying.
Data complexity of T- WHILE 	 As mentioned above, we show in this paper that T- WHILE 	  T- WHILE over really temporal instances.
This entails that T- WHILE 	 is PSPACE which disproves the claim of [1] that T- FIXPOINT is PTIME.
Intuitively, this is due to the non indZationary behavior of the current time point in T- WHILE-like languages.
New expressive power results The expressive power results that are now presented lead to a two-level hierarchy, as shows the dZgure below.
Inside each level, we display  Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  equivalent query languages (the dZgure indicates the way the equivalences are proved by displaying the inclusions we establish).
In order to obtain the hierarchy, we dZrst focus on the lower level, then we show the separation between the two levels, and dZnally turn to the higher one.
For the sake of space, the proofs are sketched and sometimes even not presented.
ahigher levela T- WHILE	    T- WHILE	  T- WHILE  (T-FIXPOINT)  TL	  TL  TL      TL	  To prove this result, we consider propositional temporal instances (i.e.
instances having only relations of arity 0).
In this context, we show that TL  L INTIME and TL expresses the NP-complete problem SAT.
The complexity measure we use here is the size of the temporal instance 8 .
As a matter of fact, we have TL  L INSPACE: the only space needed for the computation of -expressions is the one to store the auxiliary relations 9 .
We then have TL  L INTIME, because TL is an indZationary language: during the aevaluationa of a -expression, each auxiliary relation in each state of the temporal instance, can either stay empty or become full and stay full thereafter.
Finally, it is rather straightforward to encode the wellknown problem SAT (satisdZability of a propositional formula) in TL, and SAT is NP-complete.
The encoding works by considering a formula in conjonctive normal form ; it encodes each clause of the formula in a state of the temporal instance, and computes the potential models of the formula by using as many auxiliary schemas as there are variables in the formula.
Higher level of the hierarchy L EMMA 4.4  TL	  TL  alower levela  Lower level of the hierarchy Obviously from the dedZnitions, TL TL  	 .
Moreover: L EMMA 4.1  TL  	  TL   This result shows that unchecked auxiliary relations, though not indZationary, do not increase the expressive power of the indZationary language TL .
The proof is done by means of a translation of TL 	 -expressions into equivalent TL formulas.
The key argument is that, due to the indZationary nature of the computation, formulas belonging to -expressions of TL 	 are only evaluated as long as tuples are inserted in the checked auxiliary relations.
Hence, the contents of the unchecked relations can be simulated by versioning their tuples with the tuples inserted in the checked relations since the previous iteration.
The versioning is done using cartesian product.
The aolda versions are cumulated in a separate relation, so that the process is fully indZationary, as needed for the query language TL .
This technique is sketched in [1] to show that unchecked relations do not increase the expressive power of the static query language WHILE .
T HEOREM 4.2  TL     TL  	  Relation between the two levels of the hierarchy T HEOREM 4.3  TL   TL  This result shows that unchecked auxiliary relations do not increase the expressive power of TL.
The proof structure is roughly the same as the one for TL TL , 	 though more simple.
Indeed, here we do not have to deal with aindZationary vs. not indZationarya formulas, hence the versioning technique is unnecessary.
L EMMA 4.5  TL  T- WHILE  	  This result is shown only over temporal instances whose size is at least 2.
The proof is done by means of a translation of TL formulas into T- WHILE 	 programs.
This translation makes use of the fact that the size of the temporal instances is at least 2 as highlighted below.
We dZrst introduce some macros for T- WHILE 	 .
They use special auxiliary schemas called macro schemas: 1) all macro schemas are boolean and unchecked, 2) when writting a program, it is assumed that each time a macro is used new names are given to its macro schemas.
Let  fi be a closed FO formula.
 A conditional assignment if  fi then      is dedZned by      fi fi      fi fi     A conditional temporal move if  fi	   left right) is dedZned by:  fi then fi	  (where  8 Note that the complexity measure for query languages is usually the number of tuples rather than the number of states of the instance.
9 In the propositional context, each relation is either empty (i.e fi) or afulla (i.e.
, when its content is the empty tuple).
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE     fi ; while 	   do { 	  ;     } end where  is a shared macro schema.
 The macro goto  with   a boolean schema is dedZned by: while fi do left end ; while   do right end ; Intuitively, goto  sets the current time point to the leftmost time point where   is true.
 The macro FlipdZop is dedZned by: if fi then    fi ; if fi then right ; if    then left ;     ; where  is a shared macro schema.
Intuitively, FlipdZop changes the current time point as long as the temporal instance contains at least two states.
 The macro scan 	 fi, where fi is a sequence of instructions is dedZned by: fi   fi ; while fi do left end ; while 	 do { fi ; right } end ; goto fi  ; fi    ; where fi is a private macro schema.
Intuitively scan 	 fi executes fi in all states of the temporal instance from left to right starting from the dZrst state, as long as 	 is true.
The initial instruction of scan marks the current state (using fi ) in order to be able ago back therea using goto.
Hence, scan preserves the current time point.
 A global assignment     is dedZned by: scan fi     ; Intuitively, a global assignement enforces A to behave like a shared auxiliary schema for the assignment    .
 The macro Repetition    is dedZned by:     fi ; scan          fi   ; where   is a shared macro schema.
Intuitively, Repetition    checks that the instances over X and Y are the same in all states.
Sketch of proof: We now proceed to the translation.
Let   be a TL formula ; we inductively give a program  and an auxiliary schema  such that for all instance    A"    and for all   fi , the evaluation over  at time at time point point  of  is equal to the instance over  produced by the evaluation of  .
In order to build  , we inductively build an intermediate program  ; 	  (where  are declarations and 	  are instructions) and a FO formula  .
The program  is given by:   ; checked private 	  ;    .
   ;  where    denotes the number of free variables of a .
 If  is obtained through an FO formation rule, then  is essentially  itself, and  and 	  are straightforward.
 If      , let:    fi ; unchecked shared !
; unchecked private "    ;      "   	   	fi ;  "    ; /* resets  in case of nesting */ scan  fi  ; /* sets  */ where fi is: { right ; !
  fi  ; left ; "   !
 }  Intuitively, it is anot possiblea in T- WHILEAV  to grab, at the current time point, anything from the next state or any other state.
Thus in order to translate    we use !
whose purpose is to move fi  from the next state to the current state.
Hence !
needs to be shared.
It also needs to be unchecked because we compute    in all states and this computation is not indZationary.
 the case     fi#   is similar to the previous one and is omitted here.
 If     fi	 fi  $   10 , where $ is an auxiliary schema of 	 , let:    fi ; unchecked shared  	  $  ; unchecked private $ 	   $    	   fi  ;      $   	    fi   fi ; $    ; while $   do FlipdZop ;  $     $  ; 	fi ;  /* marks the current state */ /* resets 	 to  /* enforces current time point to change */ /* sets 	  to 	 in all states */  $  fi  ; Repetition $ $   ; fi if  	  then $    fi ; /* sets  end ; goto fi  fi       in case of nesting */  to 	  iff     */  ;   ; $     ;  Intuitively, since 	 is not necessarily an indZationary formula, it is translated with the unchecked auxiliary schema $ .
This implies that the evaluation of the while block proceeds with condZgurations whose single component is the current time point.
Recall that the evaluation of while loops stops either because their condition is false or because of condZguration repetition.
Here our goal is to force the evaluation of the while block to stop when a$ reaches a repetitiona.
Because $ is unchecked, repetition check over $ is encoded in the while block.
Morerover FlipdZop enforces 10 Here we consider w.l.o.g.
expressions.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  TL  restricted to single-formula  -  two consecutive condZgurations to differ by changing the current time point and thus the evaluation of while block only stops when its condition becomes false.
Note that FlipdZop works properly only if the temporal instance size is at least 2.
Of course, if the semantics of the -expression    fi  is undedZned, so is the semantics of the above program.
 Obviously T- WHILE   L EMMA 4.6 T- WHILE  T- WHILE  .
Moreover:  T- WHILE  This result shows that unchecked relations do not increase the expressive power of T- WHILE.
Sketch of proof: Let  be a while statement of a TWHILE  program  , such that  contains two auxiliary schemas fi and  , where fi (resp  ) is declared checked (resp.
unchecked).
We suppose that both fi and  appear as left-hand-sides of assignments within  .
Now let  Az be obtained from the program  by declaring  checked.
The evaluation of  in  Az is necessarily at least as long as its evaluation in  : if fi ,  and the current time point repeat, then in particular fi and current time point repeat.
But the evaluation of  in  Az can be longer, and may not terminate (e.g.
if  never reaches a repetition).
Hence a way to have equivalent evaluations of  in both  and  Az is to observe when both fi and the current time point reach a repetition, and enforce that the condition of  becomes 	 at that moment.
 L EMMA 4.7 T- WHILE   TL  Sketch of proof: This proof is decomposed into two parts: 1) partial unnesting of while statements 2) translation of partially unnested T- WHILE programs into  TL formulas.
Both parts are rather technical and intricate, hence for the sake of space we only sketch them below.
We need to unnest while statements because of a fundamental difference between T- WHILE and  TL : in the former, an instance of an auxiliary schema fi can be assigned by more than one instruction, and hence its contents can change at various nesting levels.
This is anot possiblea in  TL because an instance of fi is only dedZned once by a single formula  .
Partial unnesting of T- WHILE programs addresses this issue.
Now, let us try to outline the main ideas behind partial unnesting.
Recall that WHILE programs can be fully unnested.
Indeed, consider the following WHILE program: while A" do fiA"  fi 	A"  ; while Az do fiAz  fi 	Az  end ; end.
This program is equivalent to the following unnested one:  fiAzfi  fi fiAz  ; while A" do if  fiAzfi  fi fiAz  then fiA"  fi 	A"  ; fiAzfi  fi fiAz  ; if Az then fiAz  fi 	Az  ; end.
For WHILE programs, the main idea behind unnesting is to unfold nested while statements by means of aconditionala assignments which are assignments themselves, thus the process can be iterated until obtaining fully unnested programs.
The above technique can be applied to unnest T- WHILE programs: assignments and temporal moves in nested while statements are transformed into conditional assignments and conditional temporal moves.
Contrary to the case of WHILE, the process does not lead to fully unnested T- WHILE programs for the following reason: a conditional temporal move is a (simple) while statement 11 .
Furthermore, to unnest T- WHILE programs, we need to propagate the storage instruction fiAzfi  fi fiAz  on all states.
This leads to a global assignment, which is also a while statement.
To sum up, the partial unnesting of a T- WHILE program leads to a program whose while statements contain only conditional temporal moves, conditional assignments, conditional global assignments, and the conditional variants of the macros Repetition and Time.
Once a T- WHILE program is partially unnested, translating its conditional instructions listed above turns out to be technical but rather simple.
The main problem raised by the translation of a T- WHILE program is to deal with time: a major component of the condZguration used in dedZning the semantics of T- WHILE-like languages is the current time point which introduces some kind of explicit control of time in TWHILE ; no such notion exists for   TL -like languages.
The translation manages this difdZculty as follows: to each instruction we associate a formula aiming at marking its current time point.
Such a formula has to be declared checked in order to take time into account the way T- WHILE does.
 T HEOREM 4.8  The languages  TL,  TL , T- WHILE, TWHILE  , T- WHILE AV  are equivalent.
We would like to emphasize once again that this theorem is valid under the two-states instances assumption only.
The result does not hold for single state instances (see section 4).
5  Discussion  The dZrst contribution of this paper is to enrich the expressive power hierarchy of [1] with results for  TL-like languages.
In particular, our two-level hierarchy provides the proof of the claim of [11] that the dZrst order extension 11 We  do not succeed in unnesting conditional temporal moves.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE  of TL (denoted TL in our framework) is strictly less expressive than T- FIXPOINT (denoted T- WHILE 	 in this paper).
Because T- FIXPOINT is equivalent to T- WHILE over really temporal instances, T- FIXPOINT is PSPACE.
The second important contribution of this paper is to highlight the impact of unchecked auxiliary schemas on TWHILE -like and TL -like languages.
Allowing one to use unchecked auxiliary schemas has no impact on the expressive power of non indZationary languages of both classes and on the expressive power of the indZationary language TL .
In the static case, the indZationary (resp.
non indZationary) WHILE language is equivalent to the indZationary (resp.
non indZationary) FO dZxpoint language.
The paper shows that this symmetry is broken in the temporal framework: TL 	 T- WHILE  	.
We do not provide any insight w.r.t.
the expressive power of T- WHILE .
However, we have strong reasons (although not yet proofs) to beleive that: C ONJECTURE 5.1 T- WHILE  T- WHILE  As in [1] (see section 4), we can use a complexity argument to prove that in case of static instances T- WHILE T- WHILE probably holds because in that case T- WHILE  reduces to WHILE , T- WHILE reduces to WHILE and WHILE WHILE iff PTIME  PSPACE .
This argument relying on static instances does not completely satisfy us because it does not entail that the result holds for really temporal instances (as our result about T- WHILE 	 and T- WHILE shows).
Another direction of investigation is to show that T- WHILE  and T- WHILE are separated by some query.
A candidate is the query denoted twin which checks wether there exists two identical states in the temporal instance.
To conclude this discussion, let us comment on the specidZc treatment of time in T- WHILE-like languages.
Somehow, time is not fully implicit in these languages because of the dedZnition of condZguration.
Moreover, the temporal moves left and right alone are too apoora to simulate the  and fi modalities of TL-like languages.
Roughly, (see for instance the translation of  in the proof of lemma 4.5), during the evaluation of a T- WHILE-like program, the computations made at some time point are only aware of the state at that time point and of the shared auxiliary relations.
Thus, without shared auxiliary schemas, moving to the right does not help to compute queries dependending on data of both the current and next states because the move allows one to access the next state data and meanwhile prevents from accessing data in the current state.
It is then clear that such queries need to be supported by shared and non indZationary auxiliary schemas.
References [1] S. Abiteboul, L. Herr and J.
Van den Bussche.
Temporal Connectives versus Explicit Timestamps in Temporal Query  Languages.
In Journal of Computer and System Science, 58(1):54a68, 1999.
[2] S. Abiteboul and V. Vianu.
Datalog extensions for database queries and updates.
In Journal of Computer and System Science, 43:62a124, 1991.
[3] S. Abiteboul and V. Vianu.
Generic computation and its complexity.
In Proc.
ACM SIGACT Symp.
on the Theory Of Computing, pages 209a219, 1991.
[4] N. Bidoit and S. De Amo.
Implicit temporal query languages: towards completeness, In FST&TCS, Chennai, India, LNCS Vol.
1738, 1999, pages 245a257.
[5] N. Bidoit, S. De Amo, and L. SegoudZn.
Order independent temporal properties.
In Journal of Logic and Computation, 14(2):277a298, 2004.
[6] A. K. Chandra and D. Harel.
Structure and comlexity of relational queries.
In Journal of Computer and System Science, 25(1):99a128, 1982.
[7] J. Chomicki and D. Toman.
Temporal Logic in Information Systems.
In Logics for databases and information systems, Kluwer Academic Publishers, chapter 3, pages 31a70, 1998.
[8] E. A. Emerson.
Temporal and Modal Logic, In Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics, Jan van Leeuwen, Ed., Elsevier Science Publishers (1990) 995a1072.
[9] Y. Gurevich.
Toward a logic tailored for computational complexity.
In Computation and Proof Theory, pages 175a216, M. M. Ritcher et al.
editor, Springer Verlag, LNM 1104, 1984.
[10] Y. Gurevich and S. Shelah.
Fixed-point extensions of dZrstorder logic.
In Annals of Pure and Applied Logic, 32:265a 280,1986.
[11] L. Herr.
Langages de RequASte pour les Bases de DonnASes Temporelles.
Ph.D thesis, UniversitAS Paris Sud, 1997.
[12] D. Leivant, Inductive dedZnitions over dZnite structures.
In Information and Computation, 89:95a108, 1990.
[13] A.R.
Meyer.
Weak monadic second order theory of successor is not elementary recursive.
In Proceedings Logic Colloquium, Lecture Notes in Mathematics, Vol.
453, pp.
132a 154, Springer-Verlag, 1975.
[14] Y. N. Moschovakis.
Elementary Induction on Abstract Structures, North Holland, Amsterdam, 1974.
[15] A. P. Sistla and E. M. Clarke.
The Complexity of Propositional Linear Temporal Logics.
In Journal of the ACM, 32(3):733a749, 1985.
[16] D. Toman.
On Incompleteness of Multi-dimensional Firstorder Temporal Logics.
In TIME: 99a106, 2003.
[17] M. Y. Vardi.
A temporal dZxpoint calculus.
In Proceedings 5th ACM Symposium on Principles of Programming Languages, pages 250a259, 1988.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIMEa05) 1530-1311/05 $20.00 AS 2005 IEEE