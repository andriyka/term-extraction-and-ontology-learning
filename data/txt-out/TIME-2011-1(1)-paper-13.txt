Annals of Mathematics and Artificial Intelligence manuscript No.
(will be inserted by the editor)  The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT Davide Bresolin * Dario Della Monica * Angelo Montanari * Guido Sciavicco  Received: date / Accepted: date  Abstract Decidability and complexity of the satisfiability problem for the logics of time intervals have been extensively studied in the recent years.
Even though most interval logics turn out to be undecidable, meaningful exceptions exist, such as the logics of temporal neighborhood and (some of) the logics of the subinterval relation.
In this paper, we explore a different path to decidability: instead of restricting the set of modalities or imposing severe semantic restrictions, we take the most expressive interval temporal logic studied so far, namely, Venema's CDT, and we suitably limit the negation depth of modalities.
The decidability of the satisfiability problem for the resulting fragment, called CDTBS , over the class of all linear orders, is proved by embedding it into a well-known decidable quantifier prefix class of first-order logic, namely, Bernays-Schonfinkel class.
In addition, we show that CDTBS is in fact NP-complete (Bernays-Schonfinkel class is NEXPTIME-complete), and we prove its expressive completeness with respect to a suitable fragment of BernaysSchonfinkel class.
Finally, we show that any increase in the negation depth of CDTBS modalities immediately yields undecidability.
Keywords Interval temporal logic * Tableau methods * Decidability * Complexity 1 Introduction In the recent years, the study of temporal reasoning via interval-based (logical) approaches has been very intensive.
Since the seminal work by Halpern and Shoham [18] and VenD.
Bresolin Dept.
of Computer Science, University of Verona, Italy E-mail: davide.bresolin@univr.it D. Della Monica ICE-TCS, School of Computer Science, Reykjavik University, Iceland E-mail: dariodm@ru.is A. Montanari Dept.
of Mathematics and Computer Science, University of Udine, Italy E-mail: angelo.montanari@uniud.it G. Sciavicco Dept.
of Information and Communication Engineering, University of Murcia, Spain E-mail: guido@um.es  2  Davide Bresolin et al.
ema [33], a series of papers on interval temporal logics has been published, e.g., [5, 6, 9-11, 23, 24, 29].
As an effect, the problem of classifying all "natural", genuinely interval-based (that is, all intervals over a linear order are considered, and no projection principle is applied [17]) logics with respect to their expressive and computational power has been extensively studied and almost completely solved.
Propositional interval temporal logics are modal logics, interpreted over linearly- or partially-ordered sets, whose proposition letters are evaluated over intervals instead of over points.
They differ from each other in the number and type of basic relations between intervals that are captured by their modalities, by the linear order(s) over which they are interpreted, and by the inclusion or exclusion of point-intervals (intervals with coincident endpoints).
In the hierarchy of existing interval temporal logics based on their expressive power, the top element is Venema's CDT [33], whose language features three binary modalities, corresponding to the three possible ways to place a point with respect to the two endpoints of a given interval, and a modal constant, that identifies point-intervals.
The second-highest logic in the hierarchy is Halpern and Shoham's HS [19], which features one unary modality for each Allen's relation between pairs of intervals [1].
Both in CDT and in HS, satisfiability turns out to be undecidable, no matters what class of linear orders is considered (all, discrete, dense, finite, the linear order of natural numbers, and so on) [19].
In the recent years, some fragments of HS with a better computational behavior have been identified.
Meaningful examples include, but are not limited to, AA (a.k.a.
Propositional Neighborhood Logic, PNL), which features two modalities for Allen's relations meets and met by, and is decidable over all meaningful classes of linear orders [8, 16]; its extension AABB [28], that includes modalities for Allen's relation's starts and started by, and its mirror image AAEE, with additional modalities for Allen's relations finishes and finished by, which are decidable over the class of finite linear orders and undecidable everywhere else; and BBDDLL (and its mirror image EEDDLL), with modalities for Allen's relations starts, started by, during, contains, before, and after, which is decidable over dense linear orders [27] and undecidable over finite and (weakly) discrete linear orders (as a matter of fact, one-modality logics D and D are already undecidable over the classes of finite and discrete linear orders [23])1 .
The situation with classical first-order logic is somehow similar.
Since it has been shown that satisfiability for the full language is undecidable, a great effort has been made in order to identify more and more expressive decidable fragments.
At least three different strategies have been pursued: (i) limiting the number of variables of the language, (ii) limiting the type of formulas allowed by relativizing quantification (guarded fragments), and (iii) limiting the structure and the shape of the quantifier prefix.
First-order logics with a restriction on the number of variables have been already studied in connection with interval temporal logics.
Most notably, AA has been proved to be expressively equivalent to the two-variable fragment of first-order logic over linear orders.
Such a fragment of first-order logic has been shown to be NEXPTIME-complete over various classes of linear orders in [30].
Decidability of AA over the same classes of orders immediately follows.
Guarded fragments of first-order logic (see [2] for an introduction) have been shown to be quite useful to explain the good computational properties of modal logics, but, to the best of our knowledge, they have never been considered in the framework of interval temporal logics.
As a matter of fact, mapping interval temporal logics into guarded fragments of first-order logic would require (i) the use of a relation in the guards 1  In all these cases, including or excluding point-intervals makes no difference.
The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  3  which is (or can be forced to behave as) a linear order, (ii) at least three distinct variables, (iii) uninterpreted predicates which are at least binary, and (iv) quantifications with Boolean combinations of atomic formulas as guards.
Such requirements are not met by known decidable guarded fragments of first-order logic2 .
In this paper, we explore an original path to decidability of interval temporal logics, which follows the third strategy: we look for meaningful interval temporal logics that can be embedded into decidable quantifier prefix classes of first-order logics.
The decidability of the latter family of logics does not depend on the shape of the quantifier prefix only, but also on the number and the arity of predicate and function symbols that are allowed in the formulas, and on the presence/absence of equality.
Seven different decidable classes have been identified in the literature (a survey on quantifier prefix classes of first-order logic can be found in [4]).
We focus our attention on the prefix vocabulary class identified by Bernays and Schonfinkel in 1928 (a.k.a.
Bernays, Schonfinkel, and Ramsey class, as Ramsey proved that decidability is preserved even when equality is included) [4].
It consists of all and only formulas in prenex form whose quantifier prefix is of the form [?
]x1 .
.
.
[?
]xn [?
]y1 .
.
.[?
]ym and whose matrix may include predicate symbols of any arity (but no function symbols) and, possibly, equality.
It is well known that Bernays-Schonfinkel fragment of first-order logic is expressive enough to model a linear order devoid of specific properties such as discreteness or density.
Moreover, it can express simple frame properties, commonly studied in the interval temporal logic literature, like, for instance, boundedness.
We identify a syntactic fragment of CDT [33], called CDTBS , whose standard translation fits into Bernays-Schonfinkel class, by limiting the negation depth of the modalities to one, that is, by constraining temporal operators to occur in the scope of at most one negation.
Decidability of CDTBS , over the class of all linear orders, immediately follows.
Then, a precise characterization of CDTBS expressive power is given by showing that it is expressively complete with respect to a suitable fragment of Bernays and Schonfinkel class.
A decision procedure for CDTBS is then obtained by tailoring the non-terminating tableaubased deduction system for CDT developed in [15] to it.
As a by-product, we prove that the satisfiability problem for CDTBS is NP-complete, in sharp contrast with that of BernaysSchonfinkel class, which is NEXPTIME-complete, when relation symbols of unbounded arity are allowed, and PSPACE, when relation symbols have bounded arity, e.g., only binary relations are allowed, as it is the case for interval logics.
Finally, we show that any increase in the negation depth of CDTBS modalities immediately yields undecidability.
The paper is structured as follows.
In Section 2, we provide background knowledge about Bernays and Schonfinkel fragment of first-order logic.
In Section 3, we define syntax and semantics of CDTBS , and we define its standard translation.
Decidability immediately follows from the inclusion of the resulting set of formulas in Bernays and Schonfinkel class.
Next, in Section 4, we prove the expressive completeness of CDTBS with respect to a suitable fragment of such a class.
In Section 5, we devise a sound, complete, and terminating tableau method for CDTBS .
Finally, in Section 6, we show that fairly natural extensions of CDTBS do not preserve decidability.
An assessment of the work done and possible future research directions are given in Section 7.
2 Extended guarded fragments includes loosely guarded fragments, which allow guards to be more complex than simple atoms [3], and guarded fragments with transitive guards (in general, transitivity cannot be expressed as a guarded formula) [31].
4  Davide Bresolin et al.
2 Bernays-Schonfinkel class Bernays-Schonfinkel prefix vocabulary class, denoted here by FOBS , consists of all and only those first-order formulas, making use of any relational symbol of any arity, including equality, that can be put in prenex form by using a quantifier prefix of the form [?
]x [?
]y, where x = x1 .
.
.
xn and y = y1 .
.
.
ym are (possibly empty) vectors of first-order variables.
It is well known that the satisfiability problem for FOBS is NEXPTIME-complete [4].
Moreover, FOBS is closed under conjunction and disjunction, since all its formulas can be thought of as sentences (free variables can be existentially quantified), but it is not closed under negation.
To simplify the proofs of the results given in the paper, we introduce an alternative definition of FOBS via the following abstract grammar:  a ::= a[?]
| a [?]
a | a [?]
a | [?
]x.a | !a[?]
for a[?]
of the form [?]x.a[?]
a[?]
::= A(x) | !A(x) | a[?]
[?]
a[?]
| a[?]
[?]
a[?]
| [?]x.a[?]
A(x) ::= any relational symbol of arbitrary arity, including equality  (1) (2) (3)  Grammar (1) generates a fragment of first-order logic consisting of all and only those formulas where existential quantifiers can occur in the scope of at most one negation.
While any prenex formula of the form [?
]x [?
]y b can be generated by grammar (1), the converse is not true, since grammar (1) can generate also formulas which are not in prenex form.
However, it is not difficult to show that any formula generated by grammar (1) can be transformed into an equivalent prenex formula of the correct form, as shown by the following proposition.
Proposition 1 Any formula generated by grammar (1) can be transformed into a prenex formula of the form [?]x[?
]yb , with b quantifier-free.
Proof Let a be a formula generated by grammar (1).
We show that there exists an equivalent formula t (a ) of the required form by structural induction.
We start with the set of formulas generated by the sub-grammar for a[?]
, and we show that each of them can be transformed into a formula of the form [?
]xb , with b quantifier-free.
The case in which a is a relation or the negation of a relation is trivial.
Consider now the case of formulas a = a[?]
[?]
a[?]'
.
By inductive hypothesis, t (a[?]
) = [?
]zb and t (a[?]'
) = [?
]wb ' , for some quantifier-free b and b ' .
Without loss of generality, we can assume z [?]
w = 0/ (if this is not the case, we can apply a suitable variable substitution), and thus a is equivalent to [?
]zw(b [?]
b ' ).
The case of disjunction is similar, and thus omitted.
Consider now the case of formulas a = [?]x.a[?]
.
By inductive hypothesis, t (a[?]
) = [?
]wb , for some quantifier-free b , with x 6[?]
w, and thus a is equivalent to [?]x[?
]wb .
Let us consider now an arbitrary formula generated by grammar (1).
The only interesting case is the one for the negation of existential quantifiers.
Let a = ![?]x.a[?]
.
By inductive hypothesis, t ([?]x.a[?]
) = [?]x[?
]wb , for some quantifier-free b , with x 6[?]
w. Hence, a is equivalent to the formula (in prenex form) [?]x[?
]w!b .
[?]
[?]
Thanks to the above result, from now on we will assume that any FOBS -formula has been generated by grammar (1).
3 Decidability of the logic CDTBS over the class of all linear orders Interval temporal logics are usually interpreted over a linearly ordered set D = hD, <i.
In this setting, an interval on D is an ordered pair [di , d j ] with di <= d j (we refer to such a case as  The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  5  C di  dk  dj  Fig.
1 The ternary relation chop, splitting the interval [di ,d j ] into the subintervals [di ,dk ] and [dk ,d j ].
the non-strict semantics, in contrast with the strict one, that excludes degenerate intervals of the form [di , di ]).
The set of all intervals on D is denoted by I(D).
The variety of all possible relations between any two intervals has been studied by Allen [1], who identified 12 distinct binary relations plus the equality relation.
Halpern and Shoham modal logic of intervals, abbreviated HS, can be viewed as the modal logic of Allen's relations as it features one modality for each such relation.
As we already mentioned, HS turns out to be undecidable over any meaningful class of linear orders [19].
In [33], the ternary relation chop, depicted in Figure 1, has been taken into consideration.
The corresponding binary modality C, together with the two conjugated modalities D (done) and T (to do), and the modal constant p for point-intervals define the interval temporal logic CDT.
It can be easily shown that CDT subsumes HS (in fact, it is strictly more expressive than HS), and thus it is undecidable whenever HS is.
In [20], Hodkinson et al.
systematically investigate the three fragments of CDT with only one binary modality each (C, D, or T ), showing that each of them is undecidable.
Formulas of CDT are built on a set of proposition letters A P = {p, q, .
.
.
}, the Boolean connectives !
and [?
], the three binary modalities C, D, and T , and the modal constant p , by the following abstract grammar [33]:  ph ::= p | p | !ph | ph [?]
ph | ph C ph | ph D ph | ph T ph .
The other Boolean connectives can be viewed as suitable short forms, as usual.
Similarly, universal counterparts of the existential modalities C, D, and T can be defined by means of negation in the standard way; CDT has not any special notation for them.
The semantics of CDT-formulas can be given in terms of concrete models of the form M = hI(D),Vi, where V : A P - 2I(D) is a valuation function, as follows: M, [di , d j ]  p if and only if [di , d j ] [?]
V (p), M, [di , d j ]  p if and only if di = d j , M, [di , d j ]  !ph if and only if M, [di , d j ] 6 ph , M, [di , d j ]  ph [?]
ps if and only if M, [di , d j ]  ph or M, [di , d j ]  ps , M, [di , d j ]  ph C ps if and only if there exists di <= dk <= d j such that M, [di , dk ]  ph and that M, [dk , d j ]  ps , - M, [di , d j ]  ph D ps if and only if there exists dk <= di such that M, [dk , di ]  ph and that M, [dk , d j ]  ps , - M, [di , d j ]  ph T ps if and only if there exists dk >= d j such that M, [d j , dk ]  ph and that M, [di , dk ]  ps .
- - - - -  The standard translation is the usual way to express the semantics of a modal or temporal formula in first-order logic.
Let ph be a CDT-formula and, for every p [?]
A P, let us denote by the same symbol p the corresponding binary relation.
The standard translation function ST (ph )[x, y] is defined as follows: - ST (ph )[x, y] = x <= y [?]
ST ' (ph )[x, y], where x, y are two first-order variables and ST ' (ph )[x, y] is inductively defined as follows: - ST ' (p)[x, y] = p(x, y),  6  Davide Bresolin et al.
- - - - - -  ST ' (p )[x, y] = (x = y), ST ' (!ph )[x, y] = !ST ' (ph )[x, y], ST ' (ph [?]
ps )[x, y] = ST ' (ph )[x, y] [?]
ST ' (ps )[x, y], ST ' (ph C ps )[x, y] = [?
]z(x <= z <= y [?]
ST ' (ph )[x, z] [?]
ST ' (ps )[z, y]), ST ' (ph D ps )[x, y] = [?
]z(z <= x [?]
ST ' (ph )[z, x] [?]
ST ' (ps )[z, y]), ST ' (ph T ps )[x, y] = [?
]z(y <= z [?]
ST ' (ph )[y, z] [?]
ST ' (ps )[x, z]).
As a general rule, the standard translation makes it possible to reduce the satisfiability problem for a modal logic to a first-order satisfiability problem: a modal formula ph is satisfiable if and only if its standard translation, evaluated on a pair of points x, y, is (first-order) satisfiable.
Now, we ask ourselves the following question: which CDT-formulas are such that their satisfiability problem can be reduced to a first-order satisfiability problem in BernaysSchonfinkel class?
To answer this question, we define an abstract grammar that generates only CDT-formulas suitably limited in the negation depth of modalities:  ph ::= ph[?]
| ph [?]
ph | ph [?]
ph | ph C ph | ph D ph | ph T ph | !(ph[?]
C ph[?]
) | !(ph[?]
D ph[?]
) | !(ph[?]
T ph[?]
)  ph[?]
::= p | !p | p | !p | ph[?]
[?]
ph[?]
| ph[?]
[?]
ph[?]
| ph[?]
C ph[?]
| ph[?]
D ph[?]
| ph[?]
T ph[?]
(4) (5)  The above grammar generates a fragment of CDT, that we call CDTBS , which consists of all and only those formulas where the modalities C, D, and T can occur in the scope of at most one negation.
The next lemma shows that the above-defined standard translation maps CDTBS -formulas into Bernays-Schonfinkel class.
It is easy to check that the syntactic limitations of CDTBS do not prevent it from expressing all HS modalities (it only constrains the way in which they can be composed).
As an example, hBiph is captured by ph C !p .
Similar encodings can be given for the other HS modalities [33].
Lemma 1 For every CDTBS -formula ph , its standard translation ST (ph )[x, y] is an FOBS formula, with free variables x and y.
Proof The proof is by structural induction.
We start with the set of formulas generated by the sub-grammar for ph[?]
, and we show that the standard translation of each of these formulas belongs to the sub-grammar for a[?]
and it has x, y as its free variables.
As for the base case, let ph[?]
= p, for some proposition letter p. By definition, ST (p)[x, y] = x <= y [?]
p(x, y); the thesis immediately follows.
The cases !p, p , and !p are similar, and thus omitted.
As for the case of conjunction, let ph[?]
= ph[?]'
[?]
ph[?]''
.
By definition, ST (ph[?]'
[?]
ph[?]''
)[x, y] = x <= y [?]
ST ' (ph[?]'
)[x, y] [?]
ST ' (ph[?]''
)[x, y].
By inductive hypothesis, both ST (ph[?]'
)[x, y] and ST (ph[?]''
)[x, y], and thus ST ' (ph[?]'
)[x, y] and ST ' (ph[?]''
)[x, y], belong to the sub-grammar for a[?]
and have x, y as their free variables.
It immediately follows that ST (ph[?]'
[?]
ph[?]''
)[x, y] has the required form.
The case of disjunction is similar, and thus omitted.
Now, let ph[?]
= ph[?]'
C ph[?]''
.
By definition, ST (ph[?]'
C ph[?]''
)[x, y] = x <= y [?]
[?
]z(x <= z <= y [?]
ST ' (ph[?]'
) [x, z] [?]
ST ' (ph[?]''
)[z, y]).
By inductive hypothesis, ST ' (ph[?]'
)[x, z] is an a[?]
-formula with x, z as its free variables, and ST ' (ph[?]''
)[z, y] is an a[?]
-formula with z, y as its free variables.
Hence, the formula x <= y [?]
[?
]z(x <= z <= y [?]
ST ' (ph[?]'
)[x, z] [?]
ST ' (ph[?]''
)[z, y]) is an a[?]
-formula with x, y as its free variables.
The other two cases for D and T can be dealt with in a similar way.
Let us consider now an arbitrary formula generated by the grammar.
The only interesting cases are those for the negation of modalities.
Let ph = !(ph[?]'
C ph[?]''
).
By definition, ST (!(ph[?]'
C ph[?]''
))[x, y] = x <= y [?]
!ST ' (ph[?]'
C ph[?]''
)[x, y], and ST ' (ph[?]'
C ph[?]''
)[x, y] = [?
]z(x <= z <= y [?]
ST ' (ph[?]'
)[x, z] [?]
ST ' (ph[?]''
)[z, y]).
We have already shown that both ST ' (ph[?]'
)[x, z] and ST ' (ph[?]''
)[z, y] are a[?]
-formulas with x, z and z, y as their free variables, respectively.
Hence,  The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  7  [?
]z(x <= z <= y [?]
ST ' (ph[?]'
)[x, z] [?]
ST ' (ph[?]''
)[z, y]) is an a[?]
-formula with x, y as its free variables.
It immediately follows that !ST ' (ph[?]'
C ph[?]''
)[x, y] is an a -formula with x, y as its free variables, and thus the thesis, as the conjunction of two a -formulas is an a -formula.
The other two cases can be dealt with in a similar way.
[?]
[?]
In order to prove the main theorem, it suffices to observe that the linear order < is captured by the following axioms [4], whose conjunction Ph belongs to FOBS : 1.
2.
3.
4.
[?]x!
(x < x); [?
]x, y(x < y - !y < x); [?
]x, y, z(x < y [?]
y < z - x < z); [?
]x, y(x = y [?]
x < y [?]
y < x).
Theorem 1 The satisfiability problem for CDTBS over the class of all linear orders is decidable.
Proof By Lemma 1, if ph is a CDTBS -formula, then [?
]x, yST (ph )[x, y] (the existential closure of ST (ph )[x, y]) belongs to Bernays-Schonfinkel class.
Satisfiability of ph can thus be reduced to satisfiability of the FOBS -formula Ph [?]
[?
]x, yST (ph )[x, y].
Since the satisfiability problem for FOBS is decidable, decidability of CDTBS immediately follows.
[?]
[?]
The satisfiability problem for FOBS has been shown to be NEXPTIME-complete.
The proof relies on the observation that an FOBS -formula is satisfiable if and only if it has a model with a number of elements bounded by the number of existential quantifiers [4, Proposition 6.2.17].
This immediately leads to a nondeterministic exponential-time procedure for satisfiability checking.
However, when we restrict our attention to formulas where the arity of relational symbols is bounded (to two, in our case), the complexity of such a procedure becomes PSPACE, since in this case a candidate model for the formula can be represented using only a polynomial amount of memory.
Hence, Theorem 1 gives us a PSPACE upperbound to the complexity of CDTBS .
In Section 5, we will show that this bound is not tight, by providing an NP decision procedure for the satisfiability of CDTBS .
4 Expressive completeness of CDTBS In Section 3, we showed that CDTBS formulas can be translated into Bernays-Schonfinkel class FOBS of first-order logic with equality, thanks to the fact that the linear order < can be expressed in this fragment.
Inspired by the observation that the translation uses only binary predicates, we now ask ourselves the following question: for every formula in Bernays-Schonfinkel class of first-order logic, interpreted over the linear order < and limited to binary predicates, is there an expressively equivalent CDTBS -formula?
Similar expressivity comparison issues have been already investigated for various point- and interval-based logics.
A partial list includes basic results about the completeness of LTL with respect to the first-order fragment of monadic second-order logic over Dedekind-complete linear orders and generalizations (Kamp's Theorem and its extensions [12-14, 21, 22, 25]), the completeness of CDT with respect to the three-variable fragment of first-order logic over linear orders, where at most two variables are free [33], the completeness of AA with respect to two-variable first-order logic over linear orders [8], and the completeness of its metric extension, called MPNL, with respect to a fragment of two-variable first-order logic extended with a successor function over N [7].
8  Davide Bresolin et al.
We focus our attention on first-order logic interpreted over the linear order < and limited to binary predicates, denoted by FO[<].
We will denote by FOn,m [<] the n-variable fragment of FO[<], where at most m variables are free, and by FOo ,m [<] the fragment of FO[<] with a denumerable set of variables, where at most m are free.
Since interval logics are interpreted over intervals (represented as pairs of points), the standard translation of any interval logic formula is a formula with two free variables, and thus it belongs to FOo ,2 [<].
By analogy with the case of other interval logics, e.g., [8, 33], to establish an expressive completeness result for CDTBS , we will limit the number of variables of the corresponding first-order frago ,m n,m [<]) the n-variable fragment (resp., the fragment ment.
We denote by FOBS [<] (resp., FOBS with a denumerable set of variables) of the language defined by grammar (1), where at most m variables occur free.
In the following, we compare interval and first-order logics with respect to their ability of expressing properties of a given interval in a model.
We distinguish three cases: (i) the comparison of two interval logics, (ii) the comparison of two fragments of first-order logic, and (iii) the comparison of an interval logic and a fragment of first-order logic.
Given two interval logics (resp., fragments of first-order logic) L and L', we say that L' is at least as expressive as L, denoted by L  L' , if there is an (effective) translation t from L to L' such that for every model M, interval [di , d j ] (resp., pair of points di , d j ) in M, and formula ph of L, M, [di , d j ]  ph iff M, [di , d j ]  t (ph ) (resp., M |= ph (di , d j ) iff M |= t (ph )(di, d j )).
Furthermore, we say that L' is as expressive as L, denoted by L' [?]
L, if both L'  L and L  L' , and we say that L' is strictly more expressive than L, denoted by L [?]
L' , if L  L' and L' 6 L. To compare the expressive power of an interval logic and a fragment of first-order logic, we must cope with a technical problem: interval models constrain interval logic formulas to be evaluated on ordered pairs [di , d j ], with di <= d j , only, while relational models do not impose such a constraint.
To solve it, we map each binary relation p of the considered fragment of first-order logic into two distinct proposition letters p<= and p>= of the interval logic.
From [8], we borrow the following definition.
Definition 1 Let M = hI(D),VM i be an interval model.
The corresponding relational model e (M) is the pair hD,Ve (M)i, where, for every proposition letter p, Ve (M)(p) = {(a, b) [?]
D x D : [a, b] [?]
VM (p)}.
Conversely, let M = hD,VM i be a relational model.
The corresponding interval model z (M) is the pair hI(D), Vz (M) i, where, for every binary relation p and interval [di , d j ], [di , d j ] [?]
Vz (M) (p<= ) iff (di , d j ) [?]
VM (p) and [di , d j ] [?]
Vz (M) (p>= ) iff (d j , di ) [?]
VM (p).
Given an interval logic LI and a fragment of first-order logic LFO , we say that LFO is at least as expressive as LI , denoted by LI  LFO , if there exists an effective translation t from LI to LFO such that for any interval model M, interval [di , d j ], and LI -formula ph , M, [di , d j ]  ph iff e (M) |= t (ph )(di, d j ).
Conversely, we say that LI is at least as expressive as LFO , denoted by LFO  LI , if there exists an effective translation t ' from LFO to LI such that, for any relational model M, pair of points (di , d j ), and LFO -formula ph , M |= ph (di , d j ) if and only if z (M), [di , d j ]  t ' (ph ), if di <= d j , or z (M), [d j , di ]  t ' (ph ), otherwise.
LI [?]
LFO , LI [?]
LFO , and LFO [?]
LI are defined as usual.
In [32], Venema shows that the hierarchy of fragments FOn,2 [<], for n >= 2, is strict.
Theorem 2 For every n >= 2, FOn,2 [<] [?]
FOn+1,2 [<] (over the class of all linear orders).
The expressive completeness of the interval logic of temporal neighborhood AA with respect to FO2,2 [<] and of CDT with respect to FO3,2 [<] have been proved by Bresolin et al.
in [8] and by Venema in [33], respectively.
The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  t i, j (xi = x j ) t i, j (x j = xi ) t i, j (xi = xi ) t i, j (x j = x j ) t i, j (xi < x j ) t i, j (x j < xi ) t i, j (xi < xi ) t i, j (x j < x j ) t i, j (p(xi ,x j )) t i, j (p(x j ,xi )) t i, j (p(xi ,xi )) t i, j (p(x j ,x j ))  = = = = = = = = = = = =  p t i, j (!a (xi ,x j )) p [?]
t i, j (a (xi ,x j ) [?]
b (xi ,x j )) [?]
!p t i, j (a (xi ,x j ) [?]
b (xi ,x j )) [?]
t i, j ([?
]xk (a (xi ,xk ) [?]
b (xk ,x j ))) [?]
[?]
p<= p>= (p [?]
p<= )C [?]
[?
]C (p [?]
p<= )  9  = !t i, j (a (xi ,x j )) = t i, j (a (xi ,x j )) [?]
t i, j (b (xi ,x j )) = t i, j (a (xi ,x j )) [?]
t i, j (b (xi ,x j )) = t k,i (a (xi ,xk )) D t k, j (b (xk ,x j ))[?]
t i,k (a (xi ,xk ))C t k, j (b (xk ,x j ))[?]
t j,k (b (xk ,x j )) T t i,k (a (xi ,xk ))  Table 1 The mapping of FO3,2 sp [<] into CDTBS : translation rules.
Theorem 3 AA [?]
FO2,2 [<].
Theorem 4 CDT [?]
FO3,2 [<].
The proof of Theorem 2 shows that for any given n >= 2, there exist two models M1 and M2 such that M1 and M2 satisfy the same set of FOn,2 [<]-formulas, and there exists an FOn+1,2 [<]-formula which is satisfied by M1 and not by M2 .
Equivalence of M1 and M2 with respect to FOn,2 [<]-formulas is established by a game-theoretic argument, while the FOn+1,2 [<]-formula that differentiates the two models is the following one: ^  [?
]x1 [?
]x2 .
.
.
[?
]xn [?
]xn+1 !p(xi , x j ) .
(6) xi 6=x j  Since such a formula belongs to Bernays-Schonfinkel fragment of first-order logic, the very n+1,2 same argument can be used to prove that FOn,2 BS [<] [?]
FOBS [<], for any n >= 2.
Moreover, n,2 by Theorem 4, it holds that FOBS [<] [?]
FOn,2 [<], for every n >= 3: on the one hand, it o ,2 n,2 trivially holds that FOn,2 BS [<]  FO [<]; on the other hand, decidability of FOBS [<] and n,2 n,2 undecidability of CDT imply that FO [<] 6 FOBS [<].
Finally, we have that, for every n+1,2 n+1,2 n >= 3, FOn,2 [<] and FOBS [<] are incomparable: on the one hand, FOBS [<] 6 FOn,2 [<], n+1,2 as formula (6) belongs to FOBS [<] and there is not an equivalent formula in FOn,2 [<]; n+1,2 on the other hand, FOBS [<] is decidable, while FOn,2 [<] is not, and thus FOn,2 [<] 6 n+1,2 FOBS [<].
Hence, the following theorem holds.
Theorem 5 For every n >= 3, it holds that: n-1,2 n,2 1.
FOBS [<] [?]
FOBS [<]; n,2 n,2 2.
FOBS [<] [?]
FO [<]; n+1,2 3.
FOn,2 [<] and FOBS [<] are incomparable  (over the class of all linear orders).
We conclude the section by showing that CDTBS is expressively complete with respect to FO3,2 BS [<].
One direction is straightforward: since the standard translation of CDTBS formulas given in Section 3 makes use of 3 variables only, it holds that CDTBS  FO3,2 BS [<].
We now show that the converse holds as well, that is, FO3,2 [<]  CDT .
By analogy BS BS to the case of the mapping from FO3,2 [<] to CDT defined by Venema [33], as a preliminary step, we provide a suitable characterization of FO3,2 BS [<]-formulas.
10  Davide Bresolin et al.
Definition 2 Let {i, j, k} [?]
{1, 2, 3}.
The language FO3,2 sp [<] is defined by the following abstract grammar:  b (xi , x j ) ::= b[?]
(xi , x j ) | b (xi , x j ) [?]
b (xi , x j ) | b (xi , x j ) [?]
b (xi , x j ) | [?
]xk (b (xi , xk ) [?]
b (xk , x j )) | !b[?]
(xi , x j ) for b[?]
(xi , x j )  (7)  of the form [?
]xk (b[?]
(xi , xk ) [?]
b[?]
(xk , x j ))  b[?]
(xi , x j ) ::= A(xi , x j ) | !A(xi , x j ) | b[?]
(xi , x j ) [?]
b[?]
(xi , x j ) | b[?]
(xi , x j ) [?]
b[?]
(xi , x j ) | [?
]xk (b[?]
(xi , xk ) [?]
b[?]
(xk , x j )) A(xi , x j ) ::= xi = x j | x j = xi | xi = xi | x j = x j | xi < x j | x j < xi | xi < xi | x j < x j | p(xi , x j ) | p(x j , xi ) | p(xi , xi ) | p(x j , x j )  (8) (9)  3,2 Lemma 2 For every formula in FO3,2 BS [<], there is an equivalent formula in FOsp [<].
3,3 Proof We prove the following stronger claim on the 3-variable fragment FOBS [<], which includes formulas where all three variables occur free:  for every formula a in FO3,3 BS [<] there is equivalent formula t (a ), which is a 3,2 Boolean combination of FOsp [<]-formulas, with the same free variables as a .
The proof is by structural induction.
The base cases (a is an atomic formula or a is the negation of an atomic formula) and the case of logical connectives (a is a conjunction or a disjunction of formulas) are straightforward.
In particular, as for the base case, it suffices to remind that we restricted our attention to fragments of first-order logic with binary predicates only.
Let a be of the form [?
]xk g (xi , x j , xk ).
By the inductive hypothesis, g (xi , x j , xk ) is equivalent to a formula t (g (xi , x j , xk )), that we may assume, without loss of generality, to be a disjunction of conjunctions of formulas in FO3,2 the existential quansp [<].
By distributing W tifier [?
]xk over disjunctions, we obtain a formula of the form m h=1 [?
]xk gh (xi , x j , xk ), where each gh (xi , x j , xk ) is a conjunction of formulas.
Since only binary predicates are allowed, we can rewrite each gh (xi , x j , xk ) as xh (xi , x j ) [?]
xh (xi , xk ) [?]
xh (x j , xk ).
Since variable xk does not occur free in xh (xi , x j ), we can rewrite [?
]xk gh (xi , x j , xk ) as xh (xi , x j ) [?]
[?
]xk (xh (xi , xk ) [?]
3,2 xh (x j , xk )).
This latter formula is a conjunction of FOsp [<]-formulas with the same free variables as a .
The case in which a is of the form ![?
]xk g (xi , x j , xk ) can be dealt with in a very similar way.
[?]
[?]
We are now ready to define the translation t from FO3,2 sp [<] to CDTBS .
For the sake of brevity, we write t i, j for t [xi , x j ], with xi <= x j .
Translation rules for atomic and complex formulas are given in Table 1.
Lemma 3 Let a (xi , x j ) be an FO3,2 sp [<]-formula.
Then, for every pair of points (di , d j ), M |= a (di , d j ) if and only if di <= d j and z (M), [di , d j ]  t i, j (a (xi , x j )), or d j <= di and z (M), [d j , di ]  t j,i (a (xi , x j )).
Proof The proof is by induction on the structure of a (xi , x j ).
The cases of atomic formulas and Boolean connectives are straightforward.
Once more, the only interesting case is the one of existential quantifiers.
Let a (xi , x j ) be the formula [?
]xk (b (xi , xk ) [?]
g (xk , x j )) and di <= d j .
By the semantic clauses for FO3,2 sp [<], it  The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  11  FOo ,2 [<] ,2 FOo BS [<]  ...  FO4,2 [<] CDT [?]
FO3,2 [<] PNL [?]
FO2,2 [<]  ...  FO4,2 BS [<]  [?]
CDTBS FO3,2 BS [<]  Fig.
2 A classification of the considered interval logics and fragments of first-order logic with respect to their expressive power.
holds that M |= [?
]xk (b (di , xk ) [?]
g (xk , d j )) if and only if there exists a point dk such that M |= b (di , dk ) and M |= g (dk , d j ).
Since we are interpreting our formulas over a linear order, there are three possible ways to place dk with respect to di and d j : either dk <= di , or di <= dk <= d j , or d j <= dk .
By the inductive hypothesis, we have that M |= a (di , d j ) if and only if:   z (M), [dk , di ]  t k,i (b (xi , xk )) and z (M), [dk , d j ]  t k, j (g (xk , x j ))   or z (M), [di , dk ]  t i,k (b (xi , xk )) and z (M), [dk , d j ]  t k, j (g (xk , x j ))   or z (M), [d j , dk ]  t j,k (g (xk , x j )) and z (M), [di , dk ]  t i,k (b (xi , xk )) .
By the semantics of the C, D, and T operators, we can conclude that M |= a (di , d j ) if and only if z (M), [di , d j ]  t i, j (a (xi , x j )), as required.
[?]
[?]
Theorem 6 CDTBS is as expressive as FO3,2 BS [<].
3,2 Proof By Lemma 2 and Lemma 3, FO3,2 BS [<]  FOsp [<]  CDTBS .
Moreover, by Lemma 3,2 1, CDTBS  FO3,2 [?]
[?]
BS [<].
Hence, CDTBS [?]
FOBS [<].
Figure 2 gives a graphical account of the relationships among the considered logics (interval logics and fragments of first-order logic) in terms of their expressive power (the contributions of the present work are in boldface).
5 A tableau method for CDTBS In [15], Goranko et al.
propose a tableau method for CDT interpreted over partial orders with the linear interval property, that is, partial orders in which every interval is linear (BCDT+ for short).
The method provides a semi-decision procedure for BCDT+ (it is not guaranteed to terminate).
This does not come as a surprise as BCDT+ is undecidable.
In this section, we show how to turn the method into an NP decision procedure CDTBS .
In particular, we show how to exploit BCDT+ syntactic restrictions to guarantee termination.
Let us start with some basic terminology.
A finite tree is a finite directed acyclic graph in which every node, apart from one (the root), has exactly one incoming edge.
A successor of a node n is a node n' such that there is an edge from n to n' .
A leaf is a node with no  12  Davide Bresolin et al.
successors.
A path is a sequence of nodes n0 , .
.
.
, nk such that, for all i = 0 .
.
.
k - 1, ni+1 is a successor of ni ; a branch is a path from the root to a leaf.
The height of a node n is the maximum length (number of edges) of a path from n to a leaf, while its depth is the length of the (unique) path from the root to it.
If two nodes n and n' belong to the same branch and the height of n is less than (resp., less than or equal to) the height of n' , we write n [?]
n' (resp., n  n' ).
Definition 3 Let D be a finite linear order.
A labeled formula over D is a pair (ps , [di , d j ]), where ps [?]
CDTBS and [di , d j ] [?]
I(D).
Definition 4 Let T be a (finite) tree and let n be a node of T .
The decoration n (n) of n is a tuple hps , [di , d j ], D, p, ui, where D is a finite linear order, (ps , [di , d j ]) is a labeled formula over D, p [?]
{0, 1}, and u is a local flag function which associates the values 0 or 1 with every branch B containing n. Definition 5 A decorated tree is a finite tree T enriched with a decoration n (n) for each node n of T , apart from the root.
The tableau construction described below generates a decorated tree T .
Given a branch B and a node n belonging to it, with decoration n (n), u(B) = 1 means that n can be expanded on B.
Given a branch B, B * (n1 * .
.
.
* nh ) is the result of the expansion of B with the sequence of nodes n1 *.
.
.
*nh (for h = 1, we simply write B*n), while B*(n1,1 *.
.
.
*n1,h )| .
.
.|(nk,1 *.
.
.
*nk,h ) is the result of the expansion of B with k sequences of h nodes (for h = 1, we simply write B * n1 | .
.
.|nk ).
The auxiliary flag p has been added to simplify termination and complexity proofs.
It records the nature of formula ps : if ps is a ph[?]
-formula, then p = 0; otherwise, p = 1.
Finally, if n is the leaf of a branch B, we denote by DB the finite linear order in n (n).
Since in CDTBS negation can occur only in front of proposition letters or modalities, we need to introduce the notion of dual formula of a formula ph , denoted by ph .
It is inductively defined as follows: - - - - -  p = !p and !p = p, for every p [?]
A P [?]
{p }; ph [?]
ps = ph [?]
ps; ph [?]
ps = ph [?]
ps; ph R ps = !
(ph R ps ), for R [?]
{C, D, T }; !
(ph R ps ) = ph R ps , for R [?]
{C, D, T }.
Notice that the dual of a generic CDTBS -formula does not necessarily belong to CDTBS .
This is the case, for instance, with the formula pC !
(qC r).
However, the following lemma guarantees that dual formulas of ph[?]
-formulas are CDTBS -formulas.
Such a lemma will play a crucial role in the proof of correctness of the tableau method.
Lemma 4 Let ph be a ph[?]
-formula.
Then, ph is a CDTBS -formula.
Proof The cases of proposition letters and Boolean connectives can be proved by a straightforward structural induction.
To prove that the thesis holds also for modalities, let us assume ph = ps C t to be a ph[?]
-formula.
By definition, the dual formula ph is !
(ps C t ).
Since ps , t are ph[?]
-formulas, we can conclude that ph is a CDTBS -formula.
The other cases can be dealt with in a similar way.
[?]
[?]
The construction of a tableau for a CDTBS -formula ph to be checked for satisfiability starts from a three-node tree (initial tableau) consisting of a root and two leaves with decorations hph , [d0 , d0 ], {d0 }, 1, 1i and hph , [d0 , d1 ], {d0 < d1 }, 1, 1i, respectively.
The procedure exploits  The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  13  a set of expansion rules, adapted from those given in [15], to add new nodes to the tree.
In particular, the original rules for modalities have been revised to restrict the search for possible models to linear orders only.
Definition 6 Given a tree T , a branch B in T , and a node n [?]
B with decoration hps , [di , d j ], D, pn , un i such that un (B) = 1, the branch-expansion rule for B and n is defined as follows (in all considered cases, un' (B' ) = 1 for all new nodes n' and branches B' ).
R1 If ps = x0 [?]
x1 , then expand B to B*n0 *n1 , where n0 is decorated with hx0 , [di , d j ], DB , pn , un0 i and n1 is decorated with hx1 , [di , d j ], DB , pn , un1 i. R2 If ps = x0 [?]
x1 , then expand B to B*n0 | n1 , where n0 is decorated with hx0 , [di , d j ], DB , pn , un0 i and n1 is decorated with hx1 , [di , d j ], DB , pn , un1 i. R3 If ps = !
(x0 C x1 ) and d is a point in DB , with di <= d <= d j , which has not been used yet to expand n in B, then expand B to B * n0 |n1 , where n0 is decorated with hx0 , [di , d], DB , 0, un0 i and n1 is decorated with hx1 , [d, d j ], DB , 0, un1 i. R4 If ps = !
(x0 D x1 ), and d is a point in DB , with d <= di , which has not been used yet to expand n in B, then expand B to B * n0 |n1 , where n0 is decorated with hx0 , [d, di ], DB , 0, un0 i and n1 is decorated with hx1 , [d, d j ], DB , 0, un1 i. R5 If ps = !
(x0 T x1 ), and d is a point in DB , with d j <= d, which has not been used yet to expand n in B, then expand B to B* n0 |n1 , where n0 is decorated with hx0 , [d j , d], DB , 0, un0 i and n1 is decorated with hx1 , [di , d], DB , 0, un1 i. R6 If ps = x0 C x1 , then expand B to B * (ni * mi )| .
.
.|(n j * m j )|(n'i * m'i )| .
.
.|(n'j-1 * m'j-1 ), where: (a) for all i <= k <= j, nk is decorated with hx0 , [di , dk ], DB , pn , unk i and mk is decorated with hx1 , [dk , d j ], DB , pn , umk i; (b) for all i <= k <= j - 1, Dk is the linear ordering obtained from DB by inserting a new point d between dk and dk+1 , n'k is decorated with hx0 , [di , d], Dk , pn , un' i and m'k is k decorated with hx1 , [d, d j ], Dk , pn , um' i. k  R7 If ps = x0 D x1 and d0 is the least point of DB , then expand B to B * (n0 * m0 )| .
.
.|(ni * mi )|(n'0 * m'0 )| .
.
.|(n'i * m'i ), where: (a) for all 0 <= k <= i, nk is decorated with hx0 , [dk , di ], DB , pn , unk i and mk is decorated with hx1 , [dk , d j ], DB , pn , umk i; (b) for all 0 <= k <= i, Dk is the linear ordering obtained from DB by inserting a new point d between dk-1 and dk (for k = 0, d is placed immediately before d0 ), n'k is decorated with hx0 , [d, di ], Dk , pn , un' i and m'k is decorated with hx1 , [d, d j ], Dk , pn , um' i. k  k  R8 If ps = x0 T x1 and dN is the greatest point of DB , then expand B to B * (n j * m j )| .
.
.|(nN * mN )|(n'j * m'j )| .
.
.|(n'N * m'N ), where: (a) for all j <= k <= N, nk is decorated with hx0 , [d j , dk ], DB , pn , unk i and mk is decorated with hx1 , [di , dk ], DB , pn , umk i; (b) for all j <= k <= N, Dk is the linear ordering obtained from DB by inserting a new point d between dk and dk+1 (for k = N, d is placed immediately after dN ), n'k is decorated with hx0 , [d j , d], Dk , pn , un' i and m'k is decorated with hx1 , [di , d], Dk , pn , um' i. k  k  Finally, for each branch B' extending B, let um (B' ) = um (B), for each node m 6= n in B, and let un (B' ) = 0, unless ps = !
(x0C x1 ), ps = !
(x0 Dx1 ), or ps = !
(x0 T x1 ) (in such cases un (B' ) = 1).
14  Davide Bresolin et al.
We briefly explain the behavior of the branch-expansion rule in cases R6 (x0 C x1 ) and R3 (!
(x0C x1 )).
The corresponding cases for modalities D and T are similar.
R6 deals with two possible scenarios: either there exists dk [?]
DB such that x0 holds over [di , dk ] and x1 holds over [dk , d j ], or such a point must be added to DB .
The successors (ni * mi )| .
.
.|(n j * m j ) created by the rule cover the former case, while the successors (n'i * m'i )| .
.
.|(n'j-1 * m'j-1 ) cover the latter case.
As for R3, the formula !
(x0 C x1 ) states that, for all di <= d <= d j , either x0 holds over [di , d] or x1 holds over [d, d j ].
R3 imposes such a condition for a single point d [?]
DB and keeps the flag equal to 1.
In such a way, all points in DB are eventually considered, including those points that will be added in subsequent steps of the tableau construction.
Definition 7 A branch B is closed if one of the following conditions holds: 1. there are two nodes n, n' in B such that n (n) = hps , [di , d j ], D, p, ui and n (n' ) = hps , [di , d j ], D' , p' , u' i for some formula ps and di , d j [?]
D; 2. there is a node n such that n (n) = hp , [di , d j ], D, p, ui and di 6= d j ; 3. there is a node n such that n (n) = h!p , [di , d j ], D, p, ui and di = d j ; If none of the above conditions hold, the branch is open.
Definition 8 The branch-expansion strategy for a branch B in a decorated tree T is defined as follows: 1. apply the branch-expansion rule to a branch B only if it is open; 2. if B is open, apply the branch-expansion rule to the closest to the root node n such that un (B) = 1 and the application of the rule generates at least one node with a new decoration (if any).
Definition 9 A tableau T is any decorated tree obtained from the initial tableau by the application of the branch-expansion strategy.
We say that a tableau T is closed if and only if all its branches are closed, otherwise it is open.
We conclude the section by giving a couple of examples of the application of the proposed method.
As a first example, we consider the satisfiable formula ph = (!p D !p )C !p .
A portion of a tableau for ph is given in Figure 3, where thick edges highlights an open branch representing a four-point model for the formula.
As a second example, let ps be the unsatisfiable formula p T !([?
]C p).
A closed tableau for ps is given in Figure 4.
It is worth pointing out that there is an abuse of notation in the last component of the node decorations: while it is formally defined as a function from a set of branches to {0, 1}, in the pictures it is represented as a constant (either 0 or 1).
The reason is that in the proposed examples the function is constant for each node, that is, for each n we have that the value of the function un (B) is the same for every branch B containing n. In the following, we will show that to establish the satisfiability of a CDTBS -formula ph it is sufficient to start with the initial tableau for ph , and keep expanding it for as long as it is possible: if the resulting tableau is open, then ph is satisfiable, otherwise it is not.
Moreover, we will prove that this expansion procedure terminates and it can be executed by a nondeterministic machine that uses only a polynomial amount of time.
The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  15  root     (!p D !p )C !p , [d0 , d0 ], {d0 }, 1, 0     (!p D !p )C !p , [d0 , d1 ], {d0 < d1 }, 1, 0   !p D !p , [d0 , d0 ], {d0 }, 1, 1     !p , [d0 , d0 ], {d0 }, 1, 1  x           !p D !p , [d0 , d0 ], {d0 < d1 }, 1, 1     !p D !p , [d0 , d1 ], {d0 < d1 }, 1, 1     !p , [d1 , d1 ], {d0 < d1 }, 1, 1   !p D !p , [d0 , d2 ], {d0 < d2 < d1 }, 1, 0     !p , [d2 , d1 ], {d0 < d2 < d1 }, 1, 1  x   !p , [d0 , d1 ], {d0 < d1 }, 1, 1 ***         !p , [d0 , d2 ], {d0 < d2 < d1 }, 1, 1      !p , [d3 , d0 ], {d3 < d0 < d2 < d1 }, 1, 1      !p , [d0 , d0 ], {d0 < d2 < d1 }, 1, 1      !p , [d3 , d2 ], {d3 < d0 < d2 < d1 }, 1, 1  x Fig.
3 A portion of an open tableau for the formula (!p D !p )C !p .
5.1 Soundness In this subsection, we prove that the proposed tableau method is sound, that is, given a formula ph and a tableau T for it, if T is closed, then ph is not satisfiable.
In the next subsection, we will show that the method is also complete.
Lemma 5 (Soundness) Let ph be a CDTBS -formula and T be a tableau for it.
If T is closed, then ph is not satisfiable.
Proof Let n be a node in the tableau T , and let Dn = {d0 < .
.
.
< ds } be the linear ordering from n (n).
We will prove the following claim by induction on the height h of the node: if every branch including n is closed, then the set S(n) of all labeled formulas in the decorations of the nodes between n and the root is neither satisfiable in I(Dn ) nor in any extension of it.
If h = 0, then n is a leaf and the unique branch B containing n is closed.
Then, either S(n) contains both the labeled formulas (ps , [dk , dl ]) and (!ps , [dk , dl ]), for some CDTBS formula ps and dk , dl [?]
Dn , or the labeled formula (p , [dk , dl ]), for some dk 6= dl , or the labeled formula (!p , [dk , dl ]), for some dk = dl .
Take any model M = hI(D' ),V i, where D' extends Dn .
It holds that M, [dk , dl ]  ps if and only if M, [dk , dl ] 6 !ps , and, therefore, (ps , [dk , dl ]) and (!ps , [dk , dl ]) cannot be jointly satisfied.
Similarly, M, [dk , dl ]  p (resp., M, [dk , dl ]  !p ) if and only if dk = dl (resp., dk 6= dl ), and therefore (p , [dk , dl ]) (resp., (!p , [dk , dl ])) cannot be satisfied when dk 6= dl (resp., dk = dl ).
Now, suppose that h > 0.
Then, either n has been generated as one of the successors, but not the last one, when applying cases R1, R6, R7, or R8 of the branch-expansion rule, or the branch-expansion rule has been applied to some labeled formula (ps , [dk , dl ]) [?]
S(n) \{t }, where t is the labeled formula in the decoration n (n), to extend the branch at n. We  16  Davide Bresolin et al.
root       p T !([?
]C p),[d0 ,d0 ],{d0 },1,0   p,[d0 ,d0 ],{d0 },1,1     !([?
]C p),[d0 ,d0 ],{d0 },1,1    [?
],[d0 ,d0 ],{d0 },0,1     !p,[d0 ,d0 ],{d0 },0,1  x  x      p,[d0 ,d1 ],{d0 < d1 },1,1     !([?
]C p),[d0 ,d1 ],{d0 < d1 },1,1     [?
],[d0 ,d1 ],{d0 < d1 },0,1     !p,[d0 ,d1 ],{d0 < d1 },0,1  x  x        p T !([?
]C p),[d0 ,d1 ],{d0 < d1 },1,0   p,[d1 ,d1 ],{d0 < d1 },1,1     !([?
]C p),[d0 ,d1 ],{d0 < d1 },1,1    [?
],[d0 ,d1 ],{d0 < d1 },0,1     !p,[d1 ,d1 ],{d0 < d1 },0,1  x  x      p,[d1 ,d2 ],{d0 < d1 < d2 },1,1     !([?
]C p),[d0 ,d2 ],{d0 < d1 < d2 },1,1     [?
],[d0 ,d1 ],{d0 < d1 < d2 },0,1     !p,[d1 ,d2 ],{d0 < d1 < d2 },0,1  x  x  Fig.
4 A closed tableau for the formula p T !([?
]C p).
detail the latter case; the former one can be dealt with in the same way, and thus its analysis is omitted.
First, we observe that every branch passing through any successor of n must be closed.
It immediately follows that the inductive hypothesis applies to all successors of n. We consider the possible cases for the application of the branch-expansion rule to extend the branch at n, restricting our attention to the conceptually different ones only (the other cases can be dealt with in a similar way): - If ps = x0 [?]
x1 , R1 has been applied.
Then, there are two nodes n0 , n1 such that n (n0 ) = hx0 , [dk , dl ], D, p0 , u0 i, n (n1 ) = hx1 , [dk , dl ], D, p1 , u1 i.
Without loss of generality, we can assume n0 to be the successor of n and n1 to be the successor of n0 .
Since each branch containing n is closed, then each branch containing n1 is closed as well.
By the inductive hypothesis (n1 [?]
n), S(n1 ) is not satisfiable.
Since every model satisfying S(n) must, in particular, satisfy (x0 [?]
x1 , [dk , dl ]), and hence (x0 , [dk , dl ]) and (x1 , dk , dl ]), it follows that S(n), S(n0 ), and S(n1 ) are equi-satisfiable.
Therefore, S(n) is not satisfiable.
- If ps = x1 [?]
x2 , R2 has been applied.
Then, there exist two successor nodes n0 and n1 of n such that n (n0 ) = hx0 , [dk , dl ], D, p0 , u0 i, n (n1 ) = hx1 , [dk , dl ], D, p1 , u1 i, and both  The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  17  n0 [?]
n and n1 [?]
n. Since each branch containing n is closed, then each branch containing n0 or n1 is closed as well.
By the inductive hypothesis, S(n0 ) and S(n1 ) are not satisfiable.
Since every model satisfying S(n) must also satisfy (x0 , [dk , dl ]) or (x1 , [dk , dl ]), it follows that S(n) is not satisfiable.
- If ps = !
(x0 C x1 ), R3 has been applied.
For the sake of contradiction, let us assume S(n) to be satisfiable.
Then, since (!
(x0 C x1 ), [dk , dl ]) [?]
S(n), there is a model M = hI(D' ),V i such that D' extends Dn and M, [dk , dl ]  !
(x0C x1 ).
Hence, for each dt such that dk <= dt <= dl , M, [dk , dt ] 6 x0 or M, [dt , dl ] 6 x1 .
By construction, the two immediate successors of n are two nodes n0 and n1 and there exists a point dt , with dk <= dt <= dl , such that (x 0 , [dk , dt ]) is in n (n0 ) and (x 1 , [dt , dl ]) is in n (n1 ).
By the inductive hypothesis (both n0 [?]
n and n1 [?]
n), S(n0 ) and S(n1 ) are not satisfiable.
But, from the hypothesis of our reductio-ad-absurdum argument, there is a model M = hI(D' ),V i, where D' is an extension of Dn , such that M, [dk , dt ]  !x0 or M, [dt , dl ]  !x1 .
Thus, either S(n0 ) or S(n1 ) is satisfiable (by model M), leading to a contradiction.
- If ps = x0 C x1 , R6 has been applied.
For the sake of contradiction, let us assume S(n) to be satisfiable.
Then, there is a model M = hI(D' ),V i such that D' extends Dn and M, [dk , dl ]  x0 C x1 .
Hence, M, [dk , d]  x0 and M, [d, dl ]  x1 for some dk <= d <= dl .
Two cases are possible: 1.
If d [?]
Dn , then d = dt for some dk <= dt <= dl .
By R6, n has a successor, say it nt , which, in turn, has a successor, say it nt' , with n (nt ) = hx0 , [dk , dt ], Dn , pt , ut i and n (nt' ) = hx1 , [dt , dl ], Dn , pt' , ut' i.
By the inductive hypothesis (nt [?]
n and nt' [?]
nt ), S(nt' ) = S(n) [?
]{(x0 , [dk , dt ]), (x1 , [dt , dl ])} is not satisfiable.
But, from the hypothesis of our reductio-ad-absurdum argument, there is a model M = hI(D' ),V i, where D' is an extension of Dn , such that M, [dk , dt ]  x0 and M, [dt , dl ]  x1 .
Thus, S(nt' ) is satisfiable (by model M), leading to a contradiction.
2.
If d [?]
/ Dn , then there exists t such that k <= t <= l - 1 and dt < d < dt+1 .
By R6, n has a successor, say it nt , which, in turn, has a successor, say it nt' , with n (nt ) = hx0 , [dk , d], Dn [?]
{d}, pt , ut i, n (nt' ) = hx1 , [d, dl ], Dn [?]
{d}, pt' , ut' i.
By the inductive hypothesis (nt [?]
n and nt' [?]
nt ), S(nt' ) = S(n) [?
]{(x0 , [dk , d]), (x1 , [d, dl ])} is not satisfiable, which, as in the previous case, leads to a contradiction.
[?]
[?]
5.2 Completeness In this subsection, we prove that the proposed tableau method is complete, that is, whenever ph [?]
CDTBS is valid, every tableau T for !ph must be closed.
To this end, we need to preliminary prove some partial results.
Definition 10 Let ph be a CDTBS -formula and T0 be the initial tableau for it.
The limit tableau T for ph is the decorated tree generated as follows.
For all i >= 0, let Ti+1 be the tableau generated by the simultaneous application of the branch-expansion strategy to each branch in Ti .
If we ignore all flags from the decorations of the nodes in every Ti , we obtain a chain of decorated trees ordered by inclusion: T1 [?]
T2 [?]
.
.
.
[?]
Tk [?]
.
.
..
The limit tableau T is equal to  o S  Ti .
i=0  Notice that the above definition does not prelude the limit tableau from being infinite.
Later on, we will prove that it cannot be the case, that is, the limit tableau is always finite.
Nevertheless, finiteness (of the limit tableau) is not necessary to prove that the tableau method is complete.
18  Davide Bresolin et al.
The definitions of open and closed branch and tableau directly apply to the limit tableau as well.
In addition, we introduce the notion of saturated branch and tableau.
Definition 11 A branch in a (limit) tableau is saturated if there are no nodes on that branch to which the branch-expansion rule is applicable on the branch.
A (limit) tableau is saturated if every open branch in it is saturated.
We now show that the set of all labeled formulas on an open branch in a limit tableau has the saturation properties of a Hintikka set in first-order logic.
Lemma 6 Every limit tableau is saturated.
Proof Let B be a branch B in the limit tableau T and n be a node in B.
We prove that after every step of the expansion of that branch at which the branch-expansion rule becomes applicable to n (because n has just been introduced or a new point has been added) and the application of the rule generates at least a new node, then that rule is subsequently applied on B to that node.
The proof is by induction on depth(n) (the depth of node n).
Let us assume that depth(n) = l and the branch-expansion rule has become applicable to n. By the inductive hypothesis, the thesis holds for all nodes with depth(n) < l. If there are no nodes between the root (including the root) and n (excluding n) to which the branch-expansion rule is applicable at that moment, the next application of the branchexpansion rule on B is necessarily to n. Otherwise, let n* be the closest-to-n node between the root and n to which the branch-expansion rule is applicable, or will become applicable, on B at least once thereafter.
(Such a node exists because there are only finitely many nodes between n and the root.)
Since depth(n* ) < depth(n), by the inductive hypothesis, the branch-expansion rule has been subsequently applied to n* .
Then, the next application of the branch-expansion rule on B must have been to n and that completes the induction.
Suppose now that there exists a branch B in a limit tableau which is not saturated.
Let n be the closest-to-the-root node on B to which the branch-expansion rule is applicable.
If the case applicable to n is different from R3, R4, and R5, then the branch-expansion rule has become applicable to n at the step when n is introduced, and by the claim above, it has been subsequently applied.
Hence, the node has become unavailable thereafter, which contradicts the assumption.
Let us consider now the case of R3, that is, the formula in n (n) is !
(x0 C x1 ) (cases R4 and R5 are similar, and thus they are omitted).
An application of R3 on B would create two immediate successors with labeled formulas (x 0 , [di , d]) and (x 1 , [d, d j ]), at least one of them new on B.
For R3 to be applicable, points di , d j , and d must have been already introduced at some step of the construction of B.
Hence, at the moment when the three of them, and n, have appeared on the branch, the branch-expansion rule has become applicable to n. By the above claim, the rule has been subsequently applied on B and such an application must have introduced the labeled formulas (x0 , [di , d]) and (x1 , [d, d j ]) on B, which again contradicts the assumption.
[?]
[?]
Corollary 1 Let ph be a CDTBS -formula and T be the limit tableau for ph .
For every open branch B in T , the following closure properties hold: - If there is a node n [?]
B such that n (n) = (x0 [?]
x1 , [di , d j ], D, pn , un ), then there are a node n0 [?]
B such that n (n0 ) = (x0 , [di , d j ], D, pn0 , un0 ) and a node n1 [?]
B such that n (n1 ) = (x1 , [di , d j ], D, pn1 , un1 ).
- If there is a node n [?]
B such that n (n) = (x0 [?]
x1 , [di , d j ], D, pn , un ), then there are a node n0 [?]
B such that n (n0 ) = (x0 , [di , d j ], D, pn0 , un0 ) or a node n1 [?]
B such that n (n1 ) = (x1 , [di , d j ], D, pn1 , un1 ).
The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  19  - If there is a node n [?]
B such that n (n) = (x0 C x1 , [di , d j ], D, pn , un ), then there are two nodes n0 , n1 [?]
B such that n (n0 ) = (x0 , [di , d], D' , pn0 , un0 ) and n (n1 ) = (x1 , [d, d j ], D' , pn0 , un0 ), for some d [?]
DB , with di <= d <= d j , .
- If there is a node n [?]
B such that n (n) = (x0 D x1 , [di , d j ], D, pn , un ), then there are two nodes n0 , n1 [?]
B such that n (n0 ) = (x0 , [d, di ], D' , pn0 , un0 ) and n (n1 ) = (x1 , [d, d j ], D' , pn0 , un0 ), for some d [?]
DB , with d <= di .
- If there is a node n [?]
B such that n (n) = (x0 T x1 , [di , d j ], D, pn , un ), then there are two nodes n0 , n1 [?]
B such that n (n0 ) = (x0 , [di , d], D' , pn0 , un0 ) and n (n1 ) = (x1 , [d j , d], D' , pn0 , un0 ), for some d [?]
DB , with d >= d j , .
- If there is a node n [?]
B such that n (n) = (!
(x0 C x1 ), [di , d j ], D, pn , un ), then, for each d [?]
DB , with di <= d <= d j , there is a node n' [?]
B such that n (n' ) = (x 0 , [di , d], D' , pn' , un' ) or a node n' [?]
B such that n (n' ) = (x 1 , [d, d j ], D' , pn' , un' ).
- If there is a node n [?]
B such that n (n) = (!
(x0 D x1 ), [di , d j ], D, pn , un ), then for each d [?]
DB , with d <= di , there is a node n' [?]
B such that n (n' ) = (x 0 , [d, di ], D' , pn' , un' ) or a node n' [?]
B such that n (n' ) = (x 1 , [d, d j ], D' , pn' , un' ).
- If there is a node n [?]
B such that n (n) = (!
(x0 T x1 ), [di , d j ], D, pn , un ), then, for each d [?]
DB , with d >= d j , there is a node n' [?]
B such that n (n' ) = (x 0 , [di , d], D' , pn' , un' ) or a node n' [?]
B such that n (n' ) = (x 1 , [d j , d], D' , pn' , un' ).
The proof of Corollary 1 is straightforward, and thus it is omitted.
Lemma 7 (Completeness) If the limit tableau for some formula ph [?]
CDTBS is closed, then some finite tableau for ph is closed.
Proof Let us assume the limit tableau for ph to be closed.
Then, every branch closes at some finite step of the construction, and then it is not further expanded (it remains finite).
Since the branch-expansion rule always produces finitely many successors, every finite tableau is finitely branching, and hence so is the limit tableau.
Then, by Konig's lemma, the limit tableau, being a finitely branching tree with no infinite branches, must be finite.
This allows us to conclude that its construction stabilizes at some finite stage.
At that stage, a closed [?]
[?]
tableau for ph is constructed.
5.3 Termination and Complexity In this last subsection, we prove that the proposed tableau method is terminating, and we determine its computational complexity.
The proof rests on a pair of basic lemmas.
As a preliminary step, we define a counting function Count on B as follows: Count(B) =  [?]
|psn | * pn * un (B),  n[?
]B  where psn and pn are the formula and the p-flag in the decoration of n, respectively.
The following lemma proves that Count is non-increasing with respect to branch expansions.
Lemma 8 Let ph be a CDTBS -formula, B be a branch in a tableau for ph , and B' be an expansion of B generated by the application of the branch-expansion strategy of Definition 8.
Then, Count(B' ) <= Count(B).
Moreover, if B' is obtained from B by the application of R1, R2, R6, R7, or R8 to a node n with pn in n (n) equal to 1, then Count(B' ) < Count(B).
20  Davide Bresolin et al.
Proof Let T be a tableau for ph , B be a branch on it, and n be the closest-to-the-root node for which the branch-expansion rule is applicable.
Moreover, let B' be a branch obtained by the application of the branch-expansion strategy on B.
We consider the cases of the application of R1, R3, and R6 to n. The missing cases are similar to the considered ones (R2 is similar to R1, R4 and R5 to R3, R7 and R8 to R6), and thus they are omitted.
- R1 is applied to n. Then, n (n) = hx0 [?]
x1 , [di , d j ], D, pn , un i and B' = B * n' * m' , with x0 belonging to n (n' ) and x1 belonging to n (m' ).
Since pn' = pm' = pn , un' (B' ) = um' (B' ) = 1, un (B' ) = 0, and um (B' ) = um (B) for each m 6[?]
{n, n' , m' }, Count(B' ) = Count(B) - |x0 [?]
x1 |+|x0 |+|x1 | < Count(B), when pn = 1, and Count(B' ) = Count(B) when pn = 0.
- R3 is applied to B.
Then, n (n) = h!
(x0 C x1 ), [di , d j ], D, pn , un i and B' = B * n' , with x0 or x1 belonging to n (n' ).
In both cases, pn' in n (n' ) is equal to 0, and thus Count(B' ) = Count(B).
- R6 is applied to B.
Then, n (n) = hx0 C x1 , [di , d j ], D, pn , un i and B' = B * n' * m' , with x0 belonging to n (n' ) and x1 belonging to n (m' ).
Since pn' = pm' = pn , un' (B' ) = um' (B' ) = 1, un (B' ) = 0, and um (B' ) = um (B) for each m 6[?]
{n, n' , m' }, Count(B' ) = Count(B) - |x0 C x1 | +|x0 | +|x1 | < Count(B) when pn = 1, and Count(B' ) = Count(B) when pn = 0.
Summing up, whatever Ri one applies, Count(B' ) <= Count(B).
Moreover, when R1, R2, R6, R7, or R8 are applied to a node n with pn in n (n) equal to 1, Count(B' ) < Count(B).
[?]
[?]
Lemma 9 Let ph be a CDTBS -formula, T be a tableau for ph , and n be a node in T with decoration n (n) = hps , [di , d j ], D, pn , un i.
It holds that if pn = 0, then ps [?]
ph[?]
.
Proof Let n be a node on a branch B in T with decoration n (n) = hps , [di , d j ], D, pn , un i.
We prove the claim by induction on depth(n).
Base case.
If depth(n) <= 2, then n is either the root or one of the leaves of the initial tableau.
In both cases, the claim follows trivially.
Inductive step.
Let depth(n) > 2.
By the inductive hypothesis, the claim holds for each ancestor of n in B.
Let n' be the node to which the branch-expansion rule has been applied during the construction of T to obtain node n. As in the proof of Lemma 8, we restrict our attention to R1, R3, and R6.
The other cases can be dealt with in a similar way.
- Rule R1 has been applied to n' .
Then, n (n' ) = hx0 [?]
x1 , [di , d j ], D, pn' , un' i and either x0 or x1 belong to n (n).
Let us assume that x0 belongs to n (n) (the case in which x1 belongs to n (n) is analogous) and pn = 0.
By definition of R1, pn' = pn = 0.
By the inductive hypothesis, x0 [?]
x1 = x0 [?]
x1 [?]
ph[?]
.
From the grammar rules for CDTBS , it follows that x0 [?]
ph [?]
.
- Rule R3 has been applied to B.
Then, n (n' ) = h!
(x0 C x1 ), [di , d j ], D, pn' , un' i and either x0 or x1 belong to n (n).
Let us assume that x0 belongs to n (n) (the case in which x1 belongs to n (n) is analogous).
By definition of R3, pn = 0.
By the grammar rules for CDTBS , it holds that x0 [?]
ph[?]
.
The thesis immediately follows from x0 = x0 .
- Rule R6 has been applied to B.
Then, n (n' ) = hx0 C x1 , [di , d j ], D, pn' , un' i and either x0 or x1 belong to n (n).
Let us assume pn' = 0.
By the inductive hypothesis, it follows that x0Cx1 = !
(x0Cx1 ) [?]
ph[?]
(contradiction).
Hence, it holds that pn' = 1, and thus, by R6, pn = 1.
[?]
[?]
By exploiting Lemma 8 and Lemma 9, we now prove that the length of any branch B of any tableau for ph is polynomially bounded by the length of the formula.
Lemma 10 (Termination) Let ph be a CDTBS -formula, T be a tableau for ph , and B be a branch in T .
Then, |B| <= 2 * |ph |3 + 8 * |ph |2 + 8 * |ph |.
The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  21  Proof Let B be a branch in a tableau T for ph .
Given the branch-expansion rule and the branch-expansion strategy, there cannot be two nodes n, n' in B such that the same formula and the same interval belong to both n (n) and n (n' ).
Since for any node n in B, the formula in n (n) is either a subformula of ph or the dual of a subformula of ph , it holds that |B| <= 2 * |ph | * |DB|2 .
To give a bound on the number of points in DB , it suffices to observe that: 1. only the application of R6, R7, and R8 add new points to DB ; 2. by Lemma 9, they can be applied only to nodes where the flag p is equal to 1; 3. by Lemma 8, every application of them strictly decreases the value of Count(B).
Now, let B0 be the two-node prefix of B consisting of the root and one of its successors labeled with ph .
Since |DB0 | <= 2 and Count(B0 ) = |ph |, |DB | <= |ph | + 2, and thus |B| <= 2 * |ph | * (|ph | + 2)2 <= 2 * |ph |3 + 8 * |ph |2 + 8 * |ph |.
[?]
[?]
Theorem 7 The proposed tableau method for CDTBS is sound and complete, and the satisfiability problem for CDTBS is NP-complete.
Proof By Lemma 5 (soundness) and Lemma 7 (completeness), it holds that satisfiability of a formula ph can be reduced to the search for an open limit tableau for it.
A direct consequence of Lemma 10 is that this search can be performed by a nondeterministic algorithm that guesses an open and saturated branch of the limit tableau, using only a polynomial amount of time.
NP-hardness immediately follows from that of propositional logic.
[?]
[?]
6 Undecidable extensions of CDTBS In the previous section, we have proved that the satisfiability problem for CDTBS is NPcomplete.
Since the full logic CDT is undecidable, one may wonder whether CDTBS can be extended preserving decidability.
In this section, we show that the most natural extension of CDTBS is already undecidable.
In CDTBS -formulas, modalities can occur in the scope of at most one negation.
We slightly extend CDTBS by allowing one more nesting of negations and modalities.
The resulting logic includes formulas like !(!
(pCq)Cq) or !(pC!(qCr)).
In [20], Hodkinson et al.
have shown that CDT is undecidable over the class of all linearly-ordered domains even if we restrict ourselves to formulas where only one modality occurs.
Undecidability has been proved by reducing the problem of finding a solution to the octant tiling problem to the satisfiability problem for the logic.
The undecidability proof below is based on the observation that the entire construction given in [20] exploits formulas where modalities occur in the scope of at most two negations.
Given a set of tiles T = {t1 , .
.
., tk }, the octant tiling problem is the problem of establishing whether T can tile an octant of the Cartesian plane over the integers.
Let us consider the second octant O = {(p, q) | p, q [?]
N, p <= q}.
Each tile ti has four colors, namely, right(ti ), le f t(ti ), up(ti ), and down(ti ).
Neighboring tiles must have matching colors.
Formally, we say that a set T can tile O if there exists a function f : O 7- T such that right( f (p, q)) = le f t( f (p + 1, q)) and up( f (p, q)) = down( f (p, q + 1)), where f (p, q) represents the tile to be placed in the position (p, q), provided that all relevant coordinates ((p, q), (p + 1, q), etc.)
lie in O.
Using Konig's lemma, one can prove that a tiling system tiles the second octant if and only if it tiles arbitrarily large squares if and only if it tiles N x N if and only if it tiles Z x Z. Undecidability of the first problem immediately follows from that of the last one [4].
22  Davide Bresolin et al.
Let T = {t1 , .
.
., tk } be an instance of the octant tiling problem.
We will assume that A P contains at least the propositional letters u,t1 , .
.
.,tk .
CDTBS makes it possible to define the "somewhere in the future" operator F (we assume future to be non-strict) as follows: F ph ::= [?]
T (ph T [?]).
(10)  The universal operator G can be defined as the dual of F, that is: Gph ::= !F!ph .
(11)  Making use of G, we set our framework by forcing the existence of unit-intervals (or uintervals) working like atomic elements.
Such intervals will be denoted by the proposition letter u.
We force u-intervals to be disposed in an unbounded unique (uninterrupted) sequence by means of the following formula: uT [?]
[?]
G(u - uT !u).
(12)  Lemma 11 Let M be a model such that M, [d, d ' ]  (12).
Then, there exists an infinite sequence of points d0 < d1 < .
.
., such that 1. d ' = d0 ; 2. for every l [?]
N, M, [dl , dl+1 ]  u.
The following formulas associate a unique tile with every u-interval; moreover, they guarantee that tiles are placed in such a way that they respect conditions on colors (a graphical account of the encoding is given in Figure 5): |T |  _  G(u -  ti ),  (13)  !
(ti [?]
t j ),  (14)  i=1 |T |  G  ^  i, j=1,i6= j  G  |T |  |T |  ^  _  (ti - !
(uT !
i=1   G u-  t j )),  (15)   !
(ti T t j ) .
(16)  j=1,up(ti )=down(tj ) |T |  ^  i, j=1,right(tj )6=left(ti )  It is easy to check that, in (12), (13), and (14), modalities occur in the scope of at most two negations.
Moreover, formulas (15) and (16) can be easily rewritten in such a way that modalities occur in the scope of at most two negations as well.
Now, let phT be the following formula: (12) [?]
(13) [?]
(14) [?]
(15) [?]
(16).
(17) We prove that the encoding is sound and complete.
Lemma 12 Let T = {t1 , .
.
.
, tk } be a set of tiles.
It holds that phT is satisfiable if and only if T tiles the second octant O.
The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  23  NN  t2 *  * t3  t3  u  t1 *  t2  99K  t1  u  ^ N Fig.
5 A pictorial representation of the encoding.
Proof (Soundness) Let M, [d, d ' ] |= phT .
We show that there exists a tiling function f : O 7- T .
By Lemma 11, we know that there exists an infinite sequence of points d0 < d1 < .
.
.
such that d ' = d0 and, for every i [?]
N, M, [yl , yl+1 ] |= u.
Now, for each l, m [?]
N, with l <= m, we put: f (l, m) = t whenever M, [dl , dm+1 ] |= t. First, we have to show that f is well-defined, that is, that each f (l, m) is a tile.
We proceed by induction on (m - l).
If (m - l) = 0, then, by Lemma 11, we are on a u-interval and thus, by (13), there exists a tile associated with it.
Since by (14) such a tile is unique, f is welldefined.
Suppose now that f (l, m) is a tile whenever m - l <= p, and consider m - l = p + 1.
Since (m - 1) - l <= p, by the inductive hypothesis f (l, m - 1) is a tile, say ti , which means W|T | that M, [dl , dm ] |= ti .
By (15), M, [dl , dm ] |= !
(uT !
j=1,up(ti )=down(tj ) t j ).
Hence, for every d >= dm , if M, [dm , d] |= u, then it must be the case that M, [dl , d] |=  W|T |  j=1,up(ti )=down(tj ) t j .
Since M, [dm , dm+1 ] |= u, this applies to the particular case d = dm+1 .
Thus, we have that M, [dl , dm+1 ] |= t j , that is, f (l, m) = tj , for some j such that down(tj ) = up(ti ) (again, since by (14) such a tile is unique, f is well-defined).
This not only guarantees us that f is well-defined, but also that it respects the 'vertical' condition of a tiling function.
To conclude the proof, we need to show that the 'horizontal' condition is respected as well.
To this end, let us consider f (l, m) and f (l + 1, m).
By definition, the corresponding tiles are those associated with [dl , dm+1 ] and [dl+1 , dm+1 ].
Since, by definition, the interval [dl , dl+1 ] is a u-interval, by (16) it cannot be the case that le f t( f (l + 1, m)) 6= right( f (l, m)), which implies that le f t( f (l + 1, m)) = right( f (l, m)).
[?]
[?]
(Completeness) For simplicity, let us assume the linearly ordered set to be (N, <).
One can force the truth of phT over [0, 0] by letting u be true over all intervals of length 1 and each ti be true over all intervals of the form [l, m + 1], where f (l, m) = ti .
[?]
[?]
Theorem 8 The satisfiability problem for any syntactic extension of CDTBS where modal operators occur in the scope of two negations is undecidable.
Proof The thesis directly follows from Lemma 12.
It is worth noticing that only modality T occurs in phT .
An alternative proof of Lemma 12 can be given by making use of modality C or of modality D only.
This shows that any fragment of CDT containing at least one modality among C, D, and T , where modalities are allowed to occur in the scope of two negations, is undecidable.
24  Davide Bresolin et al.
7 Conclusions and future work In this paper, we studied a syntactic fragment of Venema's CDT logic, that we called CDTBS , whose standard translation to first-order logic fits into Bernays-Schonfinkel class of quantifier prefix formulas.
Decidability of CDTBS directly follows from that of BernaysSchonfinkel class.
We first focused our attention on expressiveness issues.
We considered the following question: "can every formula in Bernays-Schonfinkel class of first-order logic over the linear order <, limited to binary predicates, be turned into a CDTBS -formula?".
We proved that this is not the case.
In [33], Venema showed that CDT is expressively complete with respect to FO3,2 [<].
In this paper, we showed that CDTBS is expressively complete with respect to 3,2 the corresponding fragment of Bernays-Schonfinkel class FOBS [<].
Next, we developed a tableau-based decision procedure for CDTBS , and we proved that the satisfiability problem for CDTBS is NP-complete.
Finally, we showed that any natural relaxation of the syntactic restrictions we imposed on CDTBS yields undecidability, as it makes the resulting logic expressive enough to encode the (undecidable) octant tiling problem.
The present work can be developed in a number of future research directions.
From a theoretical point of view, one can think of the possibility of identifying the interval temporal logic counterparts of other decidable classes of first-order formulas.
Moreover, the relationships between interval temporal logics and (extended) guarded fragments are still unexplored.
For instance, It would be interesting to give an account of the good computational properties of decidable fragments of CDT and HS (including CDTBS ) in terms of suitable guarded fragments.
From a more practical point of view, we expect CDTBS to be applicable in a variety of areas such as, for instance, planning and synthesis of plan controllers, temporal description logics, and sequencing problems in computational genetics.
Acknowledgements This work has been partially supported by the following research projects: EU project FP7-ICT-223844 CON4COORD (D. Bresolin), Italian PRIN project Innovative and multi-disciplinary approaches for constraint and preference reasoning (A. Montanari and D. Della Monica), Spanish MEC projects TIN2009-14372-C03-01 and RYC-2011-07821 (G. Sciavicco), and project Processes and Modal Logics (project nr.
100048021) of the Icelandic Research Fund (D. Della Monica).
References 1.
Allen, J.: Maintaining knowledge about temporal intervals.
Communications of the ACM 26(11), 832- 843 (1983) 2.
Andreka, H., van Benthem, J., Nemeti, I.: Back and forth between modal logic and classical logic.
Logic Journal of the IGPL 3(5), 685-720 (1995) 3.
Benthem, J.V., Thomason, S.K.
: Dynamic bits and pieces (1997) 4.
Borger, E., Gradel, E., Gurevich, Y.: The Classical Decision Problem.
Springer (1999) 5.
Bresolin, D., Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Decidable and undecidable fragments of Halpern and Shoham's interval temporal logic: towards a complete classification.
In: Proc.
of LPAR'08, LNCS, vol.
5330, pp.
590-604.
Springer (2008) 6.
Bresolin, D., Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Undecidability of interval temporal logics with the overlap modality.
In: Proc.
of TIME'09, pp.
88-95.
IEEE Comp.
Society (2009) 7.
Bresolin, D., Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Metric Propositional Neighborhood Logics.
Journal of Software and System Modeling (2012).
DOI: 10.1007/s10270-011-0195-y 8.
Bresolin, D., Goranko, V., Montanari, A., Sciavicco, G.: Propositional interval neighborhood logics: expressiveness, decidability, and undecidable extensions.
Annals of Pure and Applied Logic 161(3), 289-304 (2009)  The Light Side of Interval Temporal Logic: the Bernays-Schonfinkel fragment of CDT  25  9.
Bresolin, D., Montanari, A., Sala, P., Sciavicco, G.: Optimal tableaux for right propositional neighborhood logic over linear orders.
In: Proc.
of JELIA'08, LNAI, vol.
5293, pp.
62-75.
Springer (2008) 10.
Bresolin, D., Montanari, A., Sala, P., Sciavicco, G.: What's decidable about Halpern and Shoham's interval logic?
The maximal fragment ABBL.
In: Proc.
of LICS'11, pp.
387-396.
IEEE Comp.
Society Press (2011) 11.
Della Monica, D., Goranko, V., Montanari, A., Sciavicco, G.: Expressiveness of the interval logics of allen's relations on the class of all linear orders: Complete classification.
In: Proc.
of IJCAI'11, pp.
845-850 (2011) 12.
Etessami, K., Vardi, M.Y., Wilke, T.: First-order logic with two variables and unary temporal logic.
Information and Computation 179(2), 279-295 (2002) 13.
Gabbay, D., Hodkinson, I., Reynolds, M.: Temporal Logic: mathematical foundations and computational aspects.
Oxford University Press (1994) 14.
Gabbay, D., Pnueli, A., Shelah, S., Stavi, J.: On the temporal analysis of fairness.
In: Proc.
of POPL'80, pp.
163-173.
ACM Press (1980) 15.
Goranko, V., Montanari, A., Sala, P., Sciavicco, G.: A general tableau method for propositional interval temporal logics: theory and implementation.
Journal of Applied Logic 4(3), 305-330 (2006) 16.
Goranko, V., Montanari, A., Sciavicco, G.: Propositional interval neighborhood temporal logics.
Journal of Universal Computer Science 9(9), 1137-1167 (2003) 17.
Goranko, V., Montanari, A., Sciavicco, G.: A road map of interval temporal logics and duration calculi.
Applied Non-classical Logics 14(1-2), 9-54 (2004) 18.
Halpern, J., Shoham, Y.: A propositional modal logic of time intervals (short version).
In: Proc.
of LICS'86, pp.
279-292.
IEEE Comp.
Society (1986) 19.
Halpern, J.Y., Shoham, Y.: A propositional modal logic of time intervals.
J. ACM 38, 935-962 (1991) 20.
Hodkinson, I., Montanari, A., Sciavicco, G.: Non-finite axiomatizability and undecidability of interval temporal logics with C, D, and T. In: Proc.
of CSL'08, LNCS, vol.
5213, pp.
308-322.
Springer (2008) 21.
Immerman, N., Kozen, D.: Definability with bounded number of bound variables.
Information and Computation 83(2), 121-139 (1989) 22.
Kamp, H.: Events, instants and temporal reference.
In: Semantics from different points of view, pp.
27-54.
Springer (1979) 23.
Marcinkowski, J., Michaliszyn, J.: The ultimate undecidability result for the Halpern-Shoham logic.
In: Proc.
of LICS'11, pp.
377-386.
IEEE Comp.
Society Press (2011) 24.
Marcinkowski, J., Michaliszyn, J., Kieronski, E.: B and D are enough to make the Halpern-Shoham logic undecidable.
In: Proc.
of ICALP'10 - Part II, LNCS, vol.
6199, pp.
357-368.
Springer (2010) 25.
Montanari, A., Peron, A., Policriti, A.: Extending Kamp's theorem to model time granularity.
Journal of Logic and Computation 12(4), 641-678 (2002) 26.
Montanari, A., Puppis, G., Sala, P.: A decidable spatial logic with cone-shaped cardinal directions.
In: Proc.
of CSL'09, LNCS, vol.
5771, pp.
394-408.
Springer (2009) 27.
Montanari, A., Puppis, G., Sala, P.: A decidable spatial logic with cone-shape cardinal directions (extended version of [26]).
Research Report 3, Dipartimento di Matematica ed Informatica, Universita di Udine (2010) 28.
Montanari, A., Puppis, G., Sala, P.: Maximal decidable fragments of Halpern and Shoham's modal logic of intervals.
In: Proc.
of ICALP'10 - Part II, LNCS, vol.
6199, pp.
345-356.
Springer (2010) 29.
Montanari, A., Puppis, G., Sala, P., Sciavicco, G.: Decidability of the interval temporal logic ABB on natural numbers.
In: Proc.
of STACS'10, pp.
597-608 (2010) 30.
Otto, M.: Two variable first-order logic over ordered domains.
Journal of Symbolic Logic 66(2), 685-702 (2001) 31.
Szwast, W., Tendera, L.: The guarded fragment with transitive guards.
Annals of Pure and Applied Logics 128(1-3), 227-276 (2004) 32.
Venema, Y.: Expressiveness and completeness of an interval tense logic.
Notre Dame Journal of Formal Logic 31(4), 529-547 (1990) 33.
Venema, Y.: A modal logic for chopping intervals.
Journal of Logic and Computation 1(4), 453-476 (1991)