The Set of Support Strategy in Temporal Resolution Clare Dixon and Michael Fisher Department of Computing and Mathematics Manchester Metropolitan University Manchester M1 5GD U.K. E MAIL :  fC,Dixon,M.Fisherg@doc.mmu.ac.uk  Abstract  tions, experiments have shown that, in a number of cases, the basic method leads to the generation of an unnecessarily large set of clauses.
As the majority of these clauses are irrelevant to the refutation, it is clear that refinements are needed.
One approach, adopted in [11], is to refine the temporal resolution rule itself so that the original requirement to carry out all step resolution (effectively classical resolution) before attempting temporal resolution can be discarded.
An additional refinement has concerned the step resolution phase itself.
As in classical resolution, a set of support strategy [22] is used in attempting to derive a contradiction via step resolution [8].
However, in this work, the set of support is not utilised in successive temporal resolution phases.
While the above refinements of the basic temporal resolution approach have met with some success, we now consider utilising the set of support strategy throughout the resolution process.
This involves passing the set of support between step and temporal phases and modifying the temporal resolution rule to incorporate this strategy.
Thus, this paper introduces a new cycle of operations to be used in temporal resolution based on the set of support, proves the circumstances under which these restrictions are complete, and considers their implications for improvement in efficiency.
The aim of this is to provide a strategy which will focus, more closely, on the core elements required for a refutation.
The structure of the paper is as follows.
In x2 we define the form of temporal logic considered1 ,  A variety of proof methods have been developed to support the effective mechanisation of temporal logic.
While clausal temporal resolution has been successfully employed for a range of problems, a number of improvements are still required.
In particular, as there is no consistent control strategy underlying the method, a large amount of irrelevant information may sometimes be generated.
Following on from classical resolution, where the Set of Support strategy has been used very successfully, we here introduce, justify and apply a temporal version of this strategy, thus allowing the supporting set to be carried over between the different phases of the resolution method.
This not only restricts the production of irrelevant information but, under certain conditions, retains the completeness of the refutation process.
1 Introduction The effective mechanisation of temporal logic is vital to the application of temporal reasoning in many fields, for example the verification of reactive systems [13], the implementation of temporal query languages [4], and temporal logic programming [1].
Consequently, a range of proof methods have been developed, implemented and applied.
In addition to well-known tableau [21] and automata-theoretic [19] methods, there has been a resurgence in interest in resolution-based methods [2, 3, 20, 9].
Although clausal temporal resolution [9] has been developed and implemented [5, 6] and has been used successfully in a variety of applica-  1 For simplicity, we consider this future-time temporal logic rather than that defined in [9], which incorporated past-time operators.
1  namely Propositional Temporal Logic (PTL) [12], and review the original temporal resolution method.
In x3, we introduce, justify and apply the new method based throughout on the set of support strategy.
The implications of this approach, both for completeness of the resolution method and for its efficiency, are considered in x4.
Finally, in x5, we provide conclusions and discuss future work in this area.
2.
(Nullary connectives): WFF;  3.
(Unary connectives): if  2 WFF then WFF,  2 WFF, and () 2 WFF;  h  4.
(Binary connectives): if ; 2 WFF, and  U 2 WFF.
: 2  2 WFF, then  _  We define a model, M, for PTL as a structure  hD; p i where  D is the temporal domain, i.e.
2.1 Propositional Temporal Logic In this section, we present the syntax and semantics of the temporal logic we consider, namely PTL [12].
This generalises classical propositional logic, and thus it contains the standard propositional connectives : (not) and _ (or); the remaining connectives are assumed to be introduced as abbreviations in the usual way.
We use temporal connectives that can re(for anexta) and U fer to the future, namely (for auntila).
We explain these connectives in detail below.
The temporal connectives are interpreted over a flow of time that is linear, discrete, bounded in the past, and infinite in the future.
An obvious choice for such a flow of time is (N ; <), i.e., the natural numbers ordered by the usual aless thana relation.
Numbers (N ), and    the Natural  : D   !
fT ; F g is a function assigning T or F to each atomic proposition at each moment in time.
p  As usual, we define the semantics of the language via the satisfaction relation aj=a.
For PTL, this relation holds between pairs of the form hM ; u i (where M is a model and u 2 N ), and well-formed PTL formulae.
The rules defining the satisfaction relation are given below  h  hM ; u i j= true hM ; u i 6j= false hM ; u i j= start hM ; u i j= q hM ; u i j= : hM ; u i j=  _ hM ; u i j= h hM ; u i j=  U  2.1.1 Syntax We now formally present the syntax of PTL.
Definition 1 The language of PTL contains the following symbols:   = fp; q; r ; : : :g  2  2.1.2 Semantics  2 The Temporal Resolution Method  1.
A set tions;  true; false; start  of primitive proposi-  iff iff iff iff iff iff  2. true and false; 3.
The binary propositional connective _ (or), and unary propositional connective : (not);  =0 p (u ; q) = T (where q 2 ) hM ; u i 6j=  hM ; u i j=  or hM ; u i j= hM ; u + 1i j=  9v 2 N such that (u  v) and hM ; vi j= ; and 8w 2 N ; if (u  w < v) then hM ; wi j=  u  Satisfiability and validity in PTL are defined in the usual way.
Other standard temporal connectives are introduced as abbreviations, in terms of U , e.g.,  h  4.
The nullary temporal connective start, the (next) and biunary temporal connective nary temporal connective U (until).
}  Definition 2 The set WFF of well-formed formulae of PTL is defined by the following rules:  W  1.
(Primitive propositions are formulae): if p 2  then p 2 WFF;    = true U  = :}: = U _ def def def    We now informally consider the meaning of the temporal connectives.
First, consider the two 2  h  h h  basic connectives: and U .
The connective means aat the next timea.
Thus  will be satisfied at some time if  is satisfied at the next moment in time.
The U connective means auntila.
Thus  U will be satisfied at some time if is satisfied at either the present time or some time in the future, and  is satisfied at all times until the time that is satisfied.
As an example of the derived connectives,  will be satisfied at some time if  is satisfied either at the present moment or at some future time.
Finally, a temporal operator that takes no arguments is defined which is true only at the first moment in time: this operator is astarta.
For more information about PTL and its application in specification and verification see for example [13, 14].
(e) rewrite new resolvents into SNF until either false is derived or no more rules can be applied.
We briefly review each of these items, starting with the normal form itself.  }
2.2.1 Separated Normal Form This resolution method [9], depends on formulae being rewritten into a normal form, called Separated Normal Form (SNF) [10].
In this section, we review SNF but do not consider the transformation procedure that takes an arbitrary formula of PTL and rewrites it into SNF (for further details, see [10]).
We note that the transformation to SNF preserves satisfiability, i.e.
given any PTL formula ' that is satisfiable, its translation into SNF is also satisfiable [10].
A formula in SNF is of the form:  2.2 Basic Resolution Method for PTL Before describing the resolution method in detail, we outline the motivation for the approach adopted.
First, we recap the problems associated with clausal resolution in non-classical logics.
The main problem with extending resolution to temporal logics, such as PTL, is that literals cannot generally be moved across temporal contexts.
In particular, if T is a temporal operator, p and T:p cannot generally be resolved.
Thus, the only inferences that can be made occur in particular temporal contexts.
For example, both p and :p can be resolved, as, for certain types of temporal operator, can Tp and T:p. The clausal resolution method introduced in [9] addresses this problem by utilising a normal form, called Separated Normal Form (SNF), which separates out complex formulae from their contexts through the use of renaming [18], and a new temporal resolution rule introduced specifically for formulae in the normal form.
The resolution method consists of the following cycle of steps.
To determine whether a formula,  2 WFF, is unsatisfiable  ^ n  i =1  )  where each of the ai the following.
start  ^ q  mj  j=1  ^ q  j=1  mj  ) )  _  (i ) i ) ia  (called rules) is one of  r  (an initial rule)  lk  k =1  h_ l r  (an always rule)  k  k =1  ) }l  (a sometime rule)  where each mj , lk or l is a literal.
2.2.2 Step Resolution The step resolution rules are simply versions of the classical resolution rule rewritten in two ways.
First, the initial step resolution rule:  1.
Rewrite  into SNF 2.
Repeat  start start start  (a) apply step resolution until either a contradiction is generated, or no further step resolution can be carried out  ) ) )  _l _ :l 1_ 2 1 2  Then the global step resolution rule:  (b) rewrite any new resolvents into SNF (c) apply simplification and subsumption rules  (1 ^  (d) apply the temporal resolution rule 3  1 2 2 )  ) h( 1 _ l ) ) h( 2 _ :l ) ) h( 1 _ 2 )  2.2.3 Simplification  2.3 Example  The simplification rules used are similar to the classical case, consisting of both simplification and subsumption rules, and so will not be duplicated here.
An additional rule is required when a contradiction in a state is produced, i.e.,  We give an example showing the use of the step and temporal resolution rules.
Rules 1a17 are an unsatisfiable set of rules given in SNF.
start true  ) hfalse ) : ) h:  This shows that, if a particular formula leads to a contradiction, then that formula should not be satisfied either in the initial state or in any subsequent state.
2.2.4 Temporal Resolution Rather than describe the temporal resolution rule in detail, we refer the interested reader to [9].
The basic idea is to resolve one sometime rule with a set of always rules as follows.
1 2  .. .
n    9 >> >> .. .. >= .
. )
h >> ) }:l >> _ ) (:  ) W :l > ; =1 ) h1 ) h2  n  where for all  16i 6n  _ ) h(l ^ j ) j=1  n  a x y z  i  i  The side condition ensures that the set of i i rules together imply  h  The rules generated from step resolution are given in Figure 2.3.
Next temporal resolution is carried out.
The following (combined) rules form a loop in l and can be resolved with rule 16.  n  i  _ n  i  i =1  ) h  ) hl ) h(a _ :c) ) hc ) h(:c _ :p _ :q) ) h(:c _ p _ :q) ) h(:c _ :p _ q) ) h(:c _ p _ q) ) h(y _ z) ) hx ) hx ) hl ) hl ) hl ) d ) a ) }:l ) l  1: a 2: a a 3: 4: d e 5: 6: (f ^ p) 7: (g ^ q) x 8: 9: y 10: z 11: x 12: y 13: z 14: start 15: start 16: d 17: start  )  ) ) ) )  h(a ^ l ) h((y ^ l ) _ (z ^ l )) h h((xx ^^ ll ))  [1; 18] [8; 11] [9; 12] [10; 13]  This produces the resolvent d  l:  ) (:(a _ x _ y _ z)) W :l  which can be translated into SNF as follows where t is a new proposition.
Such a set of rules is known as a loop in l. The resolvent states that, once  has occurred, none of the i must occur while the eventuality (i.e.
:l) is outstanding.
This resolvent must again be translated into SNF.
43: 44: 45: 46: 47: 48: 49: 50: 51: 52: 53: 54: 55: 56: 57:  }  2.2.5 Termination Finally, if start ) false is produced, the original formula is unsatisfiable and the resolution process terminates.
2.2.6 Correctness The soundness and (refutation) completeness of the original temporal resolution method have been established in [9, 16, 5].
4  start start start start start true true true true true t t t t t  ) ) ) ) ) ) ) ) ) ) ) ) ) ) )  :d _ :y _ :l :d _ :z _ :l :d _ :a _ :l :d _ :x _ :l :d _ t _ :l h(:d _ :y _ :l ) h(:d _ :z _ :l ) h(:d _ :a _ :l ) h(:d _ :x _ :l ) h(:d _ t _ :l ) h(:y _ :l ) h(:z _ :l ) h(:a _ :l ) h(:x _ :l ) h(t _ :l )  18: a 19: (d ^ a ) 20: (e ^ a ) 21: (f ^ p ^ a ) 22: (g ^ q ^ a ) 23: (e ^ d ) 24: (f ^ p ^ d ) 25: (g ^ q ^ e) 26: (g ^ q ^ f ^ p) 27: (e ^ a ^ d ) 28: (f ^ p ^ a ^ d ) 29: (g ^ q ^ a ^ e) 30: (g ^ q ^ a ^ f ^ p ) 31: (g ^ q ^ e ^ f ^ p ^ d ) 32: start 33: true 34: start start 35: 36: a 37: (a ^ e) e 38: 39: (a ^ f ^ p) 40: (f ^ p ) 41: (a ^ e ^ g ^ q ^ f ^ p) 42: (e ^ g ^ q ^ f ^ p)  ) ha ) h(:p _ :q) ) h(p _ :q) ) h(:p _ q) ) h(p _ q) ) h(:c _ :q) ) h(:c _ :p) ) h(:c _ p) ) h(:c _ q) ) h:q ) h:p ) hp ) hq ) h:c ) (:g _ :q _ :a _ :e _ :f _ :p _ :d ) ) h(:g _ :q _ :a _ :e _ :f _ :p _ :d ) ) (:g _ :q _ :a _ :e _ :f _ :p) ) (:g _ :q _ :e _ :f _ :p) ) h(:g _ :q _ :e _ :f _ :p _ :d ) ) h(:g _ :q _ :e _ :f _ :d ) ) h(:g _ :q _ :a _ :e _ :f _ :d _ :c) ) h(:g _ :e _ :f _ :p _ :d ) ) h(:g _ :a _ :e _ :f _ :p _ :d _ :c) ) h(:g _ :e _ :f _ :d ) ) h(:g _ :a _ :e _ :f _ :d _ :c)  [2; 3] [3; 4] [3; 5] [3; 6] [3; 7] [4; 5] [4; 6] [5; 7] [6; 7] [19; 20] [19; 21] [20; 22] [21; 22] [23; 26] [3; 31] [3; 31] [14; 32] [15; 34] [18; 33] [20; 36] [5; 33] [21; 36] [6; 33] [29; 39] [25; 40]  Figure 1 Example initially identify a set of clauses, and then restrict resolution operations so that they occur between two clauses, at least one of which appears in the set of support.
The resolvent is then also added to the set of support.
More step resolution can be carried out and a contradiction produced by resolving rule 45 with rules 14,15 and 17.
58: 59: 60:  start start start  ) :a _ :l [14; 45] ) :l [15; 58] ) false [17; 59]  Definition 3 Supported Resolution.
A resolution inference between two clauses is said to be supported if and only if at least one of the clauses is a member of the set of support.
3 Set of Support (SoS) In this section the set of support for classical resolution is described and then extended to deal with the temporal case.
If the initial SoS is chosen appropriately, then this approach can lead to a refutation requiring less resolution steps than without using SoS by avoiding the production of excess (irrelevant) clauses.
While the use of the set of support is obviously sound, there is a possibility of incompleteness.
3.1 SoS in Classical Resolution The Set of Support strategy [22] is a now wellestablished mechanism for restricting resolution operations whilst searching for a proof.
It has been very successful, being central to a number of theorem-proving systems, in particular Otter [15], the predominant system for classical first-order logic.
The basic idea behind the set of support is to  Theorem 1 Completeness of Set of Support.
Given an unsatisfiable set of clauses, if the set of support is chosen such that the set of clauses outside the set of support is satisfiable then a 5  Note, although this guarantees completeness it is not necessary for it.
In some situations the detection of a non-maximal loop, is enough to lead to a contradiction.
Considering the example given in x 2.3 we will see (in x 4.1) that the detection of the (non-maximal) loop  refutation can be produced using only supported resolution steps.
Proof  See for example [22].
3.2 SoS in Temporal Resolution  a  The notion of the set of support being used in step resolution follows closely the classical version.
is sufficient to generate a contradiction.
Thus we actually only require the rules that are combined to make this loop to be in the set of support prior temporal resolution to retain completeness.
Definition 4 Supported Step Resolution.
A step resolution inference between two rules is said to be supported if and only if at least one of the rules is a member of the set of support.
3.3 Cycle of Operations The resolution method consists of the following cycle of steps.
To determine whether a formula,  2 WFF, is unsatisfiable  Theorem 2 Completeness of Supported Step Resolution.
Given an unsatisfiable set of initial and always rules, if the set of support is chosen such that for the set of rules outside the set of support the set of clauses on the right hand side of the initial rules is satisfiable and the set of clauses on the right hand side of the always rules is satisfiable then a refutation can be produced using only supported step resolution steps.
Proof  1.
Rewrite  into SNF, identifying set of support S 2.
Apply S-supported step resolution until either a contradiction is generated, or no further step resolution can be carried out 3.
Rewrite any new resolvents into SNF and add to S  Follows from the classical case.
However, in temporal resolution, it is a little more complex.
4.
Apply simplification and subsumption rules to S  Definition 5 Supported Temporal Resolution.
The resolvent produced by the temporal resolution rule below is supported if all the clauses required to form a loop (e.g.
n ) n ) are in the set of support.  }
5.
Choose a sometime rule, e.g.
: : : ) l, such that :l occurs on the right hand side of a rule in S, and apply the S-supported temporal resolution rule.
h  1 2  .. .
n    9 >> >> .. .. >= .
. )
h >> ) }:l >> _ ) (:  ) W :l > ; =1 ) h1 ) h2  n  n  where for all 1 6 i  _ ) h(l ^ j )  6.
Rewrite any new resolvents into SNF and add to S  6n  7.
If either false has been derived or no new resolvents have been been derived, then terminate, otherwise go to 2.  n  i  ) ha ^ l  j=1  i  4 Practical Usage  i  This seems like a strict criterion.
Indeed, the cases where this rule is complete is relatively limited.
In this section we examine how useful supported temporal resolution is.
First we reconsider the example given in x 2.3 using the set of support.
Theorem 3 Completeness of Supported Temporal Resolution.
The supported temporal resolution rule is complete if, prior to loop search, all clauses that must be combined to produce a loop are members of the set of support.
4.1 Example We place rules 1 and 2 in the set of support.
Only one rule is generated in the first cycle of 6  4.4 Limitations  step resolution namely  18: a ) ha [2; 3; SRES]  and added to the set of support.
Next as no more step resolution can be carried out we try temporal resolution with rule 16 and search for a loop in l in the set of support.
The loop detected is a  ) h(a ^ l )  from rules 1 and 18 producing the resolvent d  ) : a W :l  which is written into SNF and added to the set of support as follows.
19: 20: 21: 22: 23: 24:  true start true start t t  ) h(:d _ :a _ :l ) ) :d _ :a _ :l ) h(:d _ t _ :l ) ) :d _ t _ :l ) h(:a _ :l ) ) h(t _ :l )  [1; 16; 18; TRES] [1; 16; 18; TRES] [1; 16; 18; TRES] [1; 16; 18; TRES] [1; 16; 18; TRES] [1; 16; 18; TRES]  Now resolution is completed by resolving rule 20 with rules 14,15 and 17 to obtain a contradiction as follows.
25: 26: 27:  start start start  ) :a _ :l [14; 20; SRES] ) :l [15; 25; SRES] ) false [17; 26; SRES]  4.2 When the SoS is Useful The supported step and temporal resolution rules are useful in examples when a large amount of irrelevant rules are produced.
The example given in x 2.3 illustrates this.
Regarding step resolution many of the rules produced from step resolution in Figure 1 are irrelevant to the proof.
During loop detection not only do we have to search through a large amount of rules but we also detect a loop involving several literals when in fact the loop a ) a ^ l was sufficient to generate a contradiction.
This approach effectively restricts the search required for a loop [6] to a small set of clauses.
In order to retain this efficiency, but extend the completeness of the approach, we utilise the resolution rule developed in [11].
This means that the criterion that all the rules required for the loop must be in the set of support can be relaxed.
We have given no guidance how to choose the set of support in the first place.
Identifying a suitable set of support affects both the completeness and the efficiency of the method.
In classical resolution work has been carried out on using both semantic and syntactic methods to choose the set of support [22].
We anticipate that extensions of these methods can be adopted.
5 Conclusions and Further Work We have extended the notion of set of support to the temporal resolution case in order to minimise the amount of irrelevant information produced.
The approach works well on problems where the contradiction can be produced by limiting resolution steps to a particular subset of clauses.
More work needs to be done to consider how to choose the set of support in the first place and when these sets retain completeness.
The use of the temporal set of support is a restriction strategy utilised in the temporal resolution theorem prover (C LATTER) being developed currently at Manchester.
We will use C LATTER to test temporal set of support further.
Acknowledgements This work was partially supported by EPSRC under Research Grant GR/K57282.
Thanks for the comments from Adam Kellett and several anonymous referees on an earlier draft of this paper.
4.3 Results Initial experiments show that examples such as that illustrated, where much irrelevant information is generated, show the greatest reduction in the number of rules produced.
Work carried out on Petersonas Algorithm [17] shows that the loop search algorithm can still detect a loop from a subset of the complete ruleset reducing the number of combinations required to find the loop.
References [1] M. Abadi and Z.
Manna.
Temporal Logic Programming.
Journal of Symbolic Computation, 8: 277a295, 1989.
[2] M. Abadi and Z.
Manna.
Nonclausal Deduction in First-Order Temporal Logic.
ACM Journal, 37(2):279a317, April 1990.
7  [3] A. Cavali and L. FarinEas del Cerro.
A Decision Method for Linear Temporal Logic.
In R. E. Shostak, editor, Proceedings of the 7th International Conference on Automated Deduction, pages 113a127.
LNCS 170, 1984.
Symposium on the Principles of Programming Languages, pages 163a173, Las Vegas, Nevada, January 1980.
[13] Z.
Manna and A. Pnueli.
The Temporal Logic of Reactive and Concurrent Systems: Specification.
Springer-Verlag, New York, 1992.
[4] J. Chomicki and D. Niwinski.
On the Feasibility of Checking Temporal Integrity Constraints.
Journal of Computer and System Sciences, 51(3):523a535, December 1995.
[14] Z.
Manna and A. Pnueli.
Temporal Verification of Reactive Systems: Safety.
SpringerVerlag, New York, 1995.
[5] C. Dixon.
Strategies for Temporal Resolution.
PhD thesis, Department of Computer Science, University of Manchester, Manchester M13 9PL, U.K., December 1995.
[15] W. W. McCune.
OTTER 2.0 Users Guide.
Argonne National Laboratory, 9700 South Cass Avenue, Argonne, Illinois 604394801, March 1990.
ANL-90/9.
[6] C. Dixon.
Search Strategies for Resolution in Temporal Logics.
In Proceedings of the Thirteenth International Conference on Automated Deduction (CADE), Lecture Notes in Computer Science.
Springer-Verlag, August 1996.
[16] M. Peim.
Propositional Temporal Resolution Over Labelled Transition Systems.
Unpublished Technical Note, Department of Computer Science, University of Manchester, 1994.
[17] G. L. Peterson.
Myths about the Mutual Exclusion Problem.
Information Processing Letters, 12(3):115a116, 1981.
[7] C. Dixon.
Temporal Resolution: Removing Irrelevant Information.
In Proceedings of International Workshop on Temporal Reasoning (TIME), Daytona Beach, Florida, May 1997.
[18] D. A. Plaisted and S. A. Greenbaum.
A Structure-Preserving Clause Form Translation.
Journal of Symbolic Computation, 2(3):293a304, September 1986.
[8] C. Dixon.
Using Otter for Temporal Resolution.
In Proceedings the Second International Conference on Temporal Logic (ICTL), Applied Logic Series, Manchester, U.K., July 1997.
Kluwer.
To appear.
[19] A. P. Sistla, M. Vardi, and P. Wolper.
The Complementation Problem for BuEchi Automata with Applications to Temporal Logic.
Theoretical Computer Science, 49:217a237, 1987.
[9] M. Fisher.
A Resolution Method for Temporal Logic.
In Proceedings of the Twelfth International Joint Conference on Artificial Intelligence (IJCAI), Sydney, Australia, August 1991.
Morgan Kaufman.
[20] G. Venkatesh.
A Decision Method for Temporal Logic based on Resolution.
Lecture Notes in Computer Science, 206:272a289, 1986.
[10] M. Fisher.
A Normal Form for Temporal Logic and its Application in TheoremProving and Execution.
Journal of Logic and Computation, 7(4), August 1997.
[21] P. Wolper.
The Tableau Method for Temporal Logic: An overview.
Logique et Analyse, 110a111:119a136, June-Sept 1985.
[11] M. Fisher and C. Dixon.
Guiding Clausal Temporal Resolution.
In Proceedings the Second International Conference on Temporal Logic (ICTL), Applied Logic Series, Manchester, U.K., July 1997.
Kluwer.
To appear.
[22] L. Wos, G. Robinson, and D. Carson.
Efficiency and Completeness of the Set of Support Strategy in Theorem Proving.
ACM Journal, 12:536a541, October 1965.
[12] D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi.
The Temporal Analysis of Fairness.
In Proceedings of the Seventh ACM 8