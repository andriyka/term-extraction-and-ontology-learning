Temporal Resolution: Removing Irrelevant Information* Clare Dixon Department of Computing Manchester Metropolitan University Manchester M1 5GD, United Kingdom C.Dixon@doc.mmu.ac.uk  Abstract 'The generation of too m u c h information prohibits e f i c i e n t resolution proof search in classical logics.
Hence subsumption is used t o discard redundant inform a t i o n and strategies have been developed t o guide the proof search avoiding irrelevant information.
T h e extension o f the resolution method t o temporal logics, f o r example that by Fisher f o r propositional linear-time temporal logics, further magnifies this problem.
Here we provide a n algorithm t o eficiently remove irrelevant information prior t o the application of Fisher's temporal resolution rule, show it retains the completeness of the temporal resolution system and demonstrate its e f i c i e n c y o n a set of examples.
1  the number of resolution inferences that can be made and completeness can be maintained if the set of support is chosen so the conjunction of clauses n o t in the set of support is satisfiable.
Likewise, given sets of Horn Clauses, unit resolution is a strategy that is both efficient and complete.
Since the resolution principle was first suggested, extensions to more exotic logics such as temporal logics [15] have been proposed [l,5, 231.
Temporal logics have been used for the specification and verification of properties of concurrent systems, see for example [2, 12, 14, 181.
Proof methods have,also been developed for these logics based on tableau [ll, 241, automata [22, 251 and translation [17].
Resolution based methods have the advantage that they are not limited to finite state problems and, as for resolution in classical logics, strategies can be used to reduce the search space.
The complexity of such logics is a barrier to efficient proof, for example the complexity of satisfiability of PTL, the logic used in this paper, is PSPACE-complete [21].
Again, this motivates the need for strategies to guide proof search, hopefully avoiding the worst case complexity in many situations.
In this paper we examine the resolution method devised by Fisher [lo] for propositional linear-time temporal logic and we describe a way to reduce the amount of information prior to the application of the temporal resolution rule.
Fisher's temporal resolution system depends on three main parts; the translation to a normal form; classical style resolution of formulae that occur within the same state; and temporal resolution over states, of formulae such as Up (always p ) and o ~ (eventually p ~ p ) Fisher's .
method has been shown complete [19] and, as it has just one temporal resolution rule, is particularly suited to mechanization.
Unfortunately, even for small problems a large amount of information is generated, motivating the use of an algorithm t o remove information irrelevant to temporal resolution.
In the rest of the paper we describe propositional  Introduction  Resolution [20] is a decision procedure for classical propositional and first-order logic claimed to be m a chine oriented.
However, the proof of theorems may be slowed or even not finish due to the generation of too much information [28].
This information could either be irrelevant, i.e.
when a clause is produced that is not necessary for the proof or redundant, i.e.
when the information is already in the database [26].
In classical logics, to overcome such problems subsumption is used to remove redundant information while strategies have been suggested to guide resolution based proofs avoiding irrelevant information.
The set of support strategy [28] for example, restricts the application of the resolution rule so that at least one of the parent clauses must be from or derived from the set of support.
Unit resolution [27] only allows resolution inferences to take place if at least one of the parent clauses is a unit clause.
However, the imposition of such strategies may compromise the completeness of the resolution system, the ideal strategy being efficient while maintaining completeness.
For example the set of support strategy is efficient as it restricts *This work was supported partially by an EPSRC PhD Studentship and partially by EPSRC Research Grant GR/K57282  0-8186-7937-9/97 $10.00 0 1997 IEEE  4  temporal logic (PTL), SS2, and explain Fisher's resolution system in more detail, $3.
We present an algorithm to remove irrelevant information before the application of the temporal resolution rule and mention completeness and complexity issues in $4.
In $5 we give experimental results showing in most cases a reduction in the time for this part of the procedure.
Finally in '$6we present our conclusions.
2  lows (a,i) start iff i = 0; (a,i) b O A iff i > 0 and (a,i- 1) F A ; (0, i) O A iff there exists a j 2 i s.t.
( a , j ) A ; ( u l i ) O A iff for all j 2 i then ( a , j ) A; (a,i) AU B iff there exists a k 3 i s.t.
(a,k ) I= B and for all i j < k then ( a , j ) A; (a,i) A W B iff ( a l i ) A U B or (0,i) RA.
+  +  A Linear temporal logic  2.2  A normal form for PTL  Formulae in PTL can be transformed to a normal form, Separated Normal Form (SNF) [lo], which is the basis of the resolution method used in this paper.
While the translation from an arbitrary temporal formula to SNF will not be described here, we note that such a transformation preserves satisfiability and SO any contradiction generated from the formula in SNF implies a contradiction in the original formula.
Formulae in SNF are of the general form  '0'  opi 2  where each Ri is known as a rule and must be one of the following forms.
r  start E 1 Otrue  start  which only holds at the beginning of time.
Models for PTL consist of a sequence of states, representing moments in time, i.e.,  sj  V h,  (an initial U-rule)  b=l  A ka  start Here, each state, si, contains those propositions satisfied in the ith moment in time.
As formulae in PTL are interpreted at a particular moment, the satisfaction of a formula f is denoted by  v r  9  0  =+  lb  (a global 0-rule)  b=l  a=l  =+  01  (an initial 0-rule)  =+  01  (a global 0-rule)  9  O Aka a=l  Here ka, Zb, and Z are literals.
The outer ' 0' operator, that surrounds the conjunction of rules is usually omitted.
Similarly, for convenience the conjunction is dropped and we consider just the set of rules Ri.
We note a variant on SNF called merged-SNF (SNF,) [lo] used for combining rules by applying the following transformation.
I= f  (0,i)  where a is the model and i is the state index at which the temporal statement is to be interpreted.
For any well-formed formula f , model a and state index i, then either ( a , i ) f or ( ~ , i ) f. For example, a proposition symbol, 'p', is satisfied in model a and at state index i if, and only if, p is one of the propositions in state si, i.e., iff  +  The full syntax and semantics of PTL will not be presented here, but can be found in [lo].
Here we summarise the syntax and semantics of the logic used and describe the normal form required for the resolution method.
2.1 Syntax and semantics The logic used in this paper is Propositional Temporal Logic (PTL), in which we use a linear, discrete model of time with finite past and infinite future.
PTL may be viewed as a classical propositional logic augmented with both future-time and past-time temporal operators.
Future-time temporal operators include (sometime in the future), ' 0' (always in the future), '0' (in the next moment in time), ' U ' (until), ' W ' (unless or weak until), each with a corresponding past-time operator.
Since our temporal models assume a finite past, for convenience, we define an operator start in terms of the last-time operator ' 0 '  (a,i) /=p  +  <  +  OA  OB O(AAB)  +3 +  F G FAG  The right hand side of the rule generated may have to be further translated into Disjunctive Normal Form (DNF), if either F or G are disjunctive, to maintain the general SNF rule structure.
p E si.
The semantics of the temporal connectives used in the normal form or the resolution rule are defined as fol-  5  3  The resolution procedure  Here we present a review of the temporal resolution method [lo].
The clausal temporal resolution method consists of repeated applications of both 'step' and 'temporal' resolution on sets of formulae in SNF, together with various simplification steps.
The step and temporal resolution rules are applied until either a contradiction has been detected or no new resolvents can be generated.
Completeness of the resolution procedure has been shown in [19].
3.1  all but the outer level of 0-operators.
So, resolution will be between a 0-rule and a set of rules that together imply an 0-formula which will contradict the +-rule.
Thus, given a set of rules in SNF, then for every rule of the form L + 01 temporal resolution may be applied between this 0-rule and a set of global 0-rules, which taken together force 1 1 always to be satisfied.
The temporal resolution rule is given by the following  Step resolution  'Step' resolution consists of the application of standard classical resolution rule to formulae representing constraints at a particular moment in time, together with simplification rules for transferring contradictions within states to constraints on previous states.
Simplification and subsumption rules are also applied.
Pairs of initial 0-rules, or global 0-rules, may be resolved using the following (step resolution) rule where C1 and Cz are both last-time formulae or both start.
C1 + A v r La + B v l r (C, ACa) + A V B Once a contradiction within a state is found using step resolution, the following rule can be used to generate extra global constraints.
OP start Otrue  +  C  =+  $1  C  +  (AiAo)Wl'  n o=O  with side conditions for all 0  5 i 5 n t Bi  j  v I  11 n  and I-  Bi  Aj  j=O  I  where the side conditions ensure that the set of rules OAi 3 Bi together imply 0-I.
So if any of the Ai are satisfied then 1 1 will always be satisfied, i.e.,  false  =+ 1 P  +  1P  This rule states that if, by satisfying P in the last moment in time a contradiction is produced, then P must never be satisfied in any moment in time.
The new constraints therefore represent 0 l P The step resolution process terminates when either no new resolvents are derived, or false is derived in the form of one of the following rules.
start Otrue  OAo =+ Bo ... ... O A , + Bn  =+ false  +  false  3.2 Temporal resolution During temporal resolution the aim is to resolve a $-rule, C + $ 1 , where C may be either a last-time formula or start, with a set of rules that together imply 0-1,for example a set of rules that together have the effect of O A + 0-1.
However the interaction between the '0' and ' 0' operators in PTL makes the definition of such a rule non-trivial and further the translation from PTL to SNF will have removed  Such a set of rules are known as a-loop in -d.  4  Reducing the rule-set  As the application of the temporal resolution is the most expensive part of the algorithm it is on this we concentrate.
Algorithms for applying the temporal resolution rule are given and compared in [7].
We note that even for small problems, such as the list of valid temporal formulae found in [14], large sets of rules are generated making the search for loops costly.
In this section we describe an algorithm that removes rules, prior to the application of one of the loop search algorithms without affecting the completeness of the overall method.
This is known as rule reduction.
The motivation being that the time taken for rule reduction will be offset by the reduced time required to perform loop search.
IIn previous presentations of this rule two resolvents are given.
However only the resolvent given here is necessary for completeness, so for simplicity we omit the other resolvent.
4.1 Overview We begin by considering a loop in literal 1 1 and  proposition is a proposition in the scope of one negation.
For example in the rule  examine the cases when the deletion of a rule does not ,affect the loop remaining.
An example of a loop for resolution with the eventuality 01 is L O(aAc) o(aAic)  =+ j  a and d are positive propositions and b and c are negative propositions.
Let C+,C-,R+ and 8- be multi-sets of propositions defined as follows.
Throughout, we only consider global 0-rules.
a A 4  ail  formed from the rules R O(aAc)  =+ a  Oa  =+  71  o ( a Ale)  =+  U.  C+ is the multi-set of propositions that occur positively on the left hand side of the set of rules.
C- is the multi-set of propositions that occur negatively on the left hand side of the set of rules.
To get the required "looping" the literal a appears on both the left and right hand sides of rules in R and the proposition c and its negation both occur on the left hand sides of rules in R2.
Finally 1 1 , the literal in which we are looking for a loop, should occur on the right hand side of rules and may occur on the left but its negation, I , should not occur at all.
The idea behind the algorithm is that, given a set of global 0-rules we want to be able t o delete rules that we know will not form part of the loop before actually detecting the loop itself.
For example if we are resolving with 011, given the rule Ox + a and the rule-set R above, as there are no rules with lx on the left hand side or x on the right hand side we can ignore this rule for the purposes of loop search.
The deletion of the rule 0 ( a A c) + a however from rule-set R, means that no loop can be detected in the remaining rules.
The deletion of a rule crucial to the loop is avoided by noting that there is a rule in R with l e on the left hand side to correspond with the c on the left side of this rule (or a c on the right hand side).
Similarly the deletion of O a j 1 1 means that no loop can be detected from the set of rules remaining in R. To avoid this we allow 7 1 (the literal in which we are looking for a loop) to appear anywhere and again make sure that such a rule is only deleted if we can't find an a on the right hand side or -vi on the left hand side of any rule in R. 4.2 Definitions We assume that rules are in their simplest forms, i.e.
all negations are pushed through to propositions and simplified and that all step resolution possible has been carried out.
A positive proposition is a proposition not in the scope of any negations and a negative  R+ is the multi-set of propositions that occur positively on the right hand side of the set of rules.
E- is the multi-set of propositions that occur negatively on the right hand side of the set of rules.
4.3  and the set of global- 0 rules in SNF having performed all the step resolution possible is R. 1.
If 2 occurs in a rule on the right or left hand side delete the rule.
2.
Create the empty multi-sets C+,C-,%+ and %-.
3.
For each rule r E R in turn, add a proposition to the relevant multi-set for each proposition occurring in r as follows.
(a) If p is a proposition occuring positively on the left hand side of r then add p t o C+.
(b) If p is a proposition occuring negatively on  the left hand side of r then add p to 2-.
(c) If p is a proposition occuring positively on the right hand side of r then add p t o 8+.
(d) If p is a proposition occuring negatively on the right hand side of r then add p to 8-.
4.
Remove the proposition 1 from any of the multisets C+, C-,%+ or RI-.
2We could actually perform resolution on the left hand side a and thus an of two of these rules to produce a rule O a equivalent loop 00. a A 4 but in general doing this in practice produces a much larger rule-set.
+  The rule reduction algorithm  Let us assume we are trying to resolve with  +  5 .
Remove rules as follows.
7  b # %+ and b # 2- all the rules with b in a left hand side positive position are deleted and C+ becomes { a ,c}.
We cannot delete the c from %+ as there may be another rule with c in this position.
Now we must recalculate the four sets and can continue the deletions until no rules remain.
4.4 Example Assume we are resolving with L + 01 and we have the following global 0-rules.
If p is in C+ and neither C- or %+ have p as a member then delete all rules with p occurring positively on the left hand side, delete all occurrences of p from C+ and delete a copy of the other propositions occurring in these rules in their respective multi-sets.
If p is in C- and neither C+ or %- have p as a member delete all rules with p occurring negatively on the left hand side, delete all occurrences of p from C- and delete a copy of the other propositions occurring in these rules in their respective multi-sets.
If p is in %+ and p is not a member of C+ then delete all rules with p occurring positively on the right hand side, delete all occurrences of p from %+ and delete a copy of the other propositions occurring in these rules in their respective multi-sets.
6.
Repeat step 5 until no more rules can be deleted.
We delete any rules containing 1 (step 1) as we are looking for a loop in 4.
Recall that we assume that all the step resolution possible has been carried out.
The right hand side of each SNF, rule in the loop implies 1 1 so 1 may not appear on the right hand side of a rule that is combined to make this loop.
The proposition 1 is removed from the multi-sets (step 4) as we are looking for a loop in -1.
Given the rules 0 a + a , O a + 7 1 that together form the loop O a + aA-1, we don't want 1 to occur only in the multi-set 8-and thus delete the latter rule.
Further it does not matter if 7 1 happens to appear in some rules on the left hand side as we know the right hand side of each rule implies 1 anyway.
We use multi-sets and adjust these sets when a rule is deleted to avoid having to re-calculate C+, C-,R+ and %- after every deletion.
For example assume we are looking for a loop in 1 1 from the rules 7  Oa Ob  +  + +  Oa Ob  3.
4.
5.
O(CA1a)  6.  o c  Otrue O(CA-b)  + + + +  w 1w TaVIb c  *  c -4  +  Firstly we build the multi-sets C+, C-, W ,and %taking each rule in turn.
In rule 1, a occurs positively on the left hand side so we add a to the multi-set C+ and w occurs positively on the right hand side so we add w to %+.
The four multi-sets are C+ = { a } , C- = {}, %+ = {w}, and %- = {}.
In rule 2 , b occurs positively on the left hand side so we add b to the multi-set C+ and w occurs negatively on the right hand side so we add w to %-.
The four multi-sets are C+ = { a , b}, C- = {}, %+ = {w}, and %- = {w}.
We continue as above until we have processed all the rules and, having deleted any occurrences of I , we obtain the four multi-sets C+ = { a , b, c, c, c } , C- = { a , b}, %+ = {w, c, e } , and %- = {w, a , b } .
Each multi-set contains propositions of a particular type.
For example the %+ multi-set tells us that the proposition w occurs positively on the right hand side of a rule (rule 1) and that c occurs positively on the right hand side of two rules (rules 4 and 5).
When carrying out deletions, starting with C+ we see a and b are both in C- and c is in %+.
Similarly for C- a and b are both in C+.
Looking at %+ the proposition c occurs in C+ but w does not occur in C+ so we need to remove all the rules with w in the %+ position and adjust all the other multi-sets.
That is, the algorithm tells us that any rule with a positive w on the right hand side can be deleted as it cannot  If p is in %- and p is not a member of 2then delete all rules with p occurring negatively on the right hand side, delete all occurrences of p from R- and delete a copy of the other propositions occurring in these rules in their respective multi-sets.
O(cAa)  1.
2.  form part of the loop.
We see rule 1 is the only rule  containing w in a RJE+ position so remove this rule, delete w from %+ and delete an a , that occurs on the left hand side of rule 1, from C+.
The rules remaining in our set are rules 2-6 and our four multi-sets are C+ = { b , c , c , c } , C- = { a , b } , %+ = { c , c } , and 8- = {w, a, b } .
So, having deleted a rule, propositions may need to be deleted from other multi-sets so that they accurately represent the current set of rules.
Then  a 4  c.  If we construct sets rather than multi-sets, having deleted 1 from the sets, we obtain C+ = { a , b, c } and R+ = { a , c } and C- = 8- = 8.
As b E C+ but  8  the algorithm can be re-applied and more rules may be deleted.
Looking at 93- w doesn't occur in 2- so we delete any rules with w in a right hand side negative position and delete a copy of any other propositions in these rules.
Looking at the rule-set rule 2 is the only rule with iw on the right hand side so we delete this rule leaving rules 3-6, and delete a copy of b from C+.
The multi-sets of propositions become = {c, e, e}, 2- = { a , b}, R+ = {c, c}, and R- = { a , b}.
We cannot delete any more rules so the reduced rule-set becomes rules 3-6.
We may now use a loop finding algorithm to detect any loops.
In this example the loop, from merging rules 3, 4 and 6 and rules 3, 5 and 6, is  0 (CA TU) 0 (C A l b )  4.5  + +  rules matching the data shown.
The third row contains data for all examples where at least one of the timings is greater than 60 milliseconds.
The reason we have chosen to isolate these subsets is that for the former we expect rule reduction to be particularly beneficial where the examples are not trivially small, and the latter to exclude any timing inaccuracies that may occur for timings that are very small.
Subset of Data  ( C A i a A TI!
)V (C A ~b A 11) l a A d)V ( C A i b A 1 1 )  I  (C A  Reduction  > Original  I  Table 1 Summary of Results from Rule Reduction  Completeness and complexity  Completeness is shown by proving that any resolvents from the application of the temporal resolution rule can be generated by applying the rule reduction algorithm and then performing temporal resolution and some step resolution.
For more details see [6].
The complexity of the algorithm will be considered in the full paper.
5  Reduction  6 Original  The loop search used in each case is Breadth-First Search [8] however another method could be used if desired, see for example those described in [7].
The timings of the loop searches are a trade off between the overhead required to remove rules from the rule-set plus the loop finding times on a potentially smaller data set, against the time for finding the loop in the full rule-set.
The timings we have obtained suggest that rule reduction does help on larger, more difficult rule-sets.
We note it is the same two examples where the time for rule reduction and loop finding is greater than the time for loop finding alone in the subsets of the data labelled (ii) and (iii).
The times for these examples for the former are not larger than 30% more than the timings of the latter (in fact the actual figures are 14% and 29%) whereas the gain from using rule reduction on some examples is much greater.
For example in one case the time for performing loop search alone is 3; times worse than for finding the loop with rule reduction.
Results  A prototype implementation performing the temporal resolution method has been built.
The programs are written in SICStus Prolog [4] running under UNIX and timings have been carried out on a SPARCstation 1 using compiled Prolog code.
The test data is a set of valid temporal formulae taken from [14] chosen as it provides a reasonably sized collection of small problems to be proved valid.
An example of the type of formulae being shown valid (we actually show the negation is unsatisfiable) is  OW A UWZ* U(% A UWZ)V U(WZA OW).
Due to space restrictions the complete set of results is omitted here but can be found in [6], however a summary is given in Table 1.
Table 1 gives the number of eventualities where the time for rule reduction followed by loop finding on the resulting rule-set is less than or equal to, or greater than the original.
The figures in brackets are the percentages for these values.
The first row of the table gives the figures for the full data set, subsequent rows take subsets of the data.
The second row contains the data for all examples where the original rule-set contains more than 10  Conclusions and further work 6.1 Conclusions We have given an algorithm for removing rules irrelevant to the application of Fisher's temporal resolution rule and in more than 80% of the examples tried the times for detecting loops are the same or better than without using this algorithm.
If examples with trivially small numbers of rules are ignored then this figure increases to more than 90% of the examples tried.
6  9  Work Bench (LWB) 1131.
Model checking systems are also available for example the STeP system [3] which combines both model checking and deductive methods.
The algorithm is independent of the type of loop search algorithm being used so an implementation could apply the rule reduction strategy whatever loop search algorithm was chosen.
Rule reduction will be most effective in loops that are small in comparison to the size of the rule-set or involve literals that don't often appear in the rest of the rule-set.
However, if the loop consists of most of the rule-set or contains literals that appear frequently throughout the rule-set then rule reduction will not be as effective.
Note that we cannot carry out the loop search just by using the sets of propositions we have constructed as we have lost information relating to individual rules which is necessary to ensure that the conditions for a loop are satisfied.
6.2 Further work Although the rule reduction algorithm seems to help us on the small problems we have tested it would be useful to try the algorithm on larger examples.
For example it would be interesting to see whether the rule reduction algorithm helps tackle problems that are too large for the original theorem prover.
We have considered parallelising the basic temporal resolution method and several loop search algorithms in [9].
Likewise the rule reduction algorithm could also be parallelised.
Firstly the construction of the sets of propositions C+ etc.
could be carried out in parallel by splitting the set of rules into n-sets given n processors and constructing the sets of propositions for each subset.
Then the totals from each processor must be merged.
Finally, the deletion of rules could also be carried out in parallel although care must be taken t o ensure that sets of propositions are maintained correctly.
6.3 Related work Decision procedures based on resolution have been developed for linear-time temporal logics in [l,5, 231, however in many cases they are unsuitable for implementation either because they only deal with a small number of the temporal operators or because of problems with proof direction due to the large numbers of resolution rules that may be applied.
Subsumption is used and strategies developed to assist resolution theorem provers for classical logics, see for example OTTER[16].
For resolution in temporal logics although subsumption rules are generally used to keep the rule-set as compact as possible the author knows of no strategies developed to guide temporal resolution proofs.
Theorem provers for temporal logic that have been implemented tend to be tableau based, for example DP [Ill and a module that forms part of the Logic  Acknowledgements  Thanks to Howard Barringer and Michael Fisher for their guidance and encouragement during this work and to Graham Gough and Martin Peim for many helpful comments and advice.
Thanks again to Michael Fisher for all the suggestions made relating to an earlier draft of this paper.
References M. Abadi and Z.
Manna.
Nonclausal Deduction in First-Order Temporal Logic.
ACM Journal, 37(2):279-317, Apr.
1990.
H. Barringer.
Using Temporal Logic in the Compositional Specification of Concurrent Systems.
In A. P. Galton, editor, Temporal Logics and their Applications, chapter 2, pages 53-90.
Academic Press Inc. Limited, London, Dec. 1987.
N. Bjorner, A. Browne, E. Chang, M. Col&, A. Kapur, Z.
Manna, H. B. Sipma, and T. E. Uribe.
STeP The Stanford Temporal Prover Educational Release Version 1.0 User's Manual.
Computer Science Department, Stanford University, California 94305, Nov. 1995.
M. Carlsson and J.
Widen.
SICStus Prolog User's Manual.
Swedish Institute of Computer Science, Kista, Sweden, Sept. 1991.
A. Cavalli and L. Farifias del Cerro.
A Decision Method for Linear Temporal Logic.
In R. E. Shostak, editor, Proceedings of the 7th International Conference on Automated Deduction, volume 170 of Lecture Notes in Computer Science, pages 113-127.
Springer-Verlag, 1984.
C. Dixon.
Strategies f o r Temporal Resolution.
PhD thesis, Department of Computer Science, University of Manchester, 1995.
[7] C. Dixon.
Search Strategies for Resolution in Temporal Logics.
In M. A. McRobbie and J. K. Slaney, editors, Proceedings of the Thirteenth International Conference on Automated Deduction (CADE), volume 1104 of Lecture Notes in Artificial Intelligence, pages 672-687, New Brunswick, New Jersey, July/August 1996.
Springer-Verlag.
10  [8] C. Dixon.
Temporal Resolution: A Breadth-First Search Approach.
In Proceedings of TIME-96 the Third International Workshop on Temporal Representation and Reasoning, Key West, Florida, May 1996.  the Thirteenth International Conference on Automated Deduction (CADE), volume 1104 of Lecture Notes in Artificial Intelligence, pages 598612, New Brunswick, New Jersey, July/August 1996.
Springer-Verlag.
[9] C. Dixon, M. Fisher, and R. Johnson.
Parallel Temporal Resolution.
In Proceedings of TIME-95 the Second International Workshop on Temporal Representation and Reasoning, Melbourne Beach, Florida, Apr.
1995.
[18] S. Owicki and L. Lamport.
Proving Liveness Properties of Concurrent Programs.
ACM Transactions on Programming Languages and Systems, 4(3):455-495, July 1982.
[19] M. Peim.
Propositional Temporal Resolution Over Labelled Transition Systems.
Unpublished Technical Note, Department of Computer Science, University of Manchester, 1994.
[lo] M. Fisher.
A Resolution Method for Temporal Logic.
In Proceedings of the Twelfth Interna-  tional Joint Conference on Artificial Intelligence (IJCAI), Sydney, Australia, Aug. 1991.
Morgan Kaufman.
[20] J.
A. Robinson.
A Machine-Oriented Logic Based on the Resolution Principle.
ACM Journal, 12(1):23-41, Jan. 1965.
[11] G. D. Gough.
Decision Procedures for Temporal Logic.
Master's thesis, Department of Computer Science, University of Manchester, October 1984.
Also University of Manchester, Department of Computer Science, Technical Report UMCS89-10-1.
[21] A. P. Sistla and E. M. Clarke.
Complexity of Propositional Linear Temporal Logics.
ACM Journal, 32(3):733-749, July 1985.
[22] M. Y. Vardi and P. Wolper.
An AutomataTheoretic Approach to Automatic Program Verification.
In Proceedings IEEE Symposium on Logic in Computer Science, pages 332-344, Cambridge, 1986.
[12] B. T .
Hailpern.
Verifying Concurrent Processes Using Temporal Logic, volume 129 of Lecture Notes in Computer Science.
Springer-Verlag, 1982.
[23] G. Venkatesh.
A Decision Method for Temporal Logic based on Resolution.
Lecture Notes in Computer Science, 206:272-289, 1986.
[13] G. Jaeger, A. Heuerding, S. Schwendimann, F. Achermann, P. Balsiger, P. Brambilla, H. Zimmermann, M. Bianchi, K. Guggisberg, and W. Heinle.
LWB-The Logics Workbench 1.0.
[24] P. Wolper.
The Tableau Method for Temporal Logic: An overview.
Logique et Analyse, 110111:119-136, June-Sept 1985.  http://lwbwww.unibe.ch:8080/LWBinfo.html.
University of Berne, Switzerland.
[25] P. Wolper, M. Vardi, and A. P. Sistla.
Reasoning about Infinite Computation Paths.
In Proceedings of the Twentyfourth Symposium on the Foundations of Computer Science.
IEEE, 1983.
[14] Z.
Manna and A. Pnueli.
Verification of Concurrent Programs: The Temporal Framework.
In R. S. Boyer and J .
S. Moore, editors, The Correctness Problem in Computer Science, pages 215273.
Academic Press, London, 1981.
[26] L. Wos.
Automated Reasoning : 33 Basic Research Problems.
Prentice-Hall, Englewood Cliffs, New Jersey, 1988.
[15] Z.
Manna and A. Pnueli.
The Temporal Logic of Reactive and Concurrent Systems: Specification.
Springer-Verlag, New York, 1992.
[27] L. Wos, D. Carson, and G. Robinson.
The Unit Preference Strategy in Theorem Proving.
In Proceedings of AFIPS Fall Joint Computer Conference, pages 615-621.
Thompson Book Company, 1964.
[16] W. W. McCune.
OTTER 2.0 Users Guide.
Argonne National Laboratory, 9700 South Cass Avenue, Argonne, Illinois 60439-4801, March 1990.
ANL-9019.
[17] A. Nonnengart.
[28] L. Wos, G. Robinson, and D. Carson.
Efficiency and Completeness of the Set of Support Strategy in Theorem Proving.
ACM Journal, 12:536-541, Oct. 1965.
Resolution-Based Calculi for  Modal and Temporal Logics.
In M. A. McRobbie and J. K .
Slaney, editors, Proceedings of  11