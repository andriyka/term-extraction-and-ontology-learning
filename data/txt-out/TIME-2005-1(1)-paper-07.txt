On the freeze quantifier in Constraint LTL: decidability and complexity [?]
arXiv:cs/0609008v2 [cs.LO] 29 Sep 2006  Stephane Demri a,1, Ranko Lazic b,2, David Nowak c,3 a LSV,  CNRS & ENS Cachan & INRIA Futurs (projet SECSI), France  b Department c Research  of Computer Science, University of Warwick, United Kingdom  Center for Information Security, National Institute of Advanced Industrial Science and Technology, Japan  Abstract Constraint LTL, a generalisation of LTL over Presburger constraints, is often used as a formal language to specify the behavior of operational models with constraints.
The freeze quantifier can be part of the language, as in some real-time logics, but this variable-binding mechanism is quite general and ubiquitous in many logical languages (first-order temporal logics, hybrid logics, logics for sequence diagrams, navigation logics, logics with l-abstraction etc.).
We show that Constraint LTL over the simple domain hN, =i augmented with the freeze quantifier is undecidable which is a surprising result in view of the poor language for constraints (only equality tests).
Many versions of freeze-free Constraint LTL are decidable over domains with qualitative predicates and our undecidability result actually establishes S11 completeness.
On the positive side, we provide complexity results when the domain is finite (ExpSpace-completeness) or when the formulae are flat in a sense introduced in the paper.
Our undecidability results are sharp (i.e.
with restrictions on the number of variables) and all our complexity characterisations ensure completeness with respect to some complexity class (mainly PSpace and ExpSpace).
Key words: Linear-time temporal logic, Constraints, Freeze quantifier, Decidability, Computational complexity  [?]
This paper is an extended version of [1].
1 Supported by the ACI "Securite et Informatique" Cortos.
2 Supported by an invited professorship from ENS Cachan, and by grants from the EPSRC (GR/S52759/01) and the Intel Corporation.
Also affiliated to the Mathematical Institute, Serbian Academy of Sciences and Arts, Belgrade.
3 Supported by the ACI "Securite et Informatique" Persee and by the e-Society project of MEXT.
A part of this work was done while affiliated to LSV, CNRS & ENS Cachan, and Department of Information Science, University of Tokyo.
Preprint submitted to Information and Computation  14 January 2014  1  Introduction  Model-checking for infinite-state systems.
Temporal logics are wellstudied formalisms to specify the behavior of finite-state systems and the computational complexity of the model-checking problems is nowadays wellknown, see e.g.
a survey in [2].
However, many systems such as communication protocols have infinitely many configurations and usually the techniques for the finite case cannot be applied directly.
For numerous infinite-state systems, the model-checking problem for the linear-time temporal logic LTL can be easily shown to be undecidable (counter automata, hybrid automata and more general constraint automata [3, Chapter 6]).
Actually, simpler problems such as reachability are already undecidable.
However, remarkable classes of infinite-state systems admit decidable model-checking problems, such as timed automata [4] and subclasses of counter automata [5,6,7,8,9].
For instance, fragments of LTL with Presburger constraints have been shown decidable over appropriate counter automata [10,11].
In order to push further the decidability border, one way consists in considering larger classes of operational models, see e.g.
[5].
Alternatively, enriching the specification language is another possibility.
In the paper, we are interested in studying systematically the extensions of versions of LTL over concrete domains by the so-called freeze quantifier, and in analysing the consequences in terms of decidability and computational complexity.
A variable-binding mechanism.
The freeze quantifier in real-time logics has been introduced by Alur and Henzinger in the logic TPTL, see e.g.
[12].
The formula x * ph(x) binds the variable x to the time t of the current state: x * ph(x) is semantically equivalent to ph(t).
Alternatively, in the explicit clock approach [13], there is an explicit clock variable t and even though in this approach the freeze variable-binding mechanism is possible, the logical formalisms from [12] and [13] are incomparable.
In this paper, we want to extend some of the decidable logics from [10,11,14] to admit the freeze quantifier: |y=x ph(y) holds true at a state iff ph(y) holds true at the same state with y taking the value of x.
Here, y can be in the scope of temporal operators.
A crucial difference with the logics in [12,13] rests on the fact that the variable x may not be monotonic.
We focus on decidability and complexity issues when the language of constraints (at the atomic level of the logics) is very simple in order to isolate the effects of the freeze quantifier.
We know for instance that LTL over integer periodicity constraints augmented with the freeze quantifier is ExpSpace-complete [14].
The above-mentioned variable-binding mechanism that allows the binding of logical variables to objects is very general and it has been used in the literature for various purposes.
Details will be provided along the paper (see e.g.
Sections 2  2.2 and 5).
In particular, one can see flexible variables as processes, values of the domain as resources, and the freeze quantifier and rigid variables as ways to extract and store the current resource used by a process.
This view is nicely illustrated in [15] by the specification of a communication protocol.
In Section 2.2, we consider the case of a process requesting memory blocks.
Our contribution.
In the paper, we analyse decidability and complexity issues of Constraint LTL augmented with the freeze quantifier.
The temporal operators we consider are restricted to the standard future-time operators 'until' and 'next' (no past-time operators).
CLTL| (D) denotes such a logic over the concrete domain D. A concrete domain is composed of a non-empty set equipped with a family of relations.
The atomic formulae of CLTL| (D) are based on constraints over D with the ability to compare values of variables at states of bounded distance (see details in the body of the paper) as done in [16,17,11,18].
First, we show that when the underlying domain D is finite, CLTL| (D) satisfiability is in ExpSpace.
If moreover D has at least two elements with the equality predicate, then CLTL| (D) is ExpSpace-hard.
As a corollary, CLTL| (D, =) satisfiability is ExpSpace-complete when |D| >= 2 and D is finite (Section 3.2).
This witnesses an exponential blow-up since satisfiability for the freeze-free fragment CLTL(D) when D is finite can be easily shown in PSpace as plain LTL [19].
When the domain D is infinite, we show that CLTL| (D, =) is undecidable which is the main result of the paper (Section 4).
This is quite surprising since the language of constraints is poor (only equality tests) and only futuretime operators are used unlike what is shown in [14, Section 7] with past-time operators.
Our proof, based on a reduction from the Recurrence Problem for 2-counter machines, refines this result: CLTL| (D, =) is S11 -complete even if only one flexible variable and two rigid variables (used to record the values of flexible variables) are involved.
Hence, in spite of the very basic Presburger constraints in CLTL| (N, =), satisfiability is S11 -complete.
Decidability of CLTL| (D) can be obtained either at the cost of syntactic restrictions or by assuming semantical constraints (as in the logic TPTL [12] where the freeze quantifier can only record the value of a monotonic variable, namely time).
In order to regain decidability, we introduce the flat fragment of CLTL| (D) which contains the freeze-free fragment CLTL(D) and we show that there is a logarithmic-space reduction from the flat fragment of CLTL| (D) into CLTL(D) assuming that the equality predicate belongs to D. As a corollary, we obtain that the flat fragments of CLTL| (Z, <, =) and CLTL| (R, <, =) are PSpace-complete (Section 3.2).
Flat fragments of plain LTL versions have been studied in [20,10] (see also in [21, Section 5] the design of a flat logical 3  temporal language for model-checking pushdown machines) and our definition of flatness takes advantage in a non-trivial way of the polarity of 'until' subformulae occurring in a formula.
This is a standard way to restrict the interplay between modalities and quantifiers, see e.g.
[22,10,23].
Although we do not claim that flat formulae are especially interesting in practice, they cover nontrivial uses of the freeze quantifier.
However, they cannot express the property that a variable at distinct points takes distinct values.
Along the paper, we consider the satisfiability problem, but as shown in Section 2.3, our results extend to the model-checking problem.
CLTL| (D) extends naturally the freeze-free fragment CLTL(D), and we show that it increases strictly the expressive power (Proposition 1).
However, we prove that significant fragments of CLTL| (D) are as expressive as the full language, for instance by recording only values of flexible variables at the current state or by allowing only rigid variables in atomic formulae (see Section 2.4).
Apart from the technical contributions of the paper, we provide comparisons with several works which involve freeze-like operators, such as in first-order quantification, in timed LTL, in hybrid logics with reference pointers, to quote a few examples.
Structure of the paper.
In Section 2, we present Constraint LTL with the freeze quantifier, satisfiability and model-checking problems of interest, and consider relative expressivity.
Section 3 contains decidability and complexity results when the underlying concrete domain is finite or with restricting to the flat fragment.
In Section 4, we show that CLTL| (N, =) is S11 -complete.
Related work is discussed in Section 5.
In Section 6, we conclude and enumerate a few open problems.
2  Constraint LTL with the freeze quantifier  2.1 Syntax and semantics A constraint system is a set, called the domain, with a countable family of relations on this set.
Let D = (D, (Ri )i[?
]I ) be a constraint system.
We define the logic CLTL| (D) by giving its syntax and semantics.
Syntax.
Let FleVarSet and RigVarSet be countable sets of variables which are respectively called flexible variables and rigid variables.
Terms are given 4  by the grammar: t ::= X * * X} x | y | *{z n times  where x is in FleVarSet and y is in RigVarSet.
We use Xn as an abbreviation for |X *{z* * X}.
Formulae are given by the grammar: n times  ph ::= R(t1 , .
.
.
, tn ) | !ph | ph1 [?]
ph2 | Xph | ph1 Uph2 ||y=Xn x ph  where R ranges over the predicate symbols associated to the relations in (Ri )i[?
]I , x over FleVarSet, and y over RigVarSet.
Note that we use X for denoting either the nth next value Xn x of the variable x or the formula Xph.
We define the Boolean constants, and the temporal operators 'sometimes' and def 'always', as the following abbreviations: [?]
= R(t1 , .
.
.
, tn ) [?]
!R(t1 , .
.
.
, tn ), def def def Fph = [?
]Uph, [?]
= R(t1 , .
.
.
, tn ) [?]
!R(t1 , .
.
.
, tn ), and Gph = !F!ph.
Let FleVars(ph) and RigVars(ph) denote the sets of all flexible and rigid (respectively) variables which occur in ph.
Freeze-free fragment.
CLTL(D) is the fragment of CLTL| (D) with no rigid variables and hence without freeze quantifier.
Flat fragment.
We say that the occurrence of a subformula in a formula is positive if it occurs under an even number of negations, otherwise it is negative.
The flat fragment of CLTL| (D) is the restriction of CLTL| (D) where, for any subformula ph1 Uph2 , if it is positive then | does not occur in ph1 , and if it is negative then | does not occur in ph2 .
More precisely, the flat fragment consists of the following formulae ph.
Subformulae ph are positive, whereas subformulae ph- are negative.
ph ::= R(t1 , .
.
.
, tn ) | !ph- | ph1 [?]
ph2 | Xph | psUph ||y=Xn x ph - - - - ph- ::= R(t1 , .
.
.
, tn ) | !ph | ph- 1 [?]
ph2 | Xph | ph Ups ||y=Xn x ph  ps ::= R(t1 , .
.
.
, tn ) | !ps | ps1 [?]
ps2 | Xps | ps1 Ups2  Semantics.
A model s : N - (FleVarSet - D) is a sequence of mappings from FleVarSet to D. For any i [?]
N, we write s i for the model defined by s i (j) = s(i+j) for every j >= 0.
An environment r is a mapping from RigVarSet to D. We write r[x 7- v] for the environment mapping x to v [?]
D, and any 5  other variable y to r(y).
The semantics of terms is given by: JXn xKs,r = s(n)(x) if x is in FleVarSet JyKs,r = r(y)  if y is in RigVarSet  The semantics of formulae is given by the following satisfaction relation.
(Note that we use R for both a relation symbol and the relation it denotes.)
* * * * * *  s s s s s s  |=r R(t1 , .
.
.
, tn ) iff (Jt1 Ks,r , .
.
.
, Jtn Ks,r ) [?]
R, |=r !ph iff s 6|=r ph, |=r ph1 [?]
ph2 iff s |=r ph1 and s |=r ph2 , |=r Xph iff s 1 |=r ph, |=r ph1 Uph2 iff there exists i such that s i |=r ph2 and for all j < i, s j |=r ph1 , |=r |y=Xn x ph iff s |=r[y7-s(n)(x)] ph.
2.2 Examples  As a first example, consider the formula phx[?]
= G |y=x XG x 6= y def  which states that the values of the variable x at different points in time are mutually distinct.
This is interesting for the verification of cryptographic protocols, where nonces are variables which have to be fresh, i.e.
they cannot take twice the same value.
As a second example, we consider a process requesting memory blocks.
Let us assume two flexible variables o (for operator) and a (for argument) such that o takes its values in the finite domain {Malloc, Access, Free} and a takes its values in an infinite set of memory locations.
We use Malloc(x), Access(x) and Free(x) as respective abbreviations for o = Malloc [?]
a = x, o = Access [?]
a = x, and o = Free [?]
a = x (x is a rigid variable).
We can easily express the following properties in CLTL| (D).
* As soon as a memory location is freed, either it is never accessed again, or it is not accessed until it is allocated again: G(o = Free = |x=a (G!Access(x) [?]
!Access(x)UMalloc(x)))  6  * When a memory location is allocated, it will either be freed in the future or will always be eventually accessed (so that we do not waste memory): G(o = Malloc = |x=a (FFree(x) [?]
GFAccess(x)))  2.3 Satisfiability and model-checking problems  We recall below the problems we are interested in.
Satisfiability problem for CLTL| (D): instance: a CLTL| (D) formula ph; question: is there a model s and an environment r such that s |=r ph?
Without loss of generality we can assume that no rigid variable occurs free in ph, which means that r is not essential above.
The model-checking problem rests on D-automata which are constraints automata.
A D-automaton is simply a Buchi automaton with alphabet a finite set of Boolean combinations of atomic CLTL| (D) formulae with terms of the form x and Xx (x [?]
FleVarSet).
In a D-automaton, letters on transitions induce constraints between the variables of the current state and the variables of the next state as done in [10].
Alternatively, labelling the transitions by CLTL| (D) formulae (as done in [24]) would not modify essentially the decidability status of model-checking problems considered in this paper.
Model-checking problem for CLTL| (D): instance: a D-automaton A and a CLTL| (D) formula ph; question: are there a symbolic o-word v = ph0 , ph1 , .
.
.
accepted by A, a model s (a realisation of v) and an environment r such that s |=r ph and for every i >= 0, s i |=r phi ?
It is not difficult to show that as soon as D is non-trivial the satisfiability problem and the model-checking problem are reducible to each other in logarithmic space following techniques from [19].
In the sequel, we prove results for the satisfiability problem but one has to keep in mind that our results extend to the model-checking problem.
2.4 Expressive power  The freeze quantifier strictly increases expressive power.
In order to show formally that the freeze quantifier is powerful, we show that CLTL| (N, =) is strictly more expressive than its freeze-free fragment CLTL(N, =).
In fact, 7  phx[?]
is an example of a formula ph in CLTL| (N, =) with no free rigid variable for which there is no equivalent formula ps in CLTL(N, =).
The result will follow from the following property.
Lemma 1 Every satisfiable formula ph in CLTL(N, =) has a model which contains only finitely many distinct values.
Moreover, the number of distinct values is polynomial in |ph|.
Proof.
Let ph be a formula in CLTL(N, =) with variables in {x1 , .
.
.
, xn } and k be equal to 1 plus the maximal j such that Xj xi occurs in ph for some flexible variable xi .
Let C be the finite set of constraints of the form Xj1 xi1 = Xj2 xi2 with 0 <= j1 , j2 <= k - 1 and i1 , i2 [?]
{1, .
.
.
, n}.
We define a total ordering on {1, .
.
.
, n} xN as follows: hi, ji < hi' , ji iff j < j ' or (j = j ' and i < i' ).
Given a model s : N - (FleVarSet - N), we build a model s ' : N - (FleVarSet - {1, .
.
.
, k x n}) such that s |= ph iff s ' |= ph.
If x is a flexible variable not occurring in ph, s ' (i)(x) = 1 for every i >= 0.
Otherwise s ' (0)(x1 ) = 1 (h1, 0i is minimal wrt <).
Now suppose that for every hi' , j ' i < hi, ji, s ' (j ' )(xi' ) has been already defined.
We shall define s ' (j)(xi ).
If for some hi' , j ' i in {hi'' , j '' i : 0 <= j -j '' <= k -1, 1 <= i'' <= n, hi'' , j '' i < hi, ji}, s(j ' )(xi' ) = s(j)(xi ) then s ' (j)(xi ) takes the value s ' (j ' )(xi' ).
Otherwise, s ' (j)(xi ) takes an arbitrary value from the set {1, .
.
.
, k x n} \ {s(j '' )(xi'' ) : 0 <= j - j '' <= k - 1, 1 <= i'' <= n, hi'' , j '' i < hi, ji} which is always possible since the second set has strictly less that k x n ele' ments.
One can show that for all c [?]
C and i >= 0, s i |= c iff s i |= c. Hence, s |= ph iff s ' |= ph.
Proposition 1 No formula of CLTL(N, =) is equivalent to the formula phx[?]
of CLTL| (N, =).
The flatness concept is only related to occurrences of the freeze quantifier and for instance the formulae of the form phx[?]
do not belong to the flat fragment.
By contrast, !phx[?]
belongs to the flat fragment of CLTL| (N, =).
By Proposition 1, the flat fragment of CLTL| (N, =) is therefore strictly more expressive than CLTL(N, =) since CLTL(N, =) is closed under negation.
Equivalent syntactic restrictions.
We now show that expressiveness of CLTL| (D) does not change if we restrict the freeze quantifier to refer only to flexible variables in the current state, or if we restrict atomic formulae to contain only rigid variables, or with both restrictions.
Therefore, those restrictions could have been incorporated into the definition of the logic.
However, 8  we chose to allow terms of the form Xn x with flexible x in atomic formulae in order to have CLTL(D) as the freeze-free fragment, and to allow the freeze quantifier to refer to the future so that formulae would be closed under substitution of terms.
Proposition 2 For any formula ph of CLTL| (D), there exists an equivalent formula ph' such that: (I) any occurence of | in ph' is of the form |y=x ; (II) FleVars(ph' ) = FleVars(ph); (III) RigVars(ph' ) = RigVars(ph).
Proof.
By structural induction on ph, it suffices to prove the statement for formulae of the form |y=Xn x ph' where ph' satisfies (I).
This can be done by induction on n. The base case n = 0 is trivial.
For the inductive step, we use structural induction on ph' .
The most difficult case is ph' = ph'1 Uph'2 .
We then have |y=Xn+1 x ph' [?]
|y=Xn+1 x ph'2 [?]
(ph'1 [?]
Xph' ) [?]
(|y=Xn+1 x ph'2 ) [?]
((|y=Xn+1 x ph'1 ) [?]
X |y=Xn x ph' )  and the induction hypotheses apply to each of the three freeze subformulae.
It is worth observing that in the worst case, in the proof of Proposition 2, ph' can be exponentially larger than ph.
Proposition 3 For any formula ph of CLTL| (D), there exists an equivalent formula ph' such that: * * * *  atomic formulae in ph' contain only rigid variables; if any occurence of | in ph is of the form |y=x , then the same is true of ph' ; FleVars(ph' ) = FleVars(ph); |RigVars(ph' )| = max{|RigVars(ph)|, k}, where k is the maximum number of distinct terms in any atomic subformula of ph.
Proof.
ph' is constructed from ph by translating only atomic subformulae of ph.
For example, R(X2 x1 , y1, X3 x2 , X2 x3 , x4 , y2 , x4 ), where xi [?]
FleVarSet and yi [?]
RigVarSet, is translated to |y3 =x4 X2 |y4 =x1 |y5 =x3 X1 |y6 =x2 R(y4 , y1 , y6 , y5, y3 , y2 , y3 ) 9  where y3 , .
.
.
, y6 are drawn from RigVars(ph) \ {y1 , y2 }.
If that set does not have enough elements, new rigid variable names are used.
The latter can then be reused in translations of other atomic subformulae.
Flexible and finitary variables.
If the domain D has at least two elements, and if the equality predicate is present, then formulae and models of CLTL| (D) with n >= 2 flexible variables can be translated to the fragment with only one flexible variable.
Proposition 4 Let D be a constraint system with at least two elements and equality.
For any formula ph of CLTL| (D), one can compute in logarithmic space a formula ph' of CLTL| (D) with a unique flexible variable and the same set of rigid variables as ph, such that ph is satisfiable iff ph' is satisfiable.
Proof.
Let ph be a formula of CLTL| (D) with flexible variables x1 , .
.
.
, xn .
We shall build in logspace a formula ph' of CLTL| (D) with only one flexible variable x' and the same set of rigid variables as ph, such that s ' |=r ph' iff there exists s with s |=r ph and s ' is an encoding of s in the following sense.
A valuation s(i) : {x1 , .
.
.
, xn } - D is encoded by 2n + 4 consecutive values of x' in s ' which form a sequence di1 , di0 , di0 , di0 , di1 , s(i)(x1 ), di2 , s(i)(x2 ), .
.
.
, din , s(i)(xn ) Using the equality predicate, the values dij are constrained in ph' so that three consecutive equal values occur in s ' only at the beginnings of sequences which encode valuations in s. The formula ph' is a conjunction phenc [?
]T (ph) where phenc enforces that models are sequences of length 2n+4 of the above form (details are omitted here).
Formula T (ph) is inductively defined as follows where start = X(x' = Xx' [?]
x' = XXx' ): * T (R(t1 , .
.
.
, tm )) = R(T (t1 ), .
.
.
, T (tm )) where T (y) = y if y is rigid and T (Xk xi ) = Xkx(2n+4)+3+2i x' , * T is homomorphic for Boolean connectives, * T (|y=Xk xi ph1 ) =|y=T (Xk xi ) T (ph1 ), * T (ph1Uph2 ) = (start = T (ph1 ))U(start [?]
T (ph2 )), * T (Xph1) = X2n+4 T (ph1 ).
The logics CLTL| (D) as defined in Section 2.1 do not in general have propositional variables.
If D has at least two elements and equality, then propositional flexible variables, or a flexible variable ranging over a finite alphabet, can be encoded using additional flexible variables over D and equality.
A translation as above can then be employed to reduce the number of flexible variables.
10  For ease of expression, to avoid unnecessary constructs, and because equality on the domain is not necessarily present, arbitrarily many flexible variables and no special finitary variables are considered in the rest of the paper.
3  Decidability results  3.1 Finite domain case  In this section, we basically show that, when D is finite (with at least two elements) and contains the equality predicate, CLTL| (D) is ExpSpace-complete.
In Theorem 1 below, we establish that ExpSpace-hardness is very common when the freeze quantifier is present.
Theorem 1 Let D be a constraint system with equality such that the underlying domain D contains at least two elements.
The satisfiability problem for CLTL| (D) is ExpSpace-hard.
Proof.
We prove this result by a reduction from an ExpSpace-complete tiling problem (see e.g.
[25]).
A tile is a unit square of one of several types and the tiling problem we consider is specified by means of a finite set T of tile types (say T = {t1 , .
.
.
, tl }), two binary relations H (horizontal matching relation) and V (vertical matching relation) over T and two distinguished tile types tinit , tf inal [?]
T .
The problem consists in determining whether, for a given number n in unary, the region [0, .
.
.
, 2n - 1] x [0, .
.
.
, k - 1] of the integer plane for some k can be tiled consistently with H and V , tinit is the left bottom tile, and tf inal is the right upper tile.
Given an instance I = hT, tinit , tf inal , ni of the tiling problem, we build a CLTL| (D) formula phI such that I = hT, tinit , tf inal , ni has a solution iff phI is CLTL| (D) satisfiable.
We consider the following flexible variables: * c1 , .
.
.
, cn are variables that allow to count until 2n and x0 , x1 are variables that will play the role of 0 and 1, respectively; there are corresponding rigid variables c'1 , .
.
.
, c'n ; each element ha, ii of a row [0, .
.
.
, 2n - 1] x {i} such that the binary representation of a is b1 .
.
.
bn , satisfies cj = x0 iff bj = 0 for every j [?]
{1, .
.
.
, n}; * for t [?]
T , zt1 , zt2 are variables such that Dt := zt1 = zt2 is the formula encoding the fact that at a certain position of the integer plane the tile t is ' ' ' ' present.
There are also rigid variables zt1 , zt2 and Dt' := zt1 = zt2 ; * end1 , end2 such that END := end1 = end2 ; 11  The formula phI is the conjunction of the following formulae: * The region of the integer plane for the solution is finite: !END [?]
(!ENDU(c1 = * * * = cn = x0 [?]
G END)) * x0 and x1 behave as different constants: !
(x0 = x1 ) [?]
G(x0 = Xx0 [?]
x1 = Xx1 ) * There is exactly one tile per element of the plane region: G(!END =  _  (Dt [?]
^  !Dt' ))  t' 6=t  t[?
]T  * Constraint on the right upper tile: ^  F(  (ci = x1 ) [?]
!END [?]
Dtf inal [?]
XEND)  1<=i<=n  * Constraint on the left bottom tile: ^  (ci = x0 ) [?]
Dtinit  1<=i<=n  * Incrementation of the counters c1 , .
.
.
, cn : G(  _  ((  2<=i<=n+1  =(  ^  ^  cj = x1 ) [?]
ci-1 = x0 [?]
!END)  i<=j<=n  (cj = Xcj ) [?]
Xci-1 = x1 [?]
1<=j<=i-2  ^  (Xcj = x0 ))))  i<=j<=n  * Limit condition for the incrementation of the counters c1 , .
.
.
, cn : G((!XEND [?]
c1 = * * * = cn = x1 ) = X(c1 = * * * = cn = x0 )) * Horizontal consistency: not the last element of a row  }|  z  {  G( !
(c1 = * * * = cn = x1 ) [?
]!END =  ^  _  (Dt =  t[?
]T  XDt' ))  ht,t' i[?
]H  * Vertical consistency: not on the last row  }|  z  {  G(!END [?]
F(X!END [?]
c1 = .
.
.
= cn = x1 ) = |c'1 =c1 * * * |c'n=cn |z 1' =z 1 |z 2' =z 2 .
.
.
|z 1' =z 1 |z 2' =z 2 X((!
^  1<=i<=n  c'i  = ci )U(  t1  t1  ^  c'i  t1  = ci [?]
1<=i<=n  tk  t1  ^  t[?
]T  12  (Dt'  =  tk  tk  _  ht,t' i[?
]V  tk  XDt' )))  It is not difficult to show that the instance I = hT, tinit , tf inal , ni has a solution iff phI is CLTL| (D) satisfiable.
This is reminiscent to the ExpSpace-hardness of Timed Propositional Temporal Logic (TPTL) [12, Theorem 2], PLTL+Now (NLTL) [26, Proposition 4.7] and a variant of the guarded fragment with transitivity [27, Theorem 2].
Our ExpSpace-hardness proof is in the same vein since basically in CLTL| (D) we are able to count till 2n using only a number of resources polynomial in n and we can compare the truth value of atomic formulae in states of "temporal distance" exactly 2n .
Our proof is a slight variant of the proof of [14, Theorem 6]: instead of using integer periodicity constraints to count till 2n , n binary counters are used.
Observe also that the resulting formula is not flat because of the encoding of vertical consistency.
If we replace U by F, then NExpTime-hardness can be shown by reducing from the n x n tiling problem with n encoded in binary.
Finiteness of D allows us to show the decidability of CLTL| (D).
Theorem 2 Let D be a finite constraint system.
The satisfiability problem for CLTL| (D) is in ExpSpace.
Proof.
Assume that D = {d1 , .
.
.
, dl }.
We introduce an auxiliary constraint system D ' = hD, P1, .
.
.
, Pl i such that Pi = {di}.
For convenience, we write x = di instead of Pi (x).
We shall show how to reduce the satisfiability problem for CLTL| (D) into the satisfiability problem for CLTL(D ' ).
PSpace-membership of CLTL(D ' ) is not very difficult to show and it is a direct consequence of [14, Theorem 4].
We introduce a translation T from CLTL| (D) formulae into CLTL(D ' ) formulae defined as follows: * T is homomorphic for the Boolean operators and the temporal operators, def W * T(R(a1 , .
.
.
, an )) = ( R(di1 ,...,din ) (a1 = di1 [?]
* * * [?]
an = din )).
So far, the translation can be done in polynomial time and logarithmic space since |D|m is a constant of CLTL| (D) where m is the maximal arity of relations in D. The last clause of T is related to the freeze quantifier: def  T(|x' =a ps) =  ^  '  (a = di ) = T(ps)x =di ,  di [?
]D '  where T(ps)x =di is obtained from T(ps) by replacing every occurrence of x' = dj with j 6= i by [?]
and every occurrence of x' = di by [?].
This step requires an exponential blow up and therefore |T(ph)| is exponential in |ph|.
It is easy to 13  show that ph is CLTL| (D) satisfiable iff T(ph) is CLTL(D ' ) satisfiable.
Since T may cause at most an exponential blow up and CLTL(D ' ) is in PSpace, we obtain that CLTL| (D) satisfiability is in ExpSpace.
Our proof can be easily adapted if the freeze quantifier is replaced by the full existential quantifier [?].
Corollary 1 Let D be a finite constraint system with equality such that the underlying domain D contains at least two elements.
The satisfiability problem for CLTL| (D) is ExpSpace-complete.
A formula ph [?]
CLTL| (D) is of |-height k, for some k >= 0, whenever every branch of the formula tree of ph has at most k freeze quantifiers.
For example, the formula |x' =x (y = x' )U |x' =z y = x' is of |-height 2.
Corollary 2 Let D be a finite constraint system.
For every k >= 0, the satisfiability problem for CLTL| (D) restricted to formulae of |-height k is in PSpace.
The complexity of CLTL| (D) with finite D and restricted to the 'sometimes' operator F is still open.
(NExpTime-hardness and ExpSpace upper bound are known.)
3.2 Flat fragment between CLTL(D) and CLTL| (D) The main result of this section is to show that the freeze quantifier in the flat fragment of CLTL| (D) can be encoded faithfully into CLTL(D) even though flat CLTL| (D) can be more expressive than CLTL(D), see for instance the case with D = hN, =i in Section 2.4.
However, as shown below, satisfiability for flat CLTL| (N, =) can be reduced in logarithmic space to satisfiability for CLTL(N, =).
By analogy, CTL* model-checking can be reduced to LTL modelchecking [28] even though CTL* is more expressive than LTL.
It is worth observing that our concept of flatness restricts the interplay between future-time operators and the freeze quantifier as done in [22,10,23] to limit the interaction between modalities and freeze-like quantifiers.
In order to understand why flat formulae are more manageable, in a formula like |y=x Fph that is flat, only the current value of x needs to be stored.
By contrast, in a formula like G |y=x ph that is not flat, one needs to store as many values of x as there are positions.
We assume that the flexible variables of CLTL| (D) are {x0 , x1 , .
.
.}
and the rigid variables of CLTL| (D) are {y0, y1 , .
.
.}.
For ease of presentation, we assume that the flexible variables of CLTL(D) are composed of the following two 14  disjoint sets: {x0 , x1 , .
.
.}
and {y0new , y1new , .
.
.}.
We define a map u from the flat fragment CLTL| (D) into CLTL(D) as follows: u replaces each yj by yjnew in atomic formulae, it is homomorphic for Boolean and temporal operators, and u(|y=Xn x ps) = y new = Xn x [?]
G(y new = Xy new ) [?]
u(ps) def  It is easy to show that u(ph) can be computed in logarithmic space in |ph|.
Proposition 5 Let D be a constraint system with equality.
For any formula ph of the flat fragment of CLTL| (D), ph is CLTL| (D) satisfiable iff u(ph) is CLTL(D) satisfiable.
Proof.
Given a model s of CLTL| (D), an environment r and a formula ph we say that the model s ' of CLTL(D) agrees with s, r and ph iff for all i, j >= 0, s(i)(xj ) = s ' (i)(xj ) and for all free rigid variable yj in ph and i >= 0, s ' (i)(yjnew ) = r(yj ).
We shall use the following basic properties: * u(ps) = ps if ps belongs to CLTL(D).
* If s ' agrees with s, r and ps then (s ' )i agrees with s i , r and ps for every i >= 0.
Given the occurrence of a subformula ps in ph with positive [resp.
negative] polarity, we write the sign sps to denote the empty string [resp.
!].
By abusing notation, we do not distinguish subformulae from occurrences.
We shall show by structural induction that for any occurrence of a subformula ps in ph, for all models s of CLTL| (D) and environment r, s |=r sps ps iff there is s ' that agrees with s, r and ps such that s ' |= sps u(ps).
Statement of the lemma is then immediate.
The base case with atomic formulae and the cases in the induction step with !, [?]
and X are by an easy verification.
By way of example, we treat the case with ps = !ps ' with negative polarity.
So ps ' occurs with positive polarity.
Let s be a model and r be an environment such that s |=r !
!ps ' .
The statements below are equivalent: * s |=r !
!ps ' , * s |=r ps ' , * there is s ' that agrees with s, r and ps ' such that s ' |= u(ps ' ) (by (IH) and change of polarity), * there is s ' that agrees with s, r and ps ' such that s ' |= !u(!ps ' ) (by definition of u).
Let us treat the remaining cases.
15  Case 1 : ps = ps1 Ups2 with positive polarity.
Since ph belongs to the flat fragment, we have ps1 = u(ps1 ).
Let s be a model and r be an environment such that s |=r ps.
The statements below are equivalent: * s |=r ps, * there is i >= 0 such that s i |=r ps2 and for every j < i, s j |=r ps1 , * there is s ' that agrees with s, r and ps2 such that (s ' )i |= u(ps2 ) and for every j < i, (s ' )j |= u(ps1 ) (by (IH), ps1 = u(ps1 ) and, s and s ' agree on flexible variables of ps1 ), * there is s ' that agrees with s, r and ps such that s ' |= u(ps1 )Uu(ps2 ) (ps1 has no free rigid variable).
Case 2 : ps = ps1 Ups2 with negative polarity.
Since ph belongs to the flat fragment, we have ps2 = u(ps2 ) and both ps1 and ps2 have negative polarity.
Let s be a model and r be an environment such that s |=r ps.
The statements below are equivalent: * s |=r !ps, * either there is j >= 0 such that s j |=r !ps1 and for every j <= i, s i |=r !ps2 or for every i >= 0, s i |=r !ps2 , * either there is s ' that agrees with s, r and ps1 such that there is j >= 0 such that (s ' )j |= !u(ps1 ) and for every j <= i, (s ' )i |= !u(ps2 ) (by (IH) and ps2 = u(ps2 )) or there is s ' that agrees with s, r and ps2 such that for every i >= 0, (s ' )i |= !u(ps2 ) (by (IH)), * there is s ' that agrees with s, r and ps1 Ups2 such that either there is j >= 0 such that (s ' )j |= !u(ps1 ) and for every j <= i, (s ' )i |= !u(ps2 ) or for every i >= 0, (s ' )i |= !u(ps2 ) (ps2 has no free rigid variables), * there is s ' that agrees with s, r and ps1 Ups2 such that s ' |= !
(u(ps1 )Uu(ps2 )).
Case 3 : ps =|y=Xn x ps ' .
Let s be a model and r be an environment for sps and ps.
The statements below are equivalent: * s |=r sps ps, * s |=r[y7-s(n)(x)] sps ps ' , * there is s ' that agrees with s, r[y 7- s(n)(x)] and ps ' such that s ' |= sps u(ps ' ) (by (IH)), * there is s ' that agrees with s, r[y 7- s(n)(x)] and ps ' such that s ' |= sps u(ps ' ) and s ' |= G(y new = Xy new ) [?]
y new = Xn x (y free in ps ' ).
* there is s ' that agrees with s, r and ps such that s ' |= sps u(ps ') [?]
G(y new = Xy new ) [?]
y new = Xn x (ps has less free rigid variable than ps ' ).
Corollary 3 For every constraint system D which contains equality, decidability of CLTL(D) implies decidability of the flat fragment of CLTL| (D).
Since CLTL(hZ, <, =i), CLTL(hN, <, =i) and CLTL(hR, <, =i) are PSpace16  complete [11], we can establish the following corollary.
Corollary 4 Flat fragments of each of CLTL| (hZ, <, =i), CLTL| (hN, <, =i), CLTL| (hR, <, =i), and CLTL| (D) with D finite are PSpace-complete.
Corollary 4 can be also adapted to the PSpace-complete constrained version of LTL introduced in [29].
4  Undecidability results  In this section, we shall prove that, if the domain is infinite, and if we do not restrict to flat formulae, the satisfiability problem for CLTL| (D) is undecidable even if we only have the equality predicate.
More precisely, Theorem 3 below is a stronger result, stating that satisfiability is S11 -hard, even restricted to formulae with 1 flexible variable and at most 2 rigid variables.
(An exposition of the analytical hierarchy can be found in [30].)
A corollary of S11 -hardness is that the logic cannot be recursively axiomatised.
The following proposition complements the main result in this section, and states that, for countable and computable constraint systems D, satisfiability for CLTL| (D) is in S11 .
Hence, for a countably infinite domain, the problem in Theorem 3 is S11 -complete.
Proposition 6 If D is countable, and (Ri )i[?
]I is a countable family of computable relations on D, then the satisfiability problem for CLTL| (D, (Ri )i[?
]I ) is in S11 .
Proof.
Let ph be a formula of CLTL| (D, (Ri )i[?
]I ).
We can assume FleVarSet = FleVars(ph) and RigVarSet = RigVars(ph).
Let n = |FleVarSet|, m = |RigVarSet|.
Any model s : N - (FleVarSet - D) can be encoded by functions f1 , .
.
.
, fn : N - N, and any environment r : RigVarSet - D as an m-tuple a1 , .
.
.
, am : N. A first-order predicate on f1 , .
.
.
, fn and a1 , .
.
.
, am which expresses that s |=r ph is routine to construct by structural recursion on ph.
We conclude that satisfiability of ph can be expressed by a S11 -sentence.
We shall prove that the satisfiability problem for a fragment of CLTL| (D, =) is S11 -hard by reducing from the Recurrence Problem for nondeterministic 2-counter machines, which was shown to be S11 -hard in [12, Section 4.1].
A nondeterministic 2-counter machine M consists of two counters C1 and C2 , and a sequence of n >= 1 instructions, each of which may increment or decrement one of the counters, or jump conditionally upon of the counters being zero.
After the execution of a non-jump instruction, M proceeds nondeterministically to one of two specified instructions.
Therefore, the lth instruction is 17  written as one of the following: l : Ci := Ci + 1; goto l' or goto l'' l : Ci := Ci - 1; goto l' or goto l'' l : if Ci = 0 then goto l' else goto l'' We represent the configurations of M by triples hl, c1 , c2 i, where 1 <= l <= n, c1 >= 0, and c2 >= 0 are the current values of the location counter and the two counters C1 and C2 , respectively.
The consecution relation on configurations is defined in the obvious way, where decrementing 0 yields 0.
A computation of M is an o-sequence of related configurations, starting with the initial configuration h1, 0, 0i.
The computation is recurring if it contains infinitely many configurations with the value of the location counter being 1.
The Recurrence Problem is to decide, given a nondeterministic 2-counter machine M, whether M has a recurring computation.
This problem is S11 -hard.
Theorem 3 If D is infinite, then the satisfiability problem for CLTL| (D, =) with |FleVarSet| = 1 and |RigVarSet| = 2 is S11 -hard.
Proof.
Suppose M is a nondeterministic 2-counter machine.
We construct a formula phM of CLTL| (D, =) such that |FleVars(ph)| = 1, |RigVars(ph)| = 2, and phM is satisfiable iff M has a recurring computation.
The basis of the construction is an encoding of computations of nondeterministic 2-counter machines by models of CLTL| (D, =) with one flexible variable, i.e.
by osequences of elements of D. As in the proofs of [12, Theorems 6 and 7], which show S11 -hardness of satisfiability of formulae of TPTL extended with either multiplication by 2 or dense time, we shall encode the value of a counter by a sequence of that length.
However, much further work is needed in this proof because the only operation we have on elements of D is equality.
Let n be the number of instructions in M. We encode a configuration hl, c1 , c2 i by a sequence of elements of D of the form ddd' d |.
.
.
d{z' .
.
}.
f11 .
.
.
fc11 eee' e'' f12 .
.
.
fc22 n  where: (i) the only two pairs of equal consecutive elements are dd and ee, and also fc22 is distinct from the first element in the encoding of the next configuration, (ii) e 6= e'' , (iii) after the first 4 elements, there is a sequence of n elements, and only the lth equals d' , 18  2 4 n+4 phinit (starte [?]
X4 (startd[?
]e )) n = startd [?]
X x = X x [?]
X def  phglob = G(startd = psn1 [?]
starte = psn2 ) n def  in dd' d...d' ... any two consecutive values are distinct  z  psn1 =  def  z   n _  l=1  [?
]X psn2 =  def  i=1  ps  dist  def  !
{  Xi x 6= Xi+1 x  [?]
in ...d' ... exactly one value equals d'  X2 x = Xl+3 x [?]
l-1 ^  }|  X2 x 6= Xj+3 x [?]
j=1  n+4  3 ^  i=1  }|    f11 ...fc11  z  n+3 ^  n ^  j=l+1  mutually distinct  (ps  }|  dist  {  {  X2 x 6= Xj+3 x  U starte ) !
f12 ...fc22 mutually distinct  z  }|  {  Xi x 6= Xi+1 x [?]
X4 (ps dist U startd )  = !startd[?
]e [?]
|y=x X((!startd[?
]e [?]
x 6= y)U startd[?
]e ) Fig.
1.
(iv) f1i , .
.
.
, fcii are mutually distinct, for each i.
We write startd[?
]e to denote the formula x = X1 x stating that the current state is an occurrence of either dd or ee.
We write startd [resp.
starte ] to denote the formula startd[?
]e [?]
x = X3 x [resp.
startd[?
]e [?]
x 6= X3 x] stating the current state is a first occurrence of d [resp.
e] in dd [ee].
The formula phM is defined as a conjunction glob phinit [?]
ph1M [?]
* * * [?]
phnM [?]
phrec n [?]
phn  where the first two conjuncts state that the model is a concatenation of configuration encodings which satisfy (i)-(iv) above, and that it begins with an encoding of the initial configuration h1, 0, 0i.
Their definitions are given in Figure 1.
For any l [?]
{1, .
.
.
, n}, phlM states that, whenever the model contains an encoding of a configuration hl, c1 , c2 i, then the next encoding is of a configuration which is obtained by executing the lth instruction.
Consider the most complex case: l : C2 := C2 - 1; goto l' or goto l'' .
The formula phlM needs to state that, whenever the location counter is l, C1 remains the same, C2 either remains 0 or is decremented, and the next value of the location counter is either l' or l'' : 19  0<=C2 <=1 and the next value of C2 equals 0  z  }|  {  kh2dec = ((x = X1 x [?]
X1 x = X2 x) [?]
(!starte U(starte [?]
X4 (x = X1 x))) [?]
def  C2 >1  }|  z  {  (!
(x = X1 x [?]
X1 x = X2 x) [?]
z  (A)  }|  {  (|y=x !starte U(starte [?]
X4 (!startd [?]
x = y))) [?]
z  (B)  }|  2  {  ((!X startd[?
]e [?]
(|y=x X | (!starte U(starte [?]
4 1 X (x 6= yU(x = y [?]
X x = y ' ))))))UX2 startd[?
]e ) [?]
y ' =x  (C)  }|  z  {  ((X2 !startd )U(X2 startd [?]
|y=x !starte U(starte [?]
X4 (x 6= yU (x = y [?]
!startd [?]
X2 startd ))))) Fig.
2.  phlM = G((startd [?]
X2 x = Xl+3 x) = Xn+4 (kh1eq [?]
(!startd[?
]e U(starte [?]
def  X4 (kh2dec [?]
(!startd[?
]e U(startd [?]
'  (X2 x = Xl +3 x [?]
X2 x = Xl  '' +3  x))))))))  The formula kh2dec given in Figure 2 specifies that, if the current value of C2 is either 0 or 1, then the next value of C2 is 0; and if neither, then the next encoding of the value of C2 equals the current encoding with the last element removed.
The latter is specified as the following conjunction: (A) the first element of the current encoding equals the first element of the next encoding, and (B) for any consecutive pair y and y ' of elements in the current encoding such that y ' is not the last element, the first occurence of y in the next encoding is followed by y ', and (C) the element before the last in the current encoding is the last element in the next encoding.
The formula kh1eq , which specifies that the value of C1 remains the same, is defined similarly.
Definitions of phlM for other forms of instruction use the same machinery.
For incrementing a counter, it is not necessary to specify that the additional element in the next encoding is distinct from the rest, because that is ensured 20  by phglob n .
def  Finally, phrec = GF(startd [?]
X2 x = X4 x) states that the model encodes a recurring computation.
By Propositions 2 and 3, we have that Theorem 3 can be strengthened by restricting to the fragment of CLTL| (D, =) with |FleVarSet| = 1, |RigVarSet| = 2 and such that the flexible variable occurs only in freeze quantifiers of the form |y=x .
By adapting the proof of Theorem 3, the variant of CLTL| (D, =) over models which are finite words is also undecidable, more precisely S01 -hard through encoding the Halting Problem for 2-counter machines.
This should be compared with the undecidability of universality of 1-way nondeterministic register automata [31, Theorem 5.1].
The proof of Theorem 3 can also be modified to yield, for CLTL| (D, =) augmented with the past-time operator U-1 ('since') but restricted to 1 rigid variable, S11 -hardness over infinite models and S01 -hardness over finite models.
The sets of values from D which are used to encode counter values do not have to be enumerated in the same order for consecutive configurations, and simpler logical formulae suffice.
These results are related to the undecidability of emptiness of 2-way deterministic register automata: see [32, Section 7], [31, Theorem 5.3].
5  Related work  In this section, we compare the logic CLTL| (N, =) and the results in this paper with a number of related works in the literature.
We show that there is a surprising variety of formalisms which involve the freeze quantifier or related constructs, revealing links among several works which appear unconnected.
This confirms that the binding mechanism of the freeze quantifier is fundamental.
LTL over concrete domains.
Complexity results for Constraint LTL over concrete domains can be found in [16,17,11,18,14] (see also related results for description logics over concrete domains in [33]).
Decidability and complexity issues for LTL over Presburger constraints have been studied for instance in [34,22,10,14].
Most decision procedures in the above-mentioned works are automata-based whereas undecidability proofs often rely on an easy encoding of the Halting Problem for 2-counter machines.
21  LTL over integer periodicity constraints augmented with the freeze quantifier is shown ExpSpace-complete [14] but CLTL(N, <, =) with past-time operator F-1 and | is undecidable [14].
Real-time logics.
Similar issues for real-time and modal logics equipped with the freeze quantifier have been considered in [12,35,13,36].
In spite of its rich language of constraints, TPTL model-checking is decidable [12] (discrete version).
In this case, decidability is due to the subtle combination of the constraint system and the semantical restrictions (see also versions of metric temporal logics in [37,38]).
The class of logics CLTL| (D) defined in this paper is quite general and it is not difficult to show that discrete-time TPTL [12] is exactly the fragment of CLTL| (D) where * D = N and the only flexible variable is t (time), * the predicates of D are (x <= c)c[?
]Z , (x <= y + c)c[?
]Z , (x [?
]d c)c,d[?
]N , (x [?
]d y + c)c,d[?
]N where [?
]d is equality modulo d, and * the formulae are of the form G(t <= Xt) [?]
GF(t < Xt) [?]
ph with any use of the freeze quantifier being of the form |x=t .
In [12, Theorem 5], S11 -hardness of satisfiability for TPTL without the monotonicity condition on time sequences is established.
By Propositions 2 and 3, CLTL| (N, =) restricted to one flexible variable can be seen as the fragment of TPTL where there are no atomic propositions, and where the only operation on time is equality.
Moreover, it is straightforward to see that Theorem 3 in this paper still holds when satisfiability is restricted to models which contain infinitely many values, which is equivalent to the progress condition when the domain is N. Therefore, a corollary of Theorem 3 is the following strengthening of [12, Theorem 5]: satisfiability for TPTL without the monotonicity condition remains S11 -complete even without atomic propositions and with only equality constraints.
(The proof of [12, Theorem 5] uses arithmetic on time values.)
Hybrid, navigation, spatio-temporal, and similar logics.
Hybrid logics (see e.g.
[39,40,41]) contain a variable-binding mechanism similar to the freeze quantifier: |x ph(x) holds true iff ph(x) holds true when the propositional variable x is interpreted as a singleton containing the current state.
The downarrow binder in such hybrid logics records the value of the current state.
Similarly, in temporal logic with forgettable past [26], the effect of the Now operator is that the origin of time takes the value of the current state: the 22  states before the current state are forgotten.
Identical mechanisms are used in navigation logics for object structures, see e.g.
[42] and in half-order dynamic temporal logics interpreted over traces from sequence diagrams [43].
In the context of spatio-temporal logics, Wolter and Zakharyaschev [16, Section 7] advocate the need to consider operators expressing constraints of W V the form i[?
]N R(x, Xi y) and i[?
]N R(x, Xi y).
They are simple to express in CLTL| (D), as |x' =x GR(x' , y) and |x' =x FR(x' , y).
These formulae are in the flat fragment: see Section 3.2.
Quantified propositional temporal logic with repeating.
The models of Quantified Propositional Temporal Logic with Repeating (also known as RQPTL) introduced in [44] can be encoded by CLTL| (N, =) formulae, unlike the second-order quantification in the language.
Such models are pairs of maps hu : N - S, p : S - 2AP i where S is an arbitrary set (of states).
A possible encoding is by treating u as the interpretation of a distinguished flexible variable, and using the freeze quantifier to specify that, whenever u(i) = u(j), any propositional variable has the same values at time points i and j.
(See Section 2.4 regarding encodings of propositional variables.)
On the other hand, the variant logic RHLTLn [44, Section 4] can be shown equivalent to CLTL| (N, =) with one flexible variable and n rigid variables, except that RHLTLn does not have the U operator but has F and the pasttime operators F-1 and X-1 .
Theorem 3 in this paper and S11 -hardness of RHLTL2 [44, Corollary 1] are therefore complementary results.
Predicate l-abstraction.
A number of decidability and undecidability results for half-order modal logics (to be compared with [35]) are presented in [45].
The half-order aspect of such logics is due to a predicate l-abstraction mechanism, which solves the famous problem of interpreting constants in modal logic.
Even though this construct is essentially the same as the freeze quantifier, apparently there have been no cross-references between the literature dealing with predicate l-abstraction (e.g.
[45,15]) and that dealing with the freeze quantifier (e.g.
[35,12,14,1]).
However, several undecidability results for LTL-like logics with predicate l-abstraction have recently been obtained in [15], independently and concurrently with [1].
The most related to Theorem 3 in this paper are S11 -hardness results for the following logics: (I) LTLl= with temporal operators X and U, and with 3 rigid variables; (II) LTLl with temporal operators X and U, and with countably infinitely many unary predicate symbols (but no equality).
23  Remarkably, LTLl= is essentially the same as CLTL| (N, =).
The proofs of (I) in [15] and of Theorem 3 above reduce from the same S11 -hard problem.
However, the encodings are different, enabling Theorem 3 to be sharper by restricting to 1 flexible and 2 rigid variables.
An interesting discussion of applications to dynamic systems with resources, like communication protocols for mobile agents, can also be found in [15].
Monodic first-order temporal logics.
Since freeze quantification is firstorder quantification over a singleton set, the freeze quantifier can be expressed in first-order temporal logics [46,47,48,49].
Indeed, CLTL| (N, =) satisfiability can be reduced to first-order temporal logic T L satisfiability over the linear structure hN, <i (the latter logic was introduced in [49, Chapter 11]).
To each flexible variable x one associates a monadic predicate symbol Px in such a way that Px is interpreted as the singleton set containing the value of x.
A formula of the form |x' =Xx ph is then translated to [?
]x' XPx (x' ) [?]
ph' where ph' is the translation of ph.
The translation is homomorphic for Boolean and temporal operators, whereas for instance y = Xz with y, z [?]
FleVarSet is translated into [?
]x Py (x) [?]
XPz (x).
One needs also to be able to express that at every state Px is interpreted by a singleton, which can be encoded by the formula G([?
]z Px (z) [?]
[?
]z, z ' (Px (z) [?]
Px (z ' ) = z = z ' )).
Consider the fragment of CLTL| (N, =) with |RigVarSet| = 1.
It is easy to check that its translation is contained in the monodic fragment of T L with equality, and with only two individual variables and monadic predicate symbols.
We recall that in the monodic fragment, any temporal subformula (i.e.
whose outermost construct is a temporal operator) must have at most one free individual variable.
Even though monodic T L over hN, <i is decidable [50], its extension with equality is not [47], even with the above restrictions [46].
Logics and automata for data languages.
In [51,52], data languages are defined as sets of finite data words in (S x D)* where S is a finite alphabet and D is an infinite domain (generalising the concept of timed languages), and automata which recognise data languages are introduced.
The latter are related to register and pebble automata for strings over infinite alphabets (e.g.
[31]).
First-order logic over finite data word models is considered in [53], with motivations stemming from query languages for semistructured data.
More precisely, the carrier of a model is the set of positions in a data word, there are no function symbols, the unary predicates correspond to elements of S, and there are binary predicates <, +1, as well as ~ which is interpreted as equality of elements of D at given positions.
FOk (~, <, +1) denotes such a logic with 24  k variables.
The main result of [53] is that satisfiability of FO2 (~, <, +1) is decidable, by a doubly exponential-time reduction to nonemptiness of multicounter automata.
(The latter problem is decidable, but there is no known elementary upper bound.)
The following variant of CLTL| (D, =) has models which are words over SxD: there is one flexible variable x which takes values in D, plus one flexible variable l which takes values in S and on which freeze quantification cannot be used, but to which unary predicates Pa for equality testing with a [?]
S can be applied.
Interestingly, that logic with infinite D and 1 rigid variable is incomparable with FO2 (~, <, +1).
In one direction, FO2 (~, <, +1) cannot express the U operator, and also not formulae of the form |y=x ph where y occurs in ph under two or more temporal operators.
In the other direction, FO2 (~, <, +1) can express past-time operators such as F-1 .
6  Conclusion  We have shown that adding the freeze quantifier to CLTL(D) leads to undecidability as soon as the underlying domain is infinite and the equality predicate is part of D. As illustrated in the paper, in most related work dealing with undecidable logics having a binding mechanism similar to freeze quantification, either past-time operators can be encoded or constraints richer than equality are available.
The logic CLTL| (D) is ExpSpace-complete for most of finite domains D. In order to design a specification language over infinite domains with LTL temporal operators and the freeze quantifier that admits a decidable modelchecking problem, syntactic restrictions could be a reasonable solution.
The existence of a logarithmic-space reduction from the flat fragment of CLTL| (D) into CLTL(D) when the equality predicate is present leads us to believe that the flatness criterion is most relevant here.
As we have seen, the following fragments/variants of CLTL| (D, =) with infinite D and |FleVarSet| = 1 are S11 -hard: * the temporal operators are X and U, and |RigVarSet| = 2; * the temporal operators are X, U and U-1 , and |RigVarSet| = 1; * the temporal operators are X, X-1 , F and F-1 , and |RigVarSet| = 2; It is open whether the intersections of these fragments are decidable.
Other open problems include: * decidability in the presence of semantic restrictions such as reversal bound25  edness [5] of a flexible variable; * decidability over infinite domains without equality (and where equality is not definable by other predicates), such as h{0, 1}*, <i with < being either the strict prefix relation or the strict subword relation.
Acknowledgements.
We are grateful to Deepak D'Souza, Claire David, Anca Muscholl and Luc Segoufin for helpful discussions, and to Frank Wolter for having directed us to related work.
References [1] S. Demri, R. Lazic, D. Nowak, On the freeze quantifier in constraint LTL: decidability and complexity, in: 12th Int.
Symp.
Temporal Representation and Reasoning (TIME), IEEE, 2005, pp.
113-121.
[2] P. Schnoebelen, The complexity of temporal logic model checking, in: AiML'02, Vol.
4 of Advances in Modal Logic, King's College, 2003, pp.
393-436.
[3] P. Revesz, Introduction to Constraint Databases, Springer, 2002.
[4] R. Alur, D. Dill, A theory of timed automata, Theoretical Comput.
Sci.
126 (1994) 183-235.
[5] O. Ibarra, Reversal-bounded multicounter machines and their decision problems, J. ACM 25 (1) (1978) 116-133.
[6] B. Boigelot, Symbolic methods for exploring infinite state spaces, Ph.D. thesis, Universite de Liege (1998).
[7] B. Boigelot, P. Wolper, Representing arithmetic constraints with finite automata: an overview, in: 18th Int.
Conf.
Logic Prog.
(ICLP), Vol.
2401 of Lect.
Notes Comput.
Sci., Springer, 2002, pp.
1-19.
[8] A. Finkel, J. Leroux, How to compose Presburger accelerations: Applications to broadcast protocols, in: 22nd Conf.
Foundations of Software Tech.
and Theoretical Comput.
Sci.
(FSTTCS), Vol.
2256 of Lect.
Notes Comput.
Sci., Springer, 2002, pp.
145-156.
[9] J. Leroux, G. Sutre, Flat counter systems are everywhere!, in: 3rd Int.
Symp.
Automated Tech.
for Verification and Analysis (ATVA), Vol.
3707 of Lect.
Notes Comput.
Sci., Springer, 2005, pp.
489-503.
[10] H. Comon, V. Cortier, Flatness is not a weakness, in: 14th Int.
Works.
Comput.
Sci.
Logic (CSL), Vol.
1862 of Lect.
Notes Comput.
Sci., Springer, 2000, pp.
262-276.
[11] S. Demri, D. D'Souza, An automata-theoretic approach to constraint LTL, Tech.
Rep. 03-11, LSV, an extended abstract appeared in FSTTCS'02 (2003).
26  [12] R. Alur, T. Henzinger, A really temporal logic, J. ACM 41 (1) (1994) 181-204.
[13] E. Harel, O. Lichtenstein, A. Pnueli, Explicit clock temporal logic, in: 5th Symp.
Logic in Comput.
Sci.
(LICS), IEEE, 1990, pp.
400-413.
[14] S. Demri, LTL over integer periodicity constraints, Tech.
Rep. 04-6, LSV, an extended abstract appeared in FOSSACS'04 (2004).
[15] A. Lisitsa, I. Potapov, Temporal logic with predicate l-abstraction, in: 12th Int.
Symp.
Temporal Representation and Reasoning (TIME), IEEE, 2005, pp.
147-155.
[16] F. Wolter, M. Zakharyaschev, Spatio-temporal representation and reasoning based on RCC-8, in: 7th Int.
Conf.
Principles of Knowledge Representation and Reasoning (KR), Morgan Kaufmann, 2000, pp.
3-14.
[17] P. Balbiani, J. Condotta, Computational complexity of propositional linear temporal logics based on qualitative spatial or temporal reasoning, in: 4th Int.
Works.
Frontiers of Combining Systems (FroCoS), Vol.
2309 of Lect.
Notes Artif.
Int., Springer, 2002, pp.
162-173.
[18] D. Gabelaia, R. Kontchakov, A. Kurucz, F. Wolter, M. Zakharyaschev, On the computational complexity of spatio-temporal logics, in: 16th Int.
Florida AI Research Soc.
Conf.
(FLAIRS), AAAI, 2003, pp.
460-464.
[19] A. Sistla, E. Clarke, The complexity of propositional linear temporal logic, J. ACM 32 (3) (1985) 733-749.
[20] D. Dams, Flat fragments of CTL and CTL*: separating the expressive and distinguishing powers, Logic J. IGPL 7 (1) (1999) 55-78.
[21] O. Ibarra, Z. Dang, On removing the stack from reachability constructions, in: Int.
Symp.
Algorithms and Computation (ISAAC), Vol.
2223 of Lect.
Notes Comput.
Sci., Springer, 2001, pp.
244-256.
[22] A. Bouajjani, P. Habermehl, Constrained properties, semilinear sets, and Petri nets, in: 7th Int.
Conf.
Concurrency Theory (CONCUR), Vol.
1119 of Lect.
Notes Comput.
Sci., Springer, 1996, pp.
481-497.
[23] B. ten Cate, M. Franceschet, On the complexity of hybrid logics with binders, in: 19th Int.
Works.
Comput.
Sci.
Logic (CSL), Vol.
3634 of Lect.
Notes Comput.
Sci., Springer, 2005, pp.
339-354.
[24] P. Wolper, Temporal logic can be more expressive, Inf.
and Comput.
56 (1983) 72-99.
[25] P. van Emde Boas, The convenience of tilings, in: Complexity, Logic, and Recursion Theory, Vol.
187 of Lecture Notes in Pure and Applied Logic, Marcel Dekker, 1997, pp.
331-363.
[26] F. Laroussinie, N. Markey, P. Schnoebelen, Temporal logic with forgettable past, in: 17th Symp.
Logic in Comput.
Sci.
(LICS), IEEE, 2002, pp.
383-392.
27  [27] E. Kieronski, EXPSPACE-complete variant of guarded fragment with transitivity, in: 19th Ann.
Symp.
Theoretical Aspects of Comput.
Sci.
(STACS), Vol.
2285 of Lect.
Notes Comput.
Sci., Springer, 2002, pp.
608-619.
[28] A. Emerson, J. Halpern, "Sometimes" and "Not Never" revisited: on branching versus linear time temporal logic, J. ACM 33 (1986) 151-178.
[29] S. Demri, R. Gascon, Verification of qualitative Z-constraints, in: 16th Int.
Conf.
Concurrency Theory (CONCUR), Vol.
3653 of Lect.
Notes Comput.
Sci., Springer, 2005, pp.
518-532.
[30] H. Rogers, Jr, Theory of Recursive Functions and Effective Computability, McGraw-Hill, 1967.
[31] F. Neven, T. Schwentick, V. Vianu, Finite state machines for strings over infinite alphabets, ACM Trans.
Comput.
Logic 5 (3) (2004) 403-435.
[32] C. David, Mots et donnees infinies, Master's thesis, LIAFA (2004).
[33] C. Lutz, NEXPTIME-complete description logics with concrete domains, ACM Trans.
Comput.
Logic 5 (4) (2004) 669-705.
[34] A. Bouajjani, R. Echahed, P. Habermehl, On the verification problem of nonregular properties for nonregular processes, in: 10th Symp.
Logic in Comput.
Sci.
(LICS), IEEE, 1995, pp.
123-133.
[35] T. Henzinger, Half-order modal logic: how to prove real-time properties, in: 9th Ann.
Symp.
Principles of Distr.
Comput.
(PODC), ACM, 1990, pp.
281-296.
[36] T. Brihaye, V. Bruyere, J. Raskin, Model-checking for weighted timed automata, in: 2nd Int.
Conf.
Formal Modelling and Analysis of Timed Systems (FORMATS), Vol.
3253 of Lect.
Notes Comput.
Sci., Springer, 2004, pp.
277- 292.
[37] R. Alur, T. Henzinger, A really temporal logic, in: 30th Ann.
Symp.
Foundations Comput.
Sci.
(FOCS), IEEE, 1989, pp.
164-169.
[38] R. Alur, T. Feder, T. Henzinger, The benefits of relaxing punctuality, J. ACM 43 (1996) 116-146.
[39] V. Goranko, Hierarchies of modal and temporal logics with references pointers, J.
Logic, Lang.
and Inf.
5 (1996) 1-24.
[40] C. Areces, P. Blackburn, M. Marx, A road-map on complexity for hybrid logics, in: 13th Int.
Works.
Comput.
Sci.
Logic (CSL), Vol.
1683 of Lect.
Notes Comput.
Sci., Springer, 1999, pp.
307-321.
[41] M. Franceschet, M. de Rijke, B.-H. Schlingloff, Hybrid logics on linear structures: Expressivity and complexity, in: 10th Int.
Symp.
Temporal Representation and Reasoning and 4th Int.
Conf.
Temporal Logic (TIMEICTL), IEEE, 2003, pp.
164-171.
28  [42] F. de Boer, R. van Eijk, Decidable navigation logics for object structures, in: 15th Int.
Works.
Comput.
Sci.
Logic (CSL), Vol.
2142 of Lect.
Notes Comput.
Sci., Springer, 2001, pp.
324-338.
[43] S. M. Cho, H. H. Kim, S. D. Cha, D. H. Bae, A semantics of sequence diagrams, Inf.
Process.
Lett.
84 (2002) 125-130.
[44] T. French, Quantified propositional temporal logic with repeating states, in: 10th Int.
Symp.
Temporal Representation and Reasoning and 4th Int.
Conf.
Temporal Logic (TIME-ICTL), IEEE, 2003, pp.
155-165.
[45] M. Fitting, Modal logic between propositional and first-order, J.
Logic and Comput.
12 (6) (2002) 1017-1026.
[46] A. Degtyarev, M. Fisher, A. Lisitsa, Equality and monodic first-order temporal logic, Studia Logica 72 (2002) 147-156.
[47] F. Wolter, M. Zakharyaschev, Axiomatizing the monodic fragment of first-order temporal logic, Ann.
Pure and Applied Logic 118 (2002) 133-145.
[48] I. Hodkinson, R. Kontchakov, A. Kurucz, F. Wolter, M. Zakharyaschev, On the computational complexity of decidable fragments of first-order linear temporal logics, in: 10th Int.
Symp.
Temporal Representation and Reasoning and 4th Int.
Conf.
Temporal Logic (TIME-ICTL), IEEE, 2003, pp.
91-98.
[49] D. Gabbay, A. Kurucz, F. Wolter, M. Zakharyaschev, Many-dimensional modal logics: theory and practice, Cambridge University Press, 2003.
[50] I. Hodkinson, F. Wolter, M. Zakharyaschev, Decidable fragments of first-order temporal logics, Ann.
Pure and Applied Logic 106 (2000) 85-134.
[51] P. Bouyer, A. Petit, D. Therien, An algebraic approach to data languages and timed languages, Inf.
and Comput.
182 (2) (2003) 137-162.
[52] P. Bouyer, A logical characterization of data languages, Inf.
Process.
Lett.
84 (2) (2002) 75-85.
[53] M. Bojanczyk, C. David, A. Muscholl, T. Schwentick, L. Segoufin, Two-variable logic on words with data, Tech.
Rep. 2005-004, LIAFA (2005).
29