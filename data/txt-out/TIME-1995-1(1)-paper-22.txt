Inferred Validity of Transaction-Time Data Cristina De Castro  Maria Rita Scalas  C.I.O.C.-C.N.R.
and Dipartimento di Elettronica, Informatica e Sistemistica Universita di Bologna Viale Risorgimento 2, I-40136 Bologna, Italy Tel.
+ 39 (51) 644.
{3542,3544} Fax: +39 (51) 644.3540 E-mail: {cdecastro,mrscalas}@deis.unibo.it Abstract: Temporal databases can support at least two kinds of independent time dimensions: transaction-time, which tells when an event is recorded in a database, and valid-time, which tells when an event occurs, occurred or is expected to occur in the real world.
According to the semantics of transaction-time, when data are retrieved from a transaction-time relation, the only temporal information that can be associated to such data is the time when they were stored, updated or deleted.
No conjecture on their validity in the real world is straightforward.
Nevertheless, when transaction-time data are used, a validity is implicitly assigned to them.
In this paper we propose three possible interpretations of the validity of transaction-time data.
Such proposals can be useful in a temporal heterogeneous environment, where relations of different temporal format must interoperate: as a matter of fact, the proposed solutions allow a conversion of temporal data to the bitemporal format, and thus they provide a common format for the execution of the operations.
All the three proposed solutions assume that data can be considered valid at least since they were stored.
Such semantics is intrinsic of transaction-time DBs, which are accordingly named historical, thus we can say that, when data validity is not specified, the knowledge actually stored in the database is taken into account.
The second assumption is that any conjecture on the  effective beginning of the validity of data preceding their insertion time would create false information and must thus be avoided.
These criteria fix the beginning of the inferred validity.
The end of validity can be defined in three distinct ways, depending on how much it can span along the valid-time axis.
A comparison among the three types of inference is provided at the end, on the basis of the possible use of such data, because the inferred validity can be used for the translation of data both to the valid-time or the bitemporal format.
The differences among the three inferences look remarkable.
Keywords: Transaction-Time, Inferred Valid-Time Extension  Valid-Time,  1.
Introduction and Notation In current bibliography on temporal databases there is a common agreement for the support of at least two kinds of time dimensions: transactiontime, which tells when an event is recorded in a database, and valid-time, which tells when an event occurs, occurred or is expected to occur in the real world [Soo91,TSC+93].
Further proposals include the temporal dimension event-time [KC93], which allows the distinction between retroactive and proactive updates, impossible with transaction and valid-time only.
In this paper we are concerned with the possible deductions that can be made when only transaction-time is  supported and thus, for the beginning, we do not take into account event time.
If we consider transaction- and valid-time, according to the temporal dimensions they support, temporal databases can be classified as monotemporal (transaction- or valid-time) , bitemporal or snapshot [JCE+94].
Transaction-time DBs record all the versions of data inserted, deleted or updated in successive transactions (current and non current versions).
The temporal information of a transaction-time relation concerns the time when data are recorded, updated or deleted from the database.
In this sense, transaction-time is the database time.
Valid-time DBs maintain the most recently inserted versions of data, each relative to a distinct valid-time interval (current versions only).
The temporal information of a valid-time relation concerns the time when events actually happen in the real world.
In this sense, valid-time is the time of the miniworld to represent.
Bitemporal DBs support both transaction and valid-time and thus maintain all the valid-time versions recorded in successive transactions (current and non current versions).
Snapshot DBs do not support time: they maintain only the most recently inserted (current) version.
When data are retrieved from a database where their validity is not represented, the user implicitly assigns them a validity interval.
For instance, when you get the latest version of the telephone book, you can use the telephone numbers and thus you consider them valid.
This process is, of course, risky, but reflects commonly used deductions made on every type of available data.
In this paper we consider a transaction-time database and propose three distinct ways for inferring data validity from their represented transaction-time.
Even if transaction- and validtime are independent (orthogonal) dimensions, the above considerations justify this type of inference.
Not only the proposed methods give criteria for making inferences on the validity of data, but also they allow the conversion of data to the bitemporal format.
This use is necessary in a temporal heterogeneous environment, where the interoperability is required of relations of different temporal format [DGS94,DGS95].
The temporal representation adopted in this paper is the Bitemporal Conceptual Data Model (BCDM in [JCE+94]), where time-stamps are represented by Temporal Elements.
In the following, we provide a concise description of the BCDM formalism and of the adopted notations.
Time is represented by means of temporal elements, which consist of sets of chronons.
As in [JCE+94] a chronon is a non-decomposable time interval of some fixed, minimal duration.
A duration p represents the chosen granularity of time.
A (bi)temporal chronon is an ordered pair of unitary-length chronons, one relative to transaction-time, the other to valid-time: for instance (ti, tj) is a bitemporal chronon, where ti denotes transaction-time, and tj denotes validtime.
Bitemporal elements are sets of bitemporal chronons of the type tb = {(ti, tj), ... , (tl, tm)}.
In general, the symbol tX denotes a transaction-time (tt), valid-time (tv) or bitemporal (tb) element.
A monotemporal element can always be represented by the union of disjoint component subsets, each represented by its endpoints (IN, OUT for transaction-time, FROM, TO for validtime) and containing contiguous chronons only: every chronon tj, such that tmi <= tj <= tni, belongs to the component subset {tmi .. tni}.
For instance, the general representation of a transaction-time temporal element is tt = [?
]i tti = [?
]i {tmi .. tni}.
The paper is organized as follows: in section 2 we present the three inferences, discuss the criteria on which they are based and provide some examples.
In section 3 we carry on the discussion and focus the attention on the different results obtained when the data produced by each inference are selected at distinct transaction-time instants.
2.
Three Inferences on the validity of transaction-time data In this section we present the three different inferences, named Square Inference, Stripe Inference and L-Shaped Inference respectively, and discuss the criteria on which each of them is based.
A comparison among the three is carried on.
The common assumption concerns the  beginning of validity of data: transaction-time (historical) data can be considered valid from the instant they were recorded.
Probably such validity precedes this instant, but, in the absence of further information, it would be absolutely unsafe and arbitrary to make further conjectures.
The difference among the three solutions is in the extent data validity is allowed to span along the valid-time axis.
The following notation is adopted: if the non-temporal attributes are denoted by r and [?]
denotes the operation of tuple concatenation, a version of an object along the temporal dimension X can be expressed as rX = r [?]
(tX).
*  Transaction-time semi-axis: {T0 ..
T[?]}
*  Valid-time semi-axis: {t0 ..
t[?]}
*  Current transaction-time: Tnow  *  If rt is a transaction-time record, rb' , rb'' and rb''' will denote the results in the bitemporal format obtained by using the first, second and third inference made on the validity of rt.
The transaction-time relation T-Employee in Tab.1 will be used in the examples.
For the sake of simplicity, in the examples the transaction-time temporal elements have a single component.
The granularity of time chosen for the examples is one year, thus, for instance, {90 .. 92} starts at the beginning of 1990 and finishes at the end of 1992.
2.1.
Square Inference The criterion on which the Square Inference is based is that when data are retrieved from a transaction-time relation they can be considered valid no less and no more than in their transaction-time interval.
This type of inference is represented in Fig.1.
The Square-inferred valid-time pertinence equals the transaction-time temporal element of each record: the transaction-time record r [?]
(tt) is thus transformed to the bitemporal format as follows:  r [?]
(tt) - r [?]
(tt) [?]
(tv) inferred validity is:  where the tv [?
]def tt  If tt is the union of disjoint intervals tt = [?
]i tti, the above definition must be applied to each component transaction-time temporal element tti: r [?]
{[?
]i tti} - r [?]
( [?
]i tti) [?]
( [?
]i tvi ) where tvi [?
]def tti 2.2.
Stripe Inference The criterion on which the Stripe-Inference is based is that when data are retrieved from a transaction-time relation they can be considered valid since they were stored and indefinitely valid in their transaction-time interval.
The Stripe inference reconstructs the bitemporal pertinence of each record taking into account that every record was current before it was updated.
Therefore, when a record had not been archived yet, it could be considered undefinitely valid.
This type of inference is represented in Fig.2.
The Stripe-inferred valid-time pertinence spans the whole valid-time axis starting from the minimum chronon of the transaction-time temporal element of each record: the transactiontime record r[?
](tt) is thus transformed as follows: where r [?]
(tt) - r [?]
(tt) [?]
(tv) def tv [?]
{min {tt} ..
t[?]}
Again, if tt = [?
]i tti , the above definition must be applied to eachtti: r [?]
( [?
]i tti) - r [?]
( [?
]i tti) [?]
( [?
]i tvi) tvi [?
]def {min {tti} ..
t[?]}
where  2.3.
L-Shaped inference A transaction-time tuple r [?]
(tt) is said to be current if Tnow [?
]tt (in this case OUT = T[?
]); it is said to be archived if Tnow >= min{tt}+1 (in this case OUT < T[?]).
A current tuple r [?]
({IN ..
T[?]})
(e.g.
r3 in Fig.3) can be considered valid since it  NAME  JOB  SALARY  tt  Ann  Engineer  2800  {85 .. 90}  Ann  Manager  3000  {91 ..
T[?]}
John  Engineer  1500  {90 .. 92}  John  Engineer  2000  {93 ..
T[?]}
Table 1: transaction-time relation T-Employee Valid-Time Axis T0 r0  T[?]
t2 = T2 t3 = T3  r 0 'b  T1  T1 r1  T2 T3  t1= T1  T0  T2 r2  r 1 'b  T3  r3  r 2 'b r 3 'b  T[?]
T[?]
Transaction-Time Axis a)  b)  Figure 1: (a) transaction-time pertinence; (b) corresponding Square-inferred validity  NAME  JOB  SALARY  tb = tt x tv  Ann  Engineer  2800  {85 .. 90} x {85 .. 90}  Ann  Manager  3000  {91 ..
T[?]}
x {91 ..
t[?]}
John  Engineer  1500  {90 .. 92} x {90 .. 92}  John  Engineer  2000  {93 ..
T[?]}
x {93 ..
t[?]}
Table 2: Square-inferred validity of T-Employee  Valid-Time Axis T0  T0  t1 = T1  r0  r 0 ''  T1  b  T1 r1  r 1 ''  T2  b  T2 r2  T3  T[?]
t2 = T2 t3 = T3  r 2 ''  T3  b  r3  r 3 '' b  T[?]
T[?]
Transaction-Time Axis a)  b)  Figure 2: (a) transaction-time pertinence; (b) corresponding Stripe-inferred validity  NAME  JOB  SALARY  tt x tv  Ann  Engineer  2800  {85 .. 90} x {85 ..
t[?]}
Ann  Manager  3000  {91 ..
T[?]}
x {91 ..
t[?]}
John  Engineer  1500  {90 .. 92} x {90 ..
t[?]}
John  Engineer  2000  {93 ..
T[?]}
x {93 ..
t[?]}
Table 3: Stripe-inferred validity of T-Employee  T0  T0 r0  T1  r 0 ''' b T1  r1 T2 T3  t1 = T1  Valid-Time Axis t2 = T2 t3 = T3 T[?]
T2 r2  T3  r3 T[?]
Transaction-Time Axis a)  r 1 ''' b r 2 ''' b r 3 ''' b  T[?]
b)  Figure 3: (a) transaction-time pertinence; (b) corresponding L-shaped inferred validity  Valid-Time Axis T0  t1= T1  T0 r0  T [?]
t2 = T2 t3 = T3  r 0 'b  T1  T1  T = T* r1 T2 T3  r 1 'b  T2 r2  r3 T = Tnow T [?]
Transaction-Time Axis  r 3 'b T [?]
T0  T0  r 2 'b  T3  t1 = T1  r0  r 0 ''b  T1  T1  T [?]
t2 = T2 t3 = T3  T = T* r 1 '' b  r1 T2  T2 T3  r2  r 2 ''b  T3  r 3 ''b  r3 T = Tnow T [?]
T [?]
T0  T0 r0  T1  t1 = T1  T[?]
t2 = T2 t3 = T3  r 0 ''' b T1  T = T* r1 T2 T3  T2 r2  T3  r 1 ''' b r 2 ''' b  r3 T = Tnow T[?]
r 3 ''' b T[?]
Figure 4: projection along the valid-time axis of the inferred validity at T = T* < T[?]
and at T = Tnow  was stored and indefinitely valid, since it cannot be forecasted if an update transaction would ever occur and archive such tuple.
An archived tuple r [?]
({IN .. OUT}) can be considered as created by a transaction with effect in [IN ..
T[?])
x [IN ..
T[?])
and modified by a successive transaction with effect in [OUT ..
T[?])
x [OUT ..
T[?]).
The update transaction cuts the initial time pertinence of the tuple to an ``L-shaped'' region (e.g.
r0b''', r1b''', r2b''' in Fig.3 and their corresponding ones).
This inference criterion was proposed in [DGS93] and fits the bitemporal view of a diagonal user (for the concept of user see [BG93]).
As in the Stripe-inferred case, the L-shaped inferred valid-time pertinence spans the whole valid-time axis starting from the minimum chronon of the transaction-time temporal element of each record; The difference is that this second criterion takes into account that, before a record was updated it were unknown if it would have been updated and when.
As a consequence, before the update, not only could the valid-time interval be interpreted as covering the whole valid-time axis from the time IN, but the same hold for the transaction-time pertinence of the record itself (OUT = T[?]
before the update).
The transactiontime record r [?]
(tt) is transformed as follows: r [?]
(tt) - r [?]
(tb), where tb [?
]def {min{tt} ..
T[?]}
x {min{tt} ..
t[?]}
{max{tt}+1 ..
T[?
]}x {max{tt}+1 ..
t[?]}
When r [?]
(tt) is current, {max{tt}+1 ..
T[?
]}x {max{tt}+1 ..
t[?]}
= [?]
Again, if tt = [?
]i tti , the above definition must be applied to each tti: r [?]
( [?
]i tti) - r [?]
( [?
]i tbi) where tbi [?
]def {min{tti} ..
T[?
]}x {min{tti} ..
t[?]}
- {max{tti}+1 ..
T[?
]}x {max{tti}+1 ..
t[?]}
3.
Further Discussion and Conclusions  In this paper we have considered how data validity can be inferred in transaction-time databases.
We proposed three distinct solutions: the Square Inference, the Stripe Inference and the L-Shaped Inference.
The Square Inference reflects only the knowledge of the database: data are valid within their transaction-time interval.
The StripeInference takes into account that archived data were current before they were updated and, before the update, data could be considered indefinitely valid.
A further deduction is made in the L-shaped solution: a portion of data is considered as still current.
As far as the use of the inferred data is concerned, a distinction must be made between their use in the bitemporal or in the valid-time format.
It can be noticed that the Square Inference can be used not only for the bitemporal view of data, but also for the valid-time view, since the Square-inferred valid-time intervals do not overlap; on the contrary, the other two solutions can be used only in the bitemporal format, since the Stripe- or Lshaped- inferred valid-time intervals overlap on the valid-time axis.
Furthermore, if we consider the bitemporal representations in Figs.1, 2, 3 and project (see Fig.4) the valid-time data inferred in each solution at T = T* < T[?]
and at T = Tnow, we find out another important difference.
At the generic time T = T* < T[?
], the Square Inference and the Stripe Inference return only the data whose original transaction-time pertinence contains T*, i.e.
they return the information which was available in the considered transaction-time interval; the L-shaped inference returns all the data whose transactiontime pertinence contains or precedes T*, i.e.
they return all the information which was available at time T*, independently of the transaction-time pertinence of such data.
If the projection is performed at the current time Tnow, the Square inference and the Stripe inference return only the current data, whereas the L-shaped inference returns all the original data, both current and archived.
These considerations can guide the use of the data produced in each type of inference.
The Square method is most in  harmony with the semantics of both transactionand valid-time, thus it allows to use the inferred data for the translation to both the bitemporal- and the valid-time format in quite a safe way, just being aware that the validity were not explicitly defined.
Also the Stripe method returns, for each transaction-time instant, only the data which were current at that time.
In this sense, it is in harmony with the semantics of transaction-time.
On the other hand, the inferred data can not be used with no transaction-time reference, because they overlap along valid-time.
The L-shaped inference, if used with no transaction-time reference, is the most risky of the three.
Its use can be justified by the fact that transaction-time can only grow, thus no retroactive insertion is possible.
As a consequence, the original transaction-time data are, in each interval, the only one version which was ever recorded and thus, in this sense, the most recently inserted one.
References: [BG93] Bhargava G., Gadia S.K., ``Relational Database Systems with Zero Information Loss'', IEEE Trans.
on Knowledge and Data Engineering, Vol.
5, No.
1, Feb. 1993.
[DGS94] De Castro C., Grandi F., Scalas M.R.
: ``Semantic Interoperability of Multitemporal Relational Databases'', in Entity-Relationship Approach - ER '93, Lecture Notes in Computer Science, Vol.
823, Springer-Verlag, 1994.
[DGS94] De Castro C., Grandi F., Scalas M.R.
: ``Meaning of Relational Operations in Temporal Environment'', accepted for presentation at the Basque International workshop on Information Technology (BIWIT 95), to be held in San Sebastian (Spain), July 1995.
[JCE+94] Jensen C., Clifford J., Elmasri R., Gadia S.K., Hayes P., Jajodia S. (editors), Dyreson C., Grandi F., Kafer W., Kline N., Lorentzos N., Mitsopoulos Y., Montanari A., Nonen D., Peressi E., Pernici B., Roddick J.F., Sarda N.L., Scalas M.R., Segev A., Snodgrass R., Soo M.D., Tansel A., Tiberio P., Wiederhold G.: ``A Consensus Glossary of Temporal Database Concepts", SIGMOD RECORD, Vol.
23, No.
1, March 1994 [KC93] Kim S.K., Chakravarthy S.: ``Modeling Time: Adequacy of Three Distinct Time Concepts for Temporal Databases", Proc.
of 12th International Conference on  Entity-Relationship Approach, Arlington, December 1993, also in Lecture Notes in Computer Science, Springer-Verlag.
[Soo91] Soo M., ``Bibliography on Temporal Databases,'' ACM SIGMOD Record, Vol.
20, No.
1, Mar.
1991.
[TSC+93] Tansel A., Snodgrass R., Clifford J., Gadia V., Segev A.
(eds), Temporal Databases: Theory, Design and Implementation, The Benjamin/Cummings Publishing Company, Redwood city, California, 1993.