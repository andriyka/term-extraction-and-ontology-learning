2013 20th International Symposium on Temporal Representation and Reasoning  Event Algebra for Transition Systems Composition Application to Timed Automata Elie FARES  Jean-Paul BODEVEIX  Mamoun FILALI  IRIT, UniversiteE de Toulouse  IRIT, UniversiteE de Toulouse  IRIT, UniversiteE de Toulouse  AbstractaFormal specidZcation languages have a lot of notions in common.
They all introduce entities usually called processes, offer similar operators, and most importantly dedZne their operational semantics based on labeled transition systems (LTS).
However, each language dedZnes specidZc synchronizing and/or memory structures.
For instance, in CSP, the synchronization is dedZned between identical events, while in CCS and in synchronization vectors-based views it is dedZned respectively between complementary events or between possibly different events.
In this paper, we aim at capturing some similarities of specidZcation languages by dedZning a label-based composition formal framework.
Firstly, we dedZne a high-level synchronization mechanism in the form of an abstract label structure.
We then couple this label structure with several compositional operations and properties.
Secondly, we introduce an LTS-based behavioral framework and dedZne a unique LTS composition operator which is reused to dedZne syntactic composition of extended transition systems and a compositional semantics.
high-level synchronization mechanism in the form of a label structure.
The label structure is abstract enough [4] so that both homogeneous and heterogeneous system synchronization could be described.
It is equipped with a composition operator which encapsulates the specidZc composition laws of each language and would further serve as a parameter of the behavioral framework.
Thanks to the separation between the composition laws and the behavioral framework, the latter, which is based on LTS, offers a unique LTS composition which is reused to dedZne syntactic composition of timed automata and a compositional semantics.
The idea of a label structure or similar constructs is not new since it appears in earlier studies [14], [15], [18], [13].
In [14], [15], the label composition operator appears under a functional form (the same as ours, see Label Structure : Section II) but the authors do not go beyond this dedZnition, while in [18], [13], it appears under a relational form.
In these latter studies, the authors are interested in reaching generic semantic rules for process calculi behavioral operators (predZx, choice...).
This is orthogonal to our goal that consists in reaching a label-based composition framework for specidZcation languages.
I. I NTRODUCTION For the past three decades, specidZcation languages such as CSP [17], CCS [16], LOTOS [10], Altarica [5], and BIP [6] have proven valuable in the specidZcation and design of concurrent and distributed systems.
The behavioral aspects of these languages share a common base since they all dedZne their operational semantics in terms of labeled transition systems (LTS).
Yet, the difference lies in the synchronizing structure of the labels of these systems.
For example in CSP the synchronization is dedZned between two identical events, while in CCS and in synchronization vectors-based views, it is dedZned respectively between complementary events or between possibly different events.
Through the years, the basic versions of some of these languages have been extended by time, memory, and priority notions.
Accordingly, other formalisms have emerged in order to model the semantics of these extensions.
For example, we can cite Alur and Dillas timed automata [3] and Henzinger et alas timed transition systems [11] that both capture the time addition or the semantic model of [19] used to model the priorities.
However, even though the rules of the composition operations of these formalisms are the same in nature (synchronous and asynchronous rules), they are well distinguished in reality, maybe because of the specidZc attributes that come with each formalism.
A distinct composition operation is then introduced for each dedZned formalism.
In this paper, we aim at capturing some similarities of specidZcation languages by providing a semantic framework for system composition.
For this purpose, we introduce a 1530-1311/13 $26.00 AS 2013 IEEE 1550-1311/13 DOI 10.1109/TIME.2013.23  Our contribution can be viewed from two perspectives.
One way is to see this work as an abstraction of the composition of different behavioral formalisms via a separation of the labels composition laws of each language and a reuse of the LTS composition.
In fact, depending on the language, the label structure is dedZned and instantiated differently.
Using the common framework, one would then proceed by giving the semantics of other behavioral operators of the specidZcation language in question.
Another way to see our label structure and their associated operations is as a generalization of the composition functions given and used in [14], [15].
Indeed, we show how such abstract composition functions (or label structures in our terms) may be implemented and instantiated to simulate existing synchronization mechanisms.
Most importantly, we push forward this work by giving new dedZnitions, properties, and operations to manipulate such label structures.
The rest of the paper is organized as follows.
In the second section, we start by dedZning the label structure along with its associated properties and operations.
In the third section, we dedZne our behavioral framework and show how it reuses the label structure notions.
We conclude the paper in the fourth section.
111 125  II.
L ABEL S TRUCTURE We start by describing the labels of transition systems by means of a label structure which is later used as an attribute of transition systems.
DedZnition 1 (Label Structure): A label structure is a tuple L, 1 where L is a set of labels and (1: L A L  L) is a partial binary composition operator over L. The function is partial because some composition may be blocked since 1 describes exclusively synchronous compositions.
The asynchronous aspects are covered later (see LTS composition).
Our composition then models the following cases : 1) A successful synchronization between l and l that results in l 1 l a L. / 2) A blocking synchronization between l and l : (l, l ) a dom(1).
Let the reader not confuse our label structure with other event structuring propositions, namely with the event structures [8].
Event structures model the occurrence of events during the system execution via the introduction of a causal dependency relation and a condZict relation between the events.
In our case, we introduce a label structure which models the way the labels (i.e., events) are statically composed.
DedZnition 2 (Commutativity of a Label Structure): Given a label structure LS = L, 1, LS is said to be commutative if its composition operator 1 is commutative.
Formally, for l1 , l2 and l3 a L, LS is commutative if :  b) Basic CSP Synchronizing Structure: Here, we model the case of the completely synchronous composition of CSP.
For C a set of communication ports, a synchronizing structure on C is the label structure : SyncCSP = C, (c1 , c2 ) a c1 if c1 = c2  The synchronization of two ports of the set C is only dedZned when these two ports are the same.
Otherwise an interleaving occurs.
c) CCS Synchronizing Structure: For C a set of events, C?
= {c?
| c a C} and C!
= {c!
| c a C}, this is represented in our label structure as follows : SyncCCS = C?aSC!aS{D }aS{(c!, c?)
a D | c a C}, {(c!, c?)
a D | c a C} B. Label Structure Properties We give the frequent label structures properties used in this paper.
Property Idempotency Unique Composition Diagonality  DedZnition al a L, (l, l) a dom(1) aSS l 1 l = l al1 l2 a L, (l1 , l2 ) a dom(1) a / dom(1) al a L, ((l1 1 l2 ), l) a aSS(l, (l1 1 l2 )) a / dom(1) al1 l2 a L, (l1 , l2 ) a dom(1) a l1 = l2  Example SyncCSP , T S SyncCCS SyncCSP , T S  We denote by ACI the conjunction of the associativity, commutativity and idempotence properties.
A label structure fuldZlling the ACI property is seen as a join semi-lattice where 1 is interpreted as the join operator and the partial order relation l a$?
l is dedZned by l a$?
l  l 1 l = l .
(l1 , l2 ) a dom(1) a (l2 , l1 ) a dom(1) aSS l1 1 l2 = l2 1 l1 DedZnition 3 (Associativity of a Label Structure): Given a label structure LS = L, 1, LS is said to be associative if its composition operator 1 is associative.
Formally, for l1 , l2 and l3 a L, LS is associative if it satisdZes the following conditions 1) (l1 , l2 ) a dom(1) aSS ((l1 1 l2 ), l3 ) a dom(1) a (l2 , l3 ) a dom(1) aSS (l1 , (l2 1 l3 )) a dom(1).
This means that independently of the composition order, they are both dedZned.
2) (l1 , l2 ) a dom(1) aSS ((l1 1 l2 ), l3 ) a dom(1) a ((l1 1 l2 ) 1 l3 ) = (l1 1 (l2 1 l3 )).
This means that independently of the composition order, they both lead to the same result.
DedZnition 4 (Stability of a Set of Labels): Given a label structure LS = L, 1 and a label set G a L, we say that G is stable over LS if a(l1 , l2 ) a dom(1), l1 1 l2 a G a l1 a G aSS l2 a G, and a(l1 , l2 ) a dom(1), l1 a G a" l2 a G a l1 1 l2 a G.  C. Composition of Label Structures We dedZne the product and the sum of two label structures.
The product operation builds new labels as pairs of the composed labels.
For example, this is used when composing synchronization and memory access labels.
Unlike the product operation, the labels of the sum operation are dedZned over the union of the composed labels.
This is used when composing synchronization and time labels to specify that only one of the events may occur at one time and not simultaneously.
1) Product of Label Structures: Given two label structures L, 1 and L , 1 , their product ranges over the set P = (L aS {fi}) A (L aS {fi })\{(fi, fi )} where fi (resp.
fi ) is a new element of L (resp.
L ) supposed to be neutral 1 for the 1 operator of its respective label structure.
For l1 , l2 a L and l1 , l2 a L , the composition of (l1 , l1 ), (l2 , l2 ) is dedZned only if the composition of l1 and l2 and the composition l1 and l2 are both dedZned.
A. Label Structure Examples a) Time Label Structure: For I a time domain, e.g., non negative real numbers, naturals .
.
.
, equipped with a binary associative operator + and a neutral element 0, we introduce the time structure T S on the domain I.
Its composition operator is only dedZned between identical time labels I' and returns the label itself.
 P,  T S = I, (I'1 , I'2 ) a I'1 if I'1 = I'2   1 If  126 112  L, 1 a L , 1  = (l1 , l1 ), (l2 , l2 ) a (l1 1 l2 , l1 1 l2 ) if (l1 , l2 ) a dom(1) aSS (l1 , l2 ) a dom(1 )     L had already a neutral element , we suppose that n 1  =  1 n = n.  2) Sum of Label Structures: Given L, 1 and L , 1 , their sum ranges over the union of LaV aS aV L where LaV = {laV | l a L} and aV L = {aV l | l a L }.
L, 1 a L , 1  = LaV aS aV L ,    aV  l1 aV , l2 aV a (l1 1 l2 ) if (l1 , l2 ) a dom(1) aV l1 , aV l2 a aV (l1 1 l2 ) if (l1 , l2 ) a dom(1 )     Proposition 1 (Preservation of ACI ): Given LS and LS  , if LS and LS  satisfy one of the ACI properties then LS a LS  and LS a LS  satisfy this same property.
A label structure transformation is used to map labels from a label structure to another.
We start by giving the dedZnition of a transformation followed by instances of such transformations.
DedZnition 5 (Transformation): A transformation f between two label structures LS1 = L1 , 11  and LS2 = L2 , 12  is dedZned as a partial morphism f from LS1 labels to LS2 labels such that : aV aV  Inl Inr  aa a a  Outl Outr Extl Extr P rjl P rjr  a  a  a  a  a  a aa a  a aa  Signature Embedding LS1  LS1 a LS2 LS2  LS1 a LS2 Retraction LS1 a LS2  LS1 LS1 a LS2  LS2 Extension LS1  LS1 a LS2 LS2  LS1 a LS2 Projection LS1 a LS2  LS1 LS2 a LS1  LS2  (tr : LS1  LS2 ) a LS1 a LS  LS2 a LS  T r Inr (aLSa LSa )  (tr : LS1  LS2 ) a LS a LS1  LS a LS2  T r Extl (aaLS aLS )  (tr : LS1  LS2 ) a LS1 a LS  LS2 a LS  T r Extr (aLSa LSa )  (tr : LS1  LS2 ) a LS a LS1  LS a LS2  aV  l1  a aV tr(l1 ) laV  a laV  aSS a"(l1 , l2 )  a (tr(l1 ), l2 ) (, l2 )  a (, l2 ) aS(l , )  a (tr(l ), ) 1 1 aSS a"(l1 , l2 )  a (l1 , tr(l2 )) (, l2 )  a (, tr(l2 )) aS(l , )  a (l , ) 1 1  A.
Labeled Transition System (LTS) DedZnition 6 (Labeled Transition System LTS): Given LS = L, 1, a labeled transition system L over LS adenoted as LLS a is dedZned as Q, Q0 a Q, T a Q A L A Q where Q, Q0 , T denote respectively the sets of states, initial states, and transitions.
We denote by LT SLS the set of LTSs over LS.
l We write q a q  for an element (q, l, q  ) of T .
Furthermore, we dedZne the alphabet of an LLS adenoted as IaLLS a as the set of labels that are actually used by the transitions of LLS : l IaLLS = {l a L | aq q  , q a q  a T }.
DedZnition 7 (Bisimulation): Given ALS = Qa , Q0a , Ta  and CLS = Qc , Q0c , Tc , a relation R a Qc A Qa dedZnes a simulation between CLS and ALS denoted as CLS fiR ALS iff : (1) aqc0 a Q0c , aqa0 a Q0a such that (qc0 , qa0 ) a R and (2) l aqc , qc , qa , l if qc a qc and (qc , qa ) a R, aqa a Qa such that l qa a qa and (qc , qa ) a R. Two LTSs LLS and L LS are said to be bisimilar through the relation R a Q A Q denoted as LLS R L LS if LLS fiR L LS and L LS fiRa1 LLS .
Furthermore, we say that LLS and L LS are state-bisimilar if transition labels are not required to match.
DedZnition 8 (LTS Diagonality, Idempotency and Determinism): An LTS is said to be diagonal (resp.
idempotent) if the restriction of its label structure to the LTS alphabet is diagonal (resp.
idempotent).
An LTS is said to be deterministic l l if whenever q a q  and q a q  then q  = q  .
In the rest of the paper, this set of LTS properties will be named DID.
1) LTS Composition: Given two LTSs dedZned over L, 1, a set S a L denoting the allowed synchronization results, and two sets of labels Al and Ar denoting respectively the left and right interleaving labels, the label composition function 1 is A A extended to an LTS composition function l 1 r as follows:  We write f : LS1  LS2 to denote such transformations.
1) Basic Transformations: Given two label structures LS1 and LS2 , we dedZne label structure transformations which are used to embed a label into a sum of labels, destruct a label sum, extend a label to a couple of labels, or also project a couple of labels to an element of the couple.
These transformations are given in the following table : Notation  T r Inl (aaLS aLS )  tr  Transformation l1 aV  a tr(l1 )aV aV l  a aV l  III.
B EHAVIORAL F RAMEWORK  ran(11 ) a dom(f ).
al, l a dom(f ), (l, l ) a dom(11 ) a (f (l), f (l )) a dom(12 ).
al, l a dom(f ), (l, l ) a dom(11 ) a f (l 11 l ) = f (l) 12 f (l ).
Name  Signature  We note here that the transformation properties are satisdZed by the resulting functions.
The previous four transformations also preserve the injectivity of tr.
D. Label Structure Transformations  aV  Name  DedZnition l a laV l a aV l laV a l aV l a l l a (l, fi) l a (fi, l) (l, fi) a l (fi, l) a l  It is not difdZcult to see that the transformation properties (DedZnition 5) are satisdZed by the transformations we have dedZned.
We note that all these transformations are injective.
2) High-Level Transformations: Given the label structures 2 LS, LS1 , LS2 , and aLS LS1 a transformation from LS1 to LS2 , we dedZne the following four high level transformations :  S  Q1 , Q01 , T1  1 Al  S  Ar  Q2 , Q02 , T2  = Q1 A Q2 , Q01 A Q02 , T   where the set T is dedZned by the following rules :  127 113  l q1 a1T1  q1fi  l q2 a2T2  q2fi  (l1 , l2 ) a dom(1) aSS (l1 1 l2 ) a S l 1l  (q1 , q2 ) 1aT2 (q1fi , q2fi )  Corollary 2: Given an associative label structure LS = L, 1, the label set S a L, the LTSs L1LS , L2LS , and L3LS we have : 1) L1 1(L2 1L3 )  (L1 1L2 )1L3 if S, S  are  S YNC  S  l  q1 a1T1 q1fi l1 a Al l  (q1 , q2 ) a1T (q1fi , q2 ) l  q2 a2T2 q2fi l2 a Ar l  (q1 , q2 ) a2T (q1 , q2fi )  I NTERLEAVINGR  S is omitted when it is equal to L. In this case, if Al = Ar = a then 1 is a fully synchronous composition operator.
Theorem 1 (Bisimulation Compatibility ): Given the LTSs L1 , L 1 , L2 , and L 2 dedZned over the label structure LS, we have : L1  L2 aSS L 1  L 2 a L1 l 1 A  Ar  S  L 1  L2 l 1 A  S  Ar  S  A  L1  1   Ar1  [f ]Q, Q0 , a1  = Q, Q0 , a2 = {(q, f (l), q  ) | l a dom(f ) aSS (q, l, q  ) aa1 }  A  S1  (L2  Al2  1   Ar2  S2  Proposition 5 (Transformation Bisimulation Compatibility): Given LS1 = L1 , 11 , LS2 = L2 , 12 , two LTSs L1 and L2 both over LS1 , and a transformation f : LS1  LS2 , L1  L2 a [f ](L1 )  [f ](L2 ).
Theorem 3 (Transformation Compositionality): Given LS1 = L1 , 11 , LS2 = L2 , 12 , two LTSs L1 and L2 both over LS1 , and an injective transformation f : LS1  LS2 such that dom(f ) is stable over LS1 , we have : A  [f ](L1 l 1 S  L3 )  Al1  1  S1  Ar1  L2 )  Al2  1  S2  Ar2  Ar  L2 )  [f ](L1 )  f (Al )   1  f (S)  f (Ar )  [f ](L2 )  Proof: We only sketch the proof of the synchronous case.
Given LS1 , LS2 , LLS1 , and L LS1 , we prove that the two sides are bisimilar through the identity relation.
The proof is based on showing that each transition of the dZrst system can be found in the second system and vice versa.
It is depicted in the following implications which can be read from bottom to top and vice versa from either sides of the parentheses.
The main points of this proof are dZrst the use of the stability hypothesis so that we conclude that when l a dom(f ) then l1 , l2 a dom(f ) and conversely, second the use of the injectivity of f in order to connect the two branches of the proof.
 (L1  S  The label structure of an LTS may be changed in a composition such as making local a global event (CSP hide) or changing its name (CSP Rename).
Here, we consider some LTS labels transformations by extending the label structure transformations to LTS transformations.
DedZnition 9 (LTS Transformation): Given two label structures LS1 and LS2 , and a transformation f : LS1  LS2 , we dedZne [f ] : LLS1 a LLS2 as :  Theorem 2 (Associativity of l 1 r ): Given LS = L, 1 S , the label sets Al1 , Ar1 , Al2 , Ar2 , S1 , S2 a L, and the LTSs L1LS , L2LS , and L3LS .
If LS is associative, S1 , S2 , Ar1 , Al2 are stable over LS, and either one of the following conditions is satisdZed : 1) Ar2 aS IaL3 = a and Al1 aS IaL1 = a.
2) Al1 a Al2 , Ar2 a Ar1 , S2 aS Al1 = a, and S1 aS Ar2 = a.
3) Al1 a Al2 , Ar2 a Ar1 , S a Al1 , S a Ar2 , and S1 = S2 .
We have : Al1  S  B. LTS Transformations  L 2  This theorem allows us to reason by making use of substitution by bisimulation.
Proposition 2 (Synchronous Composition ): Given two LTSs L1 and L2 dedZned over the label structure LS, we have L1 1L2  L1 1L2 if S is stable over LS, IaL1 a S, and S IaL2 a S. A A two Proposition 3 (Commutativity of l 1 r ): Given S LTSs L1 and L2 dedZned over the label structure LS, we have A A A A L1 l 1 r L2  L2 r 1 l L1 if LS is commutative.
S  S  stable over LS 2 .
This dZrst proposition is the same as the weak associativity theorem of the CSP generalized parallel operator [17].
The hypothesis added in our context are satisdZed by the label structure associated to CSP.
2) L1 1(L2 1L3 )  (L1 1L2 )1L3 if S, S  are S S stable over LS and IaL1 a S. Proposition 4 (Idempotency of 1): Given LS = L, 1 and LLS , if LLS is DID then 1 is idempotent meaning that LLS 1LLS  LLS .
I NTERLEAVINGL  L3  The conditions of this theorem are only sufdZcient conditions and have been selected in order to dZt with our needs.
Other conditions can be found in other contexts, for example the CSP context [17].
We note how the third set of sufdZcient conditions satisfy the CCS parallel composition.
In this case, this result can be instantiated by taking S = Al1 = Al2 = Ar1 = Ar2 = L which leads to the following CCS associativity corollary.
Corollary 1 (CCS Associativity): The CCS parallel composition operator is associative.
Other associativity corollaries may also be deduced such as the followings :  Proposition 6 (Preservation of DID properties): Given two label structures LS1 , LS2 , an injective transformation f : LS1  LS2 , and an LTS L over LS1 , each of the 2S  128 114  is the complement of S.  a  l  l  l1 fi l2 fi 1 2 fi fi q1 , q2 a q2 , l = l1 1 l2 q1 a q1 , l1 a dom(f ) q2 a q2 , l2 a dom(f ) q1 a a a ) f (l f (l2 ) l 1 a (q1 , q2 ) a (q1fi , q2fi ) , l a dom(f ) q1 a q1fi q2 a q2fi l = l1 1 l2 a f (l)  (q1 , q2 ) a (q1fi , q2fi )  (q1 , q2 )  DID properties is preserved by the transformation f .
Formally, for P a DID property we have : P (L) a P ([f ]L).
f (l)=f (l1 )1f (l2 )  aa  a a a a a   (q1fi , q2fi )  3) Timed Automata Label Structure: Given a set of clocks C, we dedZne a timed automaton as an LTS such that its transitions are labeled by communication channels (dedZned by some label structure LS), guards (the label structure G) and reset actions (the label structure A).
For this moment, LS is left undedZned and can either model the CCS-based synchronization or the CSP-based one.
Given a label structure LS, a timed automaton (TA) over LS is an LTS over LS a G a A.  IV.
T IMED S YSTEMS A.
Timed Transition Systems (TTS) DedZnition 10 (TTS): Given a label structure LS = L, 1, a Timed Transition System (TTS) over LS is an LTS over LS a T S. DedZnition 11 (TTS composition): Thanks to the introduction of our label structure, the TTS composition is the composition of the underlying LTSs.
T ALS = LT SLSaGaA DedZnition 12 (TA Composition): Thanks to our label structure, the TA composition is dedZned as the composition of the underlying LTS systems.
4) TA Semantics: The semantics of a timed automaton is a TTS over LS a G a A.
In the following we denote GA for (G a A).
Lemma 1: If LS is associative (commutative) 3 then LS a GA a T S is associative (commutative).
Proof: G, A, and T S are associative (commutative).
By Proposition 1, a and a preserves the associativity (commutativity).
The TA semantics is given via a composition with a clock manager Clk dedZned over GA a T S (Fig 2).
B.
Timed Automata (TA) We consider dZrst a dedZnition of timed automata [3] in which no invariants are associated to its locations (this is close to a timed graph [2] since neither invariants nor committed states are modeled).
The transitions are in the form of guard/event/reset where the guards contain a conjunction of constraints represented as clock intervals and the reset actions consist in a set of clocks to be reset.
This is represented as a product of three label structures.
The dZrst manages the synchronization events, the second manages clock guards, and the third manages the clock reset.
In the rest of this paper, we consider a set C of clocks and a time domain I (e.g.
R+ ).
1) Guard Label Structure: Based on the Alur Dill timed automata [3], a guard is a conjunction of interval constraints associated to clocks.
Here, this is modeled as a function C a 2I .
The guard label structure is dedZned as :       fifi     	      	       G  C a 2I , (g1 , g2 ) a (c a g1 (c) aS g2 (c)) The guard label structure is ACI.
2) Action Label Structure: Based on the Alur Dill timed automata [3], an action associated to a discrete transition can reset some clocks while keeping the other clocks managed by the current timed automaton unchanged.
In order to allow the composition of reset actions, the clocks not managed by a given timed automaton are left undetermined.
Consequently an action is modeled by two disjoint sets r denoting the clocks to be reset and u denoting the clocks to be left unchanged.
Their composition is dedZned by respectively the union of the reset sets and the union of the unchanged sets provided that the reset and the unchanged sets are disjoint.
Fig.
1.
	   fifi   	  Semantics of TA via a Composition of Two LTSs  a) Clock Manager: The Clk automaton contains variables (denoted as cE) corresponding to the clocks c of C. It has two types of transitions.
The dZrst type correspond to transitions of time evolution labeled by aV I' in which after each possible delay all of the clocks are incremented by the amount of this delay.
The second type correspond to discrete aV transitions labeled by g, (r, u) in which certain clocks are checked against their guard constraints (cE a g(c)), and clocks belonging to r are reset.
In order to impose the determinism of Clk, we suppose that raSu = C in Clk, but we synchronize labels l of ta with labels l of Clk when l a$?
l .
We recall that  A   {(r, u) a 2C A 2C | r aS u = a}, ((r1 , u1 ), (r2 , u2 )) a (r1 aS r2 , u1 aS u2 ) if r1 aS u2 = r2 aS u1 = a The action label structure is ACI.
3 This  129 115  is veridZed for both of CCS and CSP.
this partial order relation a$?
has been dedZned from the join operator in Section II-B.
Since Clk is diagonal, idempotent, and deterministic, it follows that Clk1Clk  Clk (Proposition 4).
b) Reconstructing the TA Semantics: The TA semantics is dedZned by means of a composition between the syntactic ta and Clk where ta transmits the clock commands to Clk.
Since the LTS composition is dedZned over the same label structure, then the label structures on which ta and Clk are dedZned have to be adapted so that they both become dedZned over LSaGAaT S. More precisely, we use the left embedding transformation for ta and the transformed right extension for Clk.
This is formally dedZned as : S [[ta]] = (ta aLSaGAaT  LSaGA  1  (LSaGA)aV  Theorem 5: Given a timed automaton where each transition is labeled by an action (not by fi labels introduced by the label structure product), its standard and proposed (revised) semantics are state-bisimilar through the identity relation.
C. Timed Automata with Invariants We now add state invariants to timed automata as dedZned in [12].
1) Invariant Label Structure: Here we consider an invariant to be an upper bound constraint that may be associated to each clock.
It is dedZned as a partial function from clocks to the time domain I.
The composition of two invariants associates to each clock, when it exists, the minimum of the two bounds.
The invariant label structure is dedZned as :  S LSaGA  Clk(aaT )) aT S aGA  Theorem 4 (TA Semantics Compositionality): Given two timed automata ta1 and ta2 , [[ta1 1ta2 ]]  [[ta1 ]]1[[ta2 ]].
Proof: This proof is based on proving the bisimulation between the semantics of the composition of ta1 and ta2 and the composition of their semantics.
We start by unfolding the semantics of the TA composition [[ta1 1ta2 ]] and by applying a sequence of bisimulations we reach [[ta1 ]]1[[ta2 ]].
In the S following proof we denote  1 aV  by  and aLSaGAaT LSaGA  I   C  I, (i1 , i2 )  a (c  a  The invariant label structure is ACI.
2) Timed Automata with Invariants Label Structure: Given a set of clocks C, we dedZne a timed safety automaton (TSA) as an LTS such that its transitions are labeled by communication channels (dedZned by some label structure LS), guards (the label structure G) and reset actions (the label structure A).
Furthermore, invariants which are usually attached to locations, are here stored on special looping transitions in order to synchronize with the Invariant Clock controller (IClk in paragraph IV-C3a).
Given a label structure LS, a timed safety automaton over LS is an LTS over LS a G a A a I.
(LSaGA)  S by aaaT .
a  S S S S (ta1 aaaT Clk aLSaGAaT )1(ta2 aaaT Clk aLSaGAaT ) a a GAaT S GAaT S   {Associativity : Corollary 1.2} S S S S (ta1 aaaT (Clk aLSaGAaT 1(ta2 aaaT Clk aLSaGAaT ))) a a GAaT S GAaT S  {Commutativity : Proposition 3} aaT S aaT S LSaGAaT S LSaGAaT S (ta1 aa ((ta2 aa Clk aGAaT S )1Clk aGAaT S ))  {Associativity : Corollary 1.2} S S S S (ta1 aaaT (ta2 aaaT (Clk aLSaGAaT 1Clk aLSaGAaT ))) a a GAaT S GAaT S  {Idempotency : Proposition 4} S S S (ta1 aaaT (ta2 aaaT Clk aLSaGAaT )) a a GAaT S  {Associativity : Corollary 1.1} aaT S aaT S LSaGAaT S ((ta1 aa ta2 aa )  Clk aGAaT S )  {Synchronous Composition : Proposition 2} aaT S aaT S LSaGAaT S ((ta1 aa 1ta2 aa )  Clk aGAaT S )  T SALS = LT SLSaGaAaI DedZnition 13 (TSA Composition): Thanks to our label structure, the TSA composition is dedZned as the composition of the underlying LTS systems.
3) TSA Semantics: The semantics of a timed safety automaton is a LTS over LS a GA a I a T S. Lemma 2: If LS is associative (commutative) then LS a GA a I a T S is associative (commutative).
Proof: G, A, I and T S are associative (commutative).
By Proposition 1, a and a preserves the associativity (commutativity).
The TSA semantics is given via a composition with an invariant clock manager IClk dedZned over GA a I a T S (Fig 2).
a) Invariant Clock Manager : The IClk automaton extends the Clk automaton by constraining the time elapsing.
It synchronizes on the invariant specidZed by the user-provided timed automaton, and on any GA label operator that is equal to the GA label provided by the timed automaton.
Since IClk is diagonal, idempotent, and deterministic, it follows that IClk1IClk  IClk (Proposition 4).
 {Transformation Compositionality : Theorem 3} S S ((ta1 1ta2 ) aaaT  Clk aLSaGAaT ) a GAaT S  Of course, the hypothesis of the applied results have been aV veridZed.
Namely, (LS a GA) is stable over LS a GA a T S, aV LSaGAaT S a (LS a GA) , DID is preserved by the Iata1 aLSaGA transformations, Clk veridZes the DID properties, the product and the transformation are compatible w.r.t bisimulation and Lemma 1.
5) Comparison with Standard TA Semantics: We now state the equivalence between our TA semantics and the standard one.
We start by dedZning the standard TA semantics by the function [[ ]]std : LT SLSaGA a LT SLSaGAaT S such that [[Q, Q0 , a]]std = Q A (C a R+ ), Q0 A {c : C a 0}, as  where : (l,(g,(r,u)))  q aaaaaaaaq fi ,   caC  v(c)ag(c) ,   car  v fi (c)=0 ,   cau  aSS a"min(i1 (c), i2 (c)) if c a dom(i1 ) aS dom(i2 ) i1 (c) if c a dom(i1 ) \ dom(i2 ) ) aSi (c) if c a dom(i ) \ dom(i ) 2 2 1  v fi (c)=v(c)  (l,(g,(r,u)))  (q,v)aaaaaaaas (q fi ,v fi ) I'  (q,v)as (q,v+I')  130 116  or by composing the original LTS with the one provided with the extension.
We show that these two methods are equivalent and that, provided some hypothesis, the semantics of the extension is compositional.
	     fi     	          	    Fig.
2.
	  A. Semantic Extension Given a label structure LS1 , we introduce an extension label structure LS2 supposed to be ACI, and its semantics dedZned by an LTS C(the controller) over LS2 a LS3 .
We dedZne the extended semantics by the function [[ ]]std : C LT SLS1 aLS2 a LT SLS1 aLS2 aLS3 such that [[L = 0 0 Q, Q0 , a]]std C = Q A QC , Q A QC , as  where :   fi     Semantics of TSA via a Composition of Two LTSs  b) Reconstructing the TSA Semantics: As before, the TSA semantics is dedZned by means of a composition between the syntactic tsa and IClk.
The semantics of a timed safety automaton is reconstructed as follows :  lfi2 aV  (l1 ,l2 )  qa aaaaqfi , qC aaaqCfi , l2 a$?l2fi (l1 ,l2 )aV  fi ) (q,qC )aaaaas (q fi ,qC aVl  (l,)  q aaaq fi  fi qC aqC  fi ) (q,qC )aaaas (q fi ,qC  fi ) (q,qC )as (q,qC  aVl  (l,)aV  [[tsa]] =  IaT S )1 (tsa(aLSaGAa LSaGAa aI  S LSaGA Clk(aaIaT )) aIaT S aGA  The semantic LTS is dedZned over the product of the state space of the syntactic LTS L and the controller C. Its transitions are built by joining transitions on LS1 a LS2 and adding transitions over LS3 .
In order to allow the composition with user-given LTSs, we add non-determinism through the introduction of the label l2 such that l2 a$?
l2 .
Coming back to Timed Automata, this corresponds to making at least the resets and the unchanged actions asked by the user.
Unreferenced clocks can be freely modidZed which allows parallel LTSs to impose their own modidZcations.
This semantics is shown to be equivalent to the following one which reuses the label structure operators  Theorem 6 (TSA Semantics Compositionality): Given two timed safety automata tsa1 and tsa2 , [[tsa1 1tsa2 ]]  [[tsa1 ]]1[[tsa2 ]].
Proof: This proof is similar to the TA Semantics Compositionality proof.
4) Comparison with Standard TSA Semantics: We now state the equivalence between our TSA semantics and the derived standard one in which a specidZc encoding of the state invariant is taken into account.
We start by dedZning the standard TSA semantics by the function [[ ]]std : LT SLSaGAaI a LT SLSaGAaIaT S such that [[Q, Q0 , a]]std = Q A (C a R+ ), Q0 A {c : C a 0}, as  where : (l,(g,(r,u)))  q aaaaaaaaq , fi   caC  v(c)ag(c) ,   car  fi  v (c)=0 ,   cau  1 aLS2 aLS3  [[L]]C = (L aLS LS1 aLS2  fi  v (c)=v(c)  i  3 LS1 aLS2  C(aaLS )) aLS3 aLS2  Theorem 8 (Extension Semantic): Given two LTSs L over LS1 a LS2 and C over LS2 a LS3 with LS2 ACI, [[L]]std C and [[L]]C are state-bisimilar through the identity relation if the following conditions hold : aV transitions of L are not of the form (l, fi), aV the LS2 labels of the transitions of C are maximal for a$?.
(l,(g,(r,u)))  (q,v)aaaaaaaas (q fi ,v fi ) q aq  1  (LS1 aLS2 )aV  acaC,v(c)+I'a$?i(c) I'  (q,v)as (q,v+I')  Remark that a disjunctive invariant can be modeled using several looping transitions (second rule).
Theorem 7: Given a timed safety automaton where each transition is labeled by an action (not by fi labels introduced by the label structure product), its standard and proposed (revised) semantics are state-bisimilar through the identity relation.
B. Compositionality The compositionality result concerning the parallel operator of timed automata can be generalized as follows : Theorem 9 (Generalized Compositionality): Given two LTSs L1 and L2 over LS1 a LS2 and a controller C over LS2 a LS3 , we have  V. T OWARDS G IVING L IFE TO L ABEL S TRUCTURES In this section, we show how the previous semantic dedZnitions could be generalized by attaching behaviors to label structures.
For this purpose, we abstract the timed automata semantic construction by associating a behavior to label structures in the form of an LTS.
Starting from an LTS built on a given label structure, a syntactic extension can be reached by composing labels with those of a new label structure (for instance, as we have seen, extending LTS to Timed Automata by adding action and guard labels).
The corresponding semantics can be dedZned either by overlaying  [[L1 1L2 ]]C  [[L1 ]]C 1[[L2 ]]C if the following conditions hold : aV LS1 and LS3 are associative and commutative.
aV LS2 is ACI.
aV C is DID.
This theorem has a similar proof as the timed automata one.
Furthermore, all the hypothesis are satisdZed in the timed automata context.
131 117  [2] R. Alur, C. Courcoubetis, and D. Dill.
Model-checking in dense realtime.
Inf.
Comput., 104(1):2a34, May 1993.
[3] R. Alur and D. L. Dill.
A theory of timed automata.
Theor.
Comput.
Sci., 126(2):183a235, Apr.
1994.
[4] F. Arbab.
Abstract behavior types: a foundation model for components and their composition.
Sci.
Comput.
Program., 55(1-3):3a52, Mar.
2005.
[5] A. Arnold, G. Point, A. Griffault, and A. Rauzy.
The AltaRica formalism for describing concurrent systems.
Fundam.
Inf., 40(2-3):109a124, 1999.
[6] A. Basu, M. Bozga, and J. Sifakis.
Modeling heterogeneous real-time components in bip.
In SEFM, pages 3a12.
IEEE Computer Society, 2006.
[7] G. Behrmann, A. David, and K. G. Larsen.
A tutorial on uppaal.
In M. Bernardo and F. Corradini, editors, International School on Formal Methods for the Design of Computer, Communication, and Software Systems, SFM-RT 2004.
Revised Lectures, volume 3185 of Lecture Notes in Computer Science, pages 200a237.
Springer Verlag, 2004.
[8] W. Brauer, W. Reisig, and G. Rozenberg, editors.
Petri Nets: Central Models and Their Properties, Advances in Petri Nets 1986, Part II, Proceedings of an Advanced Course, Bad Honnef, 8.-19.
September 1986, volume 255 of Lecture Notes in Computer Science.
Springer, 1987.
[9] P. Farail, P. GaudZllet, F. Peres, J.-P. Bodeveix, M. Filali, B. Berthomieu, S. Rodrigo, F. Vernadat, H. Garavel, and F. Lang.
FIACRE: an intermediate language for model veridZcation in the TOPCASED environment.
In European Congress on Embedded Real-Time Software, ERTSa08, 2008.
[10] I. O. for Standardization.
Information processing systems - open systems interconnection - LOTOS - a formal description technique based on the temporal ordering of observational behaviour.
International standard.
ISO, 1989.
[11] T. Henzinger, Z.
Manna, and A. Pnueli.
Timed transition systems.
In J. de Bakker, C. Huizing, W. de Roever, and G. Rozenberg, editors, RealTime: Theory in Practice, volume 600 of Lecture Notes in Computer Science, pages 226a251.
Springer, 1992.
10.1007/BFb0031995.
[12] T. A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine.
Symbolic model checking for real-time systems.
Inf.
Comput., 111(2):193a244, 1994.
[13] T. Hoare and P. OaHearn.
Separation logic semantics for communicating processes.
Electron.
Notes Theor.
Comput.
Sci., 212:3a25, Apr.
2008.
[14] H. HuEttel and K. Larsen.
The use of static constructs in a model process logic.
In A. Meyer and M. Taitslin, editors, Logic at Botik a89, volume 363 of Lecture Notes in Computer Science, pages 163a180.
Springer Berlin Heidelberg, 1989.
[15] K. Larsen, P. Pettersson, and W. Yi.
Model-checking for real-time systems.
In H. Reichel, editor, Fundamentals of Computation Theory, volume 965 of Lecture Notes in Computer Science, pages 62a88.
Springer, 1995.
10.1007/3-540-60249-6 41.
[16] R. Milner.
Communication and concurrency.
Prentice Hall International, 1995.
[17] A. W. Roscoe.
The Theory and Practice of Concurrency.
Prentice Hall, 1997.
[18] A. W. Roscoe.
On the expressiveness of CSP.
Technical report, www.cs.ox.ac.uk/files/1383/complete(3).pdf, 2011.
[19] E. Sekerinski and K. Sere.
A theory of prioritizing composition.
Technical report, 1996.
VI.
C ONCLUSION We have presented a formal semantic framework for studying, dedZning, and manipulating the composition of extended transition systems based on the composition of their labels.
The framework is based on the idea of dedZning a label structure containing a composition operator.
Depending on the language in question, a different label structure is dedZned and thus different composition laws are integrated.
The label structure is then used as a parameter of labeled transition systems which describe the common semantic domain of the considered languages.
We believe that the suggested parametrization of the behavioral framework is a promising work and may represent, especially with the perspectives we have, the dZrst step towards giving a unidZed formal semantic framework for different process algebras and specidZcation languages.
In our study, we emphasize on composition operators of process algebras without concentrating on other behavioral operators.
In this context, we have pushed forward existing work of similar structures [14], [18], [13] by offering a richer set of operations and properties such as the composition of label structures and transformations between label structures.
Following our technique, the composition of different LTS extensions, whether it is a syntactic model or a semantic model, is captured by a unique composition operation dedZned on LTS.
This is a direct result of the separation between the label structure and the behavioral framework.
This result is different than what can be found in the literature since with each system, a different composition operation is provided.
This can be seen classically in the composition operations of LTS and TTS.
Even though a TTS is exactly an LTS having additionally time transitions, usually its composition operation does not reuse the LTS one.
Furthermore, generic results concerning label structures and LTS transformations are applied to establish well known properties of high-level structures such as the dedZnition of timed automata semantics.
We have shown that these semantics match with the standard timed automata semantics and that the timed automata are compositional w.r.t the parallel operator.
We are now working on a dual view of this work which consists in coupling our label structures to states.
This will help us to naturally take into consideration state-based mechanisms such as the the committed states of UPPAAL [7].
We are also working on dedZning the formal semantics of real time languages (BIP [6] and FIACRE [9]).
Namely, we are interested in extending our label structure with priorities which are present in all the three cited languages.
Another extension is to revisit this work by incorporating some categorical dZavor.
Finally, all the theorems related to the presented framework have been validated in the proof assistant Coq.
The Coq theory may be found at [1].
Acknowledgement: The authors would like to thank the reviewers for thoroughly reading the paper.
R EFERENCES [1] http://www.irit.fr/~Jean-Paul.Bodeveix/COQ/LblStr.
132 118