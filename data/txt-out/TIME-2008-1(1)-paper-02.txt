15th International Symposium on Temporal Representation and Reasoning  The Complexity of CaRet + Chop Laura Bozzelli UniversitaE dellaInsubria, Via Valleggio 11, 22100 - Como, Italy  + Past (obtained by adding non regular past and future versions of the standard LTL temporal modalities), has been introduced [2] to allow the specification of such a class of context-free requirements.
Even though verifying contextfree properties of pushdown systems is in general undecidable, the pushdown model checking against CaRet is decidable and E XPTIME-complete (the same complexity as that of pushdown model checking against LTL [5]).
In [3], the class of nondeterministic visibly pushdown automata (NVPA) is proposed as an automata theoretic generalization of CaRet.
NVPA are pushdown automata where the input symbol determines when the automaton can push or pop, and thus the stack depth at every position.
The resulting class of languages (visibly pushdown languages or VPL) is closed under all boolean operations and problems such as universality and inclusion that are undecidable for contexta free languages are E XPTIMEacomplete for VPL.
Moreover, NVPA have the same expressiveness as MSOAl [3], which extends the classical monadic second order logic (MSO) over words with a binary matching predicate.
The logic CaRet is less expressive than NVPA and is easily expressible in the first-order fragment FOAl of MSOAl .
However, it is an open question whether CaRet is FOAl-complete [1].
Abstract We investigate the complexity of satisfiability and pushdown model-checking of the extension of the logic CaRet with the binary regular modality aChopa.
We present automata-theoretic decision procedures based on a direct and compositional construction, which for finite (resp., infinite) words require time of exponential height equal to the nesting depth of chop modality plus one (resp., plus two).
Moreover, we provide lower bounds which match the upper bounds for the case of finite words.
1.
Introduction The modality aChopa in linear temporal logic.
In the literature some extensions of the linear temporal logic LTL [16], with the same expressiveness as LTL, have been investigated in order to support a compositional approach to the specification and verification of concurrent systems.
These extensions enable modular and compositional reasoning about sequential constructs as well as about concurrent ones.
One of the most important extensions of LTL is the addition of the binary achopa modality [12, 17, 15], which allows to achopa away parts of the computation.
Thus, this modality is useful in cases we want to see subruns inside a run (e.g., sessions, or specific fragments) and state their temporal specifications.
Satisfiability for LTL + chop is nonelementary [17], and the best known upper bound, obtained by a semantic-tableau method, requires space of exponential height equal to the nesting depth of chop modality (the existence of a matching lower bound on the exponential height of this complexity is an open question).
Our contribution.
In this paper, we investigate the complexity of satisfiability and pushdown model-checking of the logic CaRet + Chop (C-CaRet) in terms of the nesting depth of chop modality.
For each h aL 1, let C-CaReth be the fragment of C-CaRet consisting of formulas with chop nesting depth at most h, and let h-E XPTIME be the class of languages which can be decided in (deterministic) time of exponential height h. We show the following results for C-CaReth : (1) for finite words, the considered problems are (h + 1)-E XPTIME-complete, (2) for infinite words, the problems are in (h + 2)-E XPTIME and (h + 1)-E XPTIME-hard.
The linear temporal logic CaRet.
Model checking of LTL specification w.r.t.
pushdown systems has been shown to be a useful tool for analysis of programs with recursive procedures [4, 11, 10].
LTL, however, can specify only regular properties, and properties which require either inspection of the call-stack of a procedure, or matching of calls and returns (such as correctness of procedures with respect to pre and post conditions) are not regular.
Recently, the linear temporal logic CaRet, a contextafree extension of LTL  1530-1311/08 $25.00 AS 2008 IEEE DOI 10.1109/TIME.2008.27  The upper bounds are obtained by an automata-theoretic approach.
For finite words, we propose a translation of C-CaRet formulas into equivalent NVPA, while for infinite words we exploit the class of alternating jump (finiteastate) automata (AJA) [6] which can be translated into equivalent NVPA [6] with a single exponential-time blow-up.
In both cases, the construction is direct and compositional, and is based on a non-trivial characterization of the satisfaction  23  relation, for a given formula D, in terms of sequences of pairs of sets associated with D (which generalize the classical notion of Hintikka-set of LTL) satisfying determined requirements which can be checked by NVPA and AJA.
Finally, the lower bounds for C-CaReth are obtained by a non-trivial reduction from the word problem of alternating Turing machines operating in space of exponential height h. A straightforward readaptation of these reductions lead to h-E XPSPACE-hardness for satisfiability of LTL + Chop formulas with chop nesting depth at most h.  over IL, |w| denotes the length of w (we set |w| = a if w is infinite), and for 0 a$?
i < |w|, w(i) is the ith symbol of w. A nondeterministic visibly pushdown automaton (NVPA) [3] is a pushdown automaton operating on words over a pushdown alphabet which pushes onto the stack only when it reads a call, pops the stack only at returns, and does not use the stack on internal actions.
Formally, a NVPA over IL = ILc aS ILr aS ILint is a tuple P = IL, Q, Q0 , I, a, F, where Q is a finite set of states, Q0 a Q is a set of initial states, I is the finite stack alphabet, F a Q is a set of accepting states, and a = (Q A ILc A Q A I) aS (Q A ILr A (I aS {Il0 }) A Q) aS (Q A ILint A Q) is the transition relation (where Il0 a / I is the special stack bottom symbol).
A configuration of P is a pair (q, I,), where q a Q and I, a Ia AV {Il0 } is a stack content.
A run of P over a word w on IL is a sequence of configurations r = (q0 , I,0 )(q1 , I,1 ) .
.
.
of length |w|+ 1 such that I,0 = Il0 , q0 a Q0 , and for each i < |w|: [push] if w(i) a ILc , then aB a I such that I,i+1 = B AV I,i and (qi , w(i), qi+1 , B) a a; [pop] if w(i) a ILr , then aB a I aS {Il0 } such that (qi , w(i), B, qi+1 ) a a and either I,i = I,i+1 = B = Il0 , or B = Il0 and I,i = B AV I,i+1 ; [internal] if w(i) a ILint , then (qi , w(i), qi+1 ) a a and I,i = I,i+1 .
The run r is accepting iff either w is finite and q|w| a F, or w is infinite and for infinitely many i aL 0, qi a F. The language L (P ) of P is the set of words w over IL such that there is an accepting run of P over w. A language L of words over IL is a visibly pushdown language (VPL) if L = L (P ) for some NVPA P .
In order to model formal verification problems of pushdown systems M using finite specifications (such as NVPA) denoting VPL languages, we choose a suitable pushdown alphabet IL = ILc aS ILr aS ILint , and associate a symbol in IL with each transition of M with the restriction that push transitions are mapped to ILc , pop transitions are mapped to ILr , and transitions that do not use the stack are mapped to ILint .
Note that M equipped with such a labelling is a NVPA where all the states are accepting.
The specification S describes another VPL L (S) over IL, and M is correct iff L (M) a L (S).
Given a class C of finite specifications S describing VPL over a pushdown alphabet IL, the pushdown model checking problem against C -specifications for finite (resp., infinite) words is to decide, given a pushdown system M over IL and a specification S in the class C , whether L (M) aS ILa a L (S) aS ILa (resp., L (M) aS ILD a L (S) aS ILD ).
Remark 1.
C-CaRet can be easily translated into FOAl , hence it captures a strict subclass of VPL.
Moreover, by results in [7] it easily follows that C-CaRet is FOAl -complete.
Related work.
In the literature, different extensions of the logic CaRet, which are expressively complete for FOAl , have been investigated.
In particular, Alur et al.
[1] propose two extensions of CaRet.
One of them is based on the notion of a summary path that combines both regular and non-regular next-modalities; for this logic, both satisfiability and pushdown model checking are shown to be E XPTIME-complete, which is the same complexity as that of CaRet.
The other logic is an extension of CaRet with the non-regular unary modality awithina W, which essentially evaluates a formula on a subword corresponding to the computation fragment associated with a single procedure (including nested procedure calls).
This logic is exponentially more succinct than CaRet, and its satisfiability and pushdown model checking are both 2E XPTIME-complete.
An other extension of CaRet has been studied in [7], where the extension is obtained by adding the well-known unary regular modality afrom now ona [14, 13], which allows to model forgettable past.
Satisfiability and pushdown model checking for the resulting logic are shown to be 2E XPTIME-complete.
Moreover, CaRet + W can be linearly translated into this logic.
2.
Preliminaries Let N be the set of natural numbers.
Definition 1.
For all n, h a N, let Tower(n, h) be defined as: Tower(n, 0) = n and Tower(n, h + 1) = 2Tower(n,h) .
For each h aL 0, exp[h] denotes the class of functions f : N a N such that for some constant c aL 1, f (n) = Tower(nc , h) for each n. We denote by h-E XPTIME the class of languages decided by exp[h]-time bounded deterministic Turing machines.
2.2.
The linear temporal logic C-CaRet First, we recall the syntax and semantics of full CaRet [2].
Fix a pushdown alphabet IL = ILc aS ILr aS ILint .
For a word w on IL and i a$?
j < |w|, w[i, j] denotes the finite word w(i)w(i + 1) .
.
.
w( j), and wi denotes the suffix of w starting from position i.
A finite word w is well-matched if inductively or (1) w is empty, or (2) w = Dw , D a ILint and w is well-matched, or (3) w = Dc w Dr w , Dc a ILc , Dr a ILr , and  2.1.
Visibly pushdown languages A pushdown alphabet IL is an alphabet which is partitioned in three disjoint finite alphabets ILc , ILr , and ILint , where ILc is a finite set of calls, ILr is a finite set of returns, and ILint is a finite set of internal actions.
For a word w  24  operators of LTL.
Formally, the syntax is defined as follows: succ(c, w, 7)  w=	 0 c  succ(a+ , w, 1) 1 c  2 i  3 c  4 i  i = internal action;  5 r  D ::=  | D | AZD | D aSS D | Xdir D | D U dir D  succ(a+ , w, 7)  R 6 r  where  denotes true, D a IL, and dir a {+, a, a+ , aa , c}.
Note that X+ and U + correspond to the usual anexta and auntila operators of LTL, while Xa and U a are their past counterparts.
CaRet is interpreted on words w over IL.
Given a formula D and a position i in w, the satisfaction relation (w, i) |= D (which reads as aw satisfies D at position ia) is inductively defined as follows, where dir a {+, a, a+ , aa , c} (we omit the rules for atomic actions in IL and boolean connectives which are standard):  R 7 c  c = call;  8 i  9 r  10 i  r = return  w and w are well-matched.
CaRet is based on five different notions of successor for a position i along a word w: aV The forward local successor of i along w, written succ(+, w, i), is i + 1 if i + 1 < |w|, and it is aL otherwise (the symbol aL is for aundefineda).
aV (w, i) |= Xdir D a succ(dir, w, i) = j = aL and (w, j) |= D aV (w, i) |= D1 U dir D2 a for the dir-path I" = j0 , j1 , .
.
.
of w starting from i, an < |I"| such that (w, jn ) |= D2 and a0 a$?
h < n, (w, jh ) |= D1 .
aV The backward local successor of i along w, written succ(a, w, i), is i a 1 if i > 0, and it is aL otherwise.
The logic C-CaRet extends CaRet with the binary regular modality aChopa, written C, whose semantics is given by  aV The forward abstract successor of i along w [2], succ(a+ , w, i).
If w(i) a ILc , succ(a+ , w, i) is the matching return position of i if any, i.e.
: if there is j > i s.t.
w( j) a ILr and w[i + 1, j a 1] is well-matched, then succ(a+ , w, i) = j (note that j is uniquely determined), / ILc , then otherwise succ(a+ , w, i) = aL.
If instead w(i) a succ(a+ , w, i) = i + 1 if i + 1 < |w| and w(i + 1) a / ILr , and succ(a+ , w, i) = aL otherwise.
aV (w, i) |= D1 CD2 a ai a$?
n < |w| such that (w[0, n], i) |= D1 and (wn , 0) |= D2 .
Note that the future regular fragment of C-CaRet, obtained by disallowing operators Xdir and U dir with dir a {a, a+ , aa , c}) corresponds to the logic LTL + C [12].
We denote by L (D) the language of words w over IL s.t.
(w, 0) |= D. The satisfiability problem of C-CaRet for finite words (resp., infinite words) is to decide whether L (D) aS ILa = 0/ / for a given formula D.
(resp., L (D) aS ILD = 0) For a C-CaRet formula D, we denote by dC (D) the nesting depth of modality C in D. Moreover, for each h aL 0, C-CaReth denotes the C-CaRet-fragment consisting of formulas D s.t.
dC (D) a$?
h, and future C-CaRet is the fragment obtained by disallowing the backward temporal modalities.
aV The backward abstract successor of i along w, succ(aa , w, i).
If w(i) a ILr , then it points to the matching call of i if any; otherwise, succ(aa , w, i) = aL.
If instead w(i) a / ILr , then succ(aa , w, i) = i a 1 if i a 1 > 0 and w(i a 1) a / ILc , and succ(aa , w, i) = aL otherwise.
aV The caller of i along w [2], succ(c, w, i), points to the last unmatched call of the prefix w[0, h] (where h = i a 1 if i is a call position, and h = i otherwise), i.e.
: if there is j < i such that w( j) a ILc and w[ j + 1, h] is wellamatched , then succ(c, w, i) = j (note that j is uniquely determined), otherwise succ(c, w, i) = aL.
2.3.
Alternating jump automata (AJA) Alternating jump (finite-state) automata (AJA) [6] operate on infinite words over a pushdown alphabet and capture exactly the class of VPL.
AJA extend standard alternating finiteastate automata by also allowing non-local moves: on reading a matched-call Dc , a copy of the automaton can move (jump) in a single step to the matching-return of Dc .
For a finite set X, B p (X) denotes the set of positive boolean formulas over X built from elements in X using a" and aSS (we also allow the formulas true and false).
A subset Y of X satisfies I, a B p (X) iff the truth assignment assigning true to the elements in Y and false to the elements of X \ Y satisfies I,.
A generalized BuEchi AJA is a tuple A = IL, Q, Q0 , I', F , where IL is a pushdown alphabet, Q is a finite set of states,  For i < |w| and dir a {+, a, a+ , aa , c}, the dir-path of w from i, is the maximal sequence of positions I" = j0 , j1 , .
.
.
s.t.
j0 = i and jh = succ(dir, w, jha1 ) for each 0 < h < |I"|.
Intuitively, the forward abstract paths and the backward abstract paths (i.e., the a+ -paths and aa -paths) capture the local computation within a procedure removing computation fragments corresponding to nested calls within the procedure, while a caller path (i.e., a c-path) captures the content of the call-stack of a procedure.
For example, in the figure above, the sequence of positions 4, 3, 1, 0 is a caller path, while the sequence 1, 6, 7, 9, 10 is a forward abstract path.
For each type of successor, CaRet provides the corresponding versions of the usual anexta (X) and auntila ( U )  25  Q0 a Q is the set of initial states, I' : Q A IL a B p ({+, a+ } A Q A Q) is the transition function, and F = {F1 , .
.
.
, Fk } is a set of sets of accepting states.
Intuitively, a target of a move of A is encoded by a triple (dir, q, q ) a {+, a+ } A Q A Q, meaning that a copy of A on reading the ith input symbol of the given word w moves to position succ(dir, w, i) in state q if succ(dir, w, i) = aL , and to position i + 1 in state q otherwise.
Formally, a run of A over an infinite word w a ILD is a N A Q-labeled tree r such that the root is labeled by (0, q0 ) with q0 a Q0 and for each node x with label (i, q) (describing a copy of A in state q which reads w(i)), there is a (possibly empty) set H = {(dir1 , q1 , q1 ), .
.
.
, (dirm , qm , qm )} a {+, a+ } A QA Q satisfying I'(q, w(i)) such that x has m children x1 , .
.
.
, xm , and for each 1 a$?
h a$?
m: xh has label (i + 1, qh ) if succ(dirh , w, i) = aL, and label (succ(dirh , w, i), qh ) otherwise.
The run r is accepting if for each infinite path x0 x1 .
.
.
in the tree and each accepting component F a F , there are infinitely many i aL 0 s.t.
xi is labeled by some state in F. The D-language of A , LD (A ), is the set of w a ILD such that there is an accepting run r of A over w.  chop modality is meaningfully different from that proposed in [17] for LTL + Chop.
The regular and non-regular next requirements are captured locally requiring that consecutive pairs (Ari , Ai ), (Ari+1 , Ai+1 ) along the sequence D satisfy determined syntactical constraints.
For example, if w(i) is a call, w(i + 1) is not a return, and UM(w, i + 1) = aL, then UM(w, i + 1) represents the matching return position of i along w. Thus, we have to require that the forward-abstractnext requirements in Ai are exactly the ones that hold in Ari+1 , and the backward-abstract-next requirements in Ari+1 are exactly the ones that hold in Ai .
Finally, if w is infinite, then the sequence D has to satisfy fairness non-local additional conditions reflecting the liveness requirements in forward until subformulas of D, and the liveness requirements D1 in chop subformulas D1 CD2 of D. Now, we give the technical details.
A formula D is said to be a first-level subformula of D if there is an occurrence of D in D which is not in the scope of a chop operator.
The closure Cl(D) of D is the smallest set containing , Xdir  for each dir a {+, a, a+ , aa , c}, all the first-level subformulas of D, Xdir (D1 U dir D2 ) for any firstlevel subformula D1 U dir D2 of D, and the negations of all these formulas (we identify AZAZD with D).
A simple atom A is a subset of Cl(D) such that aV A aS IL is a singleton and  a A; aV if D a Cl(D), then D a A iff AZD a / A; aV if D1 aSS D2 a Cl(D), then D1 aSS D2 a A iff D1 , D2 a A; aV if D1 U dir D2 a Cl(D), then D1 U dir D2 a A iff either D2 a A or D1 , Xdir (D1 U dir D2 ) a A; aV if Xdir D a A, then Xdir  a A; a aV if AZXa  a A, then AZXa , AZXc  a A; + aV if AZX+  a A, then AZXa  a A. where dir a {+, a, a+ , aa , c}.
Intuitively, the set of formulas in a simple atom of D represents a maximal set of first-level subformulas of D that can consistently hold at a position along a word over IL.
For each forward local until formula D1 U + D2 a Cl(D), we introduce a new symbol DD2 associated with the liveness requirement D2 (whose intuitive meaning will be given later), and denote by P(D) the set of these symbols.
Now, we define the set Atoms(D) of atoms of D by induction on the chop nesting depth dC (D): A a Atoms(D) iff   / A a Cl(D)aSP(D)aS D1 CD2 aCl(D) h=2 h=1 (Atoms(Dh )aS{0})A Atoms(Dh ) A {D1 CD2 } A {h} A {Y ES, NO} and the following additional conditions hold for each subformula D1 CD2 a Cl(D):  3.
Decision Procedures for C-CaRet In this section we solve satisfiability and pushdown model-checking of C-CaRet by an automata-theoretic approach.
For finite words, we propose a translation of C-CaRet formulas into equivalent NVPA, while for infinite words we exploit AJA.
In both cases, the construction is direct and compositional.
In the rest of this section, first, we give a non-trivial characterization of the satisfaction relation (w, 0) |= D, for a given formula D, in terms of sequences of pairs of sets associated with D satisfying determined requirements which can be checked by NVPA and AJA.
Then, we describe the translation into NVPA (for finite words) and AJA (for infinite words) based on this characterization.
Fix a pushdown alphabet IL.
For a word w over IL and i < |w|, the next unmatched return of i in w, UM(w, i), is defined as: if the caller of i is defined and has matching return ir , then UM(w, i) = ir ; otherwise, UM(w, i) = aL.
In the following, we fix a C-CaRet formula D. Essentially, for each finite or infinite word w over IL, we associate to w sequences (of length |w|) D = (Ar0 , A0 ), (Ar1 , A1 ), .
.
.
of pairs of sets, where for each 0 a$?
i < |w|, Ai is an atom and intuitively describes a maximal set of subformulas of D which can hold at position i along w, while Ari = 0/ if UM(w, i) = aL, and Ari = A j with j = UM(w, i) otherwise.
As for LTL, the notion of atom syntactically captures in particular the semantics of boolean connectives and the fixpoint characterization of the until modalities in terms of the next modalities of the same type.
Moreover, the notion of atom also partially (and syntactically) captures the semantics of chop modality.
Since C-CaRet has also backward modalities, the approach proposed here to handle the  1.
A aS Cl(D) is a simple atom; 2. if (Br , B, D1 CD2 , h, f ) a A, then B aS IL = A aS IL, and if / either AZXa  a B or AZX+  a B, then Br = 0; 3. if (Br , B, D1 CD2 , 2, f ) a A and dir a {+, a+ }, then Xdir  a A iff Xdir  a B;  26  / A Atoms(D) to a set of pairs in (Atoms(D) aS {0}) / A {0}) Atoms(D).
Intuitively, if A is the atom associated with the current position i of the given word w, and Ar is the atom associated with UM(w, i) if UM(w, i) = aL, and Ar = 0/ otherwise, then Jump SuccD (Ar , A) contains that pairs (Ar , A ) such that A is a atom associable to the next position i + 1 and Ar is the corresponding atom associable to UM(w, i + 1).
Formally, (Ar , A ) a Jump SuccD (Ar , A) iff A a SuccD (A) and the following is inductively satisfied:  4. if (Br , B, D1 CD2 , 1, f ) a A, then for each dir a {a, aa }, Xdir  a A iff Xdir  a B, and for each dir a {+, a+ }, if Xdir  a B then Xdir  a A ; 5.
D1 CD2 a A iff a(Br , B, D1 CD2 , 1,Y ES) a A. D1 a B; 6. a(Br , B, D1 CD2 , 1,Y ES) a A such that AZX+  a B iff a(Cr ,C, D1 CD2 , 2, f ) a A such that D2 , AZXa  a C; 7. a(Cr ,C, D1 CD2 , 2, f ) a A such that AZXa  a C.  / 1. a(Br , B, D1 CD2 , 1, f ) a A, Br = 0/ if Ar = 0;  Intuitively, the meaning of a tuple (Br , B, D1 CD2 , h, f ) a A is as follows: if h = 1 and the current position is i, then B describes the set of subformulas of D1 which hold at position i of a prefix w p of the given word w, and Br is the set associated with UM(w p , i) if UM(w p , i) = aL, and Br = 0/ otherwise.
Moreover, f = Y ES iff the suffix of w starting from the last position of w p initially satisfies D2 .
If instead h = 2 and the current position is i, then there is j a$?
i, such that B describes the set of subformulas of D2 which hold at position i a j of w j , and Br is the set associated with UM(w j , i a j) (if any).
Note that the value of f is irrelevant if h = 2 (we introduce it only to have a uniform notation).
By construction it easily follows that |Atoms(D)| = Tower(|D|, dC (D) + 1).
For A a Atoms(D), let D(A) be the unique element in A aS IL, and let CallerFormD (A) = {Xc D a Cl(D) | Xc D a A}.
For atoms A and A , the predicate AbsReqD (A, A ) + a + holds iff for all Xa D, Xa D a Cl(D), (Xa D a A a D a a A ) and (Xa D a A a D a A).
Similarly, the predicate LocReqD (A, A ) holds iff for all X+ D, Xa D a Cl(D) (X+ D a A a D a A ), and (Xa D a A a D a A).
Let JumpD , SuccD : Atoms(D) a 2Atoms(D) be the functions defined as follows:  2.
Case (D(A) a ILc and D(A ) a ILr ) or (D(A) a / ILc and / ILr ): Ar = Ar and for each DD a P(D), DD a A D(A ) a iff either D a A or DD a A where DD = D if Ar = 0/ and D(A) a ILc , and DD = DD otherwise; 3.
Case D(A) a / ILc and D(A ) a ILr : Ar = Ar = 0/ if aa  / A , and Ar = A and for each DD a P(D), X a DD a A iff D a A aS A , otherwise.
Moreover, if (Br , Br , D1 CD2 , h, f ) a A and (Br , B, D1 CD2 , h, f ) a A, then (Br , Br ) a Jump SuccDh (Br , B); +  / 4.
Case D(A) a ILc , D(A ) a / ILr , Xa  a / A: Ar = Ar = 0; +  5.
Case D(A) a ILc , D(A ) a / ILr , and Xa  a A: Ar =  / Ar a JumpD (A) and for each DD a P(D), DD a A 0, / or (DD a iff or D a A or (DD a A aS Ar and Ar = 0) / Also, a (Br , Br , D1 CD2 , 1, f ) a Ar , A and Ar = 0).
a (Br , B , D1 CD2 , 1, f ) a A , a(Br , B, D1 CD2 , 1, f ) a A.
(Br , B ) a Jump SuccD1 (Br , B); 6. a(Br , B, D1 CD2 , h, f ) a A such that X+  a B, a(Br , B , D1 CD2 , h, f ) a A such that (Br , B ) a Jump SuccDh (Br , B); moreover, if D(A) a ILc , / then (Br , Br , D1 CD2 , h, f ) a Ar ; D(A ) a / ILr , and Br = 0,  aV A a JumpD (A) iff CallerFormD (A) = CallerFormD (A ) and AbsReqD (A, A ).
7. a(Br , B , D1 CD2 , 1, f ) a A , a(Br , B, D1 CD2 , 1, f ) a A such that (Br , B ) a Jump SuccD1 (Br , B); moreover, / then / ILr , and Br = 0, if D(A) a ILc , D(A ) a   (Br , Br , D1 CD2 , 1, f ) a Ar .
aV A a SuccD (A) iff LocReqD (A, A ) and: - Case either (D(A) a ILc and D(A ) a ILr ) or (D(A) a / ILc and D(A ) a / ILr ): A a JumpD (A);  There are many subtleties in definition of Jump SuccD which cannot discussed here due to lack of space.
Here, we only give the intuitive meaning of the rules for the propositions DD , where D1 U + D a Cl(D) for some D1 : if the current position i is a matched call with matching return j, / A) is the pair associated with posiUM(w, i) = aL, and (0, tion i, then DD a A iff D holds at some position in [i, j].
Given a word w over IL, i a N, and  j a N aS {a} such that i a$?
 j a$?
|w| a 1, a fulfilling (i,  j, D)-sequence over w is a sequence D = (Ari , Ai ), (Ari+1 , Ai+1 ), .
.
.
of pairs in / A Atoms(D) of length  (Atoms(D) aS {0}) j a i + 1 such that a + aV AZX  a Ai if i = 0, and AZX  a A j if  j = |w|a 1 a N;  aV for each i a$?
l a$?
j, D(Al ) = w(l);  / ILr : CallerFormD (A ) = - Case D(A) a ILc and D(A ) a a {Xc D a Cl(D) | D a A} and Xa  a / A ; +  - Case D(A) a / ILc and D(A ) a ILr : Xa  a / A, (Xc  a aa  c  c A iff X  a A ), and X  a / A if X  a / A.
Intuitively, SuccD (A) is the set of atoms A containing the first-level subformulas of D which can hold at the next position i + 1 of the current position i.
Moreover, assuming that the forward abstract position j of i along the given word is defined, JumpD (A) gives the set of atoms containing the first-level subformulas of D which can hold at position j.
Now, we define by induction on dC (D) the function Jump SuccD which maps each pair (Ar , A) a (Atoms(D) aS  27  aV aV aV aV  for each i a$?
l <  j, (Arl+1 , Al+1 ) a Jump SuccD (Arl , Al );  for all i a$?
l, l a$?
 j, Arl = Arl if UM(w, l) = UM(w, l  ); for each i a$?
l a$?
 j, if UM(w, l) = l  a$?
 j, then Arl = Al  ; r for each i a$?
l a$?
 j, Al = 0/ if UM(w, l) = aL.
Corollary 1.
For each word w over IL, (w, 0) |= D iff there is a fulfilling D-sequence D = (Ar0 , A0 ), .
.
.
over w such that / D a A0 and D is fair if w is infinite (note that Ar0 = 0).
Translation into NVPA and AJA For finite fords, the translation of C-CaRet formulas D into equivalent NVPA PD , based on the result of Corollary 1 is simple.
Essentially, for a given input w, the NVPA PD guesses (by its finite control) a sequence D = (Ar0 , A0 ), .
.
.
and by using the stack checks that it is a fulfilling D-sequence over w. Details are in [8].
A fulfilling (0, |w| a 1, D)-sequence over w is called simply fulfilling D-sequence over w. A fulfilling D-sequence D = (Ar0 , A0 ), (Ar1 , A1 ), .
.
.
over an infinite word w a ILD is fair if the following is inductively satisfied for each i aL 0: 1. if (Cr ,C, D1 CD2 , 2, f ) a Ai and AZXa  a C, then there is a fair fulfilling D2 -sequence over wi from (Cr ,C);  Theorem 3.
Let D be a C-CaRet formula over IL.
Then, one can construct a NVPA PD of size O(Tower(|D|, dC (D) + 1)) such that L (PD ) aS ILa = L (D) aS ILa .
/ then there 2. if (Br , B, D1 CD2 , 1,Y ES) a Ai and Ari = 0, are m aL i, a fulfilling (i, m, D1 )-sequence over w[0, m] starting from (Br , B), and a fulfilling fair D2 -sequence (Cr ,C), .
.
.
over wm such that D2 a C;  For infinite words, we obtain the following result.
Theorem 4.
Let D be a C-CaRet formula over IL.
Then, one can construct a generalized BuEchi AJA AD of size O(Tower(|D|, dC (D) + 1)) such that LD (AD ) = L (D) aS ILD .
a+  3. if D1 U D2 a Cl(D) , then for infinitely many h aL 0, + / Arh = 0/ and {D2 , AZ(D1 U a D2 )} aS Ah = 0;  Proof.
We construct a generalized BuEchi AJA AD of size O(Tower(|D|, dC (D) + 1)) with set of states QD a / A Atoms(D) and initial states of the form (Atoms(D) aS {0}) / A) / A) with D, AZXa  a A s.t.
for each state of the form (0, (0, with AZXa  a A and infinite word w, AD has an accepting / A) iff there is a fair fulfilling D-sequence run over w from (0, / A).
Hence, the result follows from Corolover w from (0, lary 1.
The construction is given by induction on dC (D).
Thus, we can assume that for each D1 CD2 a Cl(D) (note that if dC (D) = 0, there is no such a formula), one can construct the AJA AD2 associated with D2 .
Here, we describe informally the main aspects of the AJA AD (the formal definition is given in [8]).
Essentially, AD guesses a fulfilling D-sequence over the input word w and checks that it is fair.
Assume that AD starts the computation in a state of the / A) with AZXa  a A.
Then, the first-level copy of form (0, AD behaves as follows.
When a symbol w(i) is read in a / A) (where D(A) = w(i)) and i is not a matchedstate (0, call position (note that AD can check whether this condi/ A ) a tion is satisfied or not), then AD guesses a pair (0, / A) and proceeds as follows.
A copy (the Jump SuccD (0, first-level copy) moves to the next input symbol in state / A ).
Moreover, in order to check that Properties 1 and (0, 2 in def.
of fair fulfilling D-sequence are satisfied, for each (Cr ,C, D1 CD2 , 2, f ) a A with AZXa  a C (note that by def.
/ AD starts an additional copy of the AJA AD2 of atom Cr = 0), in state (Cr ,C), and for each (Br , B, D1 CD2 , 1,Y ES) a A, AD starts a copy in a state of the form (Br , B, D1 CD2 , AZUM).
The behavior of this last copy will be explained later.
Now, assume that i is a matched-call position and w(i + 1) a / ILr (the case w(i + 1) a ILr is simpler).
As above, AD starts additional copies to check Properties 1 and 2 in def.
of fair fulfilling D-sequence.
Moreover, AD guesses a pair / A).
Assume that D(A ) = w(i + 1) (Ar , A ) a Jump SuccD (0,  4. if D1 U + D2 a Cl(D), then for infinitely many h aL 0, / and or D2 a Ah , or AZ(D1 U + D2 ) a Ah , or Arh = 0, + (DD2 , Xa  a Ah and D(Ah ) a ILc ).
The notion of fairness is used to capture recursively the liveness requirements in forward until subformulas of D (Properties 1, 3, and 4 above), and the liveness requirements D1 in chop subformulas D1 CD2 of D (Property 3 above).
As we will see, the AJA associated with D guesses a fulfilling D-sequence D over the infinite input word and checks that it is fair.
The automaton keeps tracks by its finite control of the current pair of D, and in particular, its amaina copy tracks an infinite path in the run which visits all and only the nodes which are associated with the pairs (Ar , A) of D / Thus, the acceptance condition of the AJA such that Ar = 0.
(when interpreted on the main path) exactly reflects Properties 3 and 4 above.
In particular, the propositions DD2 are used to guarantee that in case D1 U + D2 is asserted at a node x of the main path and the liveness requirement D2 does not hold along the suffix of the main path from x, then D2 holds at some other position j aL i (i.e., there is a pair (Ar , A) with Ar = 0/ of the guessed D-sequence associated with position j for some j aL i such that D2 a A).
The proofs of the following results are given in [8].
Theorem 1 (Correctness).
Let D = (Ar0 , A0 ), (Ar1 , A1 ) .
.
.
be a fair fulfilling D-sequence on w which is fair if w is infinite.
Then, for all i < |w| and D a Cl(D), (w, i) |= D iff D a Ai .
Theorem 2 (Completeness).
For each word w over IL, there is a fulfilling D-sequence over w, which is fair if w is infinite.
By Theorems 1 and 2 we obtain the following characterization of the satisfaction relation (w, 0) |= D.  28  (otherwise the input is rejected).
Then, Ar = 0/ represents the guessed atom associated with the matching return position ir of i.
Thus, a copy (the first-level copy) jumps / Ar ) (note that to the matching-return ir of i in state (0, UM(w, i) = UM(w, ir ) = aL), and another copy moves to position i + 1 in state (Ar , A ).
The goal of this last copy is also to check that the guess Ar is correct.
The behavior of these auxiliary copies, which are in states of the form (Ar , A) with Ar = 0/ is as follows.
If the input symbol w(i) is a call (note that i is a matched call-position) or (w(i) a / ILc and w(i + 1) a / ILr ), the behavior is similar to that of the first-level copy.
If instead, w(i) = D(A) is not a call, and w(i + 1) is a return, then Ar = 0/ is the guessed atom associated with w(i + 1).
Thus, the considered copy terminates with success its computation iff D(Ar ) = w(i + 1) and (Ar , Ar ) a Jump SuccD (Ar , A) for some Ar (note that since D(A) a / ILc and D(Ar ) a ILr , by def.
of Jump SuccD the fulfilment of this condition is independent on the value of Ar ).
Now, we describe the behavior of AD in states of the form (Br , B, D1 CD2 , f ), where f a {STOP,UM, AZUM}.
Assume that the current symbol is w(i).
Essentially, AD guesses a fulfilling (i, m, D1 )-sequence D over w[0, m] starting form (Br , B) for some m aL i, and on reading w(m) starts an addi/ s.t.
D2 , AZXa  a C. tion copy of the AJA AD2 in a state (0,C) In order to check the existence of D, AD proceeds similarly to the first-level copy.
The unique difference is that now Br can be empty even if UM(w, i) = aL.
Thus, the flag f is used to keep track if this last condition is satisfied or not.
If / and for example, w(i) is not a call, w(i + 1) a ILr , Br = 0, f = UM (i.e., UM(w, i) = aL), then m must be equal to i.
Finally, the BuEchi acceptance condition of AD extends the acceptance conditions of the AJAs AD2 with additional / A) sets used to check that the infinite sequence of states (0, visited by the first-level copy of AD (note that these states correspond to the pairs (Ar , A) visited by the simulated ful/ satisfies Properfilling D-sequence over w such that Ar = 0) ties 3 and 4 in def.
of fair fulfilling D-sequence.
4.
Lower Bounds In this section we show that for each h aL 0, satisfiability and pushdown model-checking of C-CaReth for both finite and infinite runs are (h + 1)-E XPTIME-hard (also for future C-CaReth ) by a reduction from the word problem for exp[h]aspace bounded alternating Turing Machines.
It is well-known [9] that the class of all languages accepted by these machines coincides with (h + 1)-E XPTIME.
Formally, an alternating Turing Machine is a tuple M = A, Q, Qa , Qa , q0 , I', F, where A is the input alphabet, Q = Qa aSQa is the finite set of states, q0 is the initial state, F a Q is the set of accepting states, and I' : Q A A a (Q A A A {a , a}) A (Q A A A {a, a}) is the transition function.
Configurations of M are words in Aa AV (Q A A) AV Aa .
A configuration C = Ia AV (q, a) AV Ia denotes that the tape content is Ia AV a AV Ia , the current state is q, and the reading head is at position |Ia| + 1.
For the configuration C, we denote by succl (C) and succr (C) the successors of C obtained by choosing respectively the left and the right triple in I'(q, a).
C is accepting if the associated state q belongs to F. Given an input Ia a Aa , a (finite) computation tree of M over Ia is a finite tree in which each node is labelled by a configuration.
The root of the tree corresponds to the initial configuration associated with Ia.
An internal node that corresponds to a universal configuration (i.e., the associated state is in Qa ) has two successors, corresponding to succl (C) and succr (C), while an internal node that corresponds to an existential configuration (i.e., the associated state is in Qa ) has a single successor, corresponding to either succl (C) or succr (C).
The tree is accepting if every leaf is labelled by an accepting configuration.
An input Ia a ILa is accepted by M if there is an accepting computation tree of M over Ia.
Fix n aL 1, a finite alphabet IL aS {0, 1}, and a countable set {$1 , $2 , .
.
.}
of symbols non in IL aS {0, 1}.
First, for each h aL 1, we define by induction on h an encoding of the integers in [0, Tower(n, h) a 1] by words, called (h, n)-codes, over {$1 , .
.
.
, $h , 0, 1} of the form $h w$h , where w does not contain occurrences of $h .
For a pushdown system M and C-CaRet formula D, checking whether L (M) aS ILa a L (D) aS ILa (resp., L (M) aS ILD a L (D)aSILD ) reduces to check emptiness of L (M)aS L (PAZD )aS ILa (resp., L (M) aS LD (AAZD )), where PAZD (rep., AAZD ) is the NVPA (resp., the AJA) of Theorem 3 (resp., Theorem 4) associated with AZD.
By [3] (resp., [6]) this can be done in time polynomial in the size of M and polynomial (resp., singly exponential) in the size of PAZD (rep., AAZD ).
Since nonemptiness of NVPA (resp., AJA) is in in P TIME (resp., E XPTIME), by Theorems 3a4 we obtain the following.
Base Step: h = 1.
A (1, n)-block over IL is a finite word w over {$1 , 0, 1} aS IL having the form w = $1 Db1 .
.
.
bn $1 , where D a IL aS {0, 1} and b1 , .
.
.
, bn a {0, 1}.
The blockcontent CON(w) of w is D, and the block-number NUM(w) of w is the natural number in [0, Tower(n, 1) a 1] (recall that Tower(n, 1) = 2n ) whose binary code is b1 .
.
.
bn .1 An (1, n)code is a (1, n)-block w such that CON(w) a {0, 1} Induction Step: let h aL 1.
A (h + 1, n)-block over IL is a finite word w on the alphabet {$1 , .
.
.
, $h+1 , 0, 1} aS IL of the form w = $h+1 D$h w1 $h w2 $h .
.
.
$h wK $h $h+1 , where D a {0, 1} aS IL, K = Tower(n, h) and for each 1 a$?
i a$?
K, $h wi $h is a (h, n)-code such that NUM($h wi $h ) =  Theorem 5.
For each h aL 1, satisfiability and pushdown model-checking of C-CaReth for finite (resp., infinite) words are in (h + 1)-E XPTIME (resp., (h + 2)-E XPTIME).
1 we  29  assume that b1 is the least significant bit  i a 1.
The block-content CON(w) of w is the symbol D, and the block-number NUM(w) of w is the natural number in [0, Tower(n, h + 1) a 1] whose binary code is CON($h w1 $h ) .
.
.
CON($h wK $h ).
A (h + 1, n)-code is a (h + 1, n)-block w such that CON(w) a {0, 1}.
For each h aL 1, a (h, n)-configuration over IL is a finite word w of the form w = $h+1 $h w1 $h w2 $h .
.
.
$h wK $h $h+1 , where K = Tower(n, h) and for each 1 a$?
i a$?
K, $h wi $h is a (h, n)-block such that NUM($h wi $h ) = i a 1 and CON($h wi $h ) a IL.
As we will see, (h, n)-configurations are used to encode the configurations reachable by exp[h]-space bounded alternating Turing machines on input of size n. We will use the following result, whose proof is given in [8].
For a word w, let wa1 be the reverse of w.  over ILP given by (b, w(0))(b, w(1)) .
.
..
In the following for a LTL + C formula D over IL , [D]c (resp., [D]r ) denotes the LTL + C formula over ILP obtained by replacing each occurrence of an action D a IL in D with (c, D) (resp., (r, D)).
Now, we describe the encoding of (finite) computation trees of M over Ia.
The code of a TM configuration C = u1 .
.
.
uTower(n,h) is the (n, h)-configuration over IL given by $h+1 $h w1 $h .
.
.
$h wTower(n,h) $h $h+1 , where for each 1 a$?
i a$?
Tower(n, h), CON($h wi $h ) = ui .
The code of a computation tree T of M over Ia is the infinite string over ILP given by wPT (null)D , where wPT is a well-matched word defined as follows.
The tree T is traversed in depth-first order as follows: for each node x, we first visit the subtree associated with the left child (if any), and successively, the subtree associated with the right child (if any).
Note that each internal node x is visited exactly twice: the first time is when we enter the node x coming from its parent node (in case x is the root, then x is the first node to be examined), and the second time is when we reach x from its right child if it exists, and from its left child otherwise.
Moreover, we assume that also each leaf is visited twice.
When a node x with TM configuration C is visited for the first time, we write the subword (c, d AV wC AV w ) (consisting of calls), where wC is the code of C, w = end if x is a leaf-node, and w is empty otherwise, d = al if x is the root, and d is defined as follows otherwise, where C is the configuration of the parent node of x and b a {l, r}: d = ab if C = succb (C ) and C is existential, and d = ab if C = succb (C ) and C is universal.
Finally, when we visit the node x for the last time, then we write the subword (r, (d AV wC AV w )a1 ) (consisting of returns).
Note that our encoding ensures that any subword (c, wC ) of wT , which encodes the first visit of a non-leaf node xC with TM configuration C, is followed by a subword (c, wl ) which corresponds to the left child of xC in T if C is an universal configuration, and the unique child of xC in T otherwise.
Also, if C is an universal configuration, then the subword (r, wa1 R ) of w corresponding to the last visit of the right child xR of xC in T is followed by the subword (r, wCa1 ) corresponding to the last visit of xC .
=,R Thus, by using the formulas LTL + C formulas D= h , Dh , con f Dh of Proposition 1, whose chop nesting depth is h a 1, it is easy to construct a future C-CaReth formula of polynomial size which is (initially) satisfied by a word w over ILP iff w is the code of an accepting computation tree of M over Ia.
Essentially, DM ,Ia uses a CaRet formula (without chop) to check that a computation tree T is traversed correctly, con f the formula [Dh ]c to check that each TM configuration r in T is encoded correctly, and the formulas [D=,R h ] and = c [Dh ] to check that T is faithful to the evolution of M .
Details of the construction are given in [8].
Pushdown modelchecking against future C-CaReth is also (h + 1)-E XPTIMEhard since satisfiability is linearly reducible to pushdown model-checking by using a NVPA over IL with a unique con-  Proposition 1.
For each h aL 1, we can construct three LTL con f =,R + C formulas Dh , D= over {$1 , .
.
.
, $h+1 , 0, 1} aS h , Dh con f 3 IL of sizes O(n AV h AV |IL|) such that dC (Dh ) = dC (D= h)= ) = h a 1 and for each word w and 0 a$?
i < |w|, dC (D=,R h con f  aV (w, i) |= Dh iff wi has a prefix that is a (h, n)configuration over IL; aV if wi is finite and has the form w1 w w2 (resp., (w1 )a1 w (w2 )a1 ) such that w1 and w2 are (h, n)-blocks =,R over IL, then (w, i) |= D= h (resp., (w, i) |= Dh ) iff NUM(w1 ) = NUM(w2 ).
Now, we can prove the desired result.
Theorem 6.
For each h aL 0, the satisfiability and pushdown model-checking problems of future C-CaReth for both finite and infinite runs are (h + 1)-E XPTIME-hard.
Proof.
We assume that h aL 1, since for h = 0, the result is well known [2, 3].
Moreover, we only examine the case of infinite words (the other case being similar).
First, we consider the satisfiability problem.
Let M = A, Q, Qa , Qa , q0 , I', F be an exp[h]aspace bounded alternating Turing Machine (TM), and let c aL 1 be a constant such that for each Ia a Aa , the space needed by M on input Ia is bounded by Tower(|Ia|c , h).
For Ia a Aa , we construct a future C-CaReth formula DM ,Ia over a pushdown alphabet ILP of size polynomial in n = |Ia|c and in the size of M , such that M accepts Ia iff DM ,Ia is satisfiable.
Note that any reachable configuration of M over Ia can be seen as a word Ia1 AV (q, a) AV Ia2 in Aa AV (Q A A) AV Aa of length Tower(n, h).
If Ia = a1 .
.
.
ar (where r = |Ia|), then the initial configuration is the word of length Tower(n, h) given by (q0 , a1 )a2 .
.
.
ar ## .
.
.
#, where # is the blank symbol.
Let IL = A aS (Q A A) and IL = IL aS {0, 1, $1, .
.
.
, $h+1 } aS {al , ar , al , ar , end}.
The pushdown alphabet ILP is given by ILP = {c, r} A IL aS{null}, where null is a return and {c} A IL (resp., {r} A IL ) is a set of calls (resp., returns).
Given a word w over IL and b a {c, r}, we denote by (b, w) the word  30  trol state and accepting the language ILD aS ILa .
[6] L. Bozzelli.
Alternating automata and a temporal fixpoint calculus for visibly pushdown languages.
In Proc.
18th CONCUR, LNCS 4703, pages 476a491.
Springer, 2007.
[7] L. Bozzelli.
Caret with forgettable past.
In Proc.
5th Workshop on Methods for Modalities, ENTCS.
Elsevier, 2008.
[8] L. Bozzelli.
The Complexity of CARET + Chop.
Technical report - http://dscpi.uninsubria.it/ staff/Bozzelli, 2008.
[9] A. Chandra, D. Kozen, and L. Stockmeyer.
Alternation.
Journal of the ACM, 28(1):114a133, 1981.
[10] H. Chen and D. Wagner.
Mops: an infrastructure for examining security properties of software.
In Proc.
9th CCS, pages 235a244.
ACM, 2002.
[11] J. Esparza, A. Kucera, and S. Schwoon.
Model checking LTL with regular valuations for pushdown systems.
Information and Computation, 186(2):355a376, 2003.
[12] D. Harel, D. Kozen, and R. Parikh.
Process logic: Expressiveness, decidability, completeness.
In Proc.
21st FOCS, pages 129a142, 1980.
[13] F. Laroussinie, N. Markey, and P. Schnoebelen.
Temporal logic with forgettable past.
In Proc.
17th LICS, pages 383a 392.
IEEE Comp.
Soc.
Press, 2002.
[14] F. Laroussinie and P. Schnoebelen.
A hierarchy of temporal logics with past.
Theoretical Computer Science, 148(2):303a324, 1995.
[15] N. Markey and P. Schnoebelen.
Model checking a path.
In Proc.
14th CONCUR, LNCS 2761, pages 251a265.
Springer-Verlag, 2003.
[16] A. Pnueli.
The temporal logic of programs.
In Proc.
18th FOCS, pages 46a57, 1977.
[17] R. Rosner and A. Pnueli.
A choppy logic.
In Proc.
1st LICS, pages 306a313.
IEEE Comp.
Soc.
Press, 1986.
5.
Conclusions In this paper, we have studied the complexity of satisfiability and pushdown model-checking of the non-regular linear temporal logic C-CaRet.
In particular, we have shown that for the class of formulas with chop nesting depth at most h, the problems are (h + 1)-E XPTIME-complete for the case of finite words, and are in (h + 2)-E XPTIME and (h + 1)-E XPTIME-hard for the case of infinite words.
The different upper bounds for the finite and infinite cases are due to the different classes of automata (with the same expressiveness) which have been exploited, namely BuEchi NVPA for finite words, and BuEchi AJA for infinite words.
For both cases, the obtained automaton has size of exponential height equal to the chop nesting depth (of the given formula) plus one.
However, while non-emptiness of NVPA is in P TIME, non-emptiness of AJA is in general E XPTIMEcomplete.
The need to use AJA instead of NVPA for the case of infinite words was due to our difficulty in capturing aparallela liveness requirements by using only nondeterminism.
In other terms, alternation seems necessary to capture in a clean way the semantics of C-CaRet for the case of infinite words.
However, we conjecture that non-emptiness for the subclass of AJA associated with C-CaRet formulas (see Theorem 4) is in P TIME (in particular, we conjecture that such AJA can be translated into equivalent NVPA with only a polynomial time blowup).
The main reason is that in each (minimal) accepting run of the AJA associated with a given formula D, there is exactly one infinite path (the amain patha) whose nodes are labeled by atoms of D, while each other infinite path satisfies the following: the suffix starting from the first node that is not on the main path only visits nodes labeled by atoms of subformulas of D whose chop nesting depth is strictly less than that of D.  References [1] R. Alur, M. Arenas, P. Barcelo, K. Etessami, N. Immerman, and L. Libkin.
First-order and temporal logics for nested words.
In Proc.
22nd LICS, pages 151a160.
IEEE Comp.
Soc.
Press, 2007.
[2] R. Alur, K. Etessami, and P. Madhusudan.
A Temporal Logic of Nested Calls and Returns.
In Proc.
10th TACAS, LNCS 2988, pages 467a481.
Springer, 2004.
[3] R. Alur and P. Madhusudan.
Visibly pushdown languages.
In Proc.
36th STOC, pages 202a211.
ACM, 2004.
[4] T. Ball and S. Rajamani.
Bebop: a symbolic model checker for boolean programs.
In 7th SPIN Workshop, LNCS 1885, pages 113a130.
Springer, 2000.
[5] A. Bouajjani, J. Esparza, and O. Maler.
Reachability Analysis of Pushdown Automata: Application to ModelChecking.
In Proc.
8th CONCUR, LNCS 1243, pages 135a 150.
Springer, 1997.
31