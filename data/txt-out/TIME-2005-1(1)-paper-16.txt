University of Westminster Eprints WestminsterResearch http://eprints.wmin.ac.uk http://www.wmin.ac.uk/westminsterresearch Search strategies for resolution in CTL-type logics: extension and complexity.
Artie Basukoski Alexander Bolotov Harrow School of Computer Science  Copyright (c) [2005] IEEE.
Reprinted from 12th International Symposium on Temporal Representation and Reasoning, 2005: TIME 2005, pp.
195-197.
This material is posted here with permission of the IEEE.
Such permission of the IEEE does not in any way imply IEEE endorsement of any of the University of Westminster's products or services.
Internal or personal use of this material is permitted.
However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution must be obtained from the IEEE by writing to pubs-permissions@ieee.org.
By choosing to view this document, you agree to all provisions of the copyright laws protecting it.
The WestminsterResearch Eprints service at theonline University Westminster aims to of make the research digitalof archive at the University Westminster output the University available to the a wider audience.
Copyright andaudience.
Moral Rights aims toofmake the research output of University available to a wider remain with theMoral authors and/or copyright owners.
Copyright and Rights remain with the authors and/or copyright owners.
Users are are permitted permitted totodownload downloadand/or and/orprint print one copy non-commercial private one copy for for non-commercial private study or or research.
research.
Further Further distribution and any use of material from within this distribution and any use of material from within this archive for profit-making enterprises or for commercial gain is strictly forbidden.
Whilst further within thisthis archive is forbidden, further distribution distributionofofspecific specificmaterials materialsfrom from within archive is forbidden, you may distribute the URL WestminsterResearch.
mayfreely freely distribute the of URL of the University of Westminster Eprints (http://www.wmin.ac.uk/westminsterresearch).
(http://eprints.wmin.ac.uk).
In case of abuse or copyright appearing without permission e-mail wattsn@wmin.ac.uk.
Search Strategies for Resolution in CTL-type Logics: Extension and Complexity.
Artie Basukoski and Alexander Bolotov Harrow School of Computer Science, University of Westminster, HA1 3TP, UK {A.Bolotov,A.Basukoski}@wmin.ac.uk Abstract A clausal resolution approach originally developed for the branching logic CTL has recently been extended to the logics ECTL and ECTL+ .
In the application of the resolution rules searching for a loop is essential.
In this paper we define a Depth-First technique to complement the existing Breadth-First Search and provide the complexity analysis of the developed methods.
Additionally, it contains a correction in our previous presentation of loops.
1.
Introduction In [1, 7] a clausal resolution method was developed for the basic logic CTL with the two main stages of the method, translation to the normal form, called Separated Normal Form for CTL, SNFCTL , and resolution rules.
It has been shown that SNFCTL can serve as a normal form for more expressive logics, ECTL ([2, 3]) and ECTL+ ([5]), and the corresponding procedures for translating ECTL and ECTL+ formulae into SNFCTL were defined.
This enables us to apply the resolution method defined over a set of SNFCTL clauses as a verification procedure for specifications written in languages of these CTL-type branchingtime logics.
The core procedure for the application of the resolution method is the discovery of loops.
Formally loops are defined as follows: A loop in l is a set of Definition 1 (Loop in SNFCTL ) merged clauses (possibly labelled) of the form B0 = P0 gC0ind0  , .
.
.
, Bn = Pn gCnindn  where P is any of path quantifiers and the following conn  ditions hold |= Ci = l and |= Ci = Bj , for all 0 <= i <= n.  j=0  We will abbreviate a loop introduced in Definintion 1 by (B0 [?]
.
.
.
[?]
Bn ) = P gP lind , where (i) if for all i, (0 <= i <= n), Pi is the 'A' path quantifier then P = A, fiind is empty, and we have an A-loop in l,  (ii) if for all i (0 <= i <= n), Pi there is only one 'E' quantifier or every Pi is the 'E' quantifier with the same label fiindi  then fiind = fiLC(indi ) and we have an E-loop in l on the path fiLC(indi ), otherwise (iii) we have indicated a hidden E-loop in l on an infinite path, fiind, combined from fiind1  .
.
.
fiindn .
1  2  Depth First Loop search algorithms  We define a self loop in l as a loop of the form Bi = P g(l [?]
Bi ) for some i.
A partial loop is given as Bi = P g(l [?]
(Bi [?]
Y1 [?]
.
.
.
[?]
Yn )), for some n, and for each Yi (0 <= i <= n), Yi is a conjunction of literals.
A partial loop becomes a loop once we have established that each Yi is also part of a loop in l. Finally, a leading loop in l is a sequence of m clauses of the form Bi = P g(Bi+1 [?]
l)<inds > for 0 <= i < m, and for m, Bm = P gP l. The depth first search method we propose is an adaptation of the analogous method for PLTL by Dixon in [8].
As with the PLTL algorithm we construct a search graph in which edges represent SNFm clauses [6] and the nodes represent the left hand side of these clauses.
However the set of SNFm clauses that are applicable is dependent on whether we are searching an A-loop or an E-loop.
Nodes are added to the graph depth first if they satisfy the expansion criteria for either backward or forward search in order to find a subgraph where one of the nodes recurs.
Backtracking is used if a particular path leads to a "dead-end".
The rules governing expansion guarantee that the desired looping occurs.
Graphs in the algorithm are represented as nested lists 1 Note that while working on this paper we have found a technical problem in our past presentations of the resolution method for CTL-type logics.
Previously [5] we gave the wrong impression that a path on which a hidden loop has been found is a limit closure of some ind while now we note that it is a limit closure of a combination of existing indices ind1  .
.
.
indn .
However, the only way in which a hidden loop in l can be used in the resolution method is in combination with the A!l clause, i.e.
with the TRES 3 rule.
However, the resolvent of TRES 3 is itself an A W clause and, therefore, has no associated indices.
This allows us to avoid unnecessary complication of the language of indices, formally preserving our old notation.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  in which successive entries represent the next node in the graph and where each additional nesting of a level indicates branching, e,g.
[n0 , n1 , [n2 , n0 ], [n4 ]] represents the two paths [n0 , n1 , n2 , n0 ] (which is a loop) and [n0 , n1 , n4 ].
As each entry in this graph is guaranteed to also imply l in the next moment of time (by the expansion rules), this example represents a partial loop in l. It becomes loop in l if we successfully expand to another loop in l from n4 Depth-First E-Search algorithm.
Let R be a set of SNFCTL clauses.2 1.
Search for all clauses of the form Bk = A gl, or Bk = E gl<ind > , for k = 0 .
.
.
b, disjoin the left n  hand sides, set toExpand = {B1 .
.
.
Bk }.
If for any B we find !B then terminate returning {true}.
Otherwise use sets of literals in toExpand as the start nodes.
2.
Set the current node n0 to the next element in toExpand if one is available, and path = [(n0 )].
If no such node is available terminate - no new loops are found.
Now, perform a backward search from n0 (step 3) and mark this point as a continuation point for a possible forced forward search.
When we return from the continuation - if we have not yet found a loop with n0 as a disjunct we force a forward search on n0 (to step 6).
Otherwise goto step 7.
3.
Perform a backward search from n0 until either (a) no loop was detected from any of the successors to n0 - goto continuation from step 2.
(b) a self-contained loop was found - goto continuation from step 2.
(c) a partial-loop was found, i.e.
we have used a clause that has two or more disjuncts on its right hand side - remove any nodes that do not form part of the partial loop (the prefix to the loop), store the disjunct list obtained from this clause after removing the disjunct already used in the partial loop and continue processing with step 4.
4.
Set n0 , the current node, equal to a new disjunct from the disjunct list if one is available and goto step 5.
Otherwise we have detected a loop and return to the continuation from step 2.
5.
Perform a forward search from n0 until either (a) no loop was detected from any of the successors to n0 , backtrack to where the disjunctive clause was used (step 3, 5 or 6) and continue processing.
(b) a self-contained loop was found - goto step 2 continuation.
(c) a partial loop was found - goto step 4.
6.
Perform a forced forward search on n0 until either 2 In the Depth-First A-Search algorithm which we do not describe here we only consider A clauses.
(a) no loop was detected from the successors to n0 , return to continuation Step 2.
(b) a self contained loop was found - goto step 7.
(c) a partial loop was found - goto step 4.
7.
Remove any nodes from the path that do not form part of the loop, called the prefix to the loop.
Extract the set of nodes from the path constructed (noting indices where appropriate) and add them to loopsF ound variable.
Start the next search from step 2.
Backwards Search Algorithm During the backwards search we seek clauses in SNFm whose right hand side contains a conjunct with l, and also implies the current node.
1.
Given the current node ni , expand the next node ni+1 in the search tree by looking for gclauses or combinations of clauses of the form a=0 ka = g  r r A g( b=0 Cb [?]
l) or a=0 ka = E g( b=0 Cb [?]
l)<inds > , where  Cb = ni .
2.
If such a clause exists g (a) set the current node ni+1 to be a=0 ka and label <inds > if looking for an E loop; (b) if r > 1 structure the search path to represent this and store the disjuncts that have not been matched to the current node in a list for future processing; and (c) goto step 3; otherwise, if no such a clause exists (a) if i > 0 backtrack setting the current node to ni-1 and repeat step 1; or (b) if i = 0 terminate backwards search and return to the main algorithm.
3.
(a) if ni+1<inds > is already in the search path return to the main algorithm - a loop or partial loop was detected on <inds > ; otherwise (b) increment i and continue at step 1.
Forwards Search Algorithm The forward search algorithm is invoked after a partial loop has been detected using Backwards Search but disjuncts remain to be processed.
We also force the forward search for each element in the initial expansion list if the backward search has not returned the most general left hand side for a loop condition for this node.3 The algorithm works by finding clauses in the set SNFm such that the current node implies the left hand side of the next node, and the right hand side of the next node also contains l. Here the g rexpansion criteria g for the [?]
l) or a=0 ka = node  ni are a=0 ka = A g( b=0 Cb r r E g( b=0 Cb [?
]l)<inds > , where ni = b=0 ka .
Otherwise the algorithm follows the basic principles of the Backwards search algorithm.
3 By "most general" loop we mean the current node as a disjunct, e.g.
if searching for a loop starting with node n0 = p and we return a loop p [?]
q = A eA l, then we force forward search on p to see if we can discover a loop condition with p as a disjunct.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE  3  Complexity Analysis  Here the upper bounds on the performance of the algorithms are proposed.
Let |SN F | stand for the number of these clauses, and Let |P rop| stand for the number of literals in SN F .
We will further distinguish the following subsets, |E|, |A| and |El |, |Al |, meaning the number of E and A clauses in SN F respectively, and the subsets of these that also imply gl.
Also let ||Pl || stand for |P | - |Pl |, where P is either of the path quantifiers.
We will follow the convention where T (n) = O(f (n)) is the upper bound on the time it takes the algorithm to find all loops and terminate for the set SN F .
The algorithm begins by extracting all the clauses which imply gl in SN F .
This number is |Al | for the Asearch and |Al |+|El<ind> | (the number of E clauses implying gl along a path labelled by < ind >) for the E-search.
Since each such clause is used as the root of a tree this value is a linear multiplier of the complexity for the depth first tree expansion.
The tree expansion begins with the backwards search.
To conduct a backwards search, from the current node, ni , we create a new node in the search tree for each SN F m clause that fulfills the expansion criteria, i.e.
the RHS of the matching clause implies the current node and also implies gl.
Let |Ak | be the number of clauses which satisfy these criteria.
Hence, the maximum branching factor is 2|A| -2||Al || , with an average branching factor of 2|Ak | for some k <= |Al |.
We now look at the depth of the search tree.
Consider the base case, that of a self loop, ni = g(ni [?]
l) which is the shortest loop possible.
If all the loops are of this kind then the maximum depth of the search tree is 0.
Hence to increase the depth of the search tree requires a chain of the form ni = g(ni+1 [?]
l) = g(ni+2 [?]
l) .
.
.
for unique n [?]
P rop.
The maximum such chain possible is |P rop|, hence, the maximum depth of the search tree is |P rop|, and we have an upper bound for our algorithm of O((2|A| - 2||Al || )|P rop| ).
A similar measure is obtained for a E search where we need to consider all the E clauses with the same index in addition to the A clauses.
So, instead of |A| we need to consider |A| + |E<Ind> |, where |E<Ind> | is the number of clauses with the same label.
The algorithm is very sensitive to the proportion of A and E clauses in the set SN F .
The worst case performance arises when all are A clauses, in which case it reduces to the PLTL complexity given by O(2|SN F |*|P rop| ).
The best case performance arises when there are no A clauses.
Here the determining factor becomes the number of clauses with the same label.
In this case |A|+|E<Ind> | becomes (0 + |E<Ind> |) and the complexity is O((2|E<Ind> | - 2||E<Ind>l || )|P rop| ), where if there is only one clause for each index then the complexity is |El | * (21 - 20 )|P rop| which is linear in the number of clauses that imply gl.
4  Conclusions and Future Work  We have extended the Depth-First Loop search algorithm originally developed for PLTL to branching time logic and presented complexity results.
We have also highlighted the cases where the algorithm performs better than the PLTL resolution in cases where a choice between the two methods is appropriate.
This algorithm significantly enhances our ability to incorporate different resolution strategies for the clausal resolution method developed for a number of branching time logics (CTL, ECTL and ECTL+).
These insights will be useful in developing guided searches in order to improve the performance of the clausal resolution method with a view towards implementation in the near future.
In our previous work [4] we have shown that the complexity of the transformation procedure ECTL+ -- SNFCTL is polynomial in the length of the input ECTL+ formula.
This result combined with the complexity of the loop searching method brings us one step further to establishing the overall complexity of the resolution technique for ECTL+ .
References [1] A. Bolotov.
Clausal Resolution for Branching-Time Temporal Logic.
PhD thesis, Department of Computing and Mathematics, The Manchester Metropolitan University, 2000.
[2] A. Bolotov.
Clausal resolution for extended computation tree logic ECTL.
In Proceedings of the Time-2003/International Conference on Temporal Logic 2003, pages 107-117, Cairns, July 2003.
IEEE.
[3] A. Bolotov and A. Basukoski.
Clausal resolution for extended computation tree logic ECTL.
To be published in the Journal of Applied Logic.
Extended version of [2].
[4] A. Bolotov and A. Basukoski.
Clausal resolution for extended computation tree logic ECTL+ .
Extended version of [5], submitted for a journal piblication.
[5] A. Bolotov and A. Basukoski.
Clausal resolution for extended computation tree logic ECTL+ .
In Proceedings of the Time2004, pages 140-147.
IEEE, July 2004.
[6] A. Bolotov and C. Dixon.
Resolution for Branching Time Temporal Logics: Applying the Temporal Resolution Rule.
In Proceedings of the 7th International Conference on Temporal Representation and Reasoning (TIME2000), pages 163-172, Cape Breton, Nova Scotia, Canada, 2000.
IEEE Computer Society.
[7] A. Bolotov and M. Fisher.
A Clausal Resolution Method for CTL Branching Time Temporal Logic.
In Proceedings of the 7th International Conference on Temporal Representation and Reasoning (TIME97), pages 20-27.
IEEE Computer Society, 1997.
[8] C. Dixon.
Temporal resolution using a breadth-first search algorithm.
Annals of Mathematics and Artificial Intelligence, 22:87-115, 1998.
Proceedings of the 12th International Symposium on Temporal Representation and Reasoning (TIME'05) 1530-1311/05 $20.00 (c) 2005 IEEE