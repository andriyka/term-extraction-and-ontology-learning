Information and Computation 205 (2007) 25-64 www.elsevier.com/locate/ic  Axiomatisation and decidability of multi-dimensional Duration Calculus Andreas Schafer Department of Computing Science, University of Oldenburg, 26111 Oldenburg, Germany Received 1 December 2005; revised 15 July 2006 Available online 23 October 2006 Communicated by Jan Chomicki and David Toman  Abstract The Shape Calculus is a spatio-temporal logic based on an n-dimensional Duration Calculus tailored for the specification and verification of mobile real-time systems.
After showing non-axiomatisability, we give a complete embedding in n-dimensional interval temporal logic and present two different decidable subsets, which are important for tool support and practical use.
(c) 2006 Elsevier Inc. All rights reserved.
Keywords: Real-time systems; Mobile systems; Spatial logic; Temporal logic; Duration Calculus  1.
Introduction 1.1.
Motivation Mobile real-time systems are omnipresent today, e.g., in airplane and railroad control systems.
Failures in these systems may have severe consequences which can even endanger lives.
Formal specification and automatic verification are promising approaches to increase the safety of such systems.
However, for these systems real-time aspects as well as spatial aspects are important.
E-mail address: schaefer@informatik.uni-oldenburg.de 0890-5401/$ - see front matter (c) 2006 Elsevier Inc. All rights reserved.
doi:10.1016/j.ic.2006.08.005  26  A. Schafer / Information and Computation 205 (2007) 25-64  Thus, commonly used formalisms that concentrate on either timing or spatial behaviour fall short in these cases because they need to abstract from important issues.
A pivotal task in the UniForM [32] project in cooperation with the industrial partner Elpro was the development of a control for a single-tracked line segment (SLS) for tramways.
The problem is to ensure the safety of trams if only one track is available and this track is passed in both directions and occupied by up to two trams simultaneously as long as they head into the same direction.
A controller has been derived, simulated, and partially verified using techniques for real-time systems, namely PLC-Automata [19].
However, the main safety requirement, i.e., mutual exclusion of trams with opposite directions on the critical section, is a spatio-temporal property and cannot be expressed in purely time-dependent models like PLC Automata [18].
Similar problems arise in the specifications of mobile robots [42].
Each robot itself constitutes a real-time system, whereas the specification of the overall system behaviour has additional spatial requirements, for example collision avoidance.
1.2.
Research contributions The shortcomings described above led us to the idea to extend the Duration Calculus, a wellknown formalism for real-time systems, with proven applicability [28], to be able to describe also spatial properties.
The use of the formalism is similar to the use of the original Duration Calculus when no spatial reasoning is required.
Thus, experienced users of temporal logics can easily adopt the new features.
We present the Shape Calculus1 (SC), a spatio-temporal logic based on the Duration Calculus, extending  the results in [42] and [43].
Shape Calculus is interval based and possesses an integral operator for measuring time as well as space.
We elaborate that this formalism is well suited for the application domain of mobile real-time systems.
We present four major results for this formalism.
First, we prove that the full logic is undecidable and non axiomatisable, even for discrete infinite models of time and space.
To this end, we present a reduction of its validity problem to the emptiness problem of tiling languages.
The full real-time logic Duration Calculus is known to be non-axiomatisable for continuous temporal domains, but still decidable for a subset in the discrete setting which shows to be undecidable in the multi-dimensional case.
This relates to the undecidability of multi-dimensional products of decidable modal logics as discussed in [24].
Second, we present an ax iomatisation of Shape Calculus relatively to an n-dimensional interval logic without the operator, a result similar to the one for continuous time Duration Calculus.
In practice, acceptance of formal methods is increased dramatically by tool support.
Hence, we discuss decidable subsets of the Shape Calculus.
Our third contribution is a decidable subset of Shape Calculus based on results for discrete Duration Calculus.
There the subset assumes a discrete and infinite temporal domain but finite spatial domains.
The decision procedure reduces validity to emptiness of regular languages.
This subset has already led to a prototypical implementation of a model checker [38].
Forth, we elaborate a decidable subset of discrete Shape Calculus using ideas from logic combination [24] and relating a syntactical subset of Shape Calculus without chop alternation to fusions of Duration Calculus.
This approach proceeds by reducing validity to iteratively checking emptiness of regular languages.
1 The name Shape Calculus was proposed by A. Ravn during a presentation of early ideas.
A. Schafer / Information and Computation 205 (2007) 25-64  27  Technical context.
We review the technical context of our contribution.
1.3.
Real-time systems Concerning real-time aspects, the operational model of Timed Automata [2] is the most popular and widespread.
Due to its decidable emptiness problem, it allows for the automatic verification of real-time properties.
Thus, it enables the development of tools like Uppaal [4,5] and Kronos [8], which contributed much to the applicability of Times Automata as shown in several case studies [29,33].
The temporal logics Duration Calculus (DC) [12,28], TCTL [30], and TPTL [3] provide the possibility to specify and reason about real-time behaviour.
The tool DCValid [36] is able to verify a restricted subset of Duration Calculus using the second order model checker MONA [31] as backend.
A detailed discussion on decidability for subsets of Duration Calculus is given in [22].
However, neither the automata theoretic nor the logical formalism do provide support for specifying and verifying spatial properties.
Except for our approach, other extensions of Duration Calculus consider hybrid aspects [13] and superdense time [37].
1.4.
Process calculi For modelling mobility of concurrent processes, the  calculus was introduced by R. Milner [35].
However, it considers a notion of mobility different from the Shape Calculus.
In the  calculus mobility stems from the change of links between processes.
A spatial logic for the  calculus is proposed in [9].
This logic integrates support for reasoning about the behaviour and the structure of systems of concurrent  calculus systems.
A model checker for a subset of this logic is implemented in [44].
Inspired by the  calculus, the Ambient Calculus [10] considers processes that are executed in hierarchically nested environments (called ambients) and that may be transfered from one ambient to another.
For grasping the structure of the nested ambients and the process behaviour, in [34] a spatial logic for the Ambient Calculus based on TLA is proposed.
Similarly to [9], the ambient logic based on modal logic is introduced in [11].
The model checking problem of the full logic against ambient calculus processes is undecidable and for finite processes (without replication) still PSPACE hard [16,15,14].
A compositional approach is proposed in [21].
It investigates the combination of logics via fusion and product.
The notion of location and space is covered by a hybrid logic using nominals [7] whereas the temporal properties are expressed in a temporal logic.
The combined logic is used to describe the overall system behaviour.
However, all these approaches do not facilitate quantitative measuring, neither of time nor of space.
Thus, it is impossible to express, for example, an upper bound on the reaction time or a minimal distance of two robots that needs to be kept.
1.5.
Spatial and spatio-temporal logics The Region Connection Calculus (RCC) [39] constitutes a spatial logic having regions as basic entities.
Thereby, it permits qualitative reasoning about relations, e.g., the part-of-relation or  28  A. Schafer / Information and Computation 205 (2007) 25-64  tangentiality.
Its main area of application is AI.
As there is no notion of time in RCC, it has been extended in [25] to a spatio-temporal formalism for describing mobility qualitatively.
Spatio-temporal logics based on modal logics are proposed in [6,1,40] and different techniques of combining modal logics--namely fusion and product--is extensively investigated in [23,24].
The logical and mathematical background developed therein can be used to create various spatio-temporal logics.
However, none of these logics proposed allows for quantitative spatial and temporal measures as needed for our intended application domain of physically mobile real-time systems.
Yet, the second decidable subset we present in this paper is gained by treating our formalism as a fusion of instances of Duration Calculus.
1.6.
Organisation of the paper After giving a short introduction to SC in Section 2, we show in Section 3 that SC is not axiomatisable, but nevertheless it can be completely axiomatised relatively to the n-dimensional extension of interval temporal logic, which is presented in Section 4.
In Section 5 we present two decidable subsets of discrete SC: one obtained by imposing restrictions on the class of models, another one by imposing restrictions on the class of formulae.
2.
Shape Calculus In this section, we introduce the Shape Calculus originally proposed in [42].
Here we make use of a simplified version.
In Duration Calculus [12], the behaviour of a system is modelled by a set of time-dependent variables (observables) whose values change over time.
We adopt this approach and use Boolean observables that depend on space and time.
We may choose to have discrete or continuous time and space depending on the current application.
With the number of spatial and temporal dimensions, say n, being fixed a priori, the semantics of an observable X is given by a trajectory I I [[X ]] : [?]
n 0 - {0, 1}  in the continuous case or as a function with domain [?]
n for the discrete case.
In general, we denote the spatio-temporal domain by [?]
.
Example 1.
To model a mobile robot moving on the floor, we need two spatial and one temporal dimension, so we fix n = 3.
We employ two observables R and A.
The observable R is true for a point in space and time if and only if the robot occupies this point in space at the given moment in time.
Similarly, the bounded safe area is modelled by the observable A.
As we will measure time and space, we have to guarantee that an integral exists and therefore require Riemann-integrability of all functions.
The language of SC is built from state expressions, terms, and formulae.
A state expression characterises properties of one point in time and space.
They are denoted by  and built from Boolean combinations of observables.
The semantics is given by a function I [[]] : [?]
n 0 - {0, 1} defined as a straightforward extension of trajectories of observables.
A. Schafer / Information and Computation 205 (2007) 25-64  29  df  I [[!]](z ) = 1 - I [[]](z ) df  I [[ [?]
fi ]](z ) = I [[]](z ) * I [[fi ]](z )  State expressions are formulae of propositional logic.
Like in propositional logic, we therefore define two state expressions  and fi to be equivalent, denoted by  [?]
fi , if for all interpretations I the equality I [[]] = I [[fi ]] holds.
Example 2.
The state expression R [?]
!A describes exactly the points in space-time where the robot is outside its restricted area.
The interpretation assigns 1 to all points satisfying the condition and 0 to all others.
 A term  is either a measure , where  is a state expression, a rigid variable x, i.e., a variable that does not change over time, the special symbol ei denoting the diameter of the n-dimensional interval (hypercube) under consideration along the i-th unit vector ei or the application of a function f .
Commonly used functions are summation or multiplication.
  ::=  | x | ei | f(1 , .
.
.
, k ) The value of a rigid variable is a real number or a natural number, depending on the time domain.
It is determined by a valuation V which is a function mapping the variables to the spatio-temporal domain.
The set of valuations is denoted by Val.
The semantics of terms assigns a real number to df  each n-dimensional interval from the set Intn ={[b1 , f1 ] x * * * x [bn , fn ]|bi , fi [?]
[?]
} of all n-dimensional intervals.
Thus, it is a function I [[]] : Intn x Val - [?]
and defined in the expected way, i.e., let M = [b1 , f1 ] x * * * x [bi , fi ] x * * * x [bn , fn ] [?]
Intn  and V [?]
Val then   df    I [[ ]](V , M) =  I [[]] M  df  I [[ei ]](V , M) = fi - bi df  I [[x]](V , M) = V (x) df  I [[f(1 , .
.
.
, k )]](V , M) = fI (I [[1 ]](V , M), .
.
.
, I [[k ]](V , M))   Example 3.
The term (R [?]
!A) is the measure of all points violating the requirement.
Formulae are interpreted over n-dimensional intervals and incorporate a special "chop" operator (  ) to partition the current interval into two parts.
A formula F ex  G is evaluated to true, if the interval can be split along the x-axis into two parts, the first satisfying F and the second satisfying  30  A. Schafer / Information and Computation 205 (2007) 25-64  Fig.
1.
Illustration for F ex  G.  G. This is sketched in Fig.
1.
As we consider a many-dimensional logic, we allow chops along each cartesian axis.
Formally, we define the set of formulae by F ::= F1 ei  F2 | p(1 , .
.
.
, k ) | !F1 | F1 [?]
F2 | [?
]x : F where p is a predicate symbol like = or , x a rigid variable that does not change over time and ei the ith unit vector.
The other Boolean connectives can be defined as the usual abbreviations.
We only give the definition of "chop" here as the other operators and the existential quantifier are defined according to in First-Order Logic.
We employ the following notation for describing the application of the chop operation on intervals.
Definition 4 (Notation).
Let M = [b1 , f1 ] x * * * x [bm , fm ] denote an m-dimensional interval.
We denote the lower bound bi of the ith dimension by mini M and the upper bound ei by maxi M, df respectively.
Furthermore, denote by M [?
]i r =[b1 , f1 ] x * * * x [bi , r] x * * * x [bm , fm ] the first subinterval obtained by chopping the original interval along the ith axis at position r and the second df part by M i r =[b1 , f1 ] x * * * x [r, fi ] x * * * x [bm , fm ].
The "interior" M- of M is defined by M- = [b1 , f1 ) x * * * x [bm , fm ).
Using this notation the semantics of the chop operator is defined as follows.
I [[F1 ei  F2 ]](V , M) = true  iff there is an m [?]
[mini M, maxi M] such that I [[F1 ]](V , M [?
]i m) = true and I [[F2 ]](V , M i m) = true.
A. Schafer / Information and Computation 205 (2007) 25-64  31  The satisfaction relation |= is defined by I , V , M |= F iff I [[F ]](V , M) = true.
We define some abbreviations to make specifications more concise.
The almost everywhere operator  expresses that a state assertion  holds almost everywhere in the interval and the interval is non-empty.
The empty interval is denoted by .
The n-dimensional volume is measured by the term .
df  =    1  df   =(  =  [?]
 > 0)  df   = 1 = 0  The somewhere operator ei F chops the n-dimensional interval twice in the ith direction such that in the middle interval F holds, hence it expresses that F holds on some region along the ith axis.
df  ei F = true ei  F ei  true The dual globally operator is ei defined by df  ei = !ei !F  and expresses that F holds in every region along the ith axis.
Although chop is associative only for chopping in the same direction, e1 e2 F still is equivalent to e2 e1 F .
We will denote the unit vector corresponding to the time dimension by et and to spatial dimensions by ex , ey , etc.
Example 5.
The initial requirement, that at most 10 cm2 of the robot R is ever outside a restricted area defined by A can be expressed by  fi et (R [?]
!A)  (10 * et ) where the unit is omitted.
The formula reads as follows: for every temporal interval the volume of all points of R outside of A is less than 10 multiplied by the temporal length.
The scenario is sketched in Fig.
2a.
The observable R modelling the robot is true for all points between the solid lines, the observable A is true for all points between the dashed lines.
For simplicity we omitted the second spatial dimension in the drawing.
Example 6 (Ensuring a minimal distance).
Consider the scenario of two moving robots using a collision avoidance system as depicted in Fig.
2b.
We require that the minimal distance is always at least than 1 cm.
This is specified by   et ex (ex R1  [?]
ex R2 ) =  et ((ex R1  [?]
!ex R2 ) ex  (!R1 [?]
!R2  [?]
ex  1) ex  fi (ex R2  [?]
!ex R1 ))  32  A. Schafer / Information and Computation 205 (2007) 25-64  a  b  Fig.
2.
(a) Moving robot scenario and (b) Minimal distance scenario.
This formula reads as follows.
For all spatio-temporal subintervals such that Robot R1 and Robot R2 are contained somewhere in this interval, there is a temporal subinterval such that we can split space into three parts such that (1) the lower part contains R1 (2) the middle part neither contains Robot R1 nor R2 and it has length greater than or equal to 1 (3) and the upper part contains R2 .
As indicated in Fig.
2b arbitrarily large temporal intervals do not need to satisfy the Condition (2).
Definition 7 (Validity/satisfiability).
A formula F is valid iff it evaluates to true for all interpretations, valuations and intervals.
It is satisfiable iff there is an interpretation, a valuation and an interval such that F holds.
Note 1.
Duration Calculus and one-dimensional Shape Calculus coincide.
In this sense the extention of Duration Calculus is conservative.
3.
Undecidability and non-axiomatisability In this section, we show that validity for Shape Calculus is undecidable and even not recursively enumerable.
Henceforth, Shape Calculus is not recursively axiomatisable by Craig's Theorem [17].
In [28] it is shown that Duration Calculus is decidable for the discrete time domain and for the formulae restricted to phase expressions *, chop and Boolean operators.
This result does not transfer to Shape Calculus when considering more than one dimension.
Since one-dimensional Shape  A. Schafer / Information and Computation 205 (2007) 25-64  33  Calculus and Duration Calculus coincide, for one-dimensional discrete Shape Calculus and this restricted subset, validity is still decidable.
Theorem 8.
For two dimensions and above, the set of valid SC formulae is not recursively enumerable, neither interpreted in the continuous nor in the discrete domain.
By Craig's Theorem [17] a theory is recursively axiomatisable if and only if the set of valid formulas is recursively enumerable.
Therefore from the above theorem, we obtain the following corollary.
Corollary 9.
There is not a sound and complete proof system for SC .
Extending the undecidability proof in [42], we provide a reduction from a non recursively enumerable tiling problem.
For this proof we restrict ourselves to the class of formulae given by F ::=  | F [?]
G | !F | F e1  G | F e2  G | ei = r for some fixed r. The corresponding subset of Duration Calculus interpreted in discrete or continuous time domain is known to be decidable [28].
Without loss of generality, we choose r = 1.
3.1.
Tiling systems The theory of string languages can be extended to two-dimensional (also called picture) languages.
We shortly review the main definitions and results.
A detailed discussion can be found in [26].
We fix an alphabet fi and a fresh boundary character #.
A two-dimensional string (picture) over fi is a two-dimensional rectangular matrix of elements of fi such that the boundary is marked by the fresh symbol #.
A tile p is a 2 x 2 matrix with elements in fi [?]
# and a tiling system  is a finite set of tiles.
The local language L() for a tiling system  is the set of all n x m matrices such that each 2 x 2 block is in  and the boundaries of the matrix consist only of # and # does not occur in the interior.
Giammarresi and Restivo show in [26] that the emptiness problem Given a tiling system , is L() = [?]
?
is undecidable.
This problem can be reformulated as follows: There is no n x m matrix for n, m [?]
[?]
such that every 2 x 2 submatrix is contained in the set  and the boundaries of the matrix consist of # only and # does not occur in the interior.
They provide a reduction such that a Turing Machine M has no successful computation iff L() is empty.
With this reduction to the termination problem, the emptiness problem for tiling systems is not recursively enumerable.
Both problems are co-recursively enumerable.
3.2.
Encoding tilings in Shape Calculus We provide a reduction of the emptiness problem for tiling systems as described above to the validity problem of Shape Calculus.
For a set of tiles  = {p1 , .
.
.
, pk }, we define a formula F in SC, such that L() = / [?]
iff F is satisfiable which is equivalent to L() = [?]
iff !F is valid.
34  A. Schafer / Information and Computation 205 (2007) 25-64  We present an encoding which does not rely on continuous or discrete time and space domain.
Therefore, to avoid chopping at arbitrary positions, we impose a chess-board marking by a fresh observable fi as a region marker to clearly identify 2 x 2 blocks in the continuous case.
We specify the grid by a formula Fgrid as follows: df  Fgrid = e1  2 [?]
e2  2 [?]
fi == (fi1 == fi2 ) [?]
 e1 ((fi1  e1  e1 = 1 = fi1  e1  !fi1 ) [?]
fi (!fi1  e1  e1 = 1 = !fi1  e1  fi1 ) [?]
e1  1 = (fi1  [?]
e1 = 1 e1  true) [?]
 e2 ((fi2  e2  e2 = 1 = fi2  e2  !fi2 ) [?]
fi (!fi2  e2  e2 = 1 = !fi2  e2  fi2 ) [?]
e2  1 = (fi2  [?]
e2 = 1 e2  true)  (*) (**) (* * *) (**) (* * *)  We use two auxiliary observables fi1 and fi2 .
The observable fi1 is true on intervals [i, i + 1] x [a, b] and false on [i + 1, i + 2] x [a, b] when i is even and a, b are arbitrary.
The same holds for fi2 and intervals [a, b] x [i, i + 1] and [a, b] x [i + 1, i + 2], respectively.
This fact can be easily proven by induction on i.
The quantified subformulae (**) specify that a fii  slice is succeeded by a !fii  slice and vice versa.
The initial condition that the first slice has a size of 1 and satisfies fi1 , respectively fi2 , is specified separately by (* * *).
The chessboard marking by fi is obtained using the equivalence operation on fi1 and fi2 in (*).
This idea is formalised in the following lemma.
Lemma 10.
Let I be an interpretation and k [?]
[?]
, a, b [?]
[?]
.
Then I , [0, k] x [a, b] |= Fgrid if and only if k  2, b - a  2, and for all i [?]
[?]
, i  k and arbitrary [afi , bfi ] [?]
[a, b] the following holds: () I , [i, i + 1] x [afi , bfi ] |= ()  fi     fi  I , [a , b ] x [i, i + 1] |=   ()  I , [i, i + 1] x [j, j + 1] |=  fi1  if i is even, !fi1  otherwise fi2  if i is even, !fi2  otherwise fi if i, j are both even or both odd !fi otherwise.
To describe a 2 x 2 block in this grid satisfying the observables P1 , P2 , P3 , P4 in its four cells starting with P1 in the lower left corner, we use the pattern df  F2x2 (P1 , P2 , P3 , P4 ) = ((fi [?]
P1 ) e1  (!fi [?]
P2 ) e2  (!fi [?]
P3 ) e1  (fi [?]
P4 )) [?]
((!fi [?]
P1 ) e1  (fi [?]
P2 ) e2  (fi [?]
P3 ) e1  (!fi [?]
P4 ))  A. Schafer / Information and Computation 205 (2007) 25-64  35  Fig.
3.
Sample encoding of tilings in a grid structure.
 and assign to every tile pi =  cd ab    df  a formula Fpi = F2x2 (a, b, c, d).
With these sub-formulae we  define F to be df  F = Fgrid    [?
]e1 e2 F2x2 (true, true, true, true) =  k 	    Fpi  (*)  i=1  [?]
# e1  (# e2  !# e2  #) e1  #  [?]
s = !sfi   (**) (* * *)  s,sfi [?
]fi,s=s / fi  The second conjunct (*) states that each 2 x 2 block in the grid must be in , whereas the third conjunct (**) states that the picture must be framed by # and # does not occur in the interior, as sketched in Fig.
3.
The last conjunct ensures mutual exclusion of symbols.
With this definition, F is satisfiable if and only if the local language L() is not empty, so !F is valid if and only if the local language L() is empty.
Proof "only if" Let I be a satisfying interpretation and [0, k1 ] x [0, k2 ] an interval such that I , [0, k1 ] x [0, k2 ] |= F .
Note that by definition of the grid and F a satisfying interval must have integer bounds.
Let (pi,j )i,j be the matrix defined by pi,j = a == I , [i, i + 1] x [j, j + 1] |= a  36  A. Schafer / Information and Computation 205 (2007) 25-64  for a [?]
fi [?]
{#}.
By (* * *) there is at most one observable a [?]
fi [?]
{#} satisfied on [i, i + 1] x [j, j + 1] and by (*) there is at least one observable satisfied.
Therefore (pi,j )i,j is welldefined.
By (*) each interval of size 2 x 2 satisfies some Fpi .
Therefore by construction each 2 x 2 submatrix in (pi,j )i,j is in .
Furthermore, since the boundary satisfies # the matrix boundaries of (pi,j )i,j consists of #.
So, (pi,j )i,j [?]
L().
"if"  Let (pi,j )i,j [?]
L().
Define an interpretation I for the observables a [?]
fi [?]
{#} by  I [[a]](x, y) =  1 if pi,j = a [?]
x [?]
[i, i + 1], y [?]
[j, j + 1], 0 otherwise  and for the auxiliary observables by   1 if there is an even i such that x [?]
[i, i + 1], 0 otherwise  1 if there is an even i such that y [?]
[i, i + 1], I [[fi2 ]](x, y) = 0 otherwise  1 if I [[fi1 ]](x, y) == I [[fi2 ]](x, y), I [[fi]](x, y) = 0 otherwise.
I [[fi1 ]](x, y) =  It is straightforward to see that I , [0, i + 1] x [0, j + 1] |= F .
  We haven proven so far that satisfiability corresponds to non-emptiness of local picture languages for tiling systems.
Therefore validity corresponds to language emptiness, which is known to be undecidable and not recursively enumerable.
By Craig's Theorem [17] this proves: SC is not recursively enumerable and not axiomatisable.
4.
Relative completeness In the previous section, we have demonstrated that Shape Calculus is not axiomatisable.
Despite this negative result, it is still possible to give an axiomatisation relatively to an n-dimensional extension of Interval Temporal Logic (ITLn ).
We assume an inference system for ITLn , i.e, a set of inference rules such that every valid ITLn formula can be derived by finitely many applications of the inference rules.
The inference relation is denoted by ITLn .
Assuming the existence of this inference system for ITLn , we derive a system for the Shape Calculus such that every valid Shape Calculus formula can be derived.
Therefore, this system is called complete relatively to ITLn .
Thereby, we extend the axiomatisation result for the Duration Calculus presented in [27] to the Shape Calculus.
Duration Calculus itself allows an axiomatisation relatively to interval temporal logic (ITL).
For this axiomatisation, we require a stronger finite variability assumption, namely every finite n-dimensional interval can be partitioned into finitely many sub-intervals such that I is constant on each sub-interval.
Considering arbitrary integrable functions  A. Schafer / Information and Computation 205 (2007) 25-64  37  would require an axiomatisation of the integral calculus which is out of scope for this paper.
The axiomatisation result for Duration Calculus presented in [27,28] relies on the same requirement, namely finite variability.
Our proof follows the lines of [27,28] and considers only the two-dimensional case, but it can easily be generalised to more dimensions.
4.1.
Interval temporal logic (ITL) We shortly introduce the n-dimensional ITL.
One-dimensional ITL is discussed in [20,28].
ITLn does not use state assertions nor the integral operator but instead uses flexible variables v whose values depend on the interval.
Furthermore, it incorporates rigid variables x and lengths ei as terms.
n n n  ITL ::= x | v | ei | f 1ITL , .
.
.
, kITL The semantics of flexible variables is given by an interpretation IITLn that assigns a real number to each n-dimensional interval.
This is extended to terms as follows: IITLn [[x]](V , M)  df  IITLn [[v]](V , M)  df  = V (x) = I (v)(M)  df  IITLn [[ei ]](V , M) = fi - bi  n n n df IITLn [[f 1ITL , .
.
.
, kITL ]](V , M) = fIITLn (IITLn [1ITL ]](V , M),    ..., n IITLn [kITL ]](V , M))  Like in Shape Calculus, V is a valuation of the rigid variables, i.e., variables that do not change over time and M = [b1 , f1 ] x * * * x [bn , fn ] is an n-dimensional interval.
Furthermore, we define the df abbreviation  = e1 * e2 to measure the two-dimensional area.
For formulae, ITLn incorporates Boolean combinations, chop and quantification as in SC.
Formally, it is given by the following BNF.
n n n n n n n n F ITL ::= F1ITL ei  F2ITL | p 1ITL , .
.
.
, kITL | !F1ITL | F1ITL [?]
F2ITL | n [?
]x : F ITL The semantics of the Boolean connectives and quantifiers is the same as in first order logic.
The semantics of the chop operator is the same as in Shape Calculus.
4.2.
Axiomatisation We present the main theorem of this section and give a short proof sketch.
To make the presendf tation more concise, we introduce negated unit vectors and define F -ei  G = G ei  F  38  A. Schafer / Information and Computation 205 (2007) 25-64  Theorem 11.
Two-dimensional SC is axiomatised relatively to ITL2 by the following axioms.
 0=0  1=  0     1 + 2 = (1 [?]
2 ) + (1 [?]
2 )     = x ei   = y =  = x + y  (SC1) (SC2) (SC3) (SC4) (SC5)   [?]
(( [?]
! e1  true) e2  true)  [?]
(( [?]
! e1  true) -e2  true)  [?]
(( [?]
! -e1  true) e2  true)  [?]
(( [?]
! -e1  true) -e2  true)  (FV1) (FV2) (FV3) (FV4)  The set of axioms can be separated into two groups.
The first group (SC1) up to (SC5) specify properties of the integral calculus need for piecewise constant functions.
The second group (FV1)-(FV4) specifies finite variability, by demanding that for every point we can find 4 rectangles to the lower left, lower right, upper left and upper right, respectively, such that the value of a state expression is constant.
The proof of relative completeness proceeds as follows.
For a valid SC formula F we have to construct a derivation using the set of axioms defined previously.
To this end, we construct a valid ITLn formula.
As we consider relative completeness, we can assume an ITLn deduction of this formula.
This deduction is lifted to a Shape Calculus deduction of F .
4.3.
From Shape Calculus to ITLn For a given valid Shape Calculus formula F , we first elaborate an encoding of all Shape Calculus axioms that are possibly needed for the proof of F into one ITLn formula.
Encoding the axioms in ITLn .
Let F be an arbitrary valid SC formula and let X1 , .
.
.
, Xl be the set of Boolean observables occurring in F and S the set of all state expressions built from these observables.
Note that, since state expressions are formulae of propositional logic, only finitely many state expressions can be nonequivalent.
Let df  [] ={fi | fi [?]
} denote such an equivalence class and S[?]
= {[]| [?]
S } denote the set of equivalence classes.
For n every equivalence class [] we  introduce an ITL flexible variable v[] with the intuition thatn v[] models the the value of .
We encode the SC Axioms by the following finite sets of ITL formulae.
df  H1 ={v[0] = 0} df  H2 ={v[1] = }  A. Schafer / Information and Computation 205 (2007) 25-64  39  df  H3 ={v[]  0 | [] [?]
S[?]
} df  H4 ={(v[1 ] + v[2 ] ) = (v[1 [?
]2 ] + v[1 [?
]2 ] ) | [1 ], [2 ] [?]
S[?]
} df  H5 ={(v[] = x ei  v[] = y) = (v[] = x + y) | [] [?]
S[?]
} df  H6 ={ [?]
((v[]  [?]
v[!]  d1  true) d2  true) | [] [?]
S[?]
, di [?]
{ei , -ei }}  df  df  where v[]  =(v[] =  [?]
 > 0) and  =(1 = 0 [?]
2 = 0).
We define HFI to be the conjunction of all formulae in H1 to H6 and F I to be the ITLn formula obtained from F by replacing every occurrence of  by v[] .
Note, that this formula depends on F .
We will now show, that an ITLn interpretation IITLn and a valuation V that satisfy the axioms encoded in HFI can already be used to derive a Shape Calculus interpretation.
We will use such interpretations, valuations and intervals frequently in what follows, so we aggregate them in triples.
Definition 12 (H-Triple).
A triple (IITLn , V , [b1 , f1 ] x [b2 , f2 ]) is called an H-triple if  IITLn , V , [b1 , f1 ] x [b2 , f2 ] |=ITLn e1 e2 HFI  i.e., HFI holds for every subrectangle of [b1 , f1 ] x [b2 , f2 ].
Using this definition and the axioms, we derive some properties of H-Triples that will be used in the completeness proof.
A complete proof of this lemma can be found in [28].
Lemma 13.
Let (IITLn , V , [b1 , f1 ] x [b2 , f2 ]) be an H-Triple.
Then the following holds: (1) IITLn , V , [b1 , f1 ] x [b2 , f2 ] |=ITLn (2) IITLn , V , [b1 , f1 ] x [b2 , f2 ] |=ITLn (3) IITLn , V , [b1 , f1 ] x [b2 , f2 ] |=ITLn (4) IITLn , V , [b1 , f1 ] x [b2 , f2 ] |=ITLn k = 1, 2.  v[] + v[!] =  v[]   v[1 ]  v[1 [?
]2 ] v[] impliesI , V , [c1 , d1 ] x [c2 , d2 ] |= v[] for[ck , dk ] [?]
[bk , fk ],  Deriving the piecewise constant property.
As we require Shape Calculus interpretations to be piecewise constant, i.e., there is a partition of time and space into intervals such that the interpretation of observables is constant on each interval, we show that this property can be derived in ITLn from the encoded axioms.
We need the instances in H6 and the Theorem of Heine Borel [41].
40  A. Schafer / Information and Computation 205 (2007) 25-64  Lemma 14.
Given an arbitrary H-triple (IITLn , V , [b1 , f1 ] x [b2 , f2 ]) such that b1 < f1 and b2 < f2 , i.e., the interval is non-empty, then for every  [?]
S there is a finite partition in sub-rectangles [b11 , f11 ] x [b12 , f21 ], .
.
.
, [bn1 , f1n ] x [bn2 , f2n ] such that for every rectangle [bi1 , f1i ] x [bi2 , f2i ] holds either IITLn , V , [bi1 , f1i ] x [bi2 , f2i ] |=ITLn v[]  or IITLn , V , [bi1 , f1i ] x [bi2 , f2i ] |=ITLn v[!]   Proof.
Let (x, y) [?]
[b1 , f1 ] x [b2 , f2 ].
Then by H6 there exists x1  x  x2 and y1  y  y2 such that IITLn , V , [x1 , x] x [y1 , y] |=ITLn IITLn , V , [x1 , x] x [y, y2 ] |=ITLn IITLn , V , [x, x2 ] x [y1 , y] |=ITLn IITLn , V , [x, x2 ] x [y, y2 ] |=ITLn  v[]  [?]
v[!]  and v[]  [?]
v[!]  and v[]  [?]
v[!]  and v[]  [?]
v[!]   Now (x1 , x2 ) x (y1 , y2 ) is an open interval covering the point (x, y) and the closed interval [x1 , x2 ] x [y1 , y2 ] has the desired property.
Then by Heine-Borels Theorem there is a finite subset of this infinite partition covering [b1 , f1 ] x [b2 , f2 ] .
The cases where (x, y) is on the border are handled similarly.
This yields the finite partition as required.
 From ITLn interpretations toSC interpretations.
We have to show that for every valid SC formula there is a valid ITLn formula such that we can lift the derivation of the ITLn formula to a derivation of the SC formula.
We will show the contrapositive, i.e., that an ITLn interpretation satisfying the axioms, corresponds to an SC interpretation.
Let (IITLn , V , [b1 , f1 ] x [b2 , f2 ]), be an H-triple.
We construct an SC-interpretation ISC by defining for every observable X the interpretation ISC (X) to be  1 if there are x1 , x2 , y1 , y2    df x1  x < x2 , y1  y < y2 such that (1) ISC (X)((x, y)) = IITLn , V , [x1 , x2 ] x [y1 , y2 ] |=ITLn v[X ]     0 otherwise This interpretation has the required finite variability property: each interval can be partitioned into finitely many subintervals such that the value of each observable X is constant on each subinterval.
It is to be shown that the SC interpretation given by this definition satisfies  if and only if the ITLn interpretation satisfies v[] .
This result is established by the following lemma.
Lemma 15.
For an H-triple (IITLn , V , [b1 , f1 ] x [b2 , f2 ]), a state assertion , and an SC-Interpretation o-1 n o as defined in Equation 1, there is a finite partition [m11 , m21 ] x [m12 , m22 ], .
.
.
, [mn-1 1 , m1 ] x [m2 , m2 ] of j j+1 the two-dimensional interval [b1 , f1 ] x [b2 , f2 ] such that for every point (x, y) [?]
[mi1 , mi+1 1 ) x [m2 , m2 ) holds j  j+1  n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[]  [?]
v[!]   and  (2)  A. Schafer / Information and Computation 205 (2007) 25-64   fi ISC [[]] (x, y) =    j  41  j+1  n 1 if I , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[]  j j+1 i+1 i 0 if I , V , [m1 , m1 ) x [m2 , m2 ) |=ITLn v[!] .
This lemma can be proven by induction on the structure of .
As the integral summation over the piecewise constant parts we obtain the following corollary.
(3)    is derived by  Corollary 16.
For the interpretation ISC and every state assertion  and interval [b1 , f1 ] x [b2 , f2 ]  ISC [[ ]]([b1 , f1 ] x [b2 , f2 ]) = IITLn [[v[] ]]([b1 , f1 ] x [b2 , f2 ]) 4.4.
Proving relative completeness Starting with a valid Shape Calculus formula F , we have shown how to construct an Shape Calculus interpretation for every ITLn interpretation that satisfies certain instances of the Shape Calculus axioms in the ITLn formula e1 e2 HFI .
Corresponding to the Shape Calculus formula F , we define the ITLn formula F I by replacing the  measure  with a variable v[] .
Using the above result, we can construct for every ITLn interpretation IITLn which violates e1 e2 HFI = F I , i.e, the interpretation satisfies e1 e2 HFI but violates F I , an SC interpretation ISC violating F .
This proves the following lemma.
Lemma 17.
|=SC F implies |=ITLn e1 e2 HFI = F I .
To show the converse implication, let ISC be an SC interpretation violating F .
Define the violating ITLn interpretation IITLn by  df IITLn (v[] )([b1 , f1 ] x [b2 , f2 ]) = ISC [[ ]]([b1 , f1 ] x [b2 , f2 ]).
Using this interpretation and the soundness of our axiomatisation, we obtain Lemma 18.
|=ITLn e1 e2 HFI = F I implies |=SC F. To prove the relative completeness, suppose |=SC F .
Then by Lemma 17 holds |=ITLn e1 e2 HFI = FI .
Take the ITLn derivation of |=ITLn e1 e2 HFI = F I and replace every occurrence of v[] by  to obtain an SC derivation.
As HF is a boxed conjunction of instances of SC axioms, it can be easily deduced in SC and therefore we obtain a derivation of F by modus ponens.
5.
Decidable subsets For acceptance of formal methods in practice, tool support is essential.
Decidable subsets therefore play an import role as they facilitate the implementation of model-checkers.
Restricted discrete Duration Calculus is known to be decidable [28] and a model-checking method is implemented in DCValid [36].
In this section, we present two different types of decidable subsets of SC.
The first is obtained by imposing restrictions on the class of models and the second by imposing restrictions on the class of formulae.
Duration Calculus is already unde-  42  A. Schafer / Information and Computation 205 (2007) 25-64  cidable in the continuous case except for very restricted subsets which, e.g., miss the possibility of taking quantitative measures.
Henceforth we assume the time-space-domain to be discrete throughout this section.
As First-Order logic is undecidable, we also omit first order variables.
We assume all interpretations to change their values only at points in [?]
and all variables to have a range in [?]
.
A detailed discussion of decidable subsets and undecidability results for Duration Calculus can be found in [28] and [22].
5.1.
Finite space with infinite time This first subset SCfin imposes a restriction on the class of models: we allow one infinite temporal dimension and require the other spatial dimensions to be finite and the size to known beforehand.
As we have shown in the previous section, Shape Calculus is already undecidable for two and more discrete infinite dimensions.
We give a decision procedure for the set of formulae given by the following BNF: F ::= P  | F [?]
G | !F | F ei  G where ei denotes a spatial or temporal unit vector.
The more general integral operator is replaced by the more specialised everywhere operation * omitting the use of SC terms.
We will see later that other operators can be defined as abbreviations in the discrete setting.
The approach for the decision procedure is sketched in Fig.
4.
As there are only finitely many observables, a configuration for a point in space-time can be represented by the finite set of observables evaluating to true.
In Fig.
4b this set is represented as a bitvector.
We generalise this idea to an arbitrary number of spatial dimensions.
All spatial dimensions are finite, so the spatial configuration for a moment in time can be represented by a finite function mapping the finite space to the powerset of the observables.
Due to the finiteness of the domain, there are only finitely many spatial configurations and therefore only finitely many functions representing a temporal snapshot.
For the decision procedure, we use these functions as an alphabet and represent interpretations over space and time by words over this alphabet.
It proceeds by inductively constructing a regular language representing all satisfying interpretations.
Conjunction is constructed by intersection, negation by complement, temporal chop by concatenation and spatial chop using inverse homomorphisms for "gluing" two words letterwise.
Definition 19 (Alphabet fiF ).
Let F be an n-dimensional SCfin formula, Obs the set of observables occurring in F and D a finite rectangular subset of [?]
n-1 .
The alphabet fiF (D) of F for space D if defined by fiF (D) = {c|c : D - P (Obs)}.
Let space be the subset of [?]
n-1 denoting the finite space, we define  fiF (D).
fiF = D[?
]space, D rectangular  A. Schafer / Information and Computation 205 (2007) 25-64  a  43  b  Fig.
4.
(a) Two objects in finite space.
(b) Their representation using a finite alphabet.
Each function in fiF represents a temporal snapshot of a spatial configuration for a point in time.
The intuition is that c((x1 , .
.
.
, xn-1 )) collects all observables that are true on the interval [x1 , x1 + 1) x * * * x [xn-1 , xn-1 + 1).
As we use discrete time and space, all interpretations are constant on these intervals.
Therefore we can define the satisfaction relation  for a state assertions , a function c [?]
fiF (D) and a spatial point x [?]
D inductively by c(x)X iff X [?]
c(x) c(x)1 [?]
2 iff c(x)1 and c(x)2 c(x)! iff c(x)   Note that fiF is finite since space and the set of observables are both finite.
For handling the chop-operation, we need to restrict the domain of functions in fiF .
This is done via a functional hD-Dfi restricting the domain from D to a subset Dfi .
This functional is extended to a homomorphism on words in fi*F and using the inverse of this homomorphism, we can generate all possible spatial extentions to space D of the word describing space Dfi .
Definition 20 (Homomorphism hD-Dfi ).
Let fiF (D) and fiF (Dfi ) be alphabets as given by Definition 19 and Dfi [?]
D. The function hD-Dfi defined by  fiF (D) - fiF (Dfi ) hD-Dfi : c - c|Dfi  fi : fiF (D)* - fiF (Dfi )* in the usual way, i.e., can be extended to a language homomorphism hD-D df  fi (e) = e and hD-D  fi (aw) = hD-Dfi (a) * hD-D  fi (w).
We omit the distinction between hD-Dfi and hD-D  fi in the following.
hD-D  44  A. Schafer / Information and Computation 205 (2007) 25-64  Definition 21 (Language L(F)).
Let F be an n-dimensional SCfin formula, fiF the alphabet and D [?]
space.
Using the notation from Definition 4 the regular language LD (F) over the alphabet fiF (D) is defined inductively by  df  LD () =    [?]
if [?]
i : mini (D)  maxi (D) {c [?]
fiF |[?]
x [?]
D- : c(x)}+ otherwise  df  LD (!F) = fiF (D)* \ LD (F) df  LD (F1 [?]
F2 ) = LD (F1 ) [?]
LD (F2 ) df  LD (F1 et  F2 ) = LD (F1 ) * LD (F2 )  The definition for the spatial chop in direction ei is more technical.
  df  LD (F1 ei  F2 ) =      -1 h-1 D-(D[?
]i r) (LD[?
]i r (F1 )) [?]
hD-(Di r) (LDi r (F2 ))  r[?
][mini D,maxi D]  The r [?]
[mini D, maxi D] is the point to chop the interval.
We construct the language for the formula F1 and the lower part of interval and use the inverse homomorphism, i.e.
the preimage, to generate all possible extensions.
The same approach is done for the upper part and formula F2 .
The intersection assures that F1 holds on the lower and F2 on the upper part of the interval.
n) By definition, a formula is satisfiable if there is an interval satisfying it.
Therefore, all finitely many spatial subintervals have to be considered for the language of F df  L(F) =    LD (F)  D[?
]space  As regular languages are closed under all operations used in this definition, L(F) is regular.
The correspondence between words and interpretations is established by the following lemma which is proven by structural induction.
Lemma 22.
Let F be an n-dimensional SCfin formula, [0, t] a temporal interval and D = [b1 , f1 ] x * * * x [bn-1 , fn-1 ] a spatial interval.
Then the following holds: df  () Let I be an interpretation satisfying F on the interval D x [0, t], then the word   = c0 .
.
.
ct-1 [?]
fiF (D)* representing I with df  ck (x) ={X [?]
Obs | I (X)(x, k) = 1} for k [?]
{0, .
.
.
, t - 1} is in LD (F).
A. Schafer / Information and Computation 205 (2007) 25-64  45  () Let   = c0 .
.
.
ct-1 [?]
LD (F), then the corresponding interpretation I defined by df  I (X)(x, t) =    1 if X [?]
ct (x) 0 otherwise  satisfies I , D x [0, t] |= F. The following corollary establishes the correctness of the construction.
Corollary 23.
An n-dimensional SCfin Formula F is satisfiable on an interval D x [0, t] where D is a (n - 1)-dimensional spatial and [0, t] is a temporal interval iff LD (F) is non-empty.
As the emptiness problem for regular languages is decidable, this proves the decidability.
Theorem 24.
The validity and satisfiability problems for SCfin are decidable.
The complexity of the decision procedure is non-elementary as each negation may cause an exponential blow-up due to the complementation of finite automata.
The complexity is polynomial in the assumed finite spatial cardinality, the degree of the polynomial is determined by the number of nested chops.
The complexity of deciding validity for Duration Calculus is also already non-elementary [28].
Although non-elementary seems to be a serious concern, the application of the procedure for Duration Calculus on several case studies[36] demonstrates the feasibility of this approach.
Example 25.
We illustrate the language construction for the decision procedure by constructing the language L(P  ey  !P ).
We assume Obs = {P }, a two-dimensional space, and a maximal spatial cardinality of 2 in each dimension.
For convenience the functions c are represented by matrices.
L[0,2]x[0,0] (P ) = [?]
L[0,2]x[2,2] (!P ) = [?]
L[0,2]x[0,1] (P ) = {({P } {P })}+ L[0,2]x[1,2] (!P ) = {({} {})}+ + +   {P } {P } {} {} L[0,2]x[0,2] (P ) = L[0,2]x[0,2] (!P ) = {P } {P } {} {} -1 L[0,2]x[0,2] (P  ey  !P ) = h[0,2]x[0,2]-[0,2]x[0,0] (L[0,2]x[0,0] (P )) [?]
h-1 [0,2]x[0,2]-[0,2]x[0,2] (L[0,2]x[0,2] (!P )) [?]
-1 h[0,2]x[0,2]-[0,2]x[0,1] (L[0,2]x[0,1] (P )) [?]
h-1 [0,2]x[0,2]-[0,2]x[1,2] (L[0,2]x[1,2] (!P )) [?]
-1 h[0,2]x[0,2]-[0,2]x[0,2] (L[0,2]x[0,2] (P )) [?]
h-1 (L[0,2]x[2,2] (!P )) [0,2]x[0,2]-[0,2]x[2,2]  + {P } {P } = {} {}  46  A. Schafer / Information and Computation 205 (2007) 25-64  Expressivity.
Although the subset SCfin seems to be rather limited, there are several expressions of the original language that can be obtained as abbreviations using the restricted set and the fact that the temporal and spatial domain are discrete.
The terms ei are obtained because it is impossible in a discrete domain to chop an interval of length 1 into two parts of positive length.
So, for k [?]
[?]
+ , we obtain measures as follows.
df   == !
1 df  ei = 1 [?]
!
== 1 [?]
!
(1 ei  1) df  ei = k + 1 [?]
!
== (ei = k [?]
!)
ei  (ei = 1 [?]
!)
df  ei > k [?]
!
== (ei = k [?]
!)
ei  1; The definition of the other operators ,,< is analogue.
As interpretations may only change  their value at discrete points, the measure P can be expressed as follows:   df  P = 0 == !P  [?]
  df P = 1 == P = 0   fi ex  P = 0 et  (P  [?]
x = 1 [?]
t = 1) et  P = 0  ex  P = 0 	    fi fifi df P = k1 ex  P = k2 [?]
P = k == k1 , k2 > 0 k1 + k2 = k  	    fi fifi  P = k1 et  P = k2  k1 , k2 > 0 k1 + k2 = k  5.2.
Non-alternating chop.
Another possibility of deriving a decidable subset is to use the fibrings and dovetailing ideas presented by Gabbay et al [23,24] to combine modal logics.
In order to create a structure for the combined logic, they start with a structure for the first one, associate to each world a structure for the second logic and so on.
The idea is depicted in Fig.
5a.
Using this approach a lot of important properties like axiomatisability and decidability are inherited by the combination.
As we are interested in models isomorphic to the grid, we need to rule out models like those sketched in 5b where going up and right is not equivalent to going right first and up afterwards because our main goal is to reason about objects in [?]
n .
To this end, we do not allow chop-alternation.
On the innermost nesting level we only allow formulae using e2  nested in formulae using e1  and so on.
To preserve decidability, we restrict the interaction of formulae by adding a constraint on the length.
A. Schafer / Information and Computation 205 (2007) 25-64  a  b  47  c  X2  X1  X1  X0  X0  X0  w w'  f1 f2  f1 f3  f1 f3  Fig.
5.
(a) Dovetailing linear modal structures.
(b) Points w and wfi need not to be equal.
(c) Dovetailing SC.
The language of this n-dimensional subset SCnAlt is the set of formulae F n generated by the following BNF: F 1 ::= P  | F11 e1  F21 | F11 [?]
F21 | !F11   fi F n+1 ::= F1n+1 en+1  F2n+1 | F1n+1 [?]
F2n+1 | !F1n+1 | F n [?]
en+1 = 1 Let (F) denote the index of chop used on the topmost level, i.e, the minimal i such that F can be generated from F i .
Note, that without this restriction, it is already possible to encode the tiling problem and the resulting subset is undecidable.
Remark 26.
An SCnAlt formula of type (F) = n can not only be interpreted by n-dimensional  inter nfi k n k pretations I : Obs x Int - {0, 1} but also by k-dimensional functions I Obs x Int - {0, 1} for any k  n. A simple consequence is obtained immediately.
Lemma 27.
Let F be an SCnAlt formula of type (F) = n. () Assume I k for k  n to be a k-dimensional interpretation and D a k-dimensional interval such df  that I k , D |= F. Define I k-k+1 as a k + 1-dimensional interpretation by I k-k+1 (X)(x, y) = I k (x).
Then any interval [b, f] satisfies I k-k+1 , D x [b, f] |= F. () Conversely, assume I k+1 , D x [b, b + 1] |= F for b [?]
[?]
, then for an interpretation I k+1-k (X)(x) df  = I k+1 (x, b) we obtain I k+1-k , D |= F. () Let I , I fi be two n-dimensional interpretations, [0, f] a one-dimensional interval and D, Dfi two (n - 1)-dimensional intervals such that I , D x [j, j + 1] |= F n-1 [?]
en = 1 iff I fi , Dfi x [j, j + 1] |= F n-1 [?]
en = 1  for all subformulae F n-1 of type (n - 1) occurring in F and all j [?]
[0, f).
Then I , D x [0, f] |= F iff I fi , Dfi x [0, f] |= F. The last proposition states that if validity for two interpretations coincides on every slice and every subformula then validity coincides for the whole formula.
Like that for finite spatial  48  A. Schafer / Information and Computation 205 (2007) 25-64  domains, the decision procedure constructs regular languages associated to fulfilling interpretations.
For a model of an n-dimensional formula, we encode each (n - 1)-dimensional slice of this model by one letter.
As this spatial slice is still infinite, we use the set of all (n - 1)dimensional subformulae that are true in this slice as a representative of the slice.
Conversely, having no chop alternation, it is possible to obtain an n-dimensional model by joining (n - 1)dimensional slices.
This idea gives rise to the following definition of the alphabets where the dimension n is indicated by a superscript n if necessary for clarity and omitted if it is clear from the context Definition 28 (Alphabet finnA (F)).
Let F be an n-dimensional SCnAlt formula.
Case (F) = n = 1.
If F is a pure DC formula (i.e.
n = 1) a letter characterises which observables are true at the current position.
Henceforth, we define the alphabet to be the powerset of the observables Obs as fi1nA (F) = P (Obs).
Case (F) = n > 1.
In this case, the subformulae of type (n - 1) play the role of the observables.
Let Subn-1 (F) = {F1 , .
.
.
, Fy } be the set of subformulae of F with type (Fi ) = n - 1.
A subset of Subn-1 (F) is used to characterise the set of all true formulae that hold for an interval of length one in direction n. Therefore the alphabet is defined by finnA (F) = P (Subn-1 (F)).
The construction of the language LnnA (F) proceeds inductively on the structure of the formula.
Case (F) = 1.
In this case F is a pure DC formula and we construct the language in the same way as for discrete DC.
Let Obs = {X0 , .
.
.
, Xz } be the Boolean observables occurring in F .
Then a subset a of Obs represents a valuation of these observables for an interval of unit length.
Define L1nA (F) inductively by df  L1nA () = {a | a}+ , df  df  L1nA (F1 [?]
F2 ) = L1nA (F1 ) [?]
L1nA (F2 ),  L1nA (F1 e1  F2 ) = L1nA (F1 ) * L1nA (F2 ),  df  L1nA (!F1 ) = L1nA (F1 ).
Case (F) = n + 1.
In this case the subformulae of type n play the role of the observables.
Let Subn (F) = {F1 , .
.
.
, Fy } be the set of subformulae of F with (Fi ) = n. Then a set a [?]
Subn (F) can be used to describe which formulae are required to hold for an interval of length one.
At first we construct an auxiliary regular language Lfi (F) for the formula F in the same way as in the above case such that for every word holds: if for every letter, i.e.
a set of subformulae of F , there is a model satisfying all the formulae in this set and the models can be joined to obtain a model for the whole formula F .
df  Lfi (F n [?]
en+1 = 1) = {a|F [?]
a} df  Lfi (!F n+1 ) = Lfi (F n+1 ) df  Lfi (F1n+1 en+1  F2n+1 ) = Lfi (F1n+1 ) * Lfi (F2n+1 ) df  Lfi (F1n+1 [?]
F2n+1 ) = Lfi (F1n+1 ) [?]
Lfi (F2n+1 )  A. Schafer / Information and Computation 205 (2007) 25-64  49  Different from the simple case, the language Lfi does not represent the set of satisfying interpretations, since a word in Lfi does not guarantee that there is a satisfying interpretation.
A requirement that two subformulae F1n and F2n of type n hold jointly for the very same interval may not be satisfiable.
Additionally, we have to ensure that * for each letter occurring in a word, i.e., subset a [?]
Subn (F), there is an interpretation which satisfies exactly those formulae F where F [?]
a and * there is a common length k such that for all letters occurring in words, there is a satisfying interpretation of this length such that joining these models yields a rectangular model.
To capture these requirements, we introduce the notion of consistency, i.e.
the existence of a common model, first for letters and then for alphabets.
A letter a [?]
fin+1 nA (F) denotes a set of formulae of type n. It is consistent if there is an n-dimensional interpretation satisfying all formulae in a.
For one formula F [?]
a, there is such an interpretation if the language LnnA (F) is not empty.
A set a of formulae is consistent if there is a word in the conjunction of all such languages and only built from consistent letters of the lower dimensional type n - 1.
A set of letters  [?]
fin+1 nA (F) is consistent if there are satisfying n-dimensional interpretations and intervals for each letter having all the same size such that they can be concatenated to form an n + 1-dimensional interpretation.
Therefore, for every word over a consistent alphabet  [?]
fin+1 nA (F), there is an interpretation such that each letter corresponds to a slice of length one in direction (n + 1) satisfying all the n-dimensional subformulae occurring in the letter.
For regarding only the length of a word, we employ the following homomorphism, which "obscures" the actual letters of the word leaving only its pure shape.
Definition 29.
Let  be an arbitrary symbol and h : fi* - {}* be the homomorphism that replaces every letter by .
For defining consistency formally, we extend the definition of an associated language for a formula F to a set of characteristic formulae a by df  LnnA (a) =   F fi [?
]a  LnnA (F fi ) [?]
 F fi  [?
]a  LnnA (F fi ).
Using this definition, the intuition depicted above is formalised inductively as follows.
Definition 30.
A subset n+1 (F) [?]
fin+1 nA (F) for n > 1 is called consistent iff there is a consistent   n [?]
a[?]
n+1 (F) G[?
]a finnA (G) such that   h (LnnA (a) [?]
(n )* ) = / [?]
a[?]
The basic case is handled directly, every subset 1 (F) [?]
fi1nA (F) is consistent.
50  A. Schafer / Information and Computation 205 (2007) 25-64  Combining consistency--the existence of interpretations satisfying the formulae for each slice that can be concatenated--and the property of Lfi that piecewise satisfaction of subformulae yields satisfaction of the whole formula, we define the language by   df fi  Ln+1 nA (F) = L (F) [?]
 [?
]fi  is consistent   *  .
The correspondence between words in LnnA (F) and n-dimensional interpretations is established by the following definition and lemma.
Definition 31 (word-interpretation correspondence).
Let F be an n-dimensional SCnAlt formula, I be an n-dimensional interpretation, D an (n - 1)-dimensional interval and [0, f] a one-dimensional interval.
We associate a word wI = aI0 .
.
.
aIf-1 [?]
finnA (F)* to this interpretation such that for n=1 df  aIj ={X |X is an observable occurring in F and I , D x [j, j + 1] |= X } and, for n > 1,   df aIj = F fi |F fi [?]
Subn-1 (F) and I , D x [j, j + 1] |= F fi , respectively.
Vice versa, we associate to a word w [?]
finnA (F)* the set of interpretations and intervals [w] such that (I , D) [?]
[w] == w = wI .
Lemma 32.
Let F be an n-dimensional SCnAlt formula.
() A subset  [?]
finnA (F) is consistent iff for every w = a0 .
.
.
ak [?]
* , there is an n-dimensional interpretation I , an (n - 1)-dimensional interval D such that I , D x [j, j + 1) |= G == G [?]
aj holds for every j [?]
[0, k] and every G [?]
Subn-1 (F).
() I , D x [0, f] |= F implies wI [?]
LnnA (F).
/ [?]
and [?]
(I , D) [?]
[w] : I , D x [0, |w|] |= F () w [?]
LnnA (F) implies [w] = An easy consequence is the following lemma.
Lemma 33.
L(F) = / [?]
iff F is satisfiable And as all these constructions can be done effectively this proves the following theorem.
Theorem 34.
Satisfiability and validity for SCnAlt are decidable.
Like for SCfin the complexity is non-elementary due to the complementation of finite automata for each negation.
A. Schafer / Information and Computation 205 (2007) 25-64  51  Example 35.
These constructions are illustrated in Fig.
5c.
Assume a formula df  F = (F1 [?]
e1 = 1 e1  F1 [?]
e1 = 1 e1  F1 [?]
e1 = 1) [?]
(F2 [?]
e1 = 1 e1  F3 [?]
e1 = 1 e1  F3 [?]
e1 = 1) with df  F1 = X1  e2  true,  df  F2 = true e2  X2 ,  df  F3 = true e2  X3 .
The word (1, 1, 0)(1, 0, 1)(1, 0, 1) is in Lfi (F) and as the alphabet is consistent also in L(F).
Therefore the models for F1 , F2 , F3 can be combined to form a model for F .
Expressivity.
Like in SCfin operators can be obtained in SCnAlt .
We illustrate the two-dimensional case here.
At first we give definitions for formulae of type 1 which are to be used in the context of " [?]
e2 = 1".
We use the superscript 1 here to stress this restriction.
df  true1 == 11 [?]
!
11 df  1e1 = 0 == !
11 df  1e1 = 1 [?]
!
== 11 [?]
!
(11 e1  11 ) df  1e1 = k + 1 == (1e1 = k) e1  (1e1 = 1) df  1e1 > k == (11 = k) e1  11  1  df  P = 0 == !P 1 [?]
1e1 = 0 1 1 1 df P = 1 == P = 0 e1  P 1 [?]
1e1 = 1 e1  P = 0 1 1 1 df P = k + 1 == P = k e1  P = 1 For formulae of type 2 the definitions are more complicated.
At first "true" can be defined in the standard way.
df  true == (1 [?]
e2 = 1) [?]
!
(1 [?]
e2 = 1) As e2 is nearly a primitive in SCnAlt , it can be defined as follows: df  e2 = 1 == (true1 ) [?]
e2 = 1 df  e2 = k + 1 == (e2 = k) e2  (e2 = 1)  52  A. Schafer / Information and Computation 205 (2007) 25-64   The measure P is non-zero iff there is a subinterval of length 1 on which the measure is non-zero.
1 Therefore the measure can be defined using the type 1 formula P = 0.
        df 1 P = 0 [?]
e2 = 1 e2  true P = 0 == !
true e2  !
Using the same idea, we can define   df  P = 1 ==    P = 0 e2     1    P = 1.
 P = 1 [?]
e2 = 1 e2  P = 0   On an interval of length m the measure P equals k iff it is equal to k1 on the leftmost subinterval of length m - 1, is equal to k2 on the rightmost subinterval of length 1 and k = k1 + k2 .
  df  P = k ==  	      P = k1 e2  P = k2  k1 , k2 [?]
[?]
0 k1 + k2 = k  6.
Conclusion In this paper, we investigated properties of a multi-dimensional extension of Duration Calculus.
We showed that it is not axiomatisable and therefore not decidable.
Nevertheless, we give an axiomatisation relative to an n-dimensional interval temporal logic.
Tool support is crucial for applications of such a formalism in practice.
For model-checking tools, decidable subsets play an important role.
We presented two different subset for discrete spatial and temporal domains, one obtained by restricting the models to finite space while preserving infinite time and the other by restricting the class of formulae by excluding chop alternation.
In the future, we would like to apply this formalism to several case studies to derive a set of lightweight rules that make the handling of this formalism in practice easier.
To give tool support, this should be accompanied by extending and implementing the decision procedures found so far.
Acknowledgments The author thanks the anonymous referees for many helpful comments, and E.-R. Olderog and the members of the "Correct System Design" group, especially J. Hoenicke, R. Meyer, and A. Platzer, for fruitful discussions on this topic.
A.
Proofs Lemma 10.
Let I be an interpretation and k [?]
[?]
, a, b [?]
[?]
and Fgrid defined by  A. Schafer / Information and Computation 205 (2007) 25-64 df  Fgrid = e1  2 [?]
e2  2 [?]
fi == (fi1 == fi2 ) [?]
 e1 ((fi1  e1  e1 = 1 = fi1  e1  !fi1 ) [?]
fi (!fi1  e1  e1 = 1 = !fi1  e1  fi1 ) [?]
e1  1 = (fi1  [?]
e1 = 1 e1  true) [?]
 e2 ((fi2  e2  e2 = 1 = fi2  e2  !fi2 ) [?]
fi (!fi2  e2  e2 = 1 = !fi2  e2  fi2 ) [?]
e2  1 = (fi2  [?]
e2 = 1 e2  true)  53  (A.1a) (A.1b) (A.1c) (A.1d) (A.1e) (A.1f) (A.1g) (A.1h)  Then: I , [0, k] x [a, b] |= Fgrid  if and only if k  2, b - a  2, and for all i [?]
[?]
, i  k and arbitrary afi  bfi [?]
[a, b] the following holds.
fi  fi    ) I , [i, i + 1] x [a , b ] |= )  fi  fi    I , [a , b ] x [i, i + 1] |=   ) I , [i, i + 1] x [j, j + 1] |=  fi1  if i is even !fi1  otherwise fi2  if i is even !fi2  otherwise fi if i, j are both even or both odd !fi otherwise  Proof "only if" To prove ), we proceed by induction on i.
Case i = 0.
This case is clear by (A.1a).
Case ii + 1.
Without loss of generality, assume i is even, the other case is similar.
{ By (IH)} I , [i - 1, i] x [afi , bfi ] |= !fi1  = I , [i - 1, i + 1] x [afi , bfi ] |= !fi1  e1  e1 = 1 {Fgrid A.1d} = I , [i - 1, i + 1] x [afi , bfi ] |= !fi1  e1  fi1  {fi1 [?]
!fi1 [?]
false} = I , [i, i + 1] x [afi , bfi ] |= fi1  Case ) is analogue to case ).
For case ) assume without loss of generality i and j to be even, the other cases are similar.
{ By ) and )} I , [i - 1, i] x [j, j + 1] |= fi1  [?]
fi2  {A.1b} = I , [i - 1, i] x [j, j + 1] |= fi  54  A. Schafer / Information and Computation 205 (2007) 25-64  "if" The Condition (A.1a) follows from the assumption on the interval and Conditions (A.1b), (A.1e) and (A.1h) are direct consequences of ), ), and ).
To prove (A.1c) assume    I , [a1 , b1 ] x [a, b] |= fi1  e1  e1 = 1.
= I , [a1 , b1 - 1] x [a, b] |= fi1    [?
]i [?]
[?]
: = I , [a1 , i + 1] x [a, b] |= fi1  i  a1  b1 - 1  i + 1 {)} = I , [i + 1, i + 2] x [a, b] |= !fi1  {b1  i + 2} = I , [i + 1, b1 ] x [a, b] |= !fi1  = I , [a1 , b1 ] x [a, b] |= fi1  e1  !fi1  The other cases are proven similarly.
  Lemma 15.
For an H-triple (IITLn , V , [b1 , f1 ] x [b2 , f2 ]), a state assertion , and an SC-Interpretation o-1 n o as defined in equation 1 there is a finite partition [m11 , m21 ] x [m12 , m22 ], .
.
.
, [mn-1 1 , m1 ] x [m2 , m2 ] of j j+1 i+1 the two-dimensional interval [b1 , f1 ] x [b2 , f2 ] such that for every point (x, y) [?]
[mi1 , m1 ) x [m2 , m2 ) holds j  j+1  n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[]  [?]
v[!]   and  fi ISC [[]] (x, y) =    j  (A.2)  j+1  n 1 if I , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[]  j j+1 i+1 i 0 if I , V , [m1 , m1 ) x [m2 , m2 ) |=ITLn v[!] .
(A.3)  Proof.
We prove this lemma by induction on the structure of .
Case 1 .
Observable X .
This case is clear from the definition of ISC and Lemma 14.
Case 2 .
!.
By the induction hypothesis the lemma holds for  and we use the same partition.
Let j j+1 (x, y) [?]
[m1 , m1 ) x [mi2 , mi+1 2 ).
From the induction hypothesis we obtain j  j+1  n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[]  [?]
v[!] .
As  [?]
!
!, we obtain v[] = v[!
(!)] and therefore i+1 i n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[!
!)]  [?]
v[!] .
(1)  i+1 i n If IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[!
!]  then by the hypothesis ISC [[]](x, y) = 1 and by definition of negation we obtain ISC [[!]](x, y) = 1 - ISC [[]](x, y) = 0 as required.
A. Schafer / Information and Computation 205 (2007) 25-64  (2)  55  i+1 i n If IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[!]  then by the hypothesis ISC [[]](x, y) = 0 and we obtain ISC [[!]](x, y) = 1 - ISC [[]](x, y) = 1 as required.
Case 3 .
1 [?]
2 .
fi fi Applying the induction hypothesis on 1 and 2 , we obtain two partitions.
Let [m11 , m21 ] x fi fi fi fi fifi fifi fi fi [m12 , m22 ], .
.
.
[mn1 -1 , mn1 ] x [mo2 -1 , mo2 ] be a common refinement of both partitions.
By Lemma 13 (3) this is also a valid partition for 1 and 2 .
On every interval one of the following cases holds.
Case 3 .1 .
At least one disjunct 1 or 2 is true throughout the interval, i.e.
v[1 ]  or v[2 ] .
Without loss of generality, we assume jfi  fi  fi  j+1 fi  IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2  ) |=ITLn v[1 ] .
Applying the induction hypothesis yields for each fi fi jfi j+1 fi (x, y) [?]
[mi1 , mi+1 1 ) x [m2 , m2 ) ISC [[1 ]](V , (x, y)) = 1  and by the definition of the semantics of state assertions in SC we obtain ISC [[1 [?]
fi fi jfi j+1 fi n evaluation is derived as 2 ]](V , [mi1 , mi+1 1 ) x [m2 , m2 )) = 1.
The ITL follows: { By Lemma 13(3)} fi  fi  jfi  j+1 fi  fi  fi  jfi  j+1 fi  fi  fi  jfi  j+1 fi  fi  fi  jfi  j+1 fi  fi  fi  jfi  j+1 fi  IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 { and by Lemma 13(2)}  ) |=ITLn v[1 ]  v[1 [?
]2 ]  IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 { By the assumption holds }  ) |=ITLn v[1 [?
]2 ]    n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[1 ] = .
{ Combining the equations we obtain}  IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 { By definition we conclude}  ) |=ITLn v[1 [?
]2 ] =   IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2  ) |=ITLn v[1 [?
]2 ] .
Case 3 .2 .
Both 1 and 2 are false throughout the interval, i.e.
jfi  fi  fi  j+1 fi  IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2  ) |=ITLn v[!1 ]  [?]
v[!2 ]   Applying the induction hypothesis yields fi  fi  jfi  j+1 fi  ISC [[1 ]](V , [mi1 , mi+1 1 ) x [m2 , m2  )) = 0  56  A. Schafer / Information and Computation 205 (2007) 25-64  and jfi  fi  fi  j+1 fi  ISC [[2 ]](V , [mi1 , mi+1 1 ) x [m2 , m2  )) = 0  and hence jfi  fi  fi  j+1 fi  ISC [[1 [?]
2 ]](V , [mi1 , mi+1 1 ) x [m2 , m2  )) = 0.
The derivation of the ITLn evaluation proceeds as follows: { By the assumptions}  fi fi jfi j+1 fi n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[1 ] = fi fi fi fi j j+1 i+1 IITLn , V , [mi1 , m1 ) x [m2 , m2 ) |=ITLn v[2 ]  0 and =0  { and by Lemma 13 holds}  fi fi jfi j+1 fi n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[1 [?
]2 ]  fi fi fi fi j j+1 n IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2 ) |=ITL v[1 [?
]2 ]  0 and 0  { By H4 } fi fi jfi j+1 fi i+1 i IITLn , V , [m1 , m1 ) x [m2 , m2 )  |=ITLn v[1 [?
]2 ] = 0 { and by Lemma 13 (13) holds}  fi  fi  jfi  j+1 fi  IITLn , V , [mi1 , mi+1 1 ) x [m2 , m2  ) |=ITLn v[!
(1 [?
]2 )]     Lemma 22.
Let F be an n-dimensional SCfin Formula, [0, t] a temporal interval and D = [b1 , f1 ] x * * * x [bn-1 , fn-1 ] a spatial interval.
Then the following holds: df  () Let I be an interpretation satisfying F on the interval D x [0, t], then the word   = c0 .
.
.
ct-1 [?]
fiF (D)* representing I with df  ck (x) ={X [?]
Obs | I (X)(x, k) = 1} for k [?]
{0, .
.
.
, t - 1} is in LD (F).
() Let   = c0 * * * ct-1 [?]
LD (F), then the corresponding interpretation I defined by  df 1 if X [?]
ct ( x) I (X)(x, t) = 0 otherwise satisfies I , D x [0, t] |= F. Proof.
We proceed inductively on the structure of F .
Case .
() Let I be an interpretation such that I , D x [0, t] |= .
Then--by definition-- I [[]](x, t fi ) = 1 and fk > bk holds for all x [?]
D- , t fi [?]
[0, t) and k [?]
{1, .
.
.
n}.
By definition of  we obtain ck (x) for all x [?]
[b1 , f1 ) x * * * x [bn-1 , fn-1 ) and therefore   [?]
LD ()  A. Schafer / Information and Computation 205 (2007) 25-64  57  () Let   = c0 .
.
.
cn-1 [?]
LD ().
The definition of LD () and  immediately yields I , D x [0, t] |=  as required.
Case F1 [?]
F2 .
() Suppose that I , D x [0, t] |= F1 [?]
F2 .
By definition of [?]
we obtain I , D x [0, t] |= F1 and I , D x [0, t] |= F2 and by the induction hypothesis and definition 21   [?]
LD (F1 ) [?]
LD (F2 ) = LD (F1 [?]
F2 ).
() Let   [?]
LD (F1 [?]
F2 ) = LD (F1 ) [?]
LD (F2 ), by the induction hypothesis we obtain I , D x [0, t] |= F1 [?]
F2 .
Case !F1 .
() Suppose that I , D x [0, t] |= !F1 .
By definition I , D x [0, t]  |= F1 .
By the induction hypothesis for ()   [?]
LD (F1 ) and henceforth we obtain   [?]
fiF (D)* \ LD (F1 ) = LD (!F1 ).
() Let   [?]
LD (!F1 ) = fiF (D)* \ LD (F1 ).
By the induction hypothesis for () holds I , D x [0, t]  |= F1 and henceforth I , D x [0, t] |= !F1 .
Case F1 et  F2 (temporalchop).
() Assume I , D x [0, t] |= F1 et  F2 .
By definition of chop, there is an t fi [?]
[0, t] such that I , D x [0, t fi ] |= F1 and I , D x [t fi , t] |= F2 .
The interpretation I fi which is obtained by left-shifting I by t fi satisfies I fi , D x [0, t - t fi ] |= F2 .
The induction hypothesis yields  1 [?]
LD (F1 ) and  2 [?]
LD (F2 ) and therefore  1  2 [?]
LD (F1 ) * LD (F2 ).
() Let   [?]
LD (F1 et  F2 ).
By definition   =  1  2 for  1 [?]
LD (F1 ) and  2 [?]
LD (F2 ).
By the induction hypothesis the two corresponding interpretations I1 and I2 satisfy I1 , D x [0, t1 ] |= F1 and I2 , D x [0, t2 ] |= F2 .
By definition of I holds  I1 (X)(x, t) if t <= t1 .
I (X)(x, t) = I2 (X)(x, t - t1 ) otherwise and so I , D x [0, t1 + t2 ] |= F1 et  F2 Case F1 ei  F2 (spatialchop).
() Assume I , D x [0, t] |= F1 ei  F2 .
By definition there is an r [?]
[bi , fi ] such that I , (D [?
]i r) x [0, t] |= F1 and I , (D i r) x [0, t] |= F2 .
By the induction hypothesis the words  1 and  2 obtained from I on the spatial intervals D [?
]i r and D i r satisfy  1 [?]
LD[?
]i r (F1 ) and  2 [?]
LDi r (F2 ).
As   is derived from I for space D and  1 is derived from the same interpretation for a space (D [?
]i r) [?]
D, they describe the same spatial configurations for (D [?
]i r) [?]
D, i.e., hD-D[?
]i r ( ) =  1 .
For  2 we obtain hD-Di r ( ) =  2 , respectively.
-1 Therefore   [?]
h-1 D-D[?
]i r ( 1 ) [?]
hD-Di r ( 2 ) as required.
() Let   [?]
LD (F1 ei  Fi ).
There is an r [?]
[bi , fi ] such that -1   [?]
h-1 D-D[?
]i r (LD[?
]i r (F1 )) and   [?]
hD-Di r (LDi r (F2 )).
Hence  1 = hD-D[?
]i r ( ) [?]
LD[?
]i r (F1 ) and  2 hD-Di r ( ) [?]
LDi r (F2 ).
58  A. Schafer / Information and Computation 205 (2007) 25-64  Applying the induction hypothesis, yields that the two interpretations I1 and I2 obtained from  1 and  2 satisfy I1 , (D [?
]i r) x [0, t] |= F1 and I2 , (D i r) x [0, t] |= F2 .
The function I obtained from   coincides with I1 on (D [?
]i r) x [bn , fn ] and with I2 on (D i r) x [0, t] and therefore I , D x [0, t] |= F1 ei  F2 .
 Lemma 27.
Let F be an SCnAlt formula of type (F) = n. () Assume I k for k  n to be a k-dimensional interpretation and D a k-dimensional interval such df  that I k , D |= F .
Define I k-k+1 as a k + 1-dimensional interpretation by I k-k+1 (X)(x, y) = I k (x).
Then any interval [b, f] satisfies I k-k+1 , D x [b, f] |= F. () Conversely, assume I k+1 , D x [b, b + 1] |= F for b [?]
[?]
, then for an interpretation I k+1-k (X)(x) df  = I k+1 (x, b) we obtain I k+1-k , D |= F. () Let I , I fi be two n-dimensional interpretations, [0, f] a one-dimensional interval and D, Dfi two (n - 1)-dimensional intervals such that I , D x [j, j + 1] |= F n-1 [?]
en = 1 iff I fi , Dfi x [j, j + 1] |= F n-1 [?]
en = 1  for all subformulae F n-1 of type (n - 1) occurring in F and all j [?]
[0, f).
Then I , D x [0, f] |= F iff I fi , Dfi x [0, f] |= F Proof () Proof by structural induction.
Case .
From the assumption we deduce I [[]](x) = 1 for all x [?]
D. By construction of I k-k+1 we obtain for all xfi [?]
D x [b, f] that I k-k+1 [[]](xfi ) = 1 and therefore I k-k+1 , D x [b, f] |=  as required.
Case F1 [?]
F2 , !F1 .
These cases are clear from the definition.
Case F1 ei  F2 , i  k. By definition of chop there is an r such that I k , D [?
]i r |= F1 and I k , D i r |= F2 .
Applying the induction hypothesis, yields I k-k+1 , (D [?
]i r) x [b, f] |= F1 and I k-k+1 , (D i r) x [b, f] |= F2 .
Henceforth, I k-k+1 , D x [b, f] |= F1 ei  F2 .
() Similar to (), note that I is assumed to be constant on [n, n + 1) for all n [?]
[?]
.
() Proof by structural induction.
Case F n-1 [?]
en = 1.
This case is obvious from the assumptions.
A. Schafer / Information and Computation 205 (2007) 25-64  59  Case F1n [?]
F2n .
I , D x [0, f] |= F1n [?]
F2n == I , D x [0, f] |= F1n and I , D x [0, f] |= F2n { By (IH)} == I fi , Dfi x [0, f] |= F1n and I fi , Dfi x [0, f] |= F2n == I fi , Dfi x [0, f] |= F1n [?]
F2n  Case !F1n .
Follows directly from the definition and induction hypothesis.
Case F1n en  F2n .
"only if" Assuming I , D x [0, f] |= F1n en  F2n , there is an m [?]
[0, f] such that I , D x fi [0, m] |= F1n and I , D x [m, f] |= F2n .
Let I -m and I -m be the functions obtained from I , respectively I fi by left-shifting by m in the nth dimension.
Then I -m , D x [0, f - m] |= F2n and for all j [?]
[0, f - m) and all subformulae F n-1 I -m , D x [j, j + 1] |= F n-1 [?]
en = 1 iff fi I -m , Dfi x [j, j + 1] |= F n-1 [?]
en = 1 Applying the induction hypothesis on this yields fi I -m , Dfi x [0, f - m] |= F2n and therefore I fi , Dfi x [0, f] |= F1n en  F2n "if" similar.
  Lemma 32.
Let F be an n-dimensional SCnAlt formula.
() A subset  [?]
finnA (F) is consistent iff for every w = a0 .
.
.
ak [?]
* there is an n-dimensional interpretation I , an (n - 1)-dimensional interval D such that I , D x [j, j + 1) |= G == G [?]
aj holds for every j [?]
[0, k] and every G [?]
Subn-1 (F).
() I , D x [0, f] |= F implies wI [?]
LnnA (F).
() w [?]
LnnA (F) implies [w] = / [?]
and [?]
(I , D) [?]
[w] : I , D x [0, |w|] |= F Proof.
We simultaneously prove ()-() by induction on the structure of F .
Case (F) = 1 "only if "  "if"  ()  As all  [?]
fi1nA are consistent, let  be be an arbitrary subset and w = a0 .
.
.
ak [?]
* .
The interpretation I given by  1 if X [?]
ai I [[X ]](i) = 0 otherwise has the required property.
As every subset of fi1nA is consistent there is nothing to show.
60  A. Schafer / Information and Computation 205 (2007) 25-64  (, ) These cases are clear from the classical construction for duration calculus.
Case F n [?]
en+1 = 1 ()  The proof of () is essentially the same for all the other cases.
"only if"  n Let n+1 [?]
fin+1 nA (F [?]
en+1 = 1) be a consistent alphabet and w = a0 .
.
.
ak [?]
n+1 * ( ) .
By definition 30 there is a consistent alphabet n and for each letter ai , 0  i  k there is a word ui = ui (0)...ui (l) [?]
L(ai ) [?]
(n )* such that all words have the same length, i.e., |ui | = l. The concatenation of all u0 .
.
.
uk is still a word in (n )* and therefore the induction hypothesis is applicable yielding an n-dimensional interpretation I fi and an (n - 1)-dimensional interval Dfi such that for all subformulae G occurring in u1 .
.
.
uk the condition I fi , Dfi x [i * l + j, i * l + j + 1] |= G fi == G fi [?]
ui (j) holds.
The interpretation I fifi obtained from "folding" I fi defined by I fifi (X)(x, i, j) = I fi (X)(x, i * l + j) still satisfies  I fifi , Dfi x [i, i + 1] x [j, j + 1] |= G fi == G fi [?]
ui (j).
(A.4)  We show that this interpretation I fifi satisfies for all subformulae G of type n I fifi , Dfi x [i, i + 1] x [0, i] |= G == G [?]
ai .
(A.5)  Applying the induction hypothesis for () on each ui [?]
L(ai ), we obtain interpretations and intervals (Ii , Di ) satisfying for all subformulae G fi of type n-1 Ii , Di x [j, j + 1] |= G fi == G fi [?]
ui (j).
"if"  and additionally all formulae given in ai .
Using Lemma 27 (), we then obtain that I fifi satisfies all formulae given in ai , thus Eq.
(A.5) and hence I fifi is the required interpretation.
Let n+1 be an alphabet, w = a0 .
.
.
ak [?]
(n+1 )* be a word, I be the interpretation and D the n-dimensional interval satisfying for all subformula G that I , D x [j, j + 1) |= G == G [?]
aj .
Then for every j the restrictions given by Ijn+1-n (X)(x) = I (x, j) satisfy Ijn+1-n , D |= G == G [?]
aj due to n+1-n  have the same length by construcLemma 27 ().
Then all words wIj tion and are in L(aj ) by the induction hypothesis ().
Defining fi to be the n+1-n (X) j and applying the induction hycommon alphabet of all words wI pothesis for part () yields consistency of fi from which we can conclude the consistency of .
A. Schafer / Information and Computation 205 (2007) 25-64  ()  ()  61  Let I , D x [0, f] |= F n [?]
en +1 = 1.
From en+1 = 1 we obtain f = 1.
Therefore wI = aI0 and F n [?]
aI0 and wI [?]
Lfi (F n [?]
en+1 = 1) due to definition 31.
The consistency of  = {aI0 } is a consequence of ().
n n n+1 (F n [?]
Let w [?]
Ln+1 nA (F [?]
en+1 =1).
By definition w = a and F [?]
a holds.
As L en+1 = 1) is non-empty, {a} is consistent and () yields an interpretation I n and interval D such that I n , D |= F n .
Therefore [w] = / [?].
Any interpretation I n satisfyn n ing I , D |= F can be extended by Lemma 27 () to I n-n+1 such that I n-n+1 , D x [0, 1] |= F n [?]
en = 1.
Case F1n+1 [?]
F2n+1 .
()  ()  Case !F1n+1 .
()  ()  Let I , D x [0, f] |= F1n+1 [?]
F2n+1 .
By definition of conjunction and n+1 the induction hypothesis, we obtain wI [?]
Ln+1 ) and wI [?]
nA (F1 n+1 n+1 n+1 n+1 I LnA (F2 ) and consistency.
Therefore holds w [?]
LnA (F1 [?]
F1n+1 ) as required.
n+1 n+1 Let w [?]
Ln+1 [?]
F2n+1 ).
By construction w [?]
Ln+1 ) and w [?]
nA (F1 nA (F1 n+1 n+1 LnA (F2 ).
Applying the induction hypothesis yields [w] = / [?]
and for every interpretation I and interval D corresponding to w the relation I , D x [0, |w|] |= F1n+1 [?]
F2n+1 holds as required.
Let I , D x [0, f] |= !F1n+1 , so I , D x [0, f]  |= F1n+1 .
Applying the inducn+1 tion hypothesis for (), we obtain wI  [?]
Ln+1 ) and therefore wI [?]
nA (F1 n+1 Lfi (!F1 ).
By definition 31 the righthand side of () is satisfied yielding n+1 ).
consistency.
Hence, wI [?]
Ln+1 nA (!F1 n+1 n+1 / [?].
Assume [w] = [?].
Let w [?]
LnA (!F1 ).
At first we show [w] = Then for all (I , D) with wI = wI , D x [0, |w|]  |= !F1 and therefore I , D x [0, |w|] |= F1 .
But then, applying the induction hypothesis yields n+1 n+1 w [?]
Ln+1 ).
Therefore [w] = / [?].
The nA (F) contradicting w [?]
LnA (!F1 second proposition is a direct consequence of the induction hypothesis for ().
Case F1n+1 en+1  F2n+1 .
()Let I , D x [0, f] |= F1n+1 en+1  F2n+1 .
By definition there is an m [?]
[0, f] such that I , D x [0, m] |= F1n+1 and I , D x [m, f] |= F2n+1 .
The interpretation I fi defined by left-shifting I by m along dimension (n + 1) satisfies I fi , D x [0, f - m] |= F2n+1 .
Applying the induction hypothesis twice fi yields two words w1I [?]
L(F1n+1 ) and w2I [?]
L(F2n+1 ) corresponding to I on D x [0, m] and I fi on D x [0, f - m], respectively.
By construction wI = fi w1I w2I holds and henceforth wI [?]
Lfi (F1n+1 en+1  F2n+1 ).
Consistency is a consequence of ().
n+1 () Let w = a0 .
.
.
a|w|-1 [?]
Ln+1 en+1  F2n+1 ).
By definition w = w1 w2 nA (F1 n+1 n+1 n+1 such that w1 [?]
LnA (F1 ) and w2 [?]
Ln+1 nA (F2 ).
The induction hypothesis yields two pairs (I1 , D1 ) and (I2 , D2 ) such that I1 , D1 x [0, |w1 |] |= F1n+1 and  (A.6)  62  A. Schafer / Information and Computation 205 (2007) 25-64  I2 , D1 x [0, |w2 |] |= F2n+1  (A.7)  From consistency of the alphabet and () we obtain an interpretation I fi and n-dimensional interval D such that for all j [?]
[0, |w| - 1] and for all subformulae F n of type n holds I fi , D x [j, j + 1] |= F n == F n [?]
aj .
By Definition 31  I1 , D1 x [j, j + 1] |= F n == F n [?]
aj for j [?]
[0, |w1 |) and I2 , D2 x [j - |w1 |, j - |w1 | + 1] |= F n == F n [?]
aj for j [?]
[|w1 |, |w1 | + |w2 |).
(A.8) (A.9)  Applying Lemma 27 () on equations (A.6), (A.7),(A.8) and (A.10), we conclude I fi , D x [0, |w1 |] |= F1n+1 and I fi , D x [|w1 |, |w1 | + |w2 |] |= F2n+1 .
Therefore I fi , D x [0, |w|] |= F1n+1 en+1  F2n+1 .
The second part follows from Lemma 27 ().
  References [1] M. Aiello, H. van Benthem, A Modal Walk Through Space, Tech.
rep., Institute for Logic, Language and Computation, University of Amsterdam, 2001.
[2] R. Alur, D.L.
Dill, A theory of timed automata, Theor.
Comput.
Sci.
126 (2) (1994) 183-235.
[3] R. Alur, T.A.
Henzinger, A really temporal logic, J. ACM 41 (1) (1994) 181-204.
[4] G. Behrmann, A. David, K.G.
Larsen, A tutorial on uppaal, in: M. Bernardo, F. Corradini (Eds.
), Formal Methods for the Design of Real-Time Systems: 4th International School on Formal Methods for the Design of Computer, Communication, and Software Systems, SFM-RT 2004, Lecture Notes in Computer Science, vol.
3185, Springer-Verlag, Berlin, 2004, pp.
200-236.
[5] J. Bengtsson, W. Yi, Timed automata: semantics, algorithms and tools, in: J. Desel, W. Reisig, G. Rozenberg (Eds.
), Lectures on Concurrency and Petri Nets, Lecture Notes in Computer Science, vol.
3098, Springer, Berlin, 2003, pp.
87-124.
[6] B. Bennett, A. Cohn, F. Wolter, M. Zakharyaschev, Multi-dimensional multi-modal logics as a framework for spatio-temporal reasoning, Appl.
Intell.
17 (3) (2002) 239-251.
[7] P. Blackburn, J. Seligman, Hybrid languages, J.
Logic Lang.
Inform.
4 (1995) 251-272.
[8] M. Bozga, C. Daws, O. Maler, A. Olivero, S. Tripakis, S. Yovine, Kronos: a model-checking tool for real-time systems, in: in: A.J.
Hu, M.Y.
Vardi (Eds.
), Proceedings of the 10th International Conference on Computer Aided Verification, Vancouver, Canada, vol.
1427, Springer-Verlag, Berlin, 1998, pp.
546-550.
[9] L. Caires, L. Cardelli, A spatial logic for concurrency, Inform.
Comput.
186 (2) (2003) 194-235.
[10] L. Cardelli, A.D. Gordon, Mobile ambients, Theor.
Comput.
Sci.
240 (1) (2000) 177-213.
[11] L. Cardelli, A.D. Gordon, Anytime, anywhere: modal logics for mobile ambients, in: POPL 2000, ACM Press, 2000, pp.
365-377.
[12] Zhou Chaochen, C. Hoare, A. Ravn, A calculus of durations, IPL 40 (5) (1991) 269-276.
[13] Z. Chaochen, A. Ravn, M. Hansen, An extended duration calculus for hybrid real-time systems, in: R.L.
Grossman, A. Nerode, A.P.
Ravn, H. Rischel (Eds.
), Hybrid Systems, Lecture Notes in Computer Science, vol.
736, Springer, Berlin, 1993, pp.
36-59.
[14] W. Charatonik, J.-M. Talbot, The decidability of model checking mobile ambients, in: L. Fribourg (Ed.
), CSL, Lecture Notes in Computer Science, vol.
2142, Springer, Berlin, 2001, pp.
339-354.
A. Schafer / Information and Computation 205 (2007) 25-64  63  [15] W. Charatonik, S. Dal-Zilio, A.D. Gordon, S. Mukhopadhyay, J.-M. Talbot, The complexity of model checking mobile ambients, in: F. Honsell, M. Miculan (Eds.
), FoSSaCS, Lecture Notes in Computer Science, vol.
2030, Springer, Berlin, 2001, pp.
152-167.
[16] W. Charatonik, S. Dal-Zilio, A.D. Gordon, S. Mukhopadhyay, J.-M. Talbot, Model checking mobile ambients, Theor.
Comput.
Sci.
308 (1-3) (2003) 277-331.
[17] W. Craig, On axiomatizability within a system, J. Symb.
Log.
18 (1) (1953) 30-32.
[18] H. Dierks, Specification and Verification of Polling Real-Time Systems, Ph.D. thesis, University of Oldenburg (Jul.
1999).
[19] H. Dierks, PLC-automata: a new class of implementable real-time automata, Theor.
Comput.
Sci.
253 (1) (2000) 61-93.
[20] B. Dutertre, Complete proof systems for first order interval temporal logic, in: LICS, IEEE Computer Society, 1995, pp.
36-43.
[21] M. Franceschet, A. Montanari, M. de Rijke, Model checking for combined logics with an application to mobile systems, Autom.
Softw.
Eng.
11 (3) (2004) 289-321.
[22] M. Franzle, Model-checking dense-time duration calculus, Formal Asp.
Comput.
16 (2) (2004) 121-139.
[23] D.M.
Gabbay, Fibring Logics, Oxford University Press, Oxford, 1999.
[24] D. Gabbay, A. Kurucz, F. Wolter, M. Zakharyaschev, Many-Dimensional Modal Logics: Theory and Applications, Elsevier, Amsterdam, 2003.
[25] A. Galton, Towards a qualitative theory of movement, in: Spatial Information Theory, 1995, pp.
377-396.
[26] D. Giammarresi, A. Restivo, Handbook of formal languages--beyond words, in: Two-Dimensional Languages, vol.
3, Springer, Berlin, 1997, pp.
215-267.
[27] M.R.
Hansen, Zhou Chaochen, Duration calculus: logical foundations, Formal Asp.
Comput.
9 (1997) 283-330.
[28] M. R. Hansen, Zhou Chaochen, Duration Calculus: A Formal Approach to Real-Time Systems, EATCS: Monographs in Theoretical Computer Science, Springer, Berlin, 2004.
[29] K. Havelund, A. Skou, K. G. Larsen, K. Lund, Formal modeling and analysis of an audio/video protocol: an industrial case study using uppaa., in: IEEE Real-Time Systems Symposium, IEEE Computer Society, 1997, pp.
2-13.
[30] T.A.
Henzinger, X. Nicollin, J. Sifakis, S. Yovine, Symbolic model checking for real-time systems, in: LICS, IEEE Computer Society, 1992, pp.
394-406.
[31] N. Klarlund, A. Moller, MONA Version 1.4 User Manual, Tech.
rep., Department of Computer Science, University of Aarhus (January 2001).
[32] B. Krieg-Bruckner, J. Peleska, E.-R. Olderog, A. Baer, The UniForM Workbench, a universal development environment for formal methods, in: J.
Wing, J. Woodcock, J. Davies (Eds.
), FM'99--Formal Methods, Lecture Notes in Computer Science, vol.
1709, Springer, Berlin, 1999, pp.
1186-1205.
[33] M. Lindahl, P. Pettersson, W. Yi, Formal design and analysis of a gear controller, in: B. Steffen (Ed.
), TACAS, Lecture Notes in Computer Science, vol.
1384, Springer, Berlin, 1998, pp.
281-297.
[34] S. Merz, M. Wirsing, J. Zappe, A spatio-temporal logic for the specification and refinement of mobile systems, in: M. Pezze (Ed.
), FASE 2003, Warsaw, Poland, Lecture Notes in Computer Science, vol.
2621, Springer, Berlin, 2003, pp.
87-1014.
[35] R. Milner, Communicating and mobile systems: the -calculus, Cambridge University Press, Cambridge, 1999.
[36] P. Pandya, Specifying and deciding quantified discrete-time duration calculus formulae using dcvalid, Tech.
rep., Tata Institute of Fundamental Research (2000).
[37] P. K. Pandya, D. V. Hung, Duration calculus of weakly monotonic time, in: A.P.
Ravn, H. Rischel (Eds.
), FTRTFT'98, Lyngby, Denmark, vol.
1998, Lecture Notes in Computer Science, Springer, Berlin, 1998, pp.
55-64.
[38] J.-D. Quesel, MoDiShCa: Model-Checking discrete Shape Calculus, Minor Thesis, University of Oldenburg (August 2005).
[39] D.A.
Randell, Z. Cui, A. Cohn, A spatial logic based on regions and connection, in: B. Nebel, C. Rich, W. Swartout (Eds.
), KR'92, Morgan Kaufmann, San Mateo, California, 1992, pp.
165-176.
[40] J.H.
Reif, A.P.
Sistla, A multiprocess network logic with temporal and spatial modalities, J. Comput.
Syst.
Sci.
30 (1) (1985) 41-53.
64  A. Schafer / Information and Computation 205 (2007) 25-64  [41] W. Rudin, Principles of Mathematical Analysis, McGraw-Hill, New York, 1964.
[42] A. Schafer, A calculus for shapes in time and space, in: Z. Liu, K. Araki (Eds.
), Theoretical Aspects of Computing, ICTAC 2004, Lecture Notes in Computer Science, vol.
3407, Springer, 2005, pp.
463-478.
[43] A. Schafer, Axiomatisation and decidability of multi-dimensional duration calculus, in: J. Chomicki, D. Toman (Eds.
), Proceedings of the 12th International Symposium on Temporal Representation and Reasoning, TIME 2005, IEEE Computer Society, 2005, pp.
122-130.
[44] H. Vieira, L. Caires, The spatial logic model checker user's manual, Tech.
rep., Departamento de Informatica, FCT/UNL, tR-DI/FCT/UNL-03/2004 (2005).