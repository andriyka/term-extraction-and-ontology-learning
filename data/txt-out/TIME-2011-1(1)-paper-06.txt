A Tableau for Until and Since over Linear Time Mark Reynolds, The University of Western Australia.
August 3, 2010  Abstract We use mosaics and games to provide a simple, sound and complete tableau reasoning procedure for the temporal logic of until and since over general linear time.
1  Introduction  Temporal logic is a widely used formalism for reasoning about hardware and software systems.
Propositional reasoning on a natural numbers model of time and its logic PLTL [Pnu77] is the standard approach.
However, other models of time may be better for many applications, ranging from philosophical, natural language and AI modelling of human reasoning to computing and engineering applications of concurrency, refinement, open systems, analogue devices and metric information.
See for example [KMP94], [BG85] or [Rey09a].
For these sorts of applications, a range of logics have been developed such as intervals [HS86], metric temporal logics [AH93], the duration calculus [CHR91], rational numbers time [GHR93], and real time with finite variability [Rab98, KMP94].
Many such problems, however, can be expressed easily by various members of a family of natural and expressive logics using the Until and Since connectives introduced in [Kam68].
The propositional language L(U, S) with Until and Since can be given a uniform and natural semantics over any class of linear orders (at least).
Thus there is a basic logic which we will call US/LIN which is the logic of L(U, S) over the class of all linear flows of time.
Other, more specialised logics, are then obtained by restricting the application of the semantics to sub-classes of linear orders.
One such logic is U and S over the reals which is called RTL in recent work in [Rey10b].
Another is the logic of L(U, S) over the natural numbers which is as expressive as PLTL with past operators.
We have, from [Bur82], a complete axiom system to allow derivation of the valid formulas of US/LIN.
Decidability of US/LIN follows directly from the fact that the universal monadic theory of the class L of all linear flows 1  of time is decidable: and this was first proved by Gurevich in [Gur64].
This is discussed more fully in [GHR94] where the decidability is also derived from the case of decidability of L(U, S) over the rationals.
The complexity of the decision problem was investigated in [Rey10a] where it is proved that US/LIN is in PSPACE (so no more complex than PLTL [SC85]).
The PSPACE proof in [Rey10a] was built on the recent result in [Rey10b] that deciding RTL is PSPACE-complete.
The RTL proof uses linear time mosaic techniques.
Mosaics were used to prove decidability in relation algebras [Nem95] and have been used since quite generally in algebraic logic and modal logic [MMR00, Rey03, HHM+ 99].
These mosaics are small pieces of a model, in our case, a small piece of a linear-flowed structure.
We decide whether a finite set of such small pieces is sufficient to be used to build a model of a given formula.
In this paper we portray the task of finding a suitable set of mosaics as a two-player game in the style of the logic games of [Ehr61] and [Fra54].
Games have often been used in temporal logic [HH02, LS02].
The existence of the suitable mosaics is equivalent to the existence of a winning strategy for one player in the game played with mosaics.
We also see that the search for a winning strategy can be arranged into a search through a tree of mosaics.
This leads us on to the tableau.
Tableaux are a popular style of modal reasoning technique and there has been a substantial amount of work on applying them to temporal logics: see [Gor99] and [RD05] for surveys.
They can be presented in an intuitive way, they are often suitable for automated reasoning and it is often not hard to prove complexity results for their use.
Tableaux were used for modal logics in [HC68] and [Fit83] and there has been much work since on tableaux for temporal logics [Wol85, Gou89, EC82, EH85, Sch98, MMR00].
It was noted in [Rey10b] and again in [Rey09a] that the mosaic-based complexity proof for RTL also vaguely suggests a tableau based method for determining RTL validity.
In this paper, progress this research programme by providing full details of a mosaic-based and game-based tableau system for US/LIN.
It is hoped that in future work the tableau could be built upon and modified to be able to handle RTL-validity instead of US/LIN validity.
In this paper we define the logic US/LIN in section 2, explain mosaics in section 3, play games in section 4, lay out the tableau in section 5, face complexity issues in section 6 and conclude in section 7.
2  The logic  Fix a countable set L of propositional atoms.
Frames (T, <), or flows of time, will be irreflexive linear orders.
Structures T = (T, <, h) will have a frame (T, <) and a valuation h for the atoms i.e.
for each atom p [?]
L, h(p) [?]
T .
The idea is that if t [?]
h(p) then the proposition p is true at time 2  t. The language L(U, S) is generated by the 2-place connectives U (Until) and S (Since) along with classical !
and [?].
That is, we define the set of formulas recursively to contain the atoms and for formulas a and b we include !a, a [?]
b, U (a, b) and S(a, b).
Note that in most of the literature on temporal logics for discrete time, the "until" connective is written in an infix manner: bU a rather than U (a, b).
This corresponds to the natural language reading "I will be here until I become hungry" rather than our equally natural alternative "until I am hungry, I will be here".
We choose to use the prefix notation for until and since because it agrees with important previous work on the language for general or dense linear time such as [Kam68], [BG85], [GHR94] and [Rey10b].
It also helps us distinguish our connective from the until connective usually seen with discrete time which is written in an infix manner and which is a slightly different connective, the non-strict until connective mentioned below.
Formulas are evaluated at points in structures T = (T, <, h).
We write T, x |= a when a is true at the point x [?]
T .
This is defined recursively as follows.
Suppose that we have defined the truth of formulas a and b at all points of T. Then for all points x: T, x |= p iff x [?]
h(p), for p atomic; T, x |= !a iff T, x 6|= a; T, x |= a [?]
b iff both T, x |= a and T, x |= b; T, x |= U (a, b) iff there is y > x in T such that T, y |= a and for all z [?]
T such that x < z < y we have T, z |= b; and T, x |= S(a, b) iff there is y < x in T such that T, y |= a and for all z [?]
T such that y < z < x we have T, z |= b.
Many definitions, results and proofs below have a mirror image.
This means that U and S are swapped and < and > are swapped.
2.1  Abbreviations  There are many common and generally useful other connectives which can be defined as abbreviations in the language.
These include the classical a [?]
b = !
(!a [?]
!b); [?]
= p [?]
!p (where p is some particular atom from L); [?]
= ![?
]; and a - b = (!a) [?]
b.
Then there are the common temporal ones: F a = U (a, [?
]), "alpha will be true (sometime in the future)" ; Ga = !F (!a), "alpha will always hold (in the future)"; and their mirror images P and H. Particularly for dense time applications we also have: G+ a = U ([?
], a), "alpha will be constantly true for a while after now"; and K + a = !G+ !a, "alpha will be true arbitrarily soon".
They have mirror images G- and K - .
See [GHR94] for 3  details.
The non-strict "until" connective [SC85], used in PLTL and other temporal logics over the natural numbers (i.e.
over sequences of states) is just "a until b" given as b [?](a[?
]U (b, a)) in terms of our strict "until".
There is a mirror image non-strict "since".
Comparisons between strict and non-strict connectives are discussed more fully in [Rey03].
In situations where time is discrete then we can also define "next" Xa [?]
U (a, [?])
and (strong) yesterday Y a [?]
S(a, [?]).
Weak yesterday is !S(!a, [?]).
It is not sensible to use this connective with dense time.
2.2  Validity and Satisfiability  US/LIN is the logic with L(U, S) formulas evaluated over the class of all linear structures.
We say that an L(U, S) formula is valid (in US/LIN) iff for all linear structures T = (T, <, g), for all x [?]
T , T, x |= ph.
In that case write |= ph.
As usual, satisfiability is dual to validity: we say that an L(U, S) formula is satisfiable iff there is a linear structure T = (T, <, g), and some x [?]
T , such that T, x |= ph.
We can also use validity to determine a finitary consequence relation.
Say that g is a consequence of G = {g1 , ..., gn } iff for all linear structures T = (T, <, g), for all x [?]
T , if for all i = 1, ..., n, T, xV|= gi then T, x |= g. In that case write G |= g. It is clear that G |= g iff |= ni=1 gi - g.  2.3  Reasoning with US/LIN  A Hilbert style axiom system for US/LIN comes from [Bur82] (with streamlining by Ming Xu [Xu88]).
The system has the usual rules for a temporal logic: i.e.
modus ponens, generalizations and substitution: A, A - B B  A GA  A HA  A(q) A(q/B)  The axioms are all classical tautologies and the six Burgess-Xu axioms: G(p - q) - (U (p, r) - U (q, r)) G(p - q) - (U (r, p) - U (r, q)) p [?]
U (q, r) - U (q [?]
S(p, r), r) U (p, q) - U (p, q [?]
U (p, q)) U (q [?]
U (p, q), q) - U (p, q) U (p, q) [?]
U (r, s) - U (p [?]
r, q [?]
s) [?]
U (p [?]
s, q [?]
s) [?]
U (q [?]
r, q [?]
s) 4  along with each of their mirror images.
Decidability follows the fact that the universal monadic theory of the class L of all linear flows of time is decidable as first proved by Gurevich in [Gur64].
See also [BG85] and [GHR94].
It also follows from the recent complexity result in [Rey10a].
The complexity of a decision procedure for US/LIN was determined as part of a wide range of linear temporal logic complexity results in [Rey10a].
A PSPACE result was provided, although it is not known if the logic is PSPACE-complete.
3  Mosaics for U and S  We will decide the satisfiability of formulas by considering sets of simple labelled structures which represent small pieces of linear structures.
The idea is based on the mosaics seen in [Nem95] and used in many other subsequent proofs.
Each mosaic is a small piece of a model, i.e.
a small set of objects (points), relations between them and a set of formulas for each point indicating which formulas are true there in the whole model.
There will be (syntactic) coherence conditions on the sets of formulas which make up the mosaic which are necessary for it to be part of a larger model.
We want to show the equivalence of the existence of a model to the existence of a certain set of mosaics: enough mosaics to build a whole model.
So the whole set of mosaics also has to obey some conditions.
These are called saturation conditions.
For example, a particular small piece of a model might require a certain other piece to exist somewhere else in the model.
We talk of the first mosaic having a defect which is cured by the latter mosaic.
3.1  A Mosaic  Our mosaics will only be concerned with a finite set of formulas: DEFINITION 1 For each formula ph, define the closure of ph to be Clph = {ps, !ps | ps <= ph} where kh <= ps means that kh is a subformula of ps.
We can think of Clph as being closed under negation: treat !
!a as if it was a.
Various parts of each mosaic, consist in a set of formulas which is intended to be a set of formulas which all hold at one point in a model.
Thus such a set should be at least consistent in terms of classical propositional logic: DEFINITION 2 Suppose ph [?]
L(U, S) and S [?]
Clph.
Say S is propositionally consistent (PC) iff there is no substitution instance of a tautology of classical propositional logic of the form !
(a1 [?]
...
[?]
an ) with each ai [?]
S. 5  Say S is maximally propositionally consistent (MPC) iff S is maximal in being a subset of Clph which is PC.
We will define a mosaic to be a triple (A, B, C) of sets of formulas.
The intuition is that this corresponds to two points from a structure: A is the set of formulas (from Clph) true at the earlier point, C is the set true at the later point and B is the set of formulas which hold at all points strictly in between.
Given two points in a structure we can find such a triple as follows: DEFINITION 3 If T = (T, <, h) is a structure and ph a formula then for each x < y from T we define mosphT (x, y) = (A, B, C) where: A = {a [?]
Clph|T, x |= a}, B = {b [?]
Clph| for all z [?]
T , if x < z < y then T, z |= b}, and C = {g [?]
Clph|T, y |= g}.
If T and ph are clear from context then we just write mos(x, y) for mosphT (x, y).
As we will see, definition 3 gives us actual satisfiable mosaics once we have a model.
However, in computing a decision procedure we have no model to build from and we want to construct such a triple as a syntactic object.
Thus we define a mosaic to be a triple of sets of formulas satisfying some reasonable but simple syntactic requirements: the coherency conditions.
The coherency conditions are given as part of the following definition.
It will be easy to see that they are necessary for a mosaic to represent a small part of a linear structure.
However, they are only simple syntactic criteria and are therefore not subtle enough to be also sufficient for a mosaic to represent a piece of structure.
Thus, as we will see later, an important task in this paper is to identify which mosaics are actually satisfiable.
DEFINITION 4 Suppose ph is from L(U, S).
A ph-mosaic is a triple (A, B, C) of subsets of Clph such that: C0.1 A and C are maximally propositionally consistent, and C0.2 for all !
!b [?]
Clph we have !
!b [?]
B iff b [?]
B and the following four coherency conditions hold:  6  C1.
C2.
C3.
C4.
if !U (a, b) [?]
A and b [?]
B then we have both: C1.1.
!a [?]
C and either !b [?]
C or !U (a, b) [?]
C; and C1.2.
!a [?]
B and !U (a, b) [?]
B. if U (a, b) [?]
A and !a [?]
B then we have both: C2.1 either a [?]
C or both b [?]
C and U (a, b) [?]
C; and C2.2.
b [?]
B and U (a, b) [?]
B. if !S(a, b) [?]
C and b [?]
B then we have both: C3.1 !a [?]
A and either !b [?]
A or !S(a, b) [?]
A; and C3.2 !a [?]
B and !S(a, b) [?]
B. if S(a, b) [?]
C and !a [?]
B then we have both: C4.1 either a [?]
A or both b [?]
A and S(a, b) [?]
A; and C4.2 b [?]
B and S(a, b) [?]
B.
The reader can check that these coherence conditions are reasonable (i.e.
sound) in terms of the intended meaning of a mosaic.
For example, considering C2.2, if U (a, b) holds at one point x of some structure and !a holds at all points between x and y > x, then it is clear from the semantics of U that there must be some z >= y with a true there and b (and so also U (a, b)) holding everywhere between x and y and beyond until z.
Continuing in such a way through all the conditions, it is straightforward to show "the soundness of coherence" i.e.
that any mosphT (x, y) is a mosaic.
LEMMA 5 For any structure T and any L(U, S) formula ph, mosphT (x, y) is a mosaic.
Some helpful terminology: DEFINITION 6 If m = (A, B, C) is a mosaic then start(m) = A is its start, cover(m) = B is its cover and end(m) = C is its end.
3.2  Defects  If we start to build a model using mosaics as building blocks then we may realize that the inclusion of one mosaic necessitates the inclusion of others.
If we claim to have in a certain set all the mosaics needed to build a model, then the other mosaics should be in our set too.
For example,--this is 1.2 below--if we have U (a, b) holding at x < y and neither a nor b true at y then it is clear that there is a point z with x < z < y, a true at z and b true everywhere between x and z.
This is an example of what we will call a defect in the mosaic.
If there is such a point z and we claim to have a sufficient set of mosaics then we should have the mosaics corresponding to 7  the pairs (x, z) and (z, y) as well as (x, y).
These other mosaics are said to cure the defect in the first mosaic.
Below we will see that we cure defects en masse via a whole sequence of other mosaics rather than just having a pair to cure one defect at a time as in this example.
DEFINITION 7 A defect in a mosaic (A, B, C) is either 1. a formula U (a, b) [?]
A with either 1.1 b 6[?]
B, 1.2 (a 6[?]
C and b 6[?]
C), or 1.3 (a 6[?]
C and U (a, b) 6[?]
C); 2. a formula S(a, b) [?]
C with either 2.1 b 6[?]
B, 2.2 (a 6[?]
A and b 6[?]
A), or 2.3 (a 6[?]
A and S(a, b) 6[?]
A); 3. a formula b [?]
Clph with !b 6[?]
B; or 4. a formula U (a, b) [?]
C; 5. a formula S(a, b) [?]
A.
We refer to defects of type 1 to 5 (as listed here).
Note that the same formula may be at the same time one type of defect in a mosaic and another type of defect in the same mosaic.
Or it could even be three different types of defect.
For example, a formula may be a type 1, a type 3 and a type 4 defect in the same mosaic.
In such cases we count it as multiple separate defects.
Types 1,2 and 3 are called internal defects while 4 and 5 are external.
Note that in earlier work using mosaics [Rey03, Rey10b] for linear time, the author used a slightly different approach and did not consider external defects.
We will need to string mosaics together to build linear orders.
This can only be done under certain conditions.
Here we introduce the idea of composition of mosaics.
DEFINITION 8 We say that ph-mosaics (A' , B ' , C ' ) and (A'' , B '' , C '' ) compose iff C ' = A'' .
In that case, their composition is (A' , B ' [?]
C ' [?]
B '' , C '' ).
It is straightforward to prove that this is a mosaic and that composition of mosaics is associative.
LEMMA 9 If mosaics m and m' compose then their composition is a mosaic.
LEMMA 10 Composition of mosaics is associative.
8  Thus, we can talk of sequences of mosaics composing and then find their composition.
We define the composition of a sequence of length one to be just the mosaic itself.
We leave the composition of an empty sequence undefined.
We write sequences as follows: h(A1 , B1 , C1 ), (A2 , B2 , C2 ), ..., (An , Bn , Cn )i.
If s is a finite sequence then s [?]
r is the concatenation of s followed by r. DEFINITION 11 A mosaic with no internal defects is called a unit.
DEFINITION 12 A mosaic with no defects at all is called perfect.
DEFINITION 13 A decomposition for a mosaic (A, B, C) is any finite sequence of mosaics which composes to (A, B, C).
It will be useful to introduce an idea of fullness of decompositions.
This is intended to be a decomposition which provides witnesses to the cure of every internal defect in the decomposed mosaic.
DEFINITION 14 The decomposition h(A1 , B1 , C1 ), (A2 , B2 , C2 ), ..., (An , Bn , Cn )i is full iff the following three conditions all hold: 1. for all U (a, b) [?]
A we have either 1.1. b [?]
B and either (b [?]
C and U (a, b) [?]
C) or a [?]
C, 1.2. or there is some i with 1 <= i < n such that a [?]
Ci , b [?]
Bj (all j <= i) and b [?]
Cj (all j < i); 2. the mirror image of 1.; and 3. for each b [?]
Clph such that !b 6[?]
B there is some i such that 1 <= i < n and b [?]
Ci .
If 1.2 above holds in the case that U (a, b) [?]
A is a type 1 defect in (A, B, C) then we say that a cure for the defect is witnessed (in the decomposition) by the end of (Ai , Bi , Ci ) (or equivalently by the start of (Ai+1 , Bi+1 , Ci+1 )).
Similarly for the mirror image for S(a, b) [?]
C. If b [?]
Ci is a type 3 defect in (A, B, C) then we also say that a cure for this defect is witnessed (in the decomposition) by the end of (Ai , Bi , Ci ).
If a cure for any defect is witnessed then we say that the defect is cured.
LEMMA 15 If hm1 , ..., mn i is a full decomposition of m then every internal defect in m is cured in the decomposition.
9  Note that if m is a unit then hmi is a full decomposition of m. In order to handle external defects as well we now employ a pair of similar concept which allow cures for external defects to be witnessed.
DEFINITION 16 A full left expansion for a mosaic (A, B, C) is any finite, possibly empty, composing sequence of mosaics h(A1 , B1 , C1 ), (A2 , B2 , C2 ), ..., (An , Bn , Cn )i such that Cn = A composes with (A, B, C) and for all S(a, b) [?]
A there is some i with 1 <= i <= n such that a [?]
Ai , b [?]
Bj (all j >= i) and b [?]
Cj (all j, i < j < n).
Full right expansion is mirror.
We say that a triple of finite sequences of mosaics is a full expansion of a mosaic iff it consists of a full left expansion, a full decomposition and a full right expansion of the mosaic.
Note that a perfect mosaic m has (hi, hmi, hi) as a full decomposition.
3.3  Satisfiability of Mosaics  In this subsection we define a notion of satisfiability for mosaics and relate the satisfiability of formulas (which is our ultimate interest) to that of mosaics.
DEFINITION 17 Say that ph-mosaic m is satisfible iff there is T and x < y from T such that m = mosphT (x, y).
LEMMA 18 Each satisfiable mosaic has a full expansion consisting only of satisfiable mosaics.
PROOF: Consider ph, T and x, y [?]
T such that x < y.
Let m = (A, B, C) = mosT ph (x, y).
We will work on the left expansion, decomposition and right expansion separately.
First consider the decomposition.
There are three types of internal defect.
1. a formula d = U (a, b) [?]
A with b 6[?]
B.
In this case there must be u [?]
T such that x < u < y and T , u |= a and for all s [?]
T with x < s < u we have T , s |= b.
Let ud = u.
2.
S(a, b) is mirror.
3. a formula d = b [?]
Cl(ph) such that !b 6[?]
B.
In this case there must be v [?]
T such that x < v < y and T , v |= b.
Let vd = v.  10  Put the various ud and vd in a sequence in order as z1 < z2 < ... < zn .
The decomposition is simply hmos(x, z1 ), mos(z1 , z2 ), ..., mos(zn-1 , zn ), mos(zn , y)i.
It is clear that we have a full decomposition and that all the mosaics are satisfiable.
Now consider a left expansion.
(The right expansion is mirror.)
Suppose that we have a formula d = S(a, b) [?]
A.
In this case there must be u [?]
T such that u < x and T , u |= a and for all s [?]
T with u < s < x we have T , s |= b.
Let ud = u.
Put the various ud in a sequence in order as z1 < z2 < ... < zn < x.
The left expansion is simply hmos(z1 , z2 ), ..., mos(zn-1 , zn ), mos(zn , x)i.
It is clear that we have a full left expansion and that all the mosaics are satisfiable.
 A mosaic for ph is a ph-mosaic (A, B, C) such that either ph [?]
A or ph [?]
C. Thus a formula is satisfiable iff it has a one point model or there is a satisfiable mosaic for it.
4  The Game  Our US/LIN satisfiability procedure will be to guess a mosaic (A, B, C) for ph and then check that (A, B, C) is satisfiable.
Thus we now turn to the question of deciding whether a mosaic is satisfiable.
This is done via a game.
We introduce a game for two players.
The game can be used to summarise the organisation of a structured collection of mosaics so that we can effectively find cures for any defects in any mosaic in the collection.
DEFINITION 19 For each ph in the language L(U, S) and each ph-mosaic m, there is a two-player game called the m-game.
The players, A and E say, have alternate moves.
E has the first move.
If m has no defects then E wins immediately.
Otherwise, E must place a triple of finite sequences of ph-mosaics on the table which, taken in order, form a full expansion of m. Then, and subsequently, there will be a sequence of mosaics on the table and A's move is to choose one of them.
If there is no defect in this mosaic then E wins.
Otherwise, E must clear the table and present a full expansion of the chosen mosaic.
Then it is A's turn again.
If E fails to be able to make a legal move then she loses.
If the game continues for o moves then E wins.
A strategy for a player is just a map which specifies possible next moves for the player at each round: given the sequence of moves up until the player's turn in some finite round, the map defines a set of possible moves.
We say that a player plays according to a strategy if the player always selects a move from the set specified at each turn in the play of the game.
We say  11  that the strategy is winning iff the player wins every possible game in which he or she plays according to the strategy.
We will show that the satisfiability of mosaics is equivalent to the existence of a winning strategy for E. This is important as it provides a very natural foundation for many possible approaches to reasoning with linear temporal logics.
LEMMA 20 If m is satisfiable then E has a winning strategy in the game for m. PROOF: In fact, we know by lemma 18 above that if E ever has to fully expand a satisfiable mosaic then she can play so that all the mosaics which she uses are themselves satisfiable.
Thus, at the next move A loses or A has to choose a satisfiable mosaic.
By keeping this up E will go on to win.
 We now show that if E has a winning strategy in the game for a mosaic then the mosaic is satisfiable.
By playing many games at once we can use E's plays to gradually build up the details of a model of the mosaic.
First, note that if E has a winning strategy then she has a deterministic one, i.e.
at most one move is specified for every possible round.
Because she can win by making the game go on forever she can use a strategy which depends only on the mosaic in front of her and not on the history of play up until then: if she has a not necessarily deterministic strategy she just needs to fix on any one of the responses which she might use for any mosaic that arises.
LEMMA 21 Suppose that ph is a formula of L(U, S).
Say m is a ph-mosaic and that E has a winning strategy in the m-game.
Then m is satisfiable.
PROOF: Say m = (A0 , B0 , C0 ).
We will build a model of m from the limit of a construction in which a labelled structure is extended by the addition of new points at each step.
Unfortunately, we can not just examine one play of the game to build the structure because any one play will only be concentrating on an ever diminishing local region of the structure.
Thus, we need to start off an infinite number of plays of the game and at each step we divide the set of plays up into infinite subsets each of which is concentrating on one part of the structure.
The infinitely many plays of the m-game, called game instances, are played in parallel with E using her deterministic winning strategy in each one.
So we need to suppose that we have o copies of the game table, o copies of the player E and o 12  copies of the player A.
For each i < o, the ith game instance will have the ith version of E sitting across the ith version of the table from the ith version of A.
By progressively dividing up the set of game instances into subsets, we build a model of m. We shall specify the play of A in each of these game instances.
Some of the concurrently played games may go on forever but some A will lose finitely.
At the start of the ith round there will be an infinite set Gi(r,s) of game instances for each adjacent r < s from a finite set Qi of rationals.
The Gi(r,s) are all disjoint.
All the game instances in any Gi(r,s) will agree up to the ith round.
We will also define a map mi from adjacent pairs of rationals in Qi into the set of ph-mosaics.
For adjacent r, s from Qi , mi (r, s) will be one of the mosaics on the table at the start of the ith round in any game in Gi(r,s) .
Finally, we will define a maximally propositionally consistent set l(r) of formulas (from Cl(ph)) for each r which ever appears in any Qi .
Each mi (r, s) will start with l(r) and end with l(s), i.e.
the start of mi (r, s) is l(r) and the end of mi (r, s) is l(s) independently of i.
We make sure that the following inheritance conditions are preserved (for each i < j): * if r <= r ' < s' <= s, r and s are adjacent in Qi , and r ' and s' are adjacent in Qj then the cover of mj (r ' , s' ) contains the cover of mi (r, s); * if r < t < s, r and s are adjacent in Qi , and t [?]
Qj then l(t) contains the cover of mi (r, s).
We start with one infinite set G0(0,1) containing all o of the game instances, Q1 = {0, 1}, m1 (0, 1) = (A0 , B0 , C0 ), l(0) = A0 and l(1) = C0 .
In all games, (A0 , B0 , C0 ) is on the table.
Now we are ready to move on to round 1.
During the parallel playing of all the game instances we proceed as follows.
At the start of the ith round we consider each adjacent pair r < s from Qi separately.
If the games in Gi(r,s) have not finished then we get all the player As in these games to choose the mosaic mi (r, s) which is one of those on the table.
If there is no defect in mi (r, s) then those games just stop (E has won).
If there is a defect in mi (r, s) then, as E is using a winning strategy, she will choose a full expansion of that mosaic.
Now we define Qi+1 , Gi+1 and mi+1 .
Qi+1 contains Qi .
Into Qi+1 we also put n - 1 distinct rationals between r and s if E played a decomposition of length n (as part of the expansion) in 13  the games in Gi(r,s) .
For each adjacent pair r < s from Qi for i which the games in Gi(r,s) have all stopped, we put Gi+1 (r,s) = G(r,s) and mi+1 (r, s) = mi (r, s).
We actually ignore external witnesses, i.e.
the left and right expansion parts of the play, unless s is the greatest element of Qi or r is the least (or both).
However, if s is the greatest element of Qi , and r is second greatest, then look at the right expansion played by E in Gi(r,s) .
If E played a right expansion of length n then put n new points of Q after s in Qi+1 .
(Similarly use a left expansion for the smallest element of Qi .)
For each adjacent pair r < s from Qi , if an n long decomposition was played in Gi(r,s) , and so Qi+1 contains r < r1 < r2 < ... < rn-1 < s, we divide the games in Gi(r,s) into n disi+1 i+1 joint infinite sets and call these Gi+1 (r,r1 ) , G(r1 ,r2 ) , ..., G(rn-2 ,rn-1 )  and Gi+1 (rn-1 ,s) .
We define mi+1 (r, r1 ) to be the first mosaic in the decomposition, each mi+1 (rj , rj+1 ) to be the (j + 1)th mosaic in the decomposition and mi+1 (rn-1 , s) to be the last mosaic in the decomposition.
For the greatest adjacent pair r < s from Qi , if an n long right expansion was played in Gi(r,s) , and so Qi+1 contains s < r1 < r2 < ... < rn , we reserve another disjoint infinite subset of Gi(r,s) and we divide it into n disjoint infinite sets and call these Gi+1 (s,r1 ) ,  i+1 i+1 Gi+1 (r1 ,r2 ) , ..., G(rn-2 ,rn-1 ) and G(rn-1 ,rn ) .
We define mi+1 (s, r1 ) to be the first mosaic in the expansion, each mi+1 (rj , rj+1 ) to be the (j + 1)th mosaic in the expansion and mi+1 (rn-1 , rn ) to be the last mosaic in the expansion.
The definition of composition allows us to see that our inheritance conditions are preserved.
Some of the games may go on forever.
Nevertheless, the E player will win them all.S Now we define T = Qi and order it via the usual ordering on rationals.
Then we define a structure T = (T, <, h) where h is defined by r [?]
h(p) iff p [?]
l(r), for any atom p [?]
L. We are almost done when we prove the truth lemma 22 below.
Assume that we have proved that now.
To complete the main proof, we just need check that the inheritance conditions and truth lemma give us m = mosphT (0, 1).
It is clear that A0 contains exactly the formulasTtrue at 0 and C0 those at 1.
Certainly B0T[?]
s[?
](0,1) l(s) by inheritance.
To see that s[?
](0,1) l(s) [?]
B0 suppose that b [?]
Cl(ph) \ B0 .
Thus !b is a type 3 defect in m and will be cured in the very first move by E in all the game instances.
Suppose that the witness  14  to the cure is put at rj [?]
(0, 1) in Q2 .
Thus !b [?]
l(rj ).
We are done.
 So it remains to prove the truth lemma: LEMMA 22 For each r [?]
T and a [?]
Cl(ph), T , r |= a iff a [?]
l(r).
PROOF: We proceed by induction on the construction of a.
The cases of atoms, truth and the Boolean connectives are straightforward.
The harder cases concern both directions for a formula U (a, b).
(S(a, b) is mirror.)
(=) Suppose T , r |= U (a, b).
So there is some s [?]
T such that r < s, T , s |= a and for each t [?]
T , if r < t < s then T , t |= b.
By the induction hypothesis a [?]
l(s) and b [?]
l(t) for any such t. We need to show U (a, b) [?]
l(r).
Suppose for contradiction that !U (a, b) [?]
l(r).
Now look at any Qi containing both s and r. Let r ' be the greatest element of Qi which is less than s but for which we have !U (a, b) [?]
l(r ' ).
So r <= r ' < s. Let s' [?]
Qi be the next biggest element of Qi after r ' .
Say that mi (r ' , s' ) = (A, B, C).
We may have s' = s or s' < s. If s = s' we have !U (a, b) [?]
l(r ' ) and a [?]
l(s' ).
Coherency condition 1 gives us b 6[?]
B.
If s' < s, U (a, b)) [?]
l(s' ) (by definition of r ' ) and b [?]
l(s' ) (as r < s' < s).
Coherency condition 1.2 gives us b 6[?]
B.
In either case, b 6[?]
B, and we know that mi (r ' , s' ) is a mosaic with a type 3 defect !b.
Thus all the games in Gi(r' ,s' ) will continue to the (i + 1)th round.
The defect !b can not be cured at this stage as we know b [?]
l(t) for any t between r and s. But E must have played a full decomposition (as part of the full expansion) and we have a contradiction.
(=) Suppose U (a, b) [?]
l(r).
Find i with r [?]
Qi and some adjacent pair r ' < s' in Qi with r <= r ' and at least one of the following properties of (A' , B ' , C ' ) = mi (r ' , s' ) holding: 1. b and U (a, b) are not both in B ' , 2. b and U (a, b) are not both in C ' , 3.
!a is not in B ' , 4. or a is in C ' .
To see that there is such an i, r ' and s' suppose not for contradiction.
Choose any i.
Thus U (a, b) holds in the end of 15  mi (r '' , s'' ) where s'' is the last element of Qi and r '' is the penultimate one.
Thus mi (r '' , s'' ) has a defect and each game in Gi(r'' ,s'' ) continues.
Look at the full right expansion of mi (r '' , s'' ) played by E in these games.
There will be a cure for the U (a, b) defect played.
Thus in Qi+1 there is some r ' < s' with mi+1 (r ' , s' ) = (A' , B ' , C ' ) with a [?]
C ' .
This is our contradiction.
Assume we have the first such r ' < s' in some Qi .
Note that U (a, b) [?]
l(r ' ) as either r = r ' or, if r < r ' , then we could replace r ' by its predecessor (and have property 2 hold).
We are looking for some s > r from T such that a [?]
l(s) and for all t [?]
T with r < t < s, b [?]
l(t).
The inductive hypothesis will then give us the result.
Furthermore, as we will see, thanks to the inheritance conditions, it will do if we find some j >= i, some s [?]
Qj , such that 1. r ' < s, 2. a [?]
l(s), 3. for each adjacent v < w from Qj , if r ' <= v < w <= s, we have b in the cover of mj (v, w), and 4. for each adjacent v < w from Qj , if r ' < v < w <= s, we have b in the start of mj (v, w).
Either we are done already if a [?]
l(s' ) and b is in the cover of mi (r ' , s' ), or we can show that mi (r ' , s' ) = (A' , B ' , C ' ) has what we will call a useful defect: 1.
U (a, b) [?]
l(r ' ) = A' and b 6[?]
B ' so we have a type 1 defect; or 2.
!a 6[?]
B ' and we have a type 3 defect.
To see this suppose (A' , B ' , C ' ) does not have such a useful defect.
Thus we have b [?]
B ' and !a [?]
B ' .
We already know that U (a, b) [?]
l(r ' ) = A' and we have assumed a 6[?]
l(s' ) = C ' (as we noted that we would have already found s = s' if a [?]
l(s' ) and b [?]
B ' ).
By coherency 3, U (a, b) [?]
B ' and by coherency 2, both b [?]
C ' and U (a, b) [?]
C ' .
This all contradicts the definition of r ' , s' .
The existence of the useful defect in mi (r ' , s' ) shows that the games in Gi(r' ,s' ) continue for another round at least.
E's play gives us a full decomposition for mi (r ' , s' ) which is allocated to some r ' < r1 < r2 < ... < rn-1 < s' in round i + 1 of the construction.
The witness s = ra to the cure of the useful defect in this decomposition is the s we are looking for.
This s will do as a [?]
l(s), b is in the cover of all mosaics between r and r ' and in starts or ends of mosaics strictly between in the ith round, and b is in the cover of all mosaics between 16  r ' and s and in starts or ends of mosaics strictly between in the (i + 1)th round (if we had needed to go on for this next round to find s).
By inheritance we are done.
  4.1  The length of full decompositions  In proposing procedures for checking for full decompositions it is useful to know how many mosaics might be needed.
We can easily find an exponential upper bound.
LEMMA 23 Suppose ph is a formula of L(U, S) of length N and m is a ph-mosaic.
If m has a full decomposition hm1 , m2 , ..., mK i then it has a full decomposition of length <= 29N using only the mi .
PROOF: First note that there are at most 2N formulas in the closure of ph and so there are at most 26N different ph-mosaics.
Suppose that m has a full decomposition m1 , m2 , ..., mK .
We show that we can throw away some of these if K > 29N .
For each internal defect in m, of which there are at most 4N , choose a mosaic mi from the full decomposition which witnesses the cure and call that mosaic important.
I claim that if there are any mosaics repeated in between successive important mosaics in the decomposition then we can chop out one copy of the repeated mosaic and all the mosaics in between the two copies and still be left with a full decomposition.
It is easy to check that the shorter sequence still composes and that it still contains cures for the defects in m. Continuing to chop in this way leaves us with at most 26N mosaics in between important mosaics.
Thus we have a full decomposition of length at most 4N.
(26N + 1) <= 29N .
 There are similar results for left and right expansions which are proved in an analagous way.
LEMMA 24 Suppose ph is a formula of L(U, S) of length N and m is a ph-mosaic.
If m has a full right (resp.
left) expansion hm1 , m2 , ..., mK i then it has a full right (resp.
left) expansion of length <= 29N using only the mi .
4.2  Using games to decide L(U, S)  We finish the section by summarising the relationship between the mosaic games and our decision problem.
We also show that this relationship gives  17  us a powerful tool for reasoning with linear time (and related logics): we can easily get a decision procedure albeit not the most efficient.
Putting together lemmas 21 and 20 we have: THEOREM 25 Suppose that ph is a formula of L(U, S).
Then ph-mosaic m is satisfiable iff E has a winning strategy in the game for m. This relationship and the simple form of the mosaic game immediately give us a decision procedure.
The general idea comes from [Pra79].
Suppose that we want to decide whether ph is satisfiable.
Look for a phmosaic m such that E has a winning strategy in the game for m. If there is such an m, it can be found by considering the set of all ph-mosaics at once.
Say that the length of ph is N so that the length of Cl(ph) is at most 2N .
There are only 26N sets of formulas from Cl(ph) so there are at most 26N ph-mosaics.
Start with the set S containing all the ph-mosaics.
In the procedure, we loop around doing some checks and removing mosaics from S. Each loop we check whether there is any ph-mosaic at all inside S. If there is not then we can stop and conclude that ph is unsatisfiable.
If S does contain a ph-mosaic then we continue.
We go through each mosaic m in S and check whether m has a full expansion into mosaics from S. As we will see, in the context of this procedure, S is closed under composition, and so this only requires checking for decompositions of length 13N because there are only 12N possible internal defects in each mosaic.
If m has no such full decomposition then mark it for removal.
Similarly for external defects.
After checking all mosaics in m then remove all the marked ones.
If any mosaics are removed then repeat the process.
Otherwise we can stop and conclude that ph is satisfiable.
The correctness of the procedure follows easily from the theorem above.
It is clear that S is indeed always closed under composition because concatenation of full decompositions/left expansions/right expansions gives us a full decomposition/left expansion/right expansion of a composition.
It is straightforward to check that the procedure terminates in exponential time and we have: THEOREM 26 LUS-SAT is in EXPTIME.
It should be noted that [Rey10a] shows that LUS-SAT is actually in PSPACE.
The proof there is by translating LUS-SAT into a satisfiability query in terms of sub-orders of the real-line and then using the PSPACE decision procedure for RTL from [Rey10b].
That result in turn involves a tree of mosaics and their decompositions.
By establishining limits on the depth of the tree (a polynomial in terms of the length of the formula) and on the branching factor (exponential) we can ensure that we have a PSPACE 18  algorithm as we only need to remember a small fixed amount of information about all the previous siblings of a given node.
5  Tableaux  Most of the work on temporal tableaux involves a move away from the traditional tree-shaped tableau building process of other modal logics.
The standard approach for temporal logics is, as we have done already in this paper, to start with a graph and repeatedly prune away nodes, according to certain removal rules, until there is nothing more to remove (success) or some failure condition is detected.
This approach is seen for the linear PLTL in [Wol85] and [Gou89] and for the simple branching CTL in [EC82] and [EH85].
The PLTL tableau in [Sch98] and the CTL* tableau in [Rey09b] are interesting because of the return to a tree shape.
We also want to use a tree tableau approach to decide validity of a formula in US/LIN.
We will start with a formula ph and determine whether ph is satisfiable in US/LIN or not.
To decide validity simply determine satisfiabilty of the negation.
The tableaux we construct will be roughly tree-shaped, albeit the traditional upside down tree with a root at the top: predecessors and ancestors above, successors and descendants below.
They can be thought of as structures for organising and representing winning strategies in the mosaic games.
We imagine trees growing downwards from the root.
A node may have children immediately below it, every node except the root has a unique parent.
Each node itself and its parent and the parent's parent and the parent's parent's parent e.t.c.
form the set of ancestors of the node.
We will also impose an earlier-later relation between siblings (children of the same parent) on some trees and represent it by left-to-right ordering in diagrams.
Here are the basic definitions.
DEFINITION 27 1.
A tree here is just a set (of nodes), with a binary successor relation determining (as its transitive closure) a derived, reflexive, anti-symmetric, transitive, ancestor relation such that the set of ancestors of any node is finite and well-ordered (by the ancestor relation) and there is a unique root with no ancestors (apart from itself ).
2.
If node x has a successor y then we say that x is the parent of y (it is unique) and y is a child of x.
Any other child of x is called a sibling of y.
A node with no children will be called a leaf node.
3.
The depth of a node with n ancestors is n. 4.
An ordered tree is a tree with finite numbers of children for each node and a left-right relation which totally orders siblings.
The left-right relation does not relate non-siblings.
19  5.
A ph-mosaic labelled tree is a partial map from nodes of a tree to ph-mosaics.
The map is partial as, in certain circumstances, we will allow some leaf nodes to be un-labelled, or null-labelled.
In this paper trees will be drawn with the root at the top and children below parents joined by lines.
The left to right ordering will be just that across the page.
The idea, as we will see, is that generally the labels of the children of a node form a full decomposition for the label of the node.
However, we have to further elaborate our trees to provide for left and right expansions.
As we will show later, this is only needed for the nodes on the left-most or right-most branches.
The left-most branch is just that consisting of the root, its left-most child, and that nodes left-most child, etc until (if) we reach a leaf.
Thus we require any non-leaf node on the left-most branch to have one or more of its left-most children being denoted as left-expanding children.
Simarly on the right-most branch.
In our diagrams we indicate these by putting - or + (for left and right, respectively) on the lines to these children.
DEFINITION 28 A (non-singleton) tableau (for ph-mosaic m) is a phmosaic labelled ordered tree with (0) root labelled by m; (1) each node having a non-null label apart from possibly the leaf-node on the left-most branch and the leaf-node on the right-most branch; (2) each non-leaf node on the left-most branch (and no other nodes) having one or more of its left-most children being left-expanding children; (3) similarly right; (4a) the labels of the left-expanding children of any node (which has such) taken in order forming a full left-expansion of the label on the node; (4b) a node which has one left-expanding child with a null label must have a mosaic label with no left defects; (5) similarly right; (6) the labels on the non-expanding children of any non-leaf node taken in order forming a full decomposition of the label on the node.
DEFINITION 29 Define a leaf node to be a clone iff it has the same label as one of its other ancestors.
Define a complete node of a tableau to be either a non-leaf, a clone leaf node or a null-labelled leaf.
Define a successful tableau as one in which all nodes are complete (otherwise the tableau is incomplete).
5.1  Examples  Here we provide some short examples of mosaics and tableaux.
Diagrams show tableaux as trees growing down from the root.
Left to right ordering of child nodes is across the page.
Left-expanding children are indicated by [?]
-, right by +.
Successful branches are indicated by .
20  {ph, U (U (q, p), p), !U (q, p), p, q}, Clph, {!ph, !U (U (q, p), p), U (q, p), !p, !q}  21  null  - {ph, U (U (q, p), p), !U (q, p), p, q}, Clph, {!ph, !U (U (q, p), p), U (q, p), !p, !q}  [?]
[?]
+ {!ph, !U (U (q, p), p), U (q, p), !p, !q}, Clph, {!ph, !U (U (q, p), p), !U (q, p), !p, q} + {!ph, !U (U (q, p), p), U (q, p), !p, !q}, Clph, null {!ph, !U (U (q, p), p), !U (q, p), !p, q} [?]
Figure 1: Tableau for ph = U (U (q, p), p) [?]
!U (q, p)  [?]
(A, D, C) - null  (A, D, C)  + (C, E, B)  (B, E, C)  +  (C, E, B)  (B, E, C) +  [?]
[?]
+  22  (C, E, B)  (B, E, C)  (C, E, B)  (B, E, C)  (C, E, B)  (B, E, C)  [?]
[?]
[?]
[?]
(C, E, B)  [?]
[?]
Figure 2: Tableau for ph = !U (!p, p) [?]
!U (p, !p): the sets named in the tableau are defined in Figure 3.
A= B= C= D= E=  {ph, !U (!p, p), !U (p, !p), p} {!ph, !U (!p, p), U (p, !p), !p} {!ph, U (!p, p), !U (p, !p), p} {!ph} Clph  Figure 3: Sets seen in the tableau for ph = !U (!p, p) [?]
!U (p, !p) in Figure 2 See the example in Figure 1 for a successful tableau for ph = U (U (q, p), p)[?]
!U (q, p).
Here the second and third successful branches terminate in clones.
See the example in Figure 2 for a successful tableau for ph = !U (!p, p) [?]
!U (p, !p).
The sets named in the tableau are defined in Figure 3.
Example 3: an unsatisfiable mosaic: ({!U (!p, q), p, q}, {!p, q, !U (!p, q)}, {p, q, !U (!p, q)}).
As p is not in the cover, it is a type 3 defect.
However, any cure will not be consistent with !U (!p, q) holding at the start.
Example 4: a perfect mosaic for U (p, q) is ({p, q, U (p, q)}, {p, !p, q, !q, U (p, q), !U (p, q)}, {p, q, !U (p, q)}).
5.2  Sound and Complete  In this section we show that the US/LIN tableau approach is sound and complete for deciding satisfiability of mosaics.
We will see that we can use tableaux to organise and present strategies for E in mosaic games.
The labels on the children of a node provide a possible play for E if A chooses the label on the node.
A play of a game can continue in such a way down a branch.
The non-expanding children of the node give a full expansion directly.
We will see that we can also find left and right expansions from the labels.
The converse is immediate: strategies give tableaux.
LEMMA 30 A ph-mosaic m has a successful tableau iff E has a winning strategy for the game on m. PROOF: We first show that if a ph-mosaic m has a complete tableau then E has a winning strategy in the game on m. First note that for every mosaic appearing as a label in the tree we can find directly from the tree a full decomposition consisting only of mosaics which also appear as labels.
If a label appears on a clone node then it will also appear on an ancestor 23  node which does sport a full decomposition.
Thus E simply uses those to determine the full decomposition part of her plays.
The slightly hard part is to see that we can also extract full left (resp.
right) expansions for any mosaic in the tree also from the tree.
We will examine the full left expansion as the full right expansion argument is mirror.
Suppose that mosaic m' appears as the label of a node in the tree.
Choose any node x which is labelled with m' .
Let x0 be the most recent ancestor of x which is on the left-most branch of the tree.
So x0 may be the root.
Let hx0 , x1 , x2 , ..., xn i be the sequence of ancestors of x in order from x0 down to x = xn .
Let p be a possibly empty full left expansion of the label of x0 .
This can be read directly as the labels of the left expanding children of x0 .
For each i = 0, 1, 2, ..., n - 1 do the following.
Suppose that the non-expanding children of xi are in left to right order hy1 , y2 , ..., yu , xi+1 , z1 , z2 , ..., zv i.
Let ti be the possibly empty sequence of mosaic labels of just the y1 , y2 , ..., yu in order.
Note that thus this is a composing sequence of mosaics.
If it is empty, i.e.
if u = 0, then the start of the label of xi+1 equals the start of the label of xi .
Otherwise, the start of the first mosaic in ti is the same as the start of xi and the end of the last mosaic in ti is the same as the start of xi+1 .
Let r be t0 [?]
t1 [?]
...
[?]
tn-1 .
This is actually a composing sequence of mosaics: this follows from the matching of starts and ends with the labels of the xi as just observed.
Note also that the start of the first mosaic in r is the start of the label of x0 and the end of the last mosaic in the sequence r is the same as the start of m' .
Let s consist of a concatenation of full decompositions of the respective mosaics in r in order.
We know that we can find full decompositions for each of the mosaics in r from the tableau.
This is also a composing sequence of mosaics as the starts and ends match.
We claim that p [?]
s is a full left expansion of m' .
To see this consider a formula S(a, b) in the start of m' .
Note that this formula also appears in the end of the last mosaic in r as that equals the start of m' .
Now find the largest index i such that ri either has a start containing a or a cover not containing !a.
If there is no such i then !a is in every start and !a is in every cover of every mosaic in r. A simple induction using the coherency of the mosaics in r (condition C4) and the fact that S(a, b) will be in the end thus shows us that b is also in every 24  start and every cover.
Also S(a, b) will be in the start of r0 (and all the other starts) which is the start of the label of x0 .
Thus one can find a witness to it from the left expansion p (then continuing on through s).
Now consider the case when ri starts with a or has a type 3 defect of a.
The full decomposition of ri in s will give us our witness.
That completes the forward part.
Conversely, if E has a winning strategy (without loss deterministic) in the game on m, then writing out her plays in all possible games on m, gives us a successful tableau.
Note that if a game finishes with a mosaic with no internal defects then, in the tableau, it may be necessary to add a clone node to that node to complete the branch.
  5.3  Using tableaux to decide US/LIN  We have seen that tableaux are useful for checking satisfiability of mosaics.
To decide satisfiability of US/LIN formulas is closely related.
It is also easy, after a few preliminary definitions.
One complication is that some formulas such as !U ([?
], [?])
[?]
!S([?
], [?])
are satisfiable but only have one point models.
To handle them we can not use mosaics (at least as we have defined them).
Instead, we simply invent a special basic one set tableau.
This is just an MPC set of subformulas of ph with the proviso that it contains no until formulas no sinces.
DEFINITION 31 A singleton tableau for a formula ph is a separate special structure just consisting of an MPC subset of the closure of ph which contains no formulas of the form U (a, b) or S(a, b).
Thus, if U (a, b) is in the closure set then !U (a, b) must be in the tableau set.
Such a tableau can be used for formulas that have one point models (a special case of a linear model).
LEMMA 32 ph has a one point model iff ph has a successful singleton tableau.
PROOF: The tableau D is related to the one point model M by D = {a [?]
Clph|M, 0 |= ph} where 0 is the one element of the domain of M .
 This allows us to now prove our main result.
THEOREM 33 ph is satisfiable iff ph has a successful tableau.
25  PROOF: (=) Suppose ph is satisfiable.
If ph has a one-point model then lemma 32 tells us that ph has a successful (singleton) tableau.
Otherwise, there is a non-singleton linear order (T, <) with valuation g for the atoms and x [?]
T such that (T, <, g), x |= ph.
In this case choose some other y [?]
T .
Assume that x < y: the other case is similar.
(T,<,g) Thus m = mosph (x, y) is satisfiable and is a mosaic for ph.
By Theorem 25, E has a winning strategy in the game on m. By lemma 30, m has a successful tableau.
(=) If ph has a singleton tableau then use lemma 32.
Otherwise, ph appears in the start or end of a mosaic m and m has a successful tableau.
So, by lemma 30, E has a winning strategy in the game for m. Thus, by Theorem 25, m is satisfiable and clearly any model of m is a model of ph.
  6  Termination, Complexity and Implementation Issues  It is easy to see that because we can, without loss of generality, stop at clone nodes, and limit branching factors, only a finite number of different tableaux need be considered for a formula.
However, that is the end of the good news.
There is an exponential bound on the number of different mosaics for a formula (in terms of its length).
This also bounds the length of branches in a tableau.
With an exponential bound on the branching factor (lemmas 23 and 24) we thus have a double exponential bound on the size of any tableau in terms of number of nodes.
There is thus a triple exponential bound on the number of tableaux.
LEMMA 34 There is a finite bound on the number of tableaux for ph, triple exponential in the length of ph.
The complexity of reasoning using such tableaux is thus triple exponential time.
A simple Java implementation shows that any direct implementation of this tableau technique is quickly overwhelmed by the multi-exponential blow-up in data structures.
The number of mosaics for a formula is a particular problem if they all need to be generated and checked.
For example, the formula ph = U (p, q) of length 3 has 2, 304 different mosaics to consider; U (U (p, q), q) of length 5 has 22, 848 different mosaics; and 26  U (U (p, q), q) [?]
!U (p, q) of length 11 has 228, 864 mosaics.
Clearly, more intelligent techniques are needed to make practical use of this basic framework.
7  Conclusion and Future Work  We have traveled via mosaics and games to provide a sound and complete tableau reasoning system for the temporal logic of until and since over general linear time, a logic which underlies a full range of logics of linear time.
The syntactic checks involved in relating the labels of nodes in the tableau tree are quite straightforward.
However, there are blow-ups in the number of mosaics needing to considered which render any unsophisticated direct use of this technique impractical.
Instead, it is hoped that it can form the foundation for more intelligent tableau construction techniques.
Particular directions to pursue in future work include finding good heuristics for the choice of mosaics to expand nodes.
There is also potential for being clever in the construction of full expansions: for example, proceeding one defect at a time, to split a mosaic into two.
Also, it would be useful to develop a notion of partial mosaics to label nodes, whereby some formulas are specified to be in the start, end or cover, some specified to be out and others left undecided.
The other direction to work towards is modifying the tableau to work for closely related logics such as, most importantly, RTL, the logic of U and S over the reals.
As shown in recent work [Rey10c] this also leads us on to a practical metric temporal logic.
Also, as shown in [Rey10a], an RTL tableau can help with deciding many other linear temporal logics.
References [AH93]  Rajeev Alur and Thomas A. Henzinger.
Real-time logics: Complexity and expressiveness.
Inf.
Comput., 104(1):35-77, 1993.
[BG85]  J. P. Burgess and Y. Gurevich.
The decision problem for linear temporal logic.
Notre Dame J.
Formal Logic, 26(2):115-128, 1985.
[Bur82]  J. P. Burgess.
Axioms for tense logic I: "Since" and "Until".
Notre Dame J.
Formal Logic, 23(2):367-374, 1982.
[CHR91]  Zhou Chaochen, C. A. R. Hoare, and Anders P. Ravn.
A calculus of durations.
Information Processing Letters, 40(5):269-276, 1991.
27  [EC82]  E. Emerson and E. C. Clarke.
Using branching time temporal logic to synthesise synchronisation skeletons.
Sci.
of Computer Programming, 2, 1982.
[EH85]  E. Emerson and J. Halpern.
Decision procedures and expressiveness in the temporal logic of branching time.
J. Comp and Sys.
Sci, 30(1):1-24, 1985.
[Ehr61]  A. Ehrenfeucht.
An application of games to the completeness problem for formalized theories.
Fund.
Math., 49:128-141, 1961.
[Fit83]  M. Fitting.
Proof methods for modal and intuitionistic logics.
Reidel, 1983.
[Fra54]  Roland Fraisse.
Sur quelques classifications des systemes de relations, thesis, Paris, 1953.
Publications Scientifiques de l'Universite d'Alger, series A(1):35-182, 1954.
[GHR93]  D. M. Gabbay, I. M. Hodkinson, and M. A. Reynolds.
Temporal expressive completeness in the presence of gaps.
In J. Oikkonen and J. Vaananen, editors, Logic Colloquium '90, Proceedings ASL European Meeting 1990, Helsinki, number 2 in Lecture Notes in Logic, pages 89-121.
Springer-Verlag, 1993.
[GHR94]  D. Gabbay, I. Hodkinson, and M. Reynolds.
Temporal Logic: Mathematical Foundations and Computational Aspects, Volume 1.
Oxford University Press, 1994.
[Gor99]  R. Gore.
Tableau methods for modal and temporal logics.
In M. D'Agostino, D. Gabbay, R. Hahnle, and J. Posegga, editors, Handbook of Tableau Methods, pages 297-396.
Kluwer Academic Publishers, 1999.
[Gou89]  G. Gough.
Decision procedures for temporal logics.
Technical Report UMCS-89-10-1, Department of Computer Science, University of Manchester, 1989.
[Gur64]  Y. Gurevich.
Elementary properties of ordered abelian groups.
Algebra and Logic, 3:5-39, 1964.
(Russian; an English version is in Trans.
Amer.
Math.
Soc.
46 (1965), 165-192).
[HC68]  G. Hughes and M. Cresswell.
An Introduction to Modal Logic.
Methuen, London, 1968.
[HH02]  R. Hirsch and I. Hodkinson.
Relation algebras by games.
Studies in Logic and the Foundations of Mathematics, Volume 147.
North-Holland, 2002.
28  [HHM+ 99] Robin Hirsch, Ian Hodkinson, Maarten Marx, Szabolcs Mikulas, and Mark Reynolds.
Mosaics and step-by-step - remarks on 'a modal logic of relations' by venema marx.
In Logic at Work.
Essays Dedicated to the Memory of Helena Rasiowa, volume 24 of Studies in Fuzziness and Soft Computing, pages 158-167.
Springer-Verlag, 1999.
[HS86]  J. Halpern and Y. Shoham.
A propositional modal logic of time intervals.
In Proceedings, Symposium on Logic in Computer Science.
IEEE, Boston, 1986.
[Kam68]  H. Kamp.
Tense logic and the theory of linear order.
PhD thesis, University of California, Los Angeles, 1968.
[KMP94]  Y. Kesten, Z.
Manna, and A. Pnueli.
Temporal verification of simulation and refinement.
In A decade of concurrency: reflections and perspectives: REX school/symposium, Noordwijkerhout, the Netherlands, June 1-4, 1993, pages 273-346.
Springer- Verlag, 1994.
[LS02]  Martin Lange and Colin Stirling.
Model checking games for branching time logics.
J. Log.
Comput., 12(4):623-639, 2002.
[MMR00]  M. Marx, S. Mikulas, and M. Reynolds.
The mosaic method for temporal logics.
In R. Dyckhoff, editor, Automated Reasoning with Analytic Tableaux and Related Methods, Proceedings of International Conference, TABLEAUX 2000, Saint Andrews, Scotland, July 2000, LNAI 1847, pages 324-340.
Springer, 2000.
[Nem95]  I. Nemeti.
Decidable versions of first order logic and cylindricrelativized set algebras.
In L. Csirmaz, D. Gabbay, and M. de Rijke, editors, Logic Colloquium '92, pages 171-241.
CSLI Publications, 1995.
[Pnu77]  A. Pnueli.
The temporal logic of programs.
In Proceedings of the Eighteenth Symposium on Foundations of Computer Science, pages 46-57, 1977.
Providence, RI.
[Pra79]  V. R. Pratt.
Models of program logics.
In Proc.
20th IEEE.
Symposium on Foundations of Computer Science, San Juan, pages 115-122, 1979.
[Rab98]  A. Rabinovich.
On the decidability of continuous time specification formalisms.
Journal of Logic and Computation, 8:669-678, 1998.
29  [RD05]  M. Reynolds and C. Dixon.
Theorem-proving for discrete temporal logic.
In M. Fisher, D. Gabbay, and L. Vila, editors, Handbook of Temporal Reasoning in Artificial Intelligence, pages 279-314.
Elsevier, 2005.
[Rey03]  Mark Reynolds.
The complexity of the temporal logic with "until" over general linear time.
J. Comput.
Syst.
Sci., 66(2):393- 426, 2003.
[Rey09a]  Mark Reynolds.
Dense time reasoning via mosaics.
In Carsten Lutz and Jean-Francois Raskin, editors, TIME 2009, pages 3-10.
IEEE Computer Society, 2009.
[Rey09b]  Mark Reynolds.
A tableau for CTL*.
In FM 2009: Formal Methods, Second World Congress, Eindhoven, The Netherlands, November 2009.
Proceedings, volume 5850, pages 403 - 418.
Springer LNCS, 2009.
[Rey10a]  M. Reynolds.
The complexity of decision problems for linear temporal logics.
Journal of Studies in Logic, 3:19-50, 2010.
[Rey10b]  M. Reynolds.
The complexity of temporal logic over the reals.
Ann.
Pure Appl.
Logic, 161(8):1063-1096, 2010.
[Rey10c]  M. Reynolds.
Metric temporal logic revisited, submitted 2010.
[SC85]  A. Sistla and E. Clarke.
Complexity of propositional linear temporal logics.
J. ACM, 32:733-749, 1985.
[Sch98]  Stefan Schwendimann.
A new one-pass tableau calculus for PLTL.
In Harrie C. M. de Swart, editor, TABLEAUX, volume 1397 of Lecture Notes in Computer Science, pages 277-292.
Springer, 1998.
[Wol85]  P. Wolper.
The tableau method for temporal logic: an overview.
Logique et Analyse, 28:110-111, June-Sept 1985.
[Xu88]  Ming Xu.
On some U, S-tense logics.
J. of Philosophical Logic, 17:181-202, 1988.
30