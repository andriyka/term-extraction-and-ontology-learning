Journal of Applied Logic 4 (2006) 141a167 www.elsevier.com/locate/jal  A clausal resolution method for extended computation tree logic ECTL Alexander Bolotov a , Artie Basukoski Harrow School of Computer Science, University of Westminster, HA1 3TP, UK Available online 21 July 2005  Abstract A temporal clausal resolution method was originally developed for linear time temporal logic and further extended to the branching-time framework of Computation Tree Logic (CTL).
In this paper, following our general idea to expand the applicability of this efficient method to more expressive formalisms useful in a variety of applications in computer science and AI requiring branching time logics, we define a clausal resolution technique for Extended Computation Tree Logic (ECTL).
The branching-time temporal logic ECTL is strictly more expressive than CTL in allowing fairness operators.
The key elements of the resolution method for ECTL, namely the clausal normal form, the concepts of step resolution and a temporal resolution, are introduced and justified with respect to this new framework.
Although in developing these components we incorporate many of the techniques defined for CTL, we need novel mechanisms in order to capture fairness together with the limit closure property of the underlying tree models.
We accompany our presentation of the relevant techniques by examples of the application of the temporal resolution method.
Finally, we provide a correctness argument and consider future work discussing an extension of the method yet further, to the logic CTLa , the most powerful logic of this class.
AS 2005 Elsevier B.V. All rights reserved.
Keywords: Branching-time; Automated deduction; Resolution; Program specification and verification  * Corresponding author.
E-mail addresses: a.bolotov@wmin.ac.uk (A. Bolotov), a.basukoski@wmin.ac.uk (A. Basukoski).
1570-8683/$ a see front matter AS 2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.jal.2005.06.003  142  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  1.
Introduction A Computation Tree Logic (CTL), first proposed in [9], and its extensions have shown to play a significant role in potential applications [11].
CTL does not permit boolean combinations of formulae with temporal operators or their nesting.
Two combinations of future time temporal operators aS (asometimea) and  (aalwaysa), are useful in expressing fairness [10]: aSp (p is true along the path of the computation except possibly some finite initial interval of it) and aSp (p is true along the computation path at infinitely many moments of time).
The logic ECTL (Extended CTL [12]) bridges this gap in CTL expressiveness, admitting simple fairness constraints.
While ECTL is strictly more expressive than CTL, their syntactic and semantic features have much in common.
In [5,6] a clausal resolution approach to CTL was developed, extending the original definition of the method for the linear-time case [14].
In this paper, following our general aim to expand the applicability of the method to more expressive formalisms, we define it for the logic ECTL.1 As a normal form for ECTL, called SNFCTL , we utilise the Separated Normal Form developed for CTL formulae.
This enables us to apply the resolution technique defined over SNFCTL as the refutation technique for ECTL formulae.
The main contribution of this paper is the extension of the set of rules used to translate CTL formulae into SNFCTL by a novel transformation technique to cope with ECTL fairness.
SNFCTL can be used for more expressive formalisms, such as ECTL: in translating CTL or ECTL formulae into our normal form, similarly to the linear time case [7], we derive propositional formulae that are existentially quantified, and to utilise the normal form as part of a proof, we effectively skolemize them producing temporal formulae without any quantification.
The structure of the paper is as follows.
In Section 2 we introduce the logic ECTL, outlining the ECTL syntax in Section 2.1, its semantics in Section 2.2 and those properties of ECTL syntax and semantics that are important for our analysis in Section 2.3.
Further, in Section 3, we review SNFCTL .
In the next section, Section 4 we describe the translation of ECTL formulae into SNFCTL .
The translation algorithm which includes a novel transformation technique to cope with ECTL fairness constraints is given in Section 4.1.
Main rules invoked in this algorithm are given in Section 4.2.
Some of these rules are used in the example transformation which can be found in Section 4.3.
We conclude this section providing in Section 4.4 the correctness argument.
Note also that in this paper we present the full correctness argument which bridges the gap contained in the correctness proof contained in [3], where we only show that the transformation procedure preserves satisfiability: now we also establish that it preserves unsatisfiability.
Having provided the translation of ECTL formulae into SNFCTL , we represent all temporal statements within ECTL as sets of SNFCTL clauses.
Now, in order to achieve a refutation, we incorporate the temporal resolution method already defined over SNFCTL in [2,6].
The method is outlined 1 Note that while working on the preparation of this article the authors have developed the resolution technique for the logic ECTL+ , the extension of ECTL, allowing Boolean combination of fairness constraints [4], and are currently working on the extended version of this paper.
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  143  in Section 5, where we also apply the temporal resolution to a set of SNFCTL clauses (previously obtained in Section 4.3).
Finally, in Section 6, we draw conclusions and discuss future work.
2.
Syntax and semantics of ECTL 2.1.
ECTL syntax For clarity we will introduce the normal form for ECTL (see Section 3) and the resolution rules defined over a set of clauses in normal form (see Section 5), based on the set of classical logic operators aSS, a", a, AZ, future time temporal operators  (always), aS (sometime),  (next time), U (until) and W (unless) and path quantifiers A (on all future paths) and E (on some future path).
Thus, to unify the presentation, here we define the language of ECTL also based upon this extended set of operators.
We fix a countable set, Prop, of atomic propositions.
In the syntax of ECTL we distinguish state (S) and path (P ) formulae, such that well formed formulae are state formulae.
These classes of formulae are inductively defined below (where C is a formula of classical propositional logic) S ::= C|S aSS S|S a" S|S a S|AZS|AP |EP P ::= S|aSS|S|SUS|SWS|aSS|aSS Thus, ECTL has a richer syntax than CTL allowing nesting of  and aS in the scope of path quantifiers.
Examples of ECTL formulae are AaSB, AaSB, EaSB and EaSB (where B is any ECTL formula), which express the fairness properties.
Note that a succinct representation of branching-time logics which invokes a minimum set of temporal logic operators, U and  (from which we can derive other operators), can be found, for example, in [10].
2.2.
ECTL semantics Let us introduce the notation of tree structures, the underlying structures of time assumed for branching-time logics, which we utilise in our presentation.
Definition 1.
A tree is a pair (S, R), where S is a set of states and R a S A S is a relation between states of S such that aV s0 a S is a unique root node, i.e., there is no state si a S such that R(si , s0 ); aV for every si a S there exists sj a S such that R(si , sj ); aV for every si , sj , sk a S, if R(si , sk ) and R(sj , sk ) then si = sj .
A path, Dsi is a sequence of states si , si+1 , si+2 , .
.
.
such that for all j fi i, (sj , sj +1 ) a R. A path Ds0 is called a fullpath.
Let X be a family of all fullpaths of M. Given a path Dsi and a state sj a Dsi (i < j ) we term a finite subsequence [si , sj ] = si , si+1 , .
.
.
, sj of Dsi a  144  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  prefix of a path Dsi and an infinite sub-sequence sj , sj +1 , sj +2 , .
.
.
of Dsi a suffix of a path Dsi abbreviated Suf (Dsi , sj ).
Definition 2 (Branching degree of a state).
The number of immediate successors of a state si a S in a tree (S, R) is called the branching degree of si .
In a general case a state of a tree can have an infinite number of successors.
However, following [10, p. 1011], trees with arbitrary, even uncountable, branching, aas far as our branching temporal logic are concerned, are indistinguishable from trees with finite, even bounded, branchinga.
Thus, without loss of generality, we assume that underlying ECTL tree models are of at most countable branching.
Definition 3 (Branching factor of a tree structure).
Given the set K = {k1 , k2 , .
.
.
, kn }, of the branching degrees of the states of a tree, the maximal ki (1  i  n) is called the branching factor of this tree.
We interpret a well-formed ECTL formula in a structure M = 	S, R, s0 , X, L , where (S, R) is a tree with a root s0 , X is a set of all fullpaths and L is an interpretation function mapping atomic propositional symbols to truth values at each state and the following conditions are satisfied: aV X is R-generable [10], i.e., for every state si a S, there exists Dj a X such that si a Dj , and for every sequence Dj = s0 , s1 , s2 , .
.
.
, Dj a X if, and only if, for every i, R(si , si+1 ); aV a tree (S, R) is of at most countable branching.
Now in Fig.
1 we define a relation aa, which evaluates well-formed ECTL formulae at a state si in a model M. 	M, si   	M, si   	M, si   	M, si   	M, si   	M, si   	M, si   	M, Dsi   	M, Dsi   	M, Dsi   	M, Dsi   	M, Dsi    p  AZA AaSSB Aa"B AaB  AB  EB A  B  aSB  B  AU B  	M, Dsi    AWB  p a L(si ), for p a Prop.
M, si    A 	M, si    A and 	M, si    B 	M, si    A or 	M, si    B 	M, si    A or 	M, si    B for each Dsi , 	M, Dsi    B. there exists Dsi such that 	M, Dsi    B 	M, si    A, for state formula A for each sj a Dsi , if i  j then 	M, Suf (Dsi , sj )   B. there exists sj a Dsi such that i  j and 	M, Suf (Dsi , sj )   B. 	M, Suf (Dsi , si+1 )   B. there exists sj a Dsi such that i  j and 	M, Suf (Dsi , sj )   B and for each sk a Dsi , if i  k < j then 	M, Suf (Dsi , sk )   A. iff 	M, Dsi    A or 	M, Dsi    AU B  iff iff iff iff iff iff iff iff iff iff iff iff  Fig.
1.
ECTL semantics.
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  145  Fig.
2.
Limit closure.
Definition 4 (Satisfiability).
A well-formed ECTL formula, B, is satisfiable if, and only if, there exists a model M such that 	M, s0    B.
Definition 5 (Validity).
A well-formed ECTL formula, B, is valid if, and only if, it is satisfied in every possible model.
As an example, let us consider the following satisfiable ECTL formula AaSp aSS EEaSAZp  (1)  A model, M, for this formula (see Fig.
2) can be derived as follows.
Let for the states along Ias0 , the following holds: k = j + 1, l = k + 1, .
.
.
; let p be satisfied at Suf (Ias0 , sj ) and also at Suf (Ils0 , sj +2 ), Suf (Dsj , sk+2 ), Suf (Dsk , sl+2 ), .
.
.
.
Finally, let sj +1 , sk+1 , sl+1 , .
.
.
along paths Il , D, D, .
.
.
, respectively, satisfy AZp.
Note that if we change the first conjunct of formula (1) to AaSAp then the whole formula becomes unsatisfiable.
Closure properties of ECTL models.
When trees are considered as models for distributed systems, paths through a tree are viewed as computations.
The natural requirements for such models would be suffix and fusion closures.
Following [10], the former means that every suffix of a path is itself a path.
The latter requires that a system, following the prefix of a computation Il , at any point sj a Il , is able to follow any computation Dsj originating from sj .
Finally, we might require that aif a system can follow a path arbitrarily long, then it can be followed forevera [10].
This corresponds to limit closure property, meaning that for any fullpath Ils0 and any paths Dsj , Dsk , .
.
.
such that Ils0 has the prefix [s0 , sj ], Dsj has the prefix [sj , sk ], Dsk has the prefix [sk , sl ], etc, and 0 < j < k < l, the following holds (see Fig.
2): there exists an infinite path Ias0 that is a limit of the prefixes [s0 , sj ], [sj , sk ], [sk , sl ], .
.
.
.
In our definition of an ECTL model structure M the set of fullpaths X is R-generable.
Therefore, following [10], it satisfies all three closure properties, i.e., it is suffix, fusion and limit closed.
2.3.
Some useful features of ECTL Here we summarize those features of ECTL that are important in our analysis and, thus, affect both the translation of ECTL formulae to the normal form and the clausal resolution method.
146  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  Fairness constraints.
Validity of the following equivalences can be easily shown in ECTL semantics: AaSB aA AAaSB,  EaSB aA EaSEB  (2)  Therefore, AaSB and EaSB have their CTL counterparts.
However, EaSB and AaSB have no analogues in CTL [10].
Note that in the case of EaS, the aS operator is in the scope of the  operator, which is a maximal fixpoint prefixed by the aEa quantifier.
In the second case, the  operator is in the scope of the aS operator, which is a minimal fixpoint and is prefixed by the aAa quantifier.
These nestings of temporal operators significantly affect the renaming of the embedded paths subformulae in the corresponding ECTL fairness constraints.
Notation.
aV In the rest of the paper, let T abbreviate any unary and T2 any binary temporal operator and P either of path quantifiers.
aV Any expression of the type PT or PT2 is called a basic CTL modality.
A class of basic ECTL modalities consists of basic CTL modalities, enriched by ECTL fairness constraints, PaS and PaS.
aV Let F be an ECTL formula and let Fi be its subformula with a path quantifier as its main operator.
We will abbreviate the latter by P-embedded subformula of F .
aV A literal is an atomic proposition or its negations.
aV We will use the symbol = in the expression A = B to refer to the graphical equivalence of formulae A and B, while A aA B would mean the logical equivalence, i.e., it abbreviates (A a B) aSS (B a A).
As we will see in Section 3, the idea behind the normal form for ECTL is to identify the core operators, P and PaS, to enable us to generate formulae relevant to either the first state in a model, or to all subsequent states in a model.
Therefore, an important part of the transformation procedure for ECTL formulae into the normal form is simplifying the structures of the given ECTL formulae.
Some of these transformations deal with embedded state subformulae of ECTL formulae.
Managing embedded state subformulae.
For an ECTL formula F , we define a notion of the degree of nesting of its path quantifiers, denoted N (F ), as follows.
Definition 6 (Degree of path quantifier nesting).
aV if F is a purely classical formula then N (F ) = 0; aV if F = TF1 |F1 T2 F2 , and F1 , F2 are purely classical formulae then N (TF1 ) = N(F1 T2 F2 ) = 0; aV if F = AZF1 |F1 aSS F2 |F1 a" F2 |F1 a F2 |TF1 |F1 T2 F2 | then N (AZF1 ) = N (TF1 ) = N(F1 ) and N (F1 aSS F2 ) = N (F1 a" F2 ) = N (F1 a F2 ) = N (F1 T2 F2 ) = max(N (F1 ), N(F2 ));  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  147  aV N(PF1 ) = N (F1 ) + 1.
Emerson and Sistla [13] showed that any CTLa formula F can be transformed into such that N (F  ) = 2 and F is satisfiable if, and only if, F  is satisfiable.
This can be achieved by a continuous renaming of the P-embedded state subformulae.
The result is obviously valid for the logic ECTL, and below we introduce a corresponding recursive procedure Red.
F  Definition 7 (Reduction of the path quantifier nesting).
Given an ECTL formula F such that N(F ) > 2, the following procedure reduces the nesting of path quantifiers in F to the degree 2: Red[F ] = A(x1 aA S1 ) aSS Red[F (S1 /x1 )], where S1 is the designated Pembedded state subformula of F , x1 is a new atomic proposition and F (S1 /x1 ) is a result of the replacement of S1 in F by x1 .
If N (Si ) = 1 then the procedure terminates.
For example, given F = AaS(EaSAZp aSS AaSAp) we can obtain Red[F ] as follows Red[F ] = A(x1 aA Ap) aSS A(x2 aA AaSx1 ) aSS A(x3 aA EaSAZp) aSS AaS(x3 aSS x2 ) Therefore, procedure Red terminates here producing the conjunction of formulae such that each of them has a degree of nesting of path quantifiers at most 2.
The following Proposition 1 is due to Emerson and Sistla [13].
Proposition 1 (Correctness of the Reduction procedure).
For any ECTL formula F , F is satisfiable if, and only if, Red(F ) is satisfiable, where Red is introduced in Definition 7.
Since normal form for ECTL is invoked as part of the resolution method, and similarly to classical resolution, the resolution based refutation commences here with the negation of a given ECTL formula (see Section 5), we will aim at translating this negation into negation normal form.
Definition 8 (Negation normal form for ECTL).
An ECTL formula is in the negation normal form if every negation operation applies to an atomic proposition.
Using the standard technique we can translate an ECTL formula F into its negation normal form, NNFECTL (F ) [10] preserving both satisfiability and unsatisfiability.
Proposition 2 (Correctness of NNFECTL ).
For any ECTL formula, F , F is satisfiable if, and only if, NNFECTL (F ) is satisfiable.
Fixpoint characterization of basic CTL modalities.
Our translation to SNFCTL and temporal resolution rules are essentially based upon the fixpoint characterizations of basic  148  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  CTL modalities (see [8]).
The corresponding definitions are given below, where maximal fixpoint operator is abbreviated by aI"a and minimal fixpoint operator by aIza: Ep = I"Is (p aSS EIs ) Ap = I"IV(p aSS AIV)   E(pWq) = I"Is q a" (p aSS EIs)   A(pWq) = I"Iz q a" (p aSS AIz )  (3)  EaSp = IzD(p a" ED) AaSp = IzD (p a" AD )   E(pUq) = IzD q a" (p aSS ED)   A(pUq) = IzI' q a" (p aSS AI')  (4)  Next we recall some results on interpreting CTL-type branching time logics over so called canonical models.
We will formulate these general results in relation to the logic ECTL, noting that they cover all CTL-type logics, including CTL .
Definition 9 (Labelled tree).
Given a tree T = (S, R) (where S is a set of nodes and R is a set of edges) and a finite alphabet, IL , a IL -labelled tree is a structure (T , L) where L is a mapping S aa IL , which assigns for each state, element of S, some label, element of IL .
Observe that in Section 2 we introduced the notion of satisfiability and validity of ECTL formulae in relation to 	M, s0  .
Now, let us, following [15], call such a structure a tree interpretation.
Next we recall a notion of a k-ary tree canonical model which plays a fundamental role in our correctness argument.
For these purposes, again following [15] and preserving its notation, we will look at tree interpretations as tree generators: the root of the tree is understood as an empty string, It, and the whole tree is seen as a result of unwinding of the root applying the successor function {(s, si) | s a [k] , i a K}, where [k] = S and si (i a K) is a set of successors of a state s. Definition 10 (Tree canonical interpretation).
Let T = (S, R) be a k-ary infinite tree such that [k] denotes the set {1, .
.
.
, k}, of branching degrees of the states in S and R = {(s, si) | s a [k] , i a K}.
Now, given an alphabet IL = 2Prop , a k-ary tree canonical interpretation for an ECTL formula F is of the form 	M, It , where M = ([k] , R, D) such that D : [k] aa 2Prop is a function which assigns truth values to the atomic propositions in each state.
As it is stated in [15], since in a canonical interpretation 	([k] , R, D), It , athe set of states, the initial state and the successor relation are all fixed they reduce to a function [k] aa 2Prop , that is to a labelled tree over the alphabet 2Prop a.
We will refer to this tree as a canonical model.
Proposition 3 given below collects the results of [15, Lemma 3.5, p. 145].
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  149  Proposition 3 (Existence of a canonical model for ECTL).
If an ECTL formula F containing n (existential) path quantifiers has a model, then it has an (n + 1)-ary canonical model.
Thus, given an interpretation 	M, s0   for an ECTL formula F , there exists an (n + 1)ary canonical tree interpretation 	M , It , where n is the number of existential path quantifiers in F , such that F is satisfied in 	M, s0   iff F is satisfied in 	M , It .
We will essentially use these results for the formulation of the transformation rule managing ECTL fairness constraints, namely, formulae that contain AaSasee Section 4.2.
The results are also central to the correctness proof of this transformation presented in Section 4.4.
3.
Normal form for ECTL As a normal form for ECTL we utilise a clausal normal form, defined for the logic CTL, SNFCTL , which has been developed in [2,6].
The idea behind SNFCTL is to identify the core operators, P and PaS, which enables us to generate formulae relevant to either the first state in a model, or to all subsequent states in a model.
Therefore, as an important part of the transformation procedure for ECTL formulae into SNFCTL we incorporate removal of all other, unwanted modalities A, E, AU, EU, AW, EW (see Section 4.2).
Additionally, to preserve a specific path context during the translation, we incorporate indices.
Indices.
The language for indices is based on the set of terms fi        IND = 	f , 	g , 	h , LC(f) , LC(g) , LC(h) .
.
.
where f, g, h .
.
.
denote constants.
Thus, EA	f  means that A holds on some path labelled as 	f .
A designated type of indices in SNFCTL are indices of the type 	LC(ind)  which represent a limit closure of 	ind .
All formulae of SNFCTL of the type P a EQ or P a EaSQ, where Q is a purely classical expression, are labelled with some index.
Labelling clauses of the normal form by indices is related to the branching factor of the canonical model for the clauses and will be explained later.
The SNFCTL language is obtained from the ECTL language by omitting the U and W operators, and adding classically defined constants true and false, and a new operator, start (aat the initial moment of timea) defined as 	M, si    start iff  i=0  Definition 11 (Separated normal form SNFCTL ).
SNFCTL is a set of formulae 	   A (Pi a Fi ) i  where each of the clauses Pi a Fi is further restricted as below, each Iai , I,j or l is a literal, true or false and 	ind  a IND is some index.
150  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  start a  k   an Initial Clause  I,j  j =1  Step Clauses  m 	     n Iai a A I,j  i=1 m 	  j =1  n  i=1  j =1  Iai a E  an A step clause     I,j  an E step clause 	ind   Sometime Clauses m 	  Iai a AaSl  i=1 m 	  an A sometime clause  Iai a EaSl	LC(ind)    an E sometime clause  i=1  Interpreting SNFCTL .
An initial SNFCTL clause, start a F , is understood as aF is satisfied at the initial state of some model Ma.
Any other SNFCTL clause is interpreted taking also into account that it occurs in the scope of A.
Thus, a clause A(x a Ap) (a model for which is given in Fig.
3, Diagram 1) is interpreted as afor any fullpath D and any state si a D (0  i), if x is satisfied at a state si then p must be satisfied at the moment, next to si , along each path which starts from si a.
Recall that following Proposition 3, for a set, R, of clauses with n existential path quantifiers, we have an (n + 1)-ary canonical model for R. Now, associating every k a 1 .
.
.
n with a unique index indk a IND, we label each E step clause with the unique indk and each E sometime clause with the unique LC(indk ).
Thus, a clause A(x a Eq	ind  ) (see Fig.
3, Diagram 1) is understood as afor any fullpath D and any state si a D (0  i), if x is satisfied at a state si then q must be satisfied at the moment, next to si , along some path 	ind  which departs from si a.
Fig.
3.
Interpretation of step and sometime clauses.
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  151  Finally, A(x a EaSp	LC(ind)  ) (see Fig.
3, Diagram 2) has the following meaning afor any fullpath D and any state si a D (0  i), if x is satisfied at a state si then p must be satisfied at some state, say sj (i  j ), along some path Iasi which is the limit closure of 	ind  which departs from si a.
4.
Transformation of ECTL formulae into SNFCTL As we have already mentioned, an important part of the transformation procedure for ECTL formulae includes removal of all unwanted modalities A, E .
.
.
.
The corresponding rules are formulated in such way that these basic CTL modalities are removed being applied to literals.
Thus, a significant part of the translation aims at simplifying the structure of formulae preparing them for application of removal rules.
While many of these methods were developed in our previous work [2,6], we here introduce a novel technique to cope with ECTL fairness constraints.
4.1.
Description of the transformation algorithm As SNFCTL is a part of the resolution technique, to check validity of an ECTL formula G, we first negate the latter and translate AZG into its Negation Normal Form, deriving C = NNFECTL (AZG).
Now we introduce the transformation procedure D = [D2 [D1 [C]]] to be applied to C, where D1 and D2 are described respectively by the steps 1a2 and 3a7 below.
1.
Anchor C to start and apply the initial renaming rule obtaining A((start a x0 ) aSS (x0 a C)), where x0 is a new atomic proposition.
2.
Apply Eqs.
(2) and then procedure Red (see Definition 7) to C. Thus, we derive a set of constraints of the following structure  	    m A (start a x0 ) aSS (Pj a Qj ) j =0  where Pj is a proposition, Qj is either a purely classical formula or if Qj contains an ECTL modality then the degree of nesting of path quantifiers in Qj is 1.
Let us call a formula G in pre-clause form if D1 [G] = G, i.e., it is of the form Pj a Qj where Pj is a literal, or conjunction of literals, or start, Qj is either a purely classical formula or Qj = PTCj or Qj = PaSCj or Qj = PaSCj or Qj = P(Cj1 T2 Cj2 ), and Cj , Cj1 and Cj2 are purely classical formulae.
3.
For every pre-clause Pj a Qj , we obtain the following conditions.
If Qj contains a basic CTL modality then a If Qj = PTCj and PT is not P then Cj is a literal, else Cj is a purely classical formula.
a If Qj = PaSCj or Qj = PaSCj then Cj is a literal,  152  4.
5.
6.
7.
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  a If Qj = P(Cj1 T2 Cj2 ) then Cj1 and Cj2 are literals.
This can be achieved by continuous renaming of the embedded classical subformulae by auxiliary propositions together with some classical transformations.
Label each pre-clause containing the E modality by a unique index 	indi   a IND and any other pre-clause containing the E quantifier by a unique index 	LC(indj )  a IND.
Let LIST_IND be a list of all indices introduced during this labelling.
Transform pre-clauses containing EaS and AaS.
Remove all unwanted basic CTL modalities.
Steps 5 and 6 are described in the next section.
Derive the desired form of SNFCTL clauses.
At this final stage we transform preclauses Pj a Qj , where Qj is either PCj or a purely classical formula: a for every pre-clause Pj a PCj , we obtain the structure where P applies either to a literal or to disjunction of literals.
This can be achieved, again, by renaming of the embedded classical subformulae, translating Cj into conjunctive normal form (CNF), and distributing P over conjunction, together with some classical transformations.
a for every remaining purely classical pre-clause Pj a Qj , we apply a number of procedures including those that are used in classical logic in transforming formulae to CNF, some simplifications and the introduction of a temporal context.
4.2.
Transformation rules towards SNFCTL In the transformation procedure D outlined above, the first stage, the procedure D1 , except for the application of equations (2) at step 2, is taken from the translation of CTL formulae to SNFCTL [2].
In the procedure D2 we introduce novel techniques to cope with ECTL fairness constraints that do not have their CTL counterparts.
Here we describe these techniques and recall some of those rules that will be used in our example given in Section 4.3.
For the full set of rules preserved from the CTL the reader is referred to [2,6].
In the presentation below we omit the outer aAa connective that surrounds the conjunction of pre-clauses (note that any pre-clause is also a clause) and, for convenience, consider a set of pre-clauses rather than the conjunction.
Expressions P and Q will abbreviate purely classical formulae.
Indices.
Recall that at step 4 of the transformation procedure, we introduce labelling of the SNFCTL pre-clauses containing the E quantifier: here we first label every pre-clause P a EQ by a unique index 	indi  , indicating a adirectiona in which Q is satisfied, given that P is satisfied.
Secondly, with any other pre-clause containing the E quantifier we associate a unique index 	LC(indj ) .
The justification of the latter labelling is based upon fixpoint characterization of basic CTL modalities E, EW and EU (see Eqs.
(3) and (4)).
Assume that a pre-clause P a Ey has been derived at some stage of the transformation procedure.
Since Ey is a maximal fixpoint of the equation I"Is (y aSS EIs ), we can represent this recursion by the following set of constraints: P ay aSSx x a E(y aSS x)	ind   (5)  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  153  Fig.
4.
Labelling ECTL formulae: the LC index.
where we introduce a new atomic proposition, x, and require that the conjunction y aSS x also occurs at those moments where P itself is satisfied.
The second constraint, x a E(y aSS x), represents a loop in y, i.e., the situation, where y occurs from some point at all subsequent states along some path in the model (given that x is satisfied at that point).
Now, labelling x a E(y aSS x) by a new index, 	ind , and noting that pre-clauses are in the scope of the outer A, we can show that P a Ey is satisfiable in some model, M, if, and only if, there is a model M which satisfies both formulae in (5).
Here we present a proof establishing that if P a Ey is satisfiable in a model M then there is a model M which satisfies both formulae in (5).
The satisfiability of pre-clause P a Ey in a model M would mean afor any fullpath D and any state sk a D (0  k), if 	M, sk    P then 	M, sk    Eya Choose arbitrarily a fullpath D (see Fig.
4).
If P is never satisfied along D then let M be the same as M except for a new proposition x such that x is false everywhere along D. Thus, we obtain   	M , D    P a (y aSS x) ,   	M , D    x a E(y aSS x)	ind  regardless of the indices since the left hand side of each implication is false.
Alternatively, let si a D be the first moment along D satisfying P .
In this case there must be a path Dsi (associated with 	ind ) such that 	M, Dsi    y.
Due to the fusion closure property, there is a fullpath [s0 , si ] aS Dsi , where aaSa is a concatenation of [s0 , si ] and Dsi .
Now we define a model M to be the same as M except for a new proposition x such that for any state sn a [s0 , si ] aS Dsi , if i  n then 	M , sn    x else 	M , sn    x.
Now we derive that sj , the successor of si on path Dsi , satisfies y aSS x.
Thus, setting in the conditions for P a Ey that D = [s0 , si ] aS Dsi and k = j , we conclude that 	M, sj    E(y aSS x)	ind  .
Therefore, there is a path Dsj associated with 	ind  such that there is a state, next to si , say sm , on this path, which satisfies y aSS x.
Continuing to reason in this way, according to the limit closure property, we must have in the model a path, 	LC(ind) , going through the states si , sj , sm .
.
.
.
Each state along 	LC(ind)  satisfies y aSS x.
Therefore, we have identified a  154  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  path which satisfies Ey, which enables us to label pre-clause P a Ey by 	LC(ind) .
Note also that this justifies that (x a E(y aSS x)ind ) indeed represents a loop in y on the path 	LC(ind) .
Searching for loops is essential for application of resolution rules, see Section 5.
Providing analogous reasoning, we can justify the labelling of pre-clauses containing EW, taking into account their definitions as maximal fixpoints, and the labelling of pre-clauses containing EaS and EU modalities based upon their definitions as minimal fixpoints.
Obviously, this representations of basic CTL modalities as sets of pre-clauses allows us to formulate corresponding rules to substitute basic CTL modalities by their fixpoint definitions.
Thus, given P a Ey	LC(ind)  , we apply (5) to remove the E modality as follows (in the formulation of the rule below x is a new atomic proposition): Removal of E.
P a Ey 	LC(ind)  P ay aSSx x a E(y aSS x)	ind  Additionally, we give the removal rule for EW referring the reader to [2,6] for the formulation of the full set of rules to remove basic CTL modalities.
Removal of EW.
P a E(pWq)	LC(ind)  P a q a" (p aSS x) x a E(q a" (p aSS x))	ind  where x is a new atomic proposition.
Managing embedded path subformulae in ECTL.
The rules to rename purely path formulae embedded in ECTL fairness constraints are based upon our analysis of the problematic variety of nesting of temporal operators in ECTL (see Section 2.3).
Thus, when renaming aSP within EaSP or P within AaSP by a new variable x, we must be sure that x and P in the former case, and x and aSP in the latter case, occur along the same path.
Second, we must establish a link between satisfiability of x and aSP (P ), i.e., any state in a model which satisfies x should also satisfy aSP (P ).
These observations have led us to the following formulation of the renaming rules.
Renaming: the EaS case.
P a EaSQ	LC(ind)  P a Ex	LC(ind)  x a EaSQ	LC(ind)  where x is a new atomic proposition.
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  155  Applying this rule, the label, 	LC(ind)  introduced for the premise at stage 4 of the transformation procedure, is preserved for both components of the conclusion.
Things are much more difficult when we deal with the AaS constraint.
Recall that once we have provided the labelling of formulae at stage 4 of the transformation procedure, the number of indices is equal to the number of different E pre-clauses.
Now we use this information about the number of existential path quantifiers based upon proof of Proposition 3, namely, from the fact that aone needs only sufficient paths from each state of a model to satisfy all the existential path formulae that have to be true in that state.
Moreover the number of existential state formulae that can appear in a formula is bounded by the number of path quantifiers in that formulaa [15].
Renaming: the AaS case.
Let LIST_IND = 	ind1  , .
.
.
, 	indn  .
If for some index 	ind  a LIST_IND we do not have 	LC(ind)  a LIST_IND then we upgrade LIST_IND by 	LC(ind)  (which can be easily justified).
Now, based on Proposition 3, we rename the Q subformula of AaSQ as follows (if the number of indices in LIST_IND, n = 0, then we create LIST_IND = 	ind  with the new index 	ind ).
if n = 0  if n > 0  P a AaSQ  P a AaSQ  P a EaSx	LC(ind)  x a EQ	LC(ind)   P a EaSx1	LC(ind1 )  x1 a EQ	LC(ind1 )  ... P a EaSxn 	LC(indn )  xn a EQ	LC(indn )   where x, x1 , .
.
.
, xn are new atomic propositions.
Next we present another useful rule, called aTemporisinga, which allows us to introduce a temporal context, rewriting into SNFCTL purely classical formulae of the type Q a P .
Temporising.
P aQ start a AZP a" Q true a A (AZP a" AZQ) Finally, we utilize two rules allowing us to distribute the A and E modalities over conjunction.
In the latter rule, which will be used in our example, we again, incorporate indices: given that the premise of this rule is labelled by 	LC(ind) , we preserve this label for both conclusions, thus, assuring that they refer to the same path.
Distributing A and E over conjunction.
P a A(P aSS Q) P a AP P a AQ  P a E(P aSS Q)	ind  P a EP	ind  P a EQ	ind   156  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  4.3.
Example transformation As an example we consider the application of the temporal resolution method, to check the validity of the following ECTL formula: AaSp a AaSp  (6)  To check that (6) is valid we negate it, obtaining AZ(AaSp a AaSp)  (7)  and then translate (7) into Negation Normal Form AaSp aSS EAZp  (8)  Following the translation algorithm, we obtain steps 0a2 below, where x is a new atomic proposition.
0. start a AaSp aSS EAZp anchoring to start 1. start a x 0, Initial Renaming 2. x a AaSp aSS EAZp 0, Initial Renaming Now we split conjunction on the right hand side of the formula at step 2, generating steps 3a4.
3. x a AaSp from 2, splitting aSS 4. x a EAZp from 2, splitting aSS At this stage we first label pre-clause 4 by a new label, 	LC(f )  creating LIST_ IND and then rename p in 3, introducing a new variable, l. 5. x a EaSl	LC(f)  from 3, Renaming : AaS case 6. l a Ep	LC(f)  from 3, Renaming : AaS case Now we must first apply the E removal rule to 4, introducing a new variable, y, thus, deriving steps 7 and 8 below.
from 4, Removal of E 7. x a AZp aSS y 8. y a E(AZp aSS y)	f  from 4, Removal of E  Similarly we remove the E modality from 6 deriving 9a10 below (and introducing a new variable, r).
from 6, Removal of E 9. l a p aSS r  10. r a E (p aSS r)	f  from 6, Removal of E  Now we split conjunctions on the right hand side of formulae 7 and 9.
11.
12.
13.
14.  x x l l  a a a a  AZp y p r  from 7, splitting aSS from 7, splitting aSS from 9, splitting aSS from 9, splitting aSS  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  157  As steps 11a14 are purely classical expressions we introduce a temporal context incorporating the rule Temporising, deriving the steps below: 15.
16.
17.
18.
19.
20.
21.
22.  start true start true start true start true  a a a a a a a a  AZx a" AZp A(AZx a" AZp) AZx a" y A(AZx a" y) AZl a" p A(AZl a" p) AZl a" r A(AZl a" r)  from 11, Temporising from 11, Temporising from 12, Temporising from 12, Temporising from 13, Temporising from 13, Temporising from 14, Temporising from 14, Temporising  Finally, we distribute the E operator over conjunction in steps 8 and 10, preserving the labelling: 23.
24.
25.
26.  y y r r  a a a a  EAZp	f  Ey	f  Ep	f  Er	f   from 8, Distributing E over aSS from 8, Distributing E over aSS from 10, Distributing E over aSS from 10, Distributing E over aSS  The normal form of the given ECTL formula is represented by clauses 1, 5, 15a26.
4.4.
Correctness of the transformation of ECTL formulae into SNFCTL Here we give the correctness proof for the transformation procedure D = D2 (D1 (G)) applied to an ECTL formula G. We first show that an ECTL formula G is satisfiable, if and only if, D1 (G) is satisfiable (Lemma 1).
Next, we will establish that the transformation procedure D2 preserves satisfiability (Lemma 2), and, finally, we prove that the converse of Lemma 2 is true, i.e., that given D2 (D1 (G)) is satisfiable so is D1 (G) (Lemma 3).
Lemma 1.
An ECTL formula, G, is satisfiable if, and only if, D1 (G) is satisfiable.
Proof.
Recall that procedure D1 consists of the following steps: anchoring the initial formula, G, to start, application of equivalences (2) and Procedure Red.
Here we first must establish that given a satisfiable formula G, we derive a satisfiable formula A((start a x0 ) aSS (x0 a G)), where x0 is a new atomic proposition.
This can be shown by taking a model M for the former and obtaining from it a model M which differs from M only in the evaluation of x0 which is set to be true at the initial state and false elsewhere.
On the other hand, given a model that satisfies A((start a x0 ) aSS (x0 a G)), we also have start a G satisfiable in the same model.
Secondly, from the semantics of ECTL, application of equivalences (2) also preserves satisfiability and unsatisfiability.
Finally, due to Proposition 1, procedure Red preserves satisfiability and unsatisfiability.
Therefore, an ECTL formula, G, is satisfiable if, and only if, D1 (G) is satisfiable.
2 Lemma 2.
Given a SNFCTL formula G, if D1 (G) is satisfiable then so is D2 (D1 (G)).
158  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  Recall that aV a formula G in pre-clause form is of the form Pj a Qj , where Pj is a literal or start, Qj is either a purely classical formula or Qj = PTCj or Qj = PaSCj or Qj = PaSCj or Qj = P(Cj1 T2 Cj2 ), and Cj , Cj1 and Cj2 are purely classical formulae.
aV any SNFCTL clause is also a formula in a pre-clause form.
We must show that any step of the transformation procedure D2 preserves satisfiability.
Proposition 4.
Let M be a model such that 	   ARi aSS AS 	M, s0    i  where each Ri and S are in a pre-clause form.
Then there exists a model M such that 	    ARi aSS AS  	M , s0    i  where each Ri is in a pre-clause form and S  is a result of one step of the transformation D2 [S].
Since S = (P a Q) is in a pre-clause form, we must consider the cases, corresponding to possible applications of D2 [AS].
These cases are given by the stages 3a7 of the transformation algorithm described in Section 4.
Here we outline the proof for the cases which represent the core transformation technique of the paper, i.e., where Q = EaSB (Case 1) and Q = AaSB (Case 2), omitting other cases, as proof of Proposition 4 for them repeats stages of the corresponding proof for CTL [2].
Case 1.
Here we apply D2 in the following way (y is a new atomic proposition).
D2 [A(P a EaSB	LC(ind)  )] D2 [A(P a Ey	LC(ind)  )] D2 [A(y a EaSB	LC(ind)  )] Let M be a model which satisfies the condition of Proposition 4 in this case: 	     	M, s0    ARi aSS A P a EaSB	LC(ind)  i  We show that there exists a model M such that the following holds: 	    ARi (a) 	M , s0    i  (b) 	M , s0    A P a Ey	LC(ind)    (c) 	M , s0    A y a EaSB	LC(ind)   A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  159  In the corresponding proof we obtain a model M from M by letting a new atomic proposition y to be satisfied in the relevant places and then establishing the conditions (a)a(c) taking into account the interpretation of the E clauses labelled with the aLCa type indices.
Choose arbitrarily a fullpath D in M. If P is never satisfied along D then let M be the same as M accept for a new atomic proposition y which is false everywhere along D. Thus, (a)a(c) are satisfied in M as the left hand side of every implication of (a)a(c) is false.
Alternatively, let si a D be the first state along D which satisfies P .
Thus, according to SNFCTL semantics, there must be a path Dsi associated with the 	LC(ind)  such that 	M, Dsi    aSB.
According to fusion closure there also must be a path [s0 , si ] aS Dsi .
Now we define a model M to be the same as M accept for a new atomic proposition y such that for a path [s0 , si ] aS Dsi associated with the 	LC(ind) , for any state sn a [s0 , si ] aS Dsi , if i  n then 	M , sn    x else 	M , sn    x.
This guarantees that (a)a(c) are now satisfied in M .
Case 2.
Here we apply D2 in the following way D2 [A(P a AaSQ)] D2 [A(P a EaSx1 )	LC(ind1 )  ] D2 [A(x1 a EQ)	LC(ind1 )  ] ... D2 [A(P a EaSxn )	LC(indn )  ] D2 [A(xn a EQ)	LC(indn )  ] Let M be a model which satisfies the condition of Proposition 4 in this case.
According to Proposition 3, there exists an (n + 1)-ary canonical model M , which also satisfies these conditions.
Let LC(ind1 ), .
.
.
LC(indn ) be labels which correspond to linear interpretations of M .
Note that each of these linear interpretations must satisfy P a AaSQ.
Now we update M to M labelling the states of the paths corresponding to linear interpretations by x1 similar to the labelling carried out in the Case 1 considered above.
Thus, we guarantee that all formulae in the conclusion of Proposition 4 in Case 2 are satisfied in M .
Note also that, once the labelling at stage 4 of the transformation procedure has been provided, no more new indices will appear in the proof.
Lemma 3.
Given an ECTL formula G, if D2 (D1 (G)) is satisfiable then so is D1 (G).
Recall that any formula to which D2 is applied is a formula in a pre-clause form, and thus, has a structure A(P a Q).
Thus, we must ensure the transformation D2 has the following property: Proposition 5.
For any ECTL formula Q if D2 (A(P a Q)) is satisfiable then so is A(P a Q), where P is a literal or conjunction of literals.
Proof.
We prove this proposition by induction on the structure of Q.
For the base cases, (B1aB5 below) we have:  160  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  (B1) Q = PaSl where P is either of path quantifiers and l is a literal.
In this case   D2 A(P a PaSl) = A(P a PaSl) Therefore, given   	M, s0    D2 A(P a PaSl) we immediately conclude that 	M, s0    A(P a PaSl) (B2) Q = (l1 a" AV AV AV a" ln ), where li (1  i  n) is a literal.
In this case      D2 A P a (l1 a" AV AV AV a" ln ) = A start a (AZP a" l1 a" AV AV AV a" ln ) aSS   A true a A(AZP a" l1 a" AV AV AV a" ln ) Thus, given   	M, s0    A start a (AZP a" l1 a" AV AV AV a" ln ) aSS   A true a A(AZP a" l1 a" AV AV AV a" ln ) we conclude that   	M, s0    start a (AZP a" l1 a" AV AV AV a" ln )   	M, s0    A true a A(AZP a" l1 a" AV AV AV a" ln ) (B3)a(B4) Q = true and Q = false, respectively.
Here the proof is immediate.
(B5) Q = P(l1 a" AV AV AV a" ln ) where P is either of path quantifiers.
Here     D2 (A P a P(l1 a" AV AV AV a" ln ) = A P a P(l1 a" AV AV AV a" ln ) Hence, given    	M, s0    D2 A P a P(l1 a" AV AV AV a" ln ) we immediately obtain   	M, s0    A P a P(l1 a" AV AV AV a" ln ) Now, assuming as an induction hypothesis that Proposition 5 holds for any formula D1 , D2 , AZD1 and AZD2 , we will show that it also holds for any of the following combinations: D1 aSS D2 , P(D1 aSS D2 ), PTD1 , PT2 D1 , EaSD1 , AaSD1 , etc.
Noting that proofs for PTD1 , PD1 T2 D2 (where D1 and D2 are classical but not literals, true or false) and P(D1 aSS D2 ) follow immediately from ECTL semantics, proof for D1 aSS D2 , which involves only classical reasoning, follows directly from SNFCTL semantics, and that proofs for the cases ED1 , A(D1 UD2 ), E(D1 UD2 ), E(D1 WD2 ) and A(D1 WD2 ) are similar to the case (AD1 ), we first consider the latter case and then two cases corresponding to the novel techniques introduced in this paper, namely, for EaSD1 and AaSD1 .
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  161  Consider the case Q = AD1 .
Here we are given   (a ) 	M, s0    D2 A(P a AD1 ) from which we will show that (aA)  	M, s0    A(P a AD1 )  1.
M, s0    D2 (A(P a Ay)), from the condition (a ); 2.
M, s0    D2 (A(y a D1 )), from the condition (a ).
Therefore, as D2 here is the aAa removal rule, from 1 we obtain 3 and 4: 3.
M, s0    D2 (A(P a (y aSS z)); 4.
M, s0    A(z a Ay) and 	M, s0    A(z a Az); Now, following SNFCTL semantics, we derive 5 and 6.
5.
M, s0    A(start a AZP a" y) and 	M, s0    A(true a A(AZP a" y)), from 3; 6.
M, s0    A(start a AZP a" z) and 	M, s0    A(true a A(AZP a" z)), from 3.
By inductive hypothesis, from 2, we also have 7.
M, s0    A(y a D1 ).
Now we can see that M indeed satisfies A(P a AD1 ): from 5 we conclude that wherever P is satisfied in M so is y and hence, from 7, so is D1 .
Also, 6 indicates that if P is satisfied at an arbitrary state si on an arbitrary fullpath D then so is z.
Hence, from 4, for any path Dsi , a state si+1 , the successor of si along Dsi , satisfies both y and z.
Therefore, from 7, si+1 satisfies D1 .
Again, as si+1 satisfies z then any successor of si+1 also satisfies y and z, hence, satisfies D1 , etc.
Therefore, each path departing at si satisfies D1 , i.e., we have shown that the conditions (aA) holds: 	M, s0    A(P a AD1 ) as required.
Consider the case Q = EaSB.
Here we are given   (a ) 	M, s0    D2 A(P a EaSB	LC(ind)  ) from which we will show that (aA)  	M, s0    A(P a EaSB	LC(ind)  )  As here D2 is the application of the Renaming rule (the EaS case) we have 1.
M, s0    D2 (A(P a Ex	LC(ind)  )), from the condition (a ); 2.
M, s0    D2 (A(x a EaSB	LC(ind)  )), from the condition (a ); By inductive hypothesis we have 3.
M, s0    A(x a EaSB	LC(ind)  ), from 2; Now we can see that M indeed satisfies A(P a EaSB	LC(ind)  ): from 1 we conclude that wherever P is satisfied in M, from that point there exists a path associated with 	LC(ind)  which satisfies x.
Also 3 indicates that if x is satisfied at an arbitrary state  162  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  si on an arbitrary fullpath D then there must be path from si associated 	LC(ind)  which satisfies aSB.
Therefore, we have shown that the conditions (aA) holds: 	M, s0    A(P a EaSB	LC(ind)  ) as required.
Consider the case Q = AaSB.
Here we are given   	M, s0    D2 A(P a EaSx1	LC(ind1 )  )   	M, s0    D2 A(x1 a EB	LC(ind1 )  ) (a ) .
.
.
M, s0    D2 A(P a EaSxn	LC(indn )  )   	M, s0    D2 A(xn a EB	LC(indn )  ) from which we will show that (aA) 	M, s0    A(P a AaSB) Recall that here D2 is the application of the Renaming rule (the AaS case).
Let us abbreviate A(P a EaSx1	LC(ind1   ), A(x1 a EB	LC(ind1 )  ), .
.
.
, A(P a EaSxn	LC(indn )  ), A(xn a EB	LC(indn )  ) as a1 , .
.
.
, an , respectively, and let M be a model which satisfies (a ), where M = (S, R, L).
Thus, we have 	M, s0    a1 aSS AV AV AV aSS an .
From Proposition 3, we know that if a formula with n path quantifiers has a model, then it has an (n + 1)aary canonical model.
We will now construct this canonical model M and show that it also satisfies aA.
The construction proceeds in the manner of [15].
We define our (n + 1)-ary tree interpretation for formula a  as 	M , It , where M = ([n + 1] , R, D) such that D : [n + 1] aa 2Prop (see Definition 10), and inductively construct a mapping D : [n + 1]a aa S, taking D(s) = L(D(s)).
We start by first selecting a linear interpretation 	Ml , s0  , where Ml = (Sl , Rl , Ll ) from 	M, s0    (a1 ) aSS AV AV AV aSS (an ) such that 	Ml , s0    aj (1  j  n), and define a mapping D0 on the set X0 = 1a , as D0 (1k ) = Rl k (s0 ) (k fi 0).
This will be a basis path (labelled by D) which is also referred to as the aleftmosta path of the canonical model in [15].
Now, given Di defined on the set of nodes Xi , we define Di+1 and the set Xi+1 .
For each aj from a , we choose a linear interpretation, 	Mlj , D(s)  and define Di+1 (s(j + 1)) = Rlj (D(s)) and Di+1 (s(j + 1)1k ) = Rlj k (D(s)) for k fi 0.
Finally, taking D to be DD completes the canonical model (see Fig.
5).
Fig.
5.
(n + 1)aary canonical model for aA.
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  163  The construction of M ensures that P a EaSB is satisfied on every path from It.
Thus 	M , It   A(P a AaSQ), from ECTL semantics.
We also know that for any ECTL formula F , 	M , It   F iff 	M, s0    F .
Hence 	M, s0    A(P a AaSQ) (aA).
2 Now from Lemmas 1, 2 and 3 we have the following theorem: Theorem 1.
An ECTL formula, G, is satisfiable if, and only if, D (G) is satisfiable.
5.
The temporal resolution method Having provided the translation of ECTL formulae into SNFCTL , we represent all temporal statements within ECTL as sets of clauses.
Now, in order to achieve a refutation, we incorporate two types of resolution rules already defined in [2,6]: step resolution (SRES) and temporal resolution (TRES).
Step resolution rules.
Step resolution is used between formulae that refer to the same initial moment of time or same next moment along some or all paths.
In the formulation of the SRES rules below l is a literal and C and D are disjunctions of literals.
SRES 1 start a C a" l start a D a" AZl  SRES 2 P a A(C a" l) Q a A(D a" AZl)  start a C a" D  (P aSS Q) a A(C a" D)  SRES 3  SRES 4  P a A(C a" l) Q a E(D a" AZl)	ind   P a E(C a" l)	ind  Q a E(D a" AZl)	ind  (P aSS Q) a E(C a" D)	ind   (P aSS Q) a E(C a" D)	ind   When an empty constraint is generated on the right hand side of the conclusion of the resolution rule, we introduce a constant false to indicate this situation and, for example, the conclusion of the SRES 1 rule, when resolving start a l and start a AZl, will be start a false.
Temporal resolution rules.
The basic idea of invoking temporal resolution is to resolve a clause containing aSAZl together with a set of formulae characterizing a loop in l, a set of SNFCTL clauses indicating a situation when l occurs at all future moments along every (an A-loop in l) or some path (a E-loop in l) from a particular point in an ECTL model [5].
164  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  TRES 1  TRES 2  P a AAl Q a AaSAZl  P a AAl Q a EaSAZl	LC(ind)   Q a A(AZP WAZl)  Q a E(AZP WAZl)	LC(ind)   TRES 3 P a EEl	LC(ind)  Q a AaSAZl	LC(ind)   TRES 4  Q a A(AZP WAZl)	LC(ind)   Q a E(AZP WAZl)	LC(ind)   P a EEl	LC(ind)  Q a EaSAZl	LC(ind)   where the first premise is the abbreviation for the A loop or E loop in l given that P is satisfied.
The aim of applying the temporal resolution method to a set of SNFCTL clauses, R, is to derive an empty clause start a false.
If we have derived an empty clause then the procedure terminates and the set R is unsatisfiable.
If we have not achieved this applying SRES rules and there is no eventuality clause in the set of clauses then the procedure terminates indicating that R is satisfiable.
Alternatively, we create a list of eventualities, say l1 , .
.
.
, ln and start looking for loops in AZl1 , AZl2 , .
.
.
which will lead us to the application of the corresponding TRES rule and subsequent chain of transformations and further applications of SRES.
This chain repeats until we either derive an empty clause or no more rules have become applicable.
(For full details of the method see [5,6].)
Correctness of the transformation of ECTL formulae into SNFCTL (Section 4.4) together with the termination and correctness of the resolution method defined over SNFCTL (shown in [2,6]) enables us to apply the latter as the refutation method for ECTL.
Namely, given an ECTL formula G, translate AZG into SNFCTL (G) and apply the temporal resolution method to the latter.
If an empty clause is derived then AZG is unsatisfiable, hence G is valid, otherwise AZG is satisfiable, hence G is not valid.
Example refutation.
We apply the resolution method to the set of SNFCTL clauses obtained for ECTL formula AaSp a AaSp (formula (6) in section Section 4.3).
We commence the proof presenting at steps 1a8 only those clauses that are involved into the resolution refutation in the following order: initial clauses, step clauses and, finally, any sometime clauses.
1.
2.
3.
4.
5.
6.
7.
8.  start start start start true y y x  a a a a a a a a  x AZx a" y AZx a" AZp AZl a" p A(AZl a" p) EAZp	f  Ey	f  EaSl	LC(f)   A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  165  As we mentioned, the first stage of applying the temporal resolution method is the application of SRES rules in order to either derive an empty clause or to specify a set of step clauses for a loop searching technique.
Thus, applying step resolution rules we obtain steps 9a12.
9. start a AZp 10. start a y 11. start a AZl 12. y a EAZl	f   1, 3 SRES 1 1, 2 SRES 1 4, 9 SRES 1 5, 6 SRES 2  As we have not derived an empty clause and there is an eventuality clause 8, we are looking for a loop in AZl.
The desired loop is given by clauses 7 and 12, namely these formulae together represent a E loop in AZl: y a EEAZl	LC(f)  .
Thus, we apply the TRES 4 rule to resolve this loop and clause 8, obtaining 13.
13. x a E(AZyWl)	LC(f)  7, 12, 8 TRES 4 At this stage we remove EW, and use only one of the conclusions of this rule.
This gives us a purely classical formula on step 14 below, where z is a new variable.
14. x a l a" AZy aSS z 13, Removal of EW Now, applying some classical transformations together with the temporising rule, we derive 15, and finally, a chain of applications of the SRES 1 gives us the terminating clause start a false.
15. start a AZx a" l a" AZy 14, classical, Temporizing 16. start a false 1, 10, 11, 15 SRES 1  6.
Conclusions and future work We have described the extension of the clausal resolution method to the useful branching-time logic ECTL.
To the best of our knowledge there are no analogous clausal resolution methods developed for branching-time logics.
One of the obvious benefits of using the clausal resolution technique is the possibility of invoking a variety of welldeveloped methods and refinements used in the framework of classical logic.
Another obvious advantage of using this technique is its capacity to handle arbitrary systems, while other methods, such as for example, the model checking technique [1], are restricted to the analysis of finite state systems.
Note also, that in [7], it was shown that the normal form developed for linear-time temporal logic is as expressive as BAzchi word automata, and, therefore, as propositional linear-time Iz-calculus [8].
Thus, in the linear-time case we are able to represent a problem specification directly as a set of formulae in the normal form and apply a resolution based verification technique to the latter.
This opens another direction of our future worka analysis of the correspondence of SNFCTL , the normal form for several branching-time logics, CTL, ECTL, and ECTL+ , and automata for branching-time logics.
166  A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  The algorithm to search for loops needed for temporal resolution was introduced in [5].
With the proof that SNFCTL can be served as the normal form for ECTL, the algorithm becomes fully functional for the latter.
Taking into account these observations, we define a future task to refine this algorithm, to analyse the complexity of the clausal resolution method for logics CTL, ECTL and ECTL+ , and to develop corresponding prototype systems.
We believe that a number of techniques explored in this paper will be useful in developing the resolution method for other extensions of CTL culminating in CTLa : (1) The method of identifying different types of nesting of temporal operators understood as minimal or maximal fixpoints.
We have shown that in the abada nesting, a temporal operator defined as a maximal fixpoint is prefixed by an aEa quantifier or a temporal operator defined as a minimal fixpoint is prefixed by an aAa quantifier.
(2) Our novel technique to transform ECTL formulae which contain fairness constraints representing these abada cases of nesting of temporal operators is based upon the indexing and the existence of the canonical model.
Note that the canonical model construction was crucial in our correctness argument.
(3) The technique of analysing formulae which have some structural similarity but have different satisfiability characteristics.
For example, a atinya change of the satisfiable CTL formula AaS(p aSS EAZp) to AaS(Ep aSS EAZp) makes the latter unsatisfiable.
Thus, in developing the required transformation rules it will be useful to have a test-bench of such CTL formulae which will also be an effective method of testing the correlation of the transformation rules under development and the desired resolution procedure.
Acknowledgements We would like to thank Michael Fisher, Clare Dixon and Mark Reynolds for useful discussions during the preliminary work on the paper, and Renate Schmidt for valuable comments on the relevant material in the PhD thesis [2].
We are also grateful to anonymous referees for their suggestions on improving this article.
References [1] O. Bernholtz, M.Y.
Vardi, P. Wolper, An automata-theoretic approach to branching-time model checking, in: Computer Aided Verification, Proc.
6th Int.
Workshop, Stanford, CA, in: Lecture Notes in Computer Science, vol.
818, Springer, Berlin, 1994, pp.
142a155.
[2] A. Bolotov, Clausal resolution for branching-time temporal logic, PhD thesis, Department of Computing and Mathematics, The Manchester Metropolitan University, 2000.
[3] A. Bolotov, Clausal resolution for extended computation tree logic ECTL, in: Proceedings of the Time2003/International Conference on Temporal Logic 2003, Cairns, IEEE, 2003.
[4] A. Bolotov, A. Basukoski, A clausal resolution for branching-time logic ECTL+ , in: Proceedings of the Time-2004, IEEE, 2004, pp.
140a147.
[5] A. Bolotov, C. Dixon, Resolution for branching time temporal logics: applying the temporal resolution rule, in: Proceedings of the 7th International Conference on Temporal Representation Reasoning (TIME2000), Cape Breton, Nova Scotia, Canada, IEEE Computer Society, 2000, pp.
163a172.
[6] A. Bolotov, M. Fisher, A clausal resolution method for CTL branching time temporal logic, J.
Experimental Theoret.
Artificial Intelligence 11 (1999) 77a93.
A. Bolotov, A. Basukoski / Journal of Applied Logic 4 (2006) 141a167  167  [7] A. Bolotov, M. Fisher, C. Dixon, On the relationship between awa-automata and temporal logic normal form, J.
Logic Comput.
12 (2002) 561a581.
[8] J. Bradfield, C. Stirling, Modal logics and mu-calculi, in: J. Bergstra, A. Ponse, S. Smolka (Eds.
), Handbook of Process Algebra, Elsevier, North-Holland, Amsterdam, 2001, pp.
293a330.
[9] E.M. Clarke, E.A.
Emerson, Design and synthesis of synchronisation skeletons using branching time temporal logic, in: Logic of Programs, Proceedings of Workshop, in: Lecture Notes in Computer Science, vol.
131, Springer, Berlin, 1981, pp.
52a71.
[10] E.A.
Emerson, Temporal and modal logic, in: J. van Leeuwen (Ed.
), Handbook of Theoretical Computer Science, vol.
B, Formal Models and Semantics, Elsevier, Amsterdam, 1990, pp.
996a1072.
[11] E.A.
Emerson, Automated reasoning about reactive systems, in: Logics for Concurrency: Structures Versus Automata, Proc.
of International Workshop, in: Lecture Notes in Computer Science, vol.
1043, Springer, Berlin, 1996, pp.
41a101.
[12] E.A.
Emerson, J.Y.
Halpern, aSometimesa and aNot nevera revisited: On branching versus linear time temporal logic, J. ACM 33 (1) (1986) 151a178.
[13] E.A.
Emerson, A.P.
Sistla, Deciding full branching time logic, in: Proceedings of the Sixteenth Annual ACM Symposium on Theory of Computing (STOC 1984), 1984, pp.
14a24.
[14] M. Fisher, A resolution method for temporal logic, in: Proc.
of the XII International Joint Conference on Artificial Intelligence (IJCAI), 1991, pp.
99a104.
[15] P. Wolper, On the relation of programs and computations to models of temporal logic, in: L. Bolc, A. SzaLas (Eds.
), Time and Logic, a Computational Approach, UCL Press Limited, 1995, pp.
131a178, Chapter 3.