Is There a Future for Deductive Temporal Verification?
Clare Dixon, Michael Fisher and Boris Konev Department of Computer Science The University of Liverpool, Liverpool L69 3BX, United Kingdom C.Dixon,M.Fisher,B.Konev  @csc.liv.ac.uk  Keywords: fragments of PTL; deductive verification; complexity; clausal temporal resolution.
Abstract In this paper, we consider a tractable sub-class of propositional linear time temporal logic, and provide a complete clausal resolution calculus for it.
The fragment is important as it captures simple B uEchi automata.
We also show that, just as the emptiness check for a BuEchi automaton is tractable, the complexity of deciding unsatisfiability, via resolution, of our logic is polynomial (rather than exponential).
Consequently, a BuEchi automaton can be represented within our logic, and its emptiness can be tractably decided via deductive methods.
This may have a significant impact upon approaches to verification, since techniques such as model checking inherently depend on the ability to check emptiness of an appropriate B uEchi automaton.
Thus, we also discuss how such a logic might form the basis for practical deductive temporal verification.
1 Introduction It is widely recognised that model checking is the most appropriate verification method for (finite state) systems.
Yet there are some surprising aspects to this.
The model checking (i.e.
satisfiability checking) problem for propositional, linear temporal logic (PTL) is PSPACE-complete [20, 23] yet practical tools for model checking formulae in this logic have been developed, most notably Spin [13].
This has led to deeper investigations into the structure of temporal formulae and their relationship with model checking,  most notably the paper by Demri and Schnoebelen [5].
There, the authors consider sub-fragments of PTL, particularly those restricting the number of propositions, the temporal operators allowed, and the depth of temporal nesting in formulae.
Demri and Schnoebelen show that, since the formulae tackled in practical model checking often fall within such fragments, then this provides a natural explanation for the viability of model checking in PTL.
Our research has followed a different, but related, direction.
Over a number of years, we have been concerned with developing a clausal resolution calculus for both propositional and first-order linear temporal logics [4, 11, 14, 15, 16].
Since deciding unsatisfiability of PTL is also PSPACE-complete, then deductive verification of PTL formulae would seem to be an impractical way to proceed.
However, just as Demri and Schnoebelen showed how PTL model checking can be seen as being tractable when we consider fragments of PTL, so we have been examining fragments of PTL that allow clausal resolution to be tractable.
In previous work, we examined a fragment where temporal formulae in the clausal form (SNF; see Section 2) were essentially restricted to Horn Clauses [8].
In this paper, however, we investigate a different fragment, where clauses inherently involve XOR operators.
As we will show, the use of XOR has several benefits.
Since the complexity of unsatisfiability for XOR clauses in classical propositional logic is low [19], there is the potential to carry much of this over to the temporal case.
More importantly, if we consider a BuEchi automaton, then we can easily represent the states (using say fi ) and labels (using say  ) of the  automaton in PTL.
Indeed, the clausal form we use makes this simpler still with clauses such as 1 fi   	      corresponding directly to transitions (in this case, from state   to state   reading label   ).
However, in such a translation, an underlying problem is representing the fact that the automaton must be in exactly one state at any moment in time (and, similarly, that the automaton can only read exactly one label at any moment).
This provides an obvious motivation for allowing XOR clauses, since the formula       captures the property on states that we require.
Thus, in this paper we provide several results.
First, we introduce the PTL fragment to be considered and show a completed clausal resolution system for this.
Then we show that the complexity of deciding unsatisfiability via resolution is polynomial and, since BuEchi automata can be described simply by clauses in this logic, then an emptiness check for a BuEchi automaton can be tractably carried out using clausal temporal resolution.
The paper is organised as follows.
Section 2 reviews the syntax and semantics of PTL, together with the normal form, SNF, for this logic.
In Section 3 we introduce the restriction based on XOR clauses and provide a corresponding modification of SNF.
Section 4 introduces the resolution calculus for this restricted logic, and considers the completeness of this calculus, while Section 5 addresses its complexity.
In Section 6 we show how BuEchi Automata can be translated into this fragment and, in Section 7 we provide concluding remarks, incorporating both related and future work.
2 PTL and SNF The particular variety of temporal logic we consider is called PTL [12], and is based on a linear, discrete model of time with finite past and infinite future.
Although many variations on this simple logic have been examined, we will just use basic PTL with future-time temporal operators.
1 Here, each proposition,  , represents the fact that the automaton is in state   .
We assume that the automaton has  such states.
2.1 Syntax of PTL The future-time temporal connectives that we use include  (sometime in the future), (always in the future),  (in the next moment in time),  (until), and  (unless, or weak until).
Formally, PTL formulae are constructed from the following elements:   a set,  , of propositional symbols;   propositional connectives, true , false , , !
,  , and 	 ; and   temporal connectives,  ,  , ,  , and .
The set of well-formed formulae of PTL, denoted by WFF, is inductively defined as the smallest set satisfying the following.
Any element of    true and false are in WFF.
If " and # +"  $"  is in WFF.
are in WFF then so are "%!&# "'(#  " ",-# "  ")	*# # .
"/  A literal is defined as either a proposition symbol or the negation of a proposition symbol.
An eventuality is defined as a well-formed formula of the form 0" .
2.2 Semantics of PTL As discussed above, a sequence of distinct amomentsa in time underlie PTL.
Typically, the Natural Numbers, 1 , is used to represent these moments in time.
So, a model for PTL, 2 , can be characterised as a sequence of states 2436587:9;5<9;589;5>=:9  where each state, 5  , is a set of proposition symbols, representing those proposition symbols which are satisfied in the ?A@CB moment in time.
As formulae in PTL are interpreted at a particular state in the sequence (i.e., at a particular moment in time), the notation 2D9;?>FE 36"  denotes the truth (or otherwise) of formula " in the model 2 at state index ?HGI1 .
For any formula " ,  2D9;?8 2D9;?8 2D9;?8 2D9;?8 2D9;?8 2D9;?8 2D9;?8 2D9;?8 2D9;?8 2D9;?8 2D9;?8  E3    iff  E3  true E3 false E 36"% # E 36"%!
# E 36")	*# E 3)$" E3  " E 3)+" E3 " E 36"  #  2D9;?8 E 36"   #  iff iff iff iff iff iff iff iff iff   G  [where   5  G   ]  2D9;?>FE 36" and 2D9;?8 E 36# 2D9;?>FE 36" or 2D9;?8 E 36# 2D9;?>FE 3)$" or 2D9;?8 E 36# 2D9;?> E 36" 2D9;?
 E3 " ?
and 2D9 FE 36" there exists a G(1 such that for all G(1 , if ?
then 2D9 FE 3 " there exists a G(1 , such that ?
and 2D9  E 3 # and for all 0G 1 , if ?
then 2D9 FE 36" 2D9;?>FE 36",-# or 2D9;?8FE 3 "  fi    	 	       	   	  	  	  	    Figure 1.
Semantics of PTL  model 2 , and state index ?G(1 , then either 2D9;?8FE 36" holds or 2D9;?8 E 36" does not hold, denoted by 2D9;?8fiE 3 " .
The pair 2D9;?> can be considered as an interpretation (or valuation) for each formula in WFF.
(N.B., we will reason about such interpretations in the completeness proof given later.)
If there is some 2 such that 2D9   E 3 " , then " is said to be satisfiable.
If 2D9  %E 3 " for all models, 2 , then " is said to be valid and is written E 3 " .
Note that formulae here are interpreted at 5;7 ; this is an anchored definition of satisfiability and validity [9].
The semantics of WFF can now be given, as in Figure 1.
2.3 SNF, a Normal Form for PTL The resolution method that we will use later is clausal, and so works on formulae transformed into a normal form.
The normal form, called Separated Normal Form (SNF), comprises formulae that are implications with present-time formulae on the left-hand side and (present or) future-time formulae on the righthand side.
The transformation into the normal form reduces most of the temporal operators to a core set and rewrites formulae to be in a particular form.
The transformation into SNF depends on three main operations: the renaming of complex subformulae; the removal of temporal operators; and classical style rewrite operations [10, 11].
To assist in the definition of the normal form we in-  troduce a further (nullary) connective astarta that holds only at the beginning of time, i.e., 2D9;?8FE 3  start  iff    ?$3    This allows the general form of the (clauses of the) normal form to be implications.
Now, formulae in SNF are of the general form      "   where each "  is known as a temporal clause (analogous to a aclausea in classical logic) and must be one of the following forms with each particular 	 , 	 ,  , !
, and  representing a literal.
# 	  "   "    " !  	# 	     start  	  true  	        (initial clause) (universal clause) (step clause) (sometime clause)  For convenience, the outer and  connectives are usually omitted, and the set of clauses $ " &% is considered.
While the translation from arbitrary temporal formulae to SNF will not be described further here, we  note that such such a transformation not only preserves satisfiability, but also ensures any model generated from the formula in SNF is a model for the original formula [10].
In addition, the complexity of the translation process is low [11].
    G  form    and   G  there is at most one clause of the      : 	  "        in the clause set.
3 PTL-X and SNFX  4 Clausal Temporal Resolution for SNFX  We will now define additional syntax for PTL, namely the XOR operator, a  a, and characterise a modification of SNF, called SNFX , especially modified to capture automata-properties.
The key aspect here is that the set of propositions,  , is partitioned into two disjoint sets, and .
Note that these will later represent states and labels once we begin translating automata into SNFX .
The XOR operator is defined simply as  Next we consider resolution rules for sets of SNFX clauses.
The resolution rules are split into four groups: initial resolution; step resolution; hyper XOR resolution and temporal resolution.
  fi       	 	  2 9;?8FE 3 D   6: there is exactly one      iff such that 2D9;?8 E 3  The new logic, PTL-X , will comprise exactly those clauses that can be represented in SNFX .
Thus, we will concentrate first on SNFX .
Like SNF, SNFX is of the general form    "    Initial Unit Resolution involves resolving an initial clause with a universal clause:  (initial clause)  	    (step clause)      :   	  true  "     "  true  	    true true  	      	  where   9    G         .:              (XOR- clause) (XOR- clause)    and  4G , and where  must be one of   , or   !)
   .
In SNFX , at most one sometime clause and at most one initial clause is allowed.
must equal $fi9 :9 9  % and must equal $fiA9 9 9  % .
Thus, all elements of and occur within some XOR clause.
In addition, there is a further restriction on the form above, namely that, for every   ,   such that               	  replaces the  SRES  	  true  	               !
          (sometime clause)       	  	  true      The conclusion of the rule,  :    	 premise      	  !
  .
(universal clause)      Step Resolution resolves step clauses with universal clauses (Step Unit Resolution, SURES) or derives additional universal clauses from contradictions obtained in the next moment (SRES):              SURES  	        The conclusion of the rule, start 	 !
fi .
premise start 	  where each "  must be one of the following.
start  !
start 	 true 	 start 	  IURES  replaces the  false   !
    Hyper XOR Resolution takes several universal clauses relating to the negation of a proposition in , together with the XOR- clause:    HRES    true  true true true  	    !
    	  	    	    The conclusion of the rule, true 	 first premises (of the form true 	      !
  6  :    	              replaces the !4   ).
Temporal Resolution Since there is only one sometime clause which is of a simple form (i.e.
it has true on the left hand side) we can use a simplified version of the standard [11] step resolution rule, defined in [3]:  " TRES     	     true  	  true  	  "              The completeness theorem requires a proof.
To apply TRES we must find a (non-temporal) for  .
mula "   such that "   implies        For standard SNF clauses this problem has been addressed previously in [6].
Here we have a simpler set of clauses so the  search for a loop (i.e.
a set of clauses that imply  ) is easier.
      Loop Search  "  .
Let        Iteratively search through  for clauses     	 !
  where  .Gfi or clauses    	  false .
Delete    	  !
  (respectively    	  false ) from  , delete .
 from fi and and let fi/3fi fi        !        $ %       Terminate when either  3 or  doesnat change as we search through the clauses.
If  "    3     -	  there  is no loop, otherwise the loop is  .
    denote the initial clause, be the set of all universal clauses,          which initially contains the      Proof We adapt the completeness proof of the original system [11, 3] as described below.
First, we introduce additional definitions.
We split the set of temporal clauses into four groups.
Let        Create two sets of propositions: fi , representing good propositions, and fi , representing bad propositions.
Initially, let fi  be the members of which occur on the left hand sides of clauses in  which are not in and let fi 3  	fi .
  Theorem 2 If a set of SNFX clauses is unsatisfiable then the temporal resolution procedure will derive a contradiction when applied to it.
Assume we are resolving with true 	 3 $fi E  G "  % .
Construct a set  set of step clauses.
!  Since the SNFX temporal resolution rules can be seen as a particular strategy for unrestricted temporal resolution [11] (note that in both unit resolution rules, the conclusion of the rule subsumes the premise); we, obviously, have the following soundness theorem.
Theorem 1 The rules of clausal temporal resolution preserve satisfiability.
     Subsumption Finally, we assume that standard subsumption takes place.
    be the set of all step clauses, be the sometime clause, and be the set of XOR clauses.
Definition 3 (behaviour graph) Given a set of SNFX clauses over a set of propositional symbols  , we construct a finite directed graph as follows.
The nodes of are interpretations of  , and an interpretation, !
, representing some pair 2D9;?8 , is a  node of if !
(E 3'"   .
For each node, !
, we construct an edge in G to a node !$# if, and only if, the following condition is satisfied:  For every step clause then !
'# E 3 .
  &%  	      ,G    , if !
(E 3  %  A node, !
, is designated an initial node of if !6E 3  ( .
The behaviour graph ) of the set of clauses is the maximal subgraph of given by the set of all nodes reachable from initial nodes.
  Notice that, because of the XOR-clauses, exactly one proposition  G and exactly one proposition  G are true in !
.
Therefore, we can associate nodes of the behaviour graph, ) , with pairs 9   , where and $G .
fiG        Let 9   ,  # 9  #  be nodes of graph the relation  )  .
We denote  Let  be a set of SNFX clauses.
Recall that the set of propositions in  is partitioned into two disjoint sets, and ; let the cardinality of be 	 the cardinality of be .
# 9  C#  , and the relation      a  # 9  #  is a successor of 9   a  by   9    #9 #.
The proof of completeness proceeds by induction on the number of nodes in the behaviour graph ) ,   which is finite.
If ) is empty then the set    is unsatisfiable.
In this case there must exist a derivation by IURES and HRES (and this is because the rules IURES and HRES taken alone coincide with complete classical hyper resolution).
Now suppose ) is not empty.
Let !
be a node of ) which has no successors.
We show that there exists an inference by temporal resolution deleting the node from the graph.
Then, there exists exactly one step rule    	    "   9  whose left-hand side matches 9   .
Notice that, for every 	 and every  G $9 % , we have   fi (for otherwise, there would be an edge     in ) from  9   to  9    ).
Because of the restricted form of  , it means that for every  G $9 % , we have  !
  G% .
Therefore, for every 	 the  can be deduced by HRES and, clause true 	 hence, the clause true 	 fi!'
 can be obtained by SURES, SRES.
This eliminates node !
from the behaviour graph.
In case when all nodes of ) have a successor, a contradiction can be derived with the help of the temporal resolution rule TRES.
Note that we impose no restriction on this rule (it coincides with the temporal resolution rule for the general calculi presented in [11, 3]) and the proof of completeness is no different from what is already published [11, 3].
        To analyse the complexity of SNFX resolution, we first consider the complexity of the saturation procedure by step resolution (by step resolution we mean rules IURES, SURES, SRES, and HRES), then we consider the complexity of loop search, and finally, we consider the overall complexity of the proof procedure.
Complexity of step resolution  a  # 9  #  is an immediate successor of  9   a by 9    5 Complexity of SNFX Resolution                  We show that there exists a polynomialcomplexity (in terms of 	 and ) procedure that saturates  by step resolution, that is, applies the rules IURES, SURES, SRES, and HRES to  exhaustively until no new clause can be derived.
Notice that any saturation procedure, which ensures that no inference rule is attempted on the same set of premises more than once, will have a polynomial complexity.
Notice further that the Given Clause Algorithm [18] satisfies this requirement.
The complexity of the procedure is bounded then by the number of different sets of premises to which inference rules can be applied.
It suffices to notice that the HRES rule can be applied to at most 	 different sets of premises; SRES to at most  	 sets of premises; the SURES rule  can be applied to at most 	 sets of dif  ferent premises (notice that, since no two step clauses have the same left-hand side, there are different step rules in any clause at most 	  set); and, similarly, the IURES rule can be applied to at most 	 sets of different premises.
Altogether, the complexity of the saturation procedure  is  	   .
       Complexity of loop search  Notice that since at every iteration of loop search, at least one proposition is deleted from fi  , there are at most 	 iterations.
Using efficient implementation techniques, the search in every iteration can be implemented in time bounded by  	   is 	          .
Therefore, the complexity of loop search .
Overall complexity  The overall procedure works as follows: the set of clauses is saturated by step resolution, then loop search is attempted.
If loop search succeeds, the set of clauses is extended by the conclusion of the TRES rule and the entire process repeats (we call the process the main loop) until either a contradiction is obtained, or nothing new can be derived.
The overall complexity of the proof procedure is bounded by the product of the number of iterations of the main loop and the joint complexity of saturation and loop search.
Note that there may not be more than 	 iterations of the main loop.
Therefore, the overall complexity of proof search = .
is  	      6 From BuEchi Automata to SNFX We will now consider the representation of a BuEchi automaton as a set of SNFX clauses and, in particular, emptiness checking of the automaton as deriving a refutation in SNFX .
We begin with a standard definition of a BuEchi automaton [21, 22].
6.2 From BuEchi Automata to SNFX We aim to construct a set of SNFX clauses , from  such that , is satisfiable if, and only if, has an accepting run.
 To represent in SNFX we use the following propositions:      for each   G      for each   G# .
  ;  The set  of SNFX clauses representing the au tomata is as follows.  "
start 	    for fi G" 7      "        	          	   false  .:    .        	  true true true 	 	  "    for   G"   9-             for    9-  3  for  3 $  9 <  for %3 $ 9 .
for   G/  %    %  Proposition 4 A BuEchi automaton  3 fi 9  9/79" 9"0	 has an accepting run (over infinite word  ) if, and only if, the set of  SNFX clauses,  , defined above, is satisfiable.
6.1 Definition of a BuEchi automaton   9  7 9  9  	 , A BuEchi automaton, , is a tuple fi 9   where:  %3 $ 79 % is a finite non-empty alphabet;   3 $  7 <  % is a finite set of states;          7     , is a set of initial states;    fi3     is a non-deterministic transition function; and       , is a set of accepting states.
A  	 3  7 9   9   9 of a BuEchi automaton,  , over the word  3F7   $ , where   G! , is an infinite sequence of states,   G  where the first G  7 , and for every other state is the initial state, i.e.
7 " state fi   for ?
 we have fi   # 3  9 9 G   ;9    .
 G  A run,  , is $&% %(' 58?
*) if there is a state  + such that  appears in  infinitely often.
  Proof   	% We first show that, given a BuEchi automaton, , with an accepting run such that  is its translation into SNFX , as described above, there is a model which satisfies  .
  3 fi 9  91 792920	 , be a given nonLet  empty BuEchi automaton and let have an ac 33 7  $.    , ( G cepting run  @ @ @ for 5 3  9 .9 9 ) over an infinite word  3  7     .
      .
For some accepting state @ @  4+6 5 G  , 5 4 must appear infinitely often in  .
In the run  , at the 58@CB moment of time when the automaton is in the state  and reads  , it moves @ @ to    , i.e.
  9   7 3   .
@ @ @ @ We now construct a model 2 and show it satisfies "  # 9  8 the clause set  .
We note that as "  # we can assume that the external a  Hence, from the semantics of a   a operator in Section 3 is applied to each implication in  .
9    9 9    2D9;5 E 3    Next we show 2 satisfies the clause set   "  	    Next we must show that the step clauses of hold.
Consider the implication,    "         E3  fi or  be some state   3  which is visited in the @ 5 moment of the accepting run and a transition @CB  G   9-  such that in the 5  st moment in time the accepting run is at state ,3    hav@ ing read  3  .
Thus, from the construction  @ of 2 , 2D9;5 : E 3  and from how we have constructed  and the semantics of !
,    2D9;5     E3  "     $  "        	 	 	 	  Finally consider the sometime clause.
From the construction of the model 2D9;5 54 if, and only if,  3 5 4 and since the automaton  hits the @ state 5 4 infinitely often, the sometime clause is satisfied.
Therefore, all clauses in            Next consider some time 5 such that 2D9;50E 3   and 2D9;5; E 3  .
We must show that 2D9;5; E 3  "   .
From the construction of 2 there must      Recall that the run  in the 58@CB moment of time visits the state   3! .
From the construction of @ 2 , 2D9;5;   and 2D9;5   for every   3    .
Hence the XOR- clause is also satisfied in 2 at every moment.
Similarly from the infinite word  of the accepting run and how we have constructed 2 at each state we have 2D9;5; E 3   for some   such that  %?
and 2D9;5fi  E 3   for all  3  ?
such that  .
   For any moment 5 such that 2D9;5; 2D9;5;E 3  the above holds trivially.
  is satisfied.
.
is satisfied at every moment in time.
    	  "   	       	                    Thus, at all moments in time each step clause holds and  The run  is an accepting run which starts from  7 .
Thus  7 is one of the initial states, i.e.
7 G 7 , and from how we have constructed 2 , :7 is satisfied in the initial moment  , i.e.
2D9   E 3 7 .
  E 3 start for 5 Also as 2D9   E 3 start and 2D9;5  , from the semantics of start, the initial clause of the clause set  fi	    and  9   9  @ @ as follows.
Set the propositions that are true in  on the aceach state to match those read by cepting run for the infinite word  , i.e.
  G  if, and only if,  3   .
For any   G/ then @ @  -" G  if, and only if,  3)  (set   to be true if @ @ and only if the state visited in the 5@CB moment in time of the accepting run,  , is   ).
2437 7:9  "   2D9;5;FE 3  Let  be a set of propositional symbols where  3 $fi -E  -G % $fi  E fi$G  % .
We construct an infinite sequence of states  a,      are satisfiable in 2 .
   Assume now that for an automaton , the corresponding set of SNFX clauses,  , is satisfi able.
We show that has an accepting run.
Consider the sequence of states 2 3  7 9   9   9 such that 2D9  E 3  .
Because of the XOR there is exactly one clauses, for every !
5   G  and exactly one  G  such that   G  and  G  .
We show by induction on 5 @ @ that the sequence of states  7 9   9-  and the @ word  7 -9  9  are such that  7 G 7 and @   9   3   .
@ @ @ For 5 3 , since              2D9  E 3  start 	  "            the state  7 is initial.
clause  Consider now the step    "       	                          true 	   	       It remains to notice that, since         "                =    =                       (Note that the right-hand side of the step clause cannot be false for otherwise false G    .)
@ Then   / G    .
Note that   G# fi>9-  .
@  2D9  E 3  start 	                   for   G  , the state   appears in the sequence  3  :7 9  9 9  9 infinitely often, that is, @ the run  is accepting.
      	        =  	  	 	   	        	  	   	 	  !
       	  true true true        	  =!
           	     	          =     fi   !
    Loop Search Initially, fi 3 $fi  9  = 9  % and fi 3 $fi9   % .
There is no change to either set so the loop is     !
= !
  	        Applying temporal resolution we obtain.
Example 1 Consider a BuEchi Automaton fi 9 $9  7 9  9 0	 , where:   $  %3         3      	  %      %  true true true            true true true start                                    The transitions are given below.
  true true true                      =         9 fi      $% $    3  	     	   	     9    9     =      9  Thus clauses 3a8 are subsumed by one of 14a16.
 9   9  = 9 9   7 3     $ 3  %  7 9-     $     -9    :9       =:9  fi  $  $ %  %  $ % $ %    %  Hence there is no accepting run.
-9  :    =       $ % $ % $ % $ % $ %   	             	 	 	 	 	 	  	  	  	     fi    false false !
   !
  false  	    	 	    9    9  9 9 	  9    9   9 9  9  ! .
  9 9 "   .9 9   .9  9   #  9      9     .9  .9  9  ! 	  .9  9 $%"&  false  false fi !
   !
                     Example 2 Now, consider a BuEchi Automaton fi  9  9  79 9 0	 , where:   $  %    %3   3  $  9  9  =  %     3    7    $  % $% 3  3   7 Conclusions  The transitions are given below.
  $       =     9-     9    =  =  %  $ % $ %  Hence there is no accepting run.
                     start         =   true true true  	     	      	 	   !
  =   =          	 	 	   =  Note that, since the only symbol in the alphabet is   , the XOR- clause is simply true 	   (clause 5).
  Loop Search Initially, fi 3 $fi9 = % and fi 3 $fi % .
From clause  we delete   from fi and add to fi and obtain fi'3 $fi= % and fi 3 $fi9  % .
There is no change to either set so the loop formula is = 	    By applying temporal resolution we obtain the following.
  true 	  =  9   This subsumes clause 3.
             	  true true     	        	 	  false   !
(        	  9 9"    9    9 9"&  9 9     Clause 11 now subsumes clause 2.
Now, attempting loop search again (note the current set of step clauses is just clause 11) we have fi  3 $fi  % and fi 3 $fi9  = % .
We obtain the loop  	    By applying temporal resolution we obtain the following.
      true 	 start 	     false    9    9 9$%"     In this paper we have introduced a novel fragment of PTL, and have provided a complete resolution calculus for this fragment.
The complexity analysis carried out has shown that the resolution approach provides a polynomial decision procedure.
While this is interesting in itself, a further important aspect is that we can represent a BuEchi Automaton (symbolically and directly) as formulae in this fragment, with the emptiness check for such an automaton corresponding to the search for a resolution refutation.
fi In establishing that some system, , satisfies a % property, , algorithmic, rather than deductive approaches have been predominant.
In particular, the model checking approach [22, 2], characterised by checking the emptiness of the automata product 2            	    has been very successfully applied.
On the other hand, deductive temporal verification has been largely ignored (though see [17]), often due to its much higher complexity.
With our work in this paper, we believe that deductive temporal verification can be successfully applied to such % problems, for exfi   & ample by representing   in PTL-X , where fi    is the temporal/symbolic description/semantics of the behaviour of the system.
That PTL-X corresponds closely to BuEchi Automata which, in turn, are at the heart of algorithmic verification, gives reason for optimism.
Thus, our future work concerns developing such a view of deductive temporal verification further, as well as examining more complex (but still tractable) XOR temporal logics [7].
Concerning practical implementation, we note that the complexity given in Section 5 is a worst case analysis.
With aclevera implementations, we expect the practical complexity to generally be much lower than this.
Work related to that developed in this paper concerns the excellent analysis by Demri and Schnoebelen [5], work on complexity of fragments of classical logic [19] and our own previous work on the relationship between SNF and BuEchi Automata [1] and on other tractable fragments of SNF [8].
Here,  captures all the paths/executions through  , while  describes all the paths that satisfy  , i.e., all those paths that do not satisfy  .
2  Finally, we would like to thank Radina Yorgova for her work on varieties of RSNF [8] which helped us to formulate the fragment described in this paper.
References [1] A. Bolotov, M. Fisher, and C. Dixon.
On the Relationship between -Automata and Temporal Logic Normal Forms.
Journal of Logic and Computation, 12(4):561a581, August 2002.
[2] E.M. Clarke, O. Grumberg, and D. Peled.
Model Checking.
MIT Press, December 1999.
[3] A. Degtyarev, M. Fisher, and B. Konev.
A Simplified Clausal Resolution Procedure for Propositional Linear-Time Temporal Logic.
In U. Egly and C. G. FermuEller, editors, Automated Reasoning with Analytic Tableaux and Related Methods (TABLEAUX-02), volume 2381 of LNCS, pages 85a99.
Springer-Verlag, 2002.
[4] A. Degtyarev, M. Fisher, and B. Konev.
Monodic Temporal Resolution.
ACM Transactions on Computational Logic, 7(1), January 2006.
[5] S. Demri and P. Schnoebelen.
The Complexity of Propositional Linear Temporal Logic in Simple Cases.
Information and Computation, 174(1):84a103, 2002.
[6] C. Dixon.
Temporal Resolution using a Breadth-First Search Algorithm.
Annals of Mathematics and Artificial Intelligence, 22:87a115, 1998.
[7] C. Dixon, M. Fisher, and B. Konev.
XOR-Temporal Logics.
(Submitted), 2006.
[8] C. Dixon, M. Fisher, and M. Reynolds.
Execution and Proof in a Horn-clause Temporal Logic.
In Advances in Temporal Logic.
Kluwer Academic Publishers, 1999.
[9] E. A. Emerson.
Temporal and Modal Logic.
In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 996a1072.
Elsevier, 1990.
[10] M. Fisher.
A Normal Form for Temporal Logic and its Application in Theorem-Proving and Execution.
Journal of Logic and Computation, 7(4):429a456, August 1997.
[11] M. Fisher, C. Dixon, and M. Peim.
Clausal Temporal Resolution.
ACM Transactions on Computational Logic, 2(1):12a56, January 2001.
[12] D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi.
The Temporal Analysis of Fairness.
In Proceedings of the Seventh ACM Symposium on the Principles of Programming Languages (POPL), pages 163a173, January 1980.
[13] G. J. Holzmann.
The Spin Model Checker: Primer and Reference Manual.
Addison-Wesley, November 2003.
[14] U. Hustadt and B. Konev.
TRP++ 2.0: A Temporal Resolution Prover.
In Proceedings of Conference on Automated Deduction (CADE-19), number 2741 in LNAI, pages 274a278.
Springer, 2003.
[15] U. Hustadt, B. Konev, A. Riazanov, and A. Voronkov.
TeMP: A Temporal Monodic Prover.
In D. Basin and M. Rusinowitch, editors, Proceedings of the Second International Joint Conference on Automated Reasoning (IJCAR 2004), volume 3097 of LNAI, pages 326a 330.
Springer, 2004.
[16] B. Konev, A. Degtyarev, C. Dixon, M. Fisher, and U. Hustadt.
Mechanising First-Order Temporal Resolution.
Information and Computation, 199(1-2):55a 86, 2005.
[17] Z.
Manna and the STeP group.
STeP: Deductivea Algorithmic Verification of Reactive and Real-Time Systems.
In International Conference on Computer Aided Verification (CAV), volume 1102 of LNCS.
Springer-Verlag, 1996.
[18] W. McCune.
Otter 2.0.
In Proceedings of Conference on Automated Deduction (CADE-10), volume 449 of LNCS, pages 663a664, 1990.
[19] T. J. Schaefer.
The Complexity of Satisfiability Problems.
In Proceedings of the Tenth Annual ACM Symposium on Theory of Computing, pages 216a226, 1978.
[20] A. P. Sistla and E. M. Clarke.
Complexity of Propositional Linear Temporal Logics.
Journal of the ACM, 32(3):733a749, July 1985.
[21] A. P. Sistla, M. Vardi, and P. Wolper.
The complementation problem for buEchi automata with applications to temporal logic.
Theoretical Computer Science, 49:217a237, 1987.
[22] M. Y. Vardi.
An automata-theoretic approach to linear temporal logic.
In Logics for Concurrency - Structure versus Automata (Proceedings of 8th Banff Higher Order Workshop), volume 1043 of LNCS, pages 238a 266.
Springer, 1996.
[23] P. Wolper.
Temporal Logic Can Be More Expressive.
Information and Control, 56, 1983.