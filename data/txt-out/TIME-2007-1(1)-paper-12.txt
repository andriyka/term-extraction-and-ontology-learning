Relational Temporal Machines Nicole Bidoit Univ.
Paris-Sud, UMR 8623, Orsay F-91405 CNRS, Orsay F-91405 nicole.bidoit@lri.fr  Abstract The paper introduces and investigates relational temporal machine (RTM) as a general abstract model for generic temporal querying.
The RTM devices subsume most temporal query languages that have emerged in the literature.
A first contribution of the paper is to provide two simplified forms for our machines, namely extended onetape RTMs and one-tape RTMs.
Another contribution is to establish connections between RTMs and the T- WHILE and TS - WHILE extensions of FO based on complexity criteria.
1 Introduction Emerging applications such as the web, bioinformatics, medical applications, multimedia applications, animation, simulation, personal information management, data flow processing, streaming, are intensively managing temporal or ordered information.
Thus in many computer science areas, modeling and manipulating temporal and ordered information turns out to be a central issue.
Suitable database models [12, 21] have been developed to store and support temporal information management.
The languages mainly target snapshot queries (what are the data available at some time point?
), history extractions (what is the evolution of some data?).
Most temporal query languages are based on extensions of first-order logic ( FO) or SQL.
Two central classes of formal temporal languages have been considered so far.
- Linear temporal logic TL [13, 12] and its extensions ETL [24], TL [23], T- WHILE and T- FIXPOINT [3, 8] allow to query temporal databases represented as finite sequences of database states.
- Time-stamped first-order logic TS - FO and its extension TS - WHILE [3] allows to query temporal databases represented by time-stamped relations.
The aim of this paper is to introduce and investigate relational temporal machines (RTM) as a  Francois Hantry Rectorat de Paris francois.hantry@voila.fr  general-purpose computation model for temporal querying.
The first issue is to provide an abstract model of temporal querying.
Indeed, the well-known formal temporal languages TL and TS - FO have very strong limitations: they provide the ability to define mappings from temporal instances to relations (tables) and lack the ability to map temporal instances to temporal instances, in a general manner.
The TWHILE extension of FO shares the same limitation although the language allows for computing auxiliary temporal instances in a restricted manner: auxiliary temporal instances in T- WHILE programs need to have a number of states equal to that of the input temporal instance.
Indeed, RTMs have the ability to map temporal instances to temporal instances and thus these devices subsume most temporal query languages.
The temporal computations defined by RTM are generic in the classical sense, that is, data with identical logical properties are treated uniformly.
The second issue is to demonstrate that RTMs are of special interest for studying, understanding and extending some of the features of known temporal languages by mapping such languages to subclasses of RTMs.
Indeed, one contribution of our paper is to establish connections between RTMs and the T- WHILE and TS - WHILE extensions of FO .
RTM s are based on Turing machines and have been inspired by relational machines (RM) [5] known as a very powerful formal tool for studying relational queries and their complexity.
The RTM model is a rather simple and intuitive extension of the RM model, given that we assume temporal instances to be finite sequences of database states.
An RTM machine uses tapes to store the input temporal instance (input tape) and the auxiliary temporal instances (auxiliary tapes).
Roughly, the contents of an RTM cell is a (set of) relation(s) of fixed arity rather than a bit in a Turing machine cell.
The interactions or transitions of an RTM can modify the auxiliary tapes either by changing the contents of (relations stored in) a cell through a first order (FO) query, or by adding/removing cells.
The input is accepted if the machine halts in an accepting state.
The output is the temporal instance stored in one of its auxiliary tapes.
Thus, a RTM is able to output a temporal instance of any (finite)  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  size, and of course of a size greater than that of the input temporal instance.
Note that, like a RM, an RTM uses a fixed set of FO queries.
The first results presented in the paper are dedicated to analysing the usefulness of different components of our devices.
Focussing on the number of auxiliary tapes, we are able to provide two reductions for RTMs.
The first reduction is rather simple and expected: it says that any RTM can be reduced to one, called extended one-tape RTM, using exactly two auxiliary tapes of which one is a simple store.
A store is a one-cell tape.
Although more powerful, extended onetape RTMs features are closely related to T- WHILE features.
The second result is a stronger contribution and provides a normal form for RTMs.
We prove that any RTM can be reduced to one using one and only one auxiliary tape.
Indeed, the proof strongly relies on the technical tools developed in [5] for building RM normal forms.
We then investigate some complexity classes of temporal computation by RTMs.
Our complexity measures are with respect to the length of the input temporal instance (tape).
We focus on space complexity: we intend to measure the size (length) of the auxiliary memory needed to compute some temporal query.
The paper first investigates linearspace and polynomial-space RTM.
Although T- WHILE and TS - WHILE are standard temporal query languages (they output static tables), they make use of temporal auxiliary instances during their computation.
Thus it makes sense to compare T- WHILE and TS - WHILE with RTM.
Nicely enough, it turns out that T- WHILE (resp.
TS - WHILE) is complete (i.e.
expresses all queries) w.r.t.
the class of linear-space (resp.
polynomial-space) RTMs, when outputs are restricted to be relations.
Constant-space RTMs are devices using one auxiliary store.
Recall that a store is a one-cell tape.
Such devices are called relational register machine (RRM), because registers are needed in that case.
Investigating RRM leads us to study new languages based on T- WHILE or on TL .
Indeed, we first investigate queries that are computable by relational pebble machine (RPM), which are RRM conforming to a stack discipline for register management.
It is immediate to show that, in the propositional case, the languages accepted by RPMs are exactly regular languages.
This entails that RRM are strictly more powerful than RPM.
We then show that RPM are strictly more expressive than TS - FO and ETL and claim the same for a natural restriction of T- WHILE called T- WHILE .
Our main contribution concerning RRM provides two temporal query languages, which are complete w.r.t.
RRMs.
The first language is a while-loop language called TWHILE based on T- WHILE.
The second language, called TL , is based on TL and hybrid modal logic [10] and uses temporal variables as propositions plus a fixpoint operator.
The paper is organized as follows.
After the preliminary definitions and notations presented in section 2, section 3 introduces relational temporal machines and then presents the two main reductions.
Section 4 investigates linear-space, polynomial-space and constant-space sub-classes of RTMs as well as their relationship with known languages.
The last section provides a short concluding discussion and further research directions.
2 Preliminaries We review informally some notions and notations related to relational databases (db) and query languages.
We assume the reader familiar with both first-order logic FO and with the usual definitions of relation schema, database schema and instances.
In the whole paper, we assume a unique possibly infinite domain for all attributes.
In the context of query specification, the db schema (resp. )
is a set of relation schemas and is used, in general, as the input db schema (resp.
auxiliary db schema).
An implicit temporal instance over the db schema is a finite sequence of finite instances over .
The size of , denoted is the size of the sequence , that is .
For each , is called the state of at time point .
The instance of the relation schema at time point is also denoted by .
The active domain of , denoted , is set of domain elements appearing in .
Thus is a finite subset of the domain.
In the paper, represents a tuple of (data) variables whose arity is clear from the context, and is a valuation of ranging over the active domain.
We assume w.l.o.g.
that the db schema includes two 0-ary relations (propositions) and such that iff , and iff .
We denote the temporal instance over of size whose states are all empty.
Thus, denotes the temporal instance of size .
The temporal query language TL The first order linear temporal logic TL [13] is a well known formalism for specifying queries over implicit temporal databases [12, 3, 7].
The syntax of TL over a db schema is given by the formation rules for FO over , together with the following additional rules: if and are formulas then and are formulas.
The satisfaction of a TL formula over a temporal instance at time point , given a valuation of the free variables of , denoted , is defined as follows: If  is  ,  iff  If is obtained by a first order rule, as usual.
14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  and for all  iff there exists such that ,  .
is defined such that .
and for all  iff there exists such that ,  such that .
A TL query over the db schema is specified by a TL formula and the answer of over the temporal instance , denoted , is obtained by evaluating at time point 1: a valuation .
The temporal query language ETL ETL [24, 3] is an extension of TL build using FO and regular languages.
The following formation rule is added to FO.
Let be a regular language over the finite alphabet and let be ETL formulas.
Then and are also ETL formulas.
iff there exists a word in of length such that for .
is dual and, intuitively, The semantics of checks a matching word over the past (left to ) instead of over the future (rigth to ).
For example, in order to specify in ETL the TL formula , one needs to consider the language and the formula with and .
A ETL query is defined exactly as a TL query and evaluated at time point 1.
Another example illustrates the power of ETL.
One can express in ETL the query t-even which returns true over if is even and false otherwise.
It suffices to consider the language and the formula with .
The temporal query language T- WHILE [3] is an extension of the well-known WHILE query language for static databases [11].
It is built using imperative mechanisms like assignments, loops and temporal moves.
Variants of this language have been investigated in [8].
A program over is specified by a sequence of declarations specifying the auxiliary db schema , followed by a sequence of instructions.
An auxiliary schema can either be declared shared or private.
Intuitively, instances of auxiliary shared schema are identical in all states of a temporal instance, that is if is a temporal instance over and is shared then for all .
No such restriction is enforced for private schemas.
The instructions of a program are: [temporal moves] left and right.
, where and is a FO for[assignment] mula over with free variables .
do end, where is [while loop] while a closed FO formula over and a sequence of instructions.
While loops can be nested.
E XAMPLE 2.1 The program shared proposition .
while do right ;  below uses an auxiliary end ;  Indeed, the value of iff t-even  returned by .
evaluated over  is  over a temIntuitively, the evaluation of a program poral instance proceeds as follows.
We use a temporal cursor, called current time point, denoted , which is assigned initially to 1.
A temporal instance over the auxiliary db schema is initialized with the empty temporal instance .
Instructions of are executed sequencially.
Each instruction has some effect either on the instance or on as explained below: left (resp.
right) decreases (resp.
increases) by 1.
If (resp. )
before the execution of left (resp.
right) then remains unchanged.
changes the instance only over .
Let be the answer of the FO query evaluated over the static instance (i.e.
over the snapshot of at the current time point ).
If is private then changes over only at , that is becomes ; if is shared then changes over everywhere, that is becomes for all .
do end executes all instructions of until either becomes false, or until a repetition of the effect of the execution of is obtained.
The effect of one loop iteration is measured by observing configurations.
A configuration, at some point of the evaluation of a program, is the pair where is the current instance of the auxiliary db schema and is the current time point.
Thus a while loop stops as soon as the configuration obtained after an iteration is the same as the one at its beginning.
The reader should pay attention to the fact that a repetition of the auxiliary instances over is not sufficient to exit the loop: if changes then the evaluation of the body of the loop is reactivated.
Of course, if neither the condition of the loop becomes false nor the sequence of configurations reaches a repetition, then the semantics of both the while loop and the program it belongs to are undefined.
Finally, a T- WHILE query over is specified by a T- WHILE program over and a distinguish shared schema whose instance, at the end of the evaluation of , is intended to collect the answer of the query.
Let us emphasize that T- WHILE is a query language that maps temporal instances to static relations although it computes auxiliary temporal instances.
Indeed, note that the size of these auxiliary temporal instances is exactly the size of the input temporal instance.
while  The temporal language TS - FO The definition of this language only makes sense when considering a temporal instance over as a standard instance over the time-stamped db schema where is obtained from by adding  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  one attribute of type "time" to each relation schema .
The domain of the attribute is the set of positive integers.
It is well known that any temporal instance over can be transformed into a time-stamped instance over , and vice versa.
For the sake of our presentation, the set of FO formulas over the time-stamped schema is denoted FO in order to distinghish these formulas from FO formulas over .
The language TS - FO is defined as a restriction of FO : free variables in a TS - FO formula are required to be "data" variables.
E XAMPLE 2.2 Let be a unary schema.
The formula below is a FO formula using one data variable and two free variables and of type "time": .
The evaluation of such a formula over a time-stamped instance returns pairs of integers (time points).
is a TS - FO query, called twin, which checks whether there exists two time points holding the same instance over .
The temporal language TS - WHILE This language also assumes that the temporal instances over are given as time-stamped instances over .
Then the language TS WHILE over is simply defined as the language WHILE over .
Thus a TS - WHILE program is build using auxiliary relation schemas, assigments of the form where FO , and while loops of the form while do end where is a boolean FO formula and is a sequence of instructions.
The fact that the right part of an assignement is a FO formula entails that the auxiliary schema S may have multiple attributes of type "time".
Of course in this framework, there is no such things as shared or private auxiliary schemas and instructions do not include temporal moves.
3 Relational temporal machines In this section, we introduce relational temporal machine (RTM) as an abstract model for general temporal db querying.
Recall that here we intend to capture temporal queries where both the input and the output are temporal db instances as explained in the introduction.
The model is a Turing-like machine which merges ideas from relational machines [5] and automata [22].
The input tape contains the input temporal instance and is read only.
A finite number of working tapes are available for storing intermediate computing and the output.
Of course, for both input and working tapes, each cell of the tape is a relational db instance.
A relational db schema is associated to each tape for typing the contents of the cells.
Over each tape, a cursor is used to scan the corresponding temporal instance and for  accessing the contents of a cell, i.e.
a relational instance.
A cursor is allowed to move in both directions (left and right).
A finite number of registers is introduced in order to store time points over the input tape; the only operation on registers (apart from assignment) is a comparison with the input cursor.
As usual, transitions specify the changes of state, of registers and of the tape contents as well as the moves of the cursors.
Transition may use a query in order to modify the contents of a cell (pointed by a cursor).
Queries are FO formulas specified over the input and auxiliary schemas.
They are evaluated on the relational instance composed by the contents of the cells pointed by the input and auxiliary cursors.
Next, we assume that is the input schema and that the input tape stores an instance over .
Formally, a relational temporal machine over working with tapes and registers, denoted RTM , is specified by: a finite number of db auxiliary schemas pairwise disjoint, one for each of the working tapes; an output tape given by , a finite set of states among which state; a subset of final states, a finite set where: -  is a subset of the and  - -  of transitions of the form ( ,  is a boolean FO query over  -  is the initial , ) ,  register indices,  are states,  is an action among where , for and a and finally with  FO  where , query over .
, with ,  on input is specified by A configuration of an RTM a tuple , , , where are the input and auxiliary cursor values, is a register assignment and is a temporal instance over .
It is required that and , for .
The initial configuration is , , , where , .
A configuration whose state is in is accepting and then the RTM outputs the temporal instance .
, , , , the Given a configuration transition applies iff , and where is the relational instance over defined by and .
It leads to the new configuration ... where (we only mention changes): - if  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  1 for  is  (resp.
(resp.
the case i=0, one should take  ) then1 if  then ),  - if is then is obtained by removing the last cell of the tape ; as side effects, if then , and if then , - if is then is obtained by extending the tape with a new empty cell, - if  is , where  with , if , then is defined as above (nothing  else changes), - if  is  then  ,  Before we start the analysis of our model, let us illustrate the definition of RTM by presenting an example.
Assume that the temporal database stores a sequence of picture descriptors.
Each state is a picture and each picture contains circles and triangles which can be either blue or red.
The RTM given in Figure 2 takes as input a sequence of pictures and split each picture in order to separate red forms from blue ones: red forms are placed in a picture that preceeds the blue ones which are placed in another picture.
Thus, in general, the result of this "color based splitting" is a temporal instance whose size is greater or equal to the input size.
Figure 1 gives an input sequence of pictures and the expected output.
Figure 2 represents the RTM implementing the color based splitting .
A transaction is drawn like this ( is omitted because the example does not require it): s ns .
When the boolean query is , the , and when there no action, it is arrow is labelled by labelled by .
RTM versus relational machines In case temporal instances are represented by timestamped relations (thus in case of working under the explicit time representation), the most straigthforward model for temporal querying that one may think of, is the standard relational machines.
However, the standard relational machine model is not powerful enough for captuting queries whose output length has to be greater than the input size.
This is due to the fact that standard relational machines do not invent "new" value in their result and thus the temporal domain cannot be changed by the query.
The previous example of "color based splitting" shows that RTM are able to define such queries.
genericity Genericity is a property which captures one of the main features of database system functional architecture, the so called physical independance principle: queries are assumed to only use information provided by the abstract view of data which is, of course, independent of the internal data representation.
More formally, generic computation is insensitive to automorphisms of the input.
Clearly, RTM specify generic computations.
RTM  Determinism Next, we will concentrate on deterministic RTMs, ensuring that in each configuration at most one transition applies.
The source of non determinism of an RTM comes from the boolean queries in a transition .
One way to enforce determinism is to require that given a state , there exists at most two kinds of transitions, the ones with premises of the form and the others with premises of the form .
In other words, "determines" .
Next, RTM denotes the temporal queries computable by deterministic RTM .
Register The reader should be aware about the fact that registers do not add any expressiveness to our model.
Registers have been introduced in order to simplify the specification of RTMs and also because they are needed useful when considering restricted version of our model as discussed in section 4.
P ROPOSITION 3.1  RTM  RTM  Sketch of proof : The RTM that simulates an RTM is very much like .
Its extra tape (let us call it the reg-tape) is used to simulate the registers over the input tape.
Its size is at most the size of the input tape.
It uses a unary schema and new constants : the constant is meant to keep track, on the reg-tape, of the input cursor position for technical reasons, and for , the constant keeps track of the value of the 's registers.
It is rather immediate to change the set of transitions of in order to enforce that if after some step of the computation, the configuration of is , , , then the corresponding steps of 's computation leads to a configuration , , such that: (i) , (ii) iff , and (iii) for , iff .
Auxiliary tapes The RTM model can be simplified with respect to the number of auxiliary tapes (or temporal instances) required.
The first result below says that it is sufficient to consider RTMs with only two auxiliary tapes and moreover that one of these two tapes is a store.
A store is a one-cell tape.
Such devices are called extended one-tape RTMs and denoted RTM .
P ROPOSITION 3.2  RTM  RTM  Sketch of proof : Let us show that any RTM can be simulated by an extended one-tape RTM .
Intuitively, the auxiliary tapes of the RTM are concatenated on the single temporal auxiliary tape (let us call it temp-tape) of the extended one-tape RTM .
The db schema of the temp-tape is composed by the schemas , for and  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  (  , red)  (  ,blue)  (  , blue)  ( (  , blue) ,red)  (  , red)  ( (  ,blue)  (  , blue)  (  , blue)  ,red)  Temporal output instance  Temporal input instance  Figure 1.
An example of a color based splitting.
last(0) red blue cpred(1) cpblue(1)  queries and actions checks end of input  Update( , Update( ,  ) )  Figure 2.
The RTM for color based splitting.
a unary schema Cur for the purpose of keeping track, over temp-tape, of the 's auxiliary cursors.
Indeed, we use new constants and : for , the constant keeps track of the 's cursor over the tape and the constant is used as a separator between the concatenated tapes.
Recall that only one cursor is available over each tape and that the transitions of make use of queries (in the premise or/and the action) that are evaluated over relations pointed by the input and the auxiliary cursors.
The purpose of the store is to handle these relations, in order for to be able to evaluate such queries.
Thus the db schema associated with the store is composed by the schemas .
Now it is quite easy to change/modify the set of transitions of in order to enforce that, if after some step of the computation, the configuration of is , , , then the corresponding steps of 's computation lead to a configuration , , , such that: (i) the value of does not really matter and it may be assumed that , (ii) the temp-tape contains (nothing else than) in the cell , in the cell , in the cells for , and (iii) .
sues.
The next result is quite strong and may seem surprising at a first glance although it turns out to be a generalization of the normalisation of RM developed in [5].
It tells us that, indeed, any RTM can be simulated by an RTM .
T HEOREM 3.3  RTM  RTM  Sketch of proof : The proof strongly relies on the technics developed in [5] for exhibiting a normal form for loosely coupled Generic Machine.
Indeed we could have stated our result more precisely and provide details about the "shape" of the RTM as follows:  meaning that the RTM  The reader may have noticed the immediate relationship between extended one-tape RTMs and T- WHILE languages although extended one-tape RTMs are more powerful: the temporal auxiliary tape (resp.
the store) of an extended one-tape RTM plays a role similar to the private (resp.
shared) auxiliary schemas of a T- WHILE program, although, the auxiliary instance of a T- WHILE program has always the size of the input temporal instance which is not the case for a RTM.
This result will serve in the next section to study complexity is-  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  works in four phases:  phase: One should keep in mind that, the ultimate goal of this phase is to encode a superset of the auxiliary relations computed when running the RTM over the input temporal instance.
Thus, this step, as in [5], is dedicated to the computation of a relation which is a representation of an ordered partition of the set of the -ary tuples build from the active domain of the input temporal instance .
For the sake of simplicity and w.l.o.g.
we assume that all schemas have the same arity and thus that all queries used by the RTM have free variables.
The partition is based on the equivalence relation and it characterizes -tuples that cannot be distinguished by any composition of queries used by .
Note that uses a finite set of queries .
The closure of under composition is a generalization of the notion of closure provided in [5].
It should carefully take into  account the ability of the machine to move its cursor over the input tape.
Thus the set of formula in depends of the size of .
It is defined as the smallest set of formulas with free variables over the db schema such that: (a) for each and , is in ; (b) for each formula written using occurrences of schemas in and for in , is in where denotes the formula obtained by replacing the -th occurrence of a schema by .
Now, we have that iff for every composition of queries in , we have iff .
The definition of extends slightly that of [5] and is easy to infer from the definition of .
It is explained using an example.
Assume that and and let be a temporal instance of size .
Now assume that is .
Then given a valuation for , iff and .
In [5], it is showed that the relation can be computed by a fixpoint query.
In our case, we can show that can be computed by a simple RTM (indeed, it can be computed by a T- WHILE program as well).
The RTM also computes the action tables of the queries based on the partition.
Roughly, for each query , describes the effect of in terms of partition blocks: iff .
Note that and the action tables are stored in the first cell of the auxiliary tape.
phase: Intuitively, during this phase, the RTM encodes on the auxiliary tape (starting at the 2nd cell) the relation , the action tables and the input instance .
The auxiliary tape is then used as a Turing machine tape.
The encoding relies on the fact that the relation is a representation of an ordered partition and thus an integer (or its binary encoding) may be substituted to each block of the partition.
phase: The RTM simulates the run of the on the input .
Roughly, is a Turing machine that works on the encoding previously stored on the auxiliary tape.
RTM  phase: The result produced by the Turing machine needs to be decoded to provide a temporal instance whose state (cell contents) are sets of tuples.
This means that the integers encoding the partition blocks have to be replaced by the corresponding tuples.
This is made possible using only one auxiliary tape because the computation of the relation can be (re)done and stored in any cell of the auxiliary tape.
In the previous proof, the one-tape RTM machine uses the same number of registers as the original one.
This entails that: C OROLLARY 3.4  RTM  =RTM .
The normalization of RTM is an interesting result by itself.
It is a witness, once more, that the technics provided in [5] are quite powerful.
Before considering complexity issues, we would like to briefly comment on the normalization of T- WHILE programs.
Although we are not yet able to provide a detailed proof, we claim that T- WHILE programs can be normalized in the same way as WHILE programs are in [5].
However, this normalization cannot be realized without using shared auxiliary schemas in order to store the relation and make it available to any step of the program evaluation.
Because shared auxiliary schemas of T- WHILE programs play a role closely related to the store of the extended one-tape RTM, this is in favour of working with extended one-tape RTM rather than with the one-tape machines.
4 Space complexity: languages  RTM  versus temporal  Now, we are going to investigate the connection, in terms of complexity and expressiveness, between our general temporal computation model RTM and some languages, namely T- WHILE and TS - WHILE , as well as some restriction of these languages.
As already mentioned, we focus on space complexity and the main issue addressed in this section is to measure temporal computation complexity in terms of the auxiliary space required.
Recall that the size of a temporal instance is .
We are not interested here in the size of the active domain as usually assumed.
Next, we consider extended one-tape RTMs, the ones using one temporal tape plus a store.
The set of RTMs whose runs make use of an auxiliary temporal tape of size linear (resp.
polynomial) in the size of the input temporal instance is denoted LinSpace- RTM (resp.
PSpace-RTM).
The question that arises here is why do we consider extended one-tape RTMs rather than one-tape RTMs?
Indeed, as we study linear and sublinear space complexities, the onetape RTMs are useless because of the polynomial encoding of the input tape on the auxiliary tape.
The first result of this section establishes a strong correspondence between LinSpace-RTMs and T- WHILE queries in the one hand, and between PSpace-RTMs and TS - WHILE queries in the other hand.
The reader should be aware that this result holds iff the output tape of the extended one-tape RTM is restricted to be the store.
T HEOREM 4.1 The following holds (under the above restriction):  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  LinSpace-RTM PSpace-RTM  T- WHILE , and TS - WHILE .
Sketch of proof : LinSpace-RTM T- WHILE: Proving that any T- WHILE program can be simulated by a linear RTM does not present any difficulty.
Indeed, we show that the RTM simulating uses an auxiliary tape of size when the input temporal instance is of size .
Building the RTM is done by building an RTM for each instruction of the program and by concatenating these machines.
Proving that any linear RTM can be simulated by a TWHILE program is not difficult either.
The only technical point deserving to be mentioned concerns the fact that a T- WHILE program works with auxiliary temporal instances whose sizes are exactly that of the input temporal instance.
Thus, assuming that the RTM is of complexity where is the size of the input, in order to simulate the auxiliary tape of by the program , we declare copies of the auxiliary schema associated to the temporal tape of : the auxiliary temporal instance of can be viewed as a multidimensional tape of size and it is managed by in such a way that the "dimension" of encodes the segment of size of the temporal tape of size at most .
PSpace-RTM TS - WHILE : First, recall that, for TS (1) the input schema is time stamped and (2) the auxiliary schemas may have multiple attributes of type "time".
Recall also that the queries (used in assignments) in TS - WHILE are FO queries.
For simulating a TS - WHILE program by an RTM, it is more convenient wlog to target multi-tape devices.
Thus now simulating a TS - WHILE program by an RTM essentially requires to show how to manage general time stamped relations by implicit temporal instances and how to translate FO queries.
Assume that is a relation schema with attributes of type "time" ( is a vector of data attributes).
We associate with an auxiliary temporal tape whose schema is .
The RTM will encode an instance of as the temporal instance over : if then and , and if then where and then the cell of the tape contains (over P) the data projection of the tuples of time-stamped by with .
Intuitively, the first in , state of stores the data time-stamped by the state of stores the data time-stamped by in , etc.
Now, in order for the RTM to compute the encoded effect of a FO query, it needs to properly manage the cursor which does not present any difficulty.
Thus we prove that any TS - WHILE program can be simulated by a RTM working on temporal auxiliary tapes.
The size of each tape is polynomial in the size of the input and thus we can conclude by using (the proof) of proposition 3.2.
The proof of the converse i.e.
PSpace-RTM TS - WHILE is WHILE ,  based on an encoding of the temporal auxiliary tape of by a general time-stamped auxiliary relation managed by .
This encoding is more or less the inverse of the encoding used in the first part of this proof.
It takes the auxiliary tape whose length is at most , and maps it to an instance of a predicate having attributes of type "time".
The last part of this section focusses on RTMs whose space complexity is constant.
Indeed constant space RTMs are the devices using an auxiliary store and no auxiliary temporal tape.
Such devices are next called relational register machine (RRM ), because registers are necessary components in that case.
We would like to highlight that such class of temporal queries has never been studied before.
Remark: The reader should pay attention to the fact that proposition 3.1 stating that registers do not add expressiveness to the model, does not apply when considering RRM because registers can no more be simulated using a temporal tape.
In this section, we also use relational pebble machine RPM which are straightforward restrictions of RRM that enforces a stack discipline over the registers.
Thus, an RPM requires to order the registers, to keep track of the top of the stack whose value is used as the cursor over the input temporal instance.
A configuration is given as before by a tuple although now is the index of the top of the stack and is the value of the cursor over the input tape.
The set of actions of a transition are modified and simplified: , , are defined as before more or less; increments the top stack index, if possible and the new configuration is such that and , and finally decrements the top stack index.
Notice that the size of the stack of a RPM is bounded by .
It is interesting to know that: P ROPOSITION 4.2 Propositional RPM expresses exactly the regular languages over finite alphabet.
A propositional RPM takes as input a propositional temporal instance.
Wlog, we assume that the auxiliary db schema of an RPM is a set of 0-ary relation schemas (i.e.
propositions).
Sketch of proof : The proof is based on mappings from words over a finite alphabet to temporal instances over 0-ary schemas and vice versa.
The mapping from words to propositional temporal instances is rather obvious: each element of the finite alphabet is mapped to a proposition (i.e.
a 0-ary relation schema) and the word is mapped to the temporal instance such that iff .
The inverse mapping, from propositional temporal instances to words, assumes that an element of the  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  alphabet is reserved for each possible subset of propositions and a temporal instance is then mapped to the word such that for , where is the set of propositions "true" at .
The transformation of a determinist automata for a regular language into an RPM is straightforward.
In order to show that the languages recognized by propositional RPMs are regular, the idea is to show that any propositional RPM can be simulated by a pebble automata PA over a finite alphabet and, then we conclude by applying the following result [19]: PA MSO .
This proposition entails that: C OROLLARY 4.3  RPM  RRM .
Sketch of proof : The strict inclusion is entailed by the fact that for any fixed integer , the language can be "recognized" by a propositionnal RRM.
We now are investigating languages that express computable queries, resp.
RRM computable queries .
T HEOREM 4.4 We have: TS - FO RPM , ETL RPM , and T- WHILE RPM .
RPM  (claim: the inclusion is strict)  First let us present the language T- WHILE : it is the restriction of T- WHILE to the case where only shared auxiliary relations can be used by the programs.
Recall that the languages TS - FO and ETL are not comparable [3]: TS - FO can express the query twin ( ) but ETL cannot; ETL can express the query t-even (t-even( )=true iff is even) but TS - FO cannot.
On the other hand, TS - FO can express the query -twin ( ) but T- WHILE cannot; T- WHILE can express transitive closures which cannot be expressed neither by TS - FO nor ETL.
Finally, we claim that the languages ETL and TWHILE are incomparable.
ETL queries involving nested formulas can probably not be translated into a T- WHILE program roughly because T- WHILE lacks the ability to store (or mark) any time point over the input.
Sketch of proof : TS - FO RPM : The proof of the inclusion involves rather technical details.
The subformulas of a TS - FO formula are in FO*.
Thus we need to show how to translate a FO* formula by an RPM.
The main idea is to simulate the variables of type "time" of the FO* formulas via pebbles.
The only critical point is to show that the stack discipline is adequate for the simulation.
The inclusion is strict because the query t-even is RPM computable but cannot be expressed in TS - FO.
ETL RPM : By induction on the structure of the ETL formula , we show that there exists an RPM such that, (1) the auxiliary db schema of includes a relational schema whose arity is the number of free variables of , and such that given any temporal input instance , for any , any run of starting with the configuration with stops with configuration with .
2 Assume that is atomic i.e.
of the form , then it is easy to see that the RPM has two states and , and one transition .
The induction steps corresponding to disjunction, negation and universal quantification constructs are not difficult.
Let us comment the induction step for where is either or and assuming that A is the automata recognizing the language L and for , is the RPM simulating as described above.
The main idea is to build based on the automata A (the behaviour of the automata can be encoded in the store).
will scan the input instance from up to (resp.
down to 1) if is (resp.
is ) and at the end will put the input cursor back at .
A relation schema is associated to each state of the automata A and will serve for storing the relevant tuples according to state .
Computing these tuples will of course be done using (slightly modified copies of) the RPM .
The inclusion of ETL in RPM is strict because the query twin is RPM computable but cannot be expressed in ETL.
T- WHILE RPM : The proof of the inclusion is rather immediate.
The translation of a T- WHILE program into a RPM is done (by induction) instruction by instruction.
The only technicality is the translation of while loops.
The level of nesting of while loops in a program will determine the size of the stack of .
Recall that a while loop execution stops either because of the condition or because two consecutive iterations compute the same configuration.
The important point is that a configuration is composed of both the current time point and the auxiliary (shared) relations.
The naive approach consisting in pushing the value of the input cursor in the stack at each iteration of the loop will lead to use an unbounded number of pebbles and thus cannot be followed to build our RPM.
Thus, intuitively, the idea is to "duplicate" the execution of each iteration or in other words to simulate one iteration of a loop by two executions of its body.
The purpose of the first execution is to determine whether it is the last iteration of the loop: it uses a new pebble pushed on the top of the stack, it uses a copy of the auxiliary shared relations and the new pebble is lift once the decision is made.
The second execution of the iteration corresponds to the "real" one: it does not use any pebble and it changes the auxiliary shared relations.
We show that the RPM that simulates a T- WHILE program uses a stack of size at most where is the maximum  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  2 Wlog  we disallow constants in .
nesting level of while loops in .
Although we do not have a proof yet, we claim that the inclusion is strict because T- WHILE programs do not have the ability to register current time points since any auxiliary relation is shared.
The last part of this section is devoted to the presentation of two languages T- WHILE and TL which are complete with respect to RRM.
The first language, T- WHILE , is an extension of T- WHILE with temporal variables (tvariables) which are obviously meant to mimic the registers of the RRM devices.
essentially by describing We now define T- WHILE the features that have been added to T- WHILE .
Thus besides shared auxiliary schemas, the declaration of a TWHILE program may include a finite list of t-variables which are all initialized to 1.
The formulas in the right part of assignements belong to FO .
The language FO over and allows one for new atomic formulas of the form but restrict quantification to apply over "data" variables only.
Finally, instructions of the form are added in order to bind t-variables to the current time point.
The semantics of a T- WHILE program directly follows from that of T- WHILE .
While loop execution and termination are based on configurations: a configuration is now a triple where is a t-variable assignement.
A while loop executions stops as soon as either its condition is false or the configuration produced by an iteration is equal to the configuaration at the beginning of this iteration.
E XAMPLE 4.1 The following sequences of instructions places the current time point at the time point contained in the t-variable .
It uses two t-variables and .
while not(first) do left end;  L EMMA 4.6 Any RRM is equivalent to a RRM whose transitions use two states only: and Intuitively, states of the RRM are encoded as boolean in the store.
Thus it remains to show that any 2-states RRM can be simulated by a T- WHILE program which turns out to be rather immediate.
The second language presented here, called TL, is equivalent to T- WHILE although its definition is based on TL and borrows some idea from Hybrid modal logic [10].
The main idea is similar to the one used to define T- WHILE : temporal variables (t-variables)3 are added as propositions in order to mark time points over the input temporal instance; we also introduce a fixpoint operator.
Let us assume that are t-variables.
Then the TL language over is inductively defined by: an TL atomic formula is either a FO atomic formula over or a t-variable , Let and be TL formulas, let be a data variable and be a t-variable, then , and , next( ), prev( ) and are TL formulas, is a TL formula where is a fixpoint expression where: is a TL formula using the new (auxiliary) relation schema of arity ; this formula has free data variables.
Finaly, and are two vectors of t-variables of same size.
above, t-variables in are Intuitively, in the formula viewed as nominals or constants.
This means that, when evaluating the fixpoint expression , at each iteration, should be viewed as time points previously computed and as the time points under computation.
E XAMPLE 4.2 The formula where is defined by:  ; while not (  ) do ( right;  ) end.
The next result states that the language T- WHILE complete wrt RRM.
T HEOREM 4.5 T- WHILE  is  =RRM.
Sketch of proof :  is equivalent to the hybrid modal logic formula whose semantics assigns the t-variable to the evaluation (current) time before evaluating .
We restrict the presentation of the semantics of the TL language to its specific features.
Let be a temporal instance over , let be a valuation of data variables and a valuation of t-variables, then  T- WHILE RRM : Proving this inclusion is very similar to proving that T- WHILE RPM and we use quite the same translation, especially for while loops.
We build an RRM that simulates a T- WHILE program that uses a number of registers where is the number of t-variables of and is the maximum nesting level of while loops in .
RRM  T- WHILE  following lemma:  : The proof starts by showing the  iff  .
iff  where  ,  iff iff 3 Temporal variables are called state variables in the framework of Hybrid modal logic.
14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  iff lation defined as the limit of ously with as follows: and  where is the redefined simltane-  for any t-variable  of .
if there exists a single valuation of the t-variables such that: (a) for any t-variable in , (b) for any t-variable occuring in but neither in nor in , and (c) there exists a valuation of the free data variables in such that then and for any t-variable of .
Above, the semantics of a fixpoint expression relies on the unicity of the t-variable valuation .
This condition is rather strong and clearly, testing if a fixpoint expression is well defined is undecidable.
One possible direction to cope with this, may be for instance to choose the least (dualy, the greatest) t-valuation.
E XAMPLE 4.3 Let us consider the fixpoint expression of the previons example.
Let us assume that the formula is simply and that the fixpoint expression is evaluated given and given a temporal instance with .
The simultaneous sequences and are, by definition equal to:  We can now state that: TL = RRM  and thus  TL = T- WHILE  The RTM computation model provides the basis for identifying some critical features of temporal computation which are often implicit when just considering concrete languages.
Investigating the features/parameters of RTM seem a promising research direction and may well benefit to more specific domains like streaming.
Continuous-query processing over data streams [6] is a very challenging research topic because of its large range of applications, from stock ticks to sensor applications.
Formalizing continuous query and streamable queries [15, 14] is under study but a general model still needs to be proposed.
For instance, none of the proposed formal models is yet able to take into account manipulations over multiple streams like fusion or in general operations that output a stream from streams which is a critical issue in the framework of distributed sensors applications.
Let us now briefly review some of the questions that may arise when considering some variants of our RTM:  , and  T HEOREM 4.7  The results of the paper show that RTM provides an interesting formal tool for analysing standard languages and we claim that this tool opens several further research directions.
Some of these directions have been already discussed during the presentation as for instance working on defining a normal form for T- WHILE.
[1] investigates normal form of RM and WHILE language as an optimization tool.
On the other hand, [2] provides and evaluates practical heuristics based on the normal form.
Although it needs to be carrefully studied, we could reasonably expect that such results and directions extend to our framework and that our normal form could be used as well to optimize some temporal computations.
.
Sketch of proof : Thanks to lemma 4.6, proving that RRM TL can be reduced to show that any 2-state RRM can be simulated by a TL query.
This will require one fixpoint expression (and no nesting of fixpoint expression).
Proving the converse, that is TL RRM , is done by induction over the structure of TL formulas.
The difficult case is of course that of a formula build from a fixpoint expression although the underlying idea are borrowed from previous proofs.
5 Discussion In this paper, we have introduced a general computation model for temporal database queries.
This model is the first that captures queries whose outputs are temporal instances.
- finite versus infinite temporal instances: we have assumed all along the presentation that the input tape is finite (as well as the auxiliary tapes); it is relevant to relax this assumption in the context of streaming computation for instance.
- controling cursor moves: the general setting makes no restriction on the moves of the cursors neither on the input nor on the auxiliary tapes; studying right only moves and forbiding/restricting reversals are relevant topics, once again in the context of streaming computation but not only.
Other restrictions may be of interest as well: synchronisation of the cursors (indeed, T- WHILE implements such a discipline); enforcing cursor moves at each transition especialy in the case of right only moves for capturing a loose real time behavior.
- internal query language: recall that RTM make use of (a finite set) of FO queries either to control transitions or as transition actions.
Of course, the impact of restricting queries to be inflationary has to be revisited in our framework.
Obviously, one may also need to use a language more powerful than FO, for instance in order to  14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007  take into account sophisticated abstract data types.
One exiting and inspiring area is musical improvisation [16] whose goal is to generate new musical sequences from (live) musical performances.
Another important research direction focusses on the definition of concrete temporal languages satisfying reasonable complexity criteria or/and complying to some of the restrictions listed above.
In [9], we propose a class of languages called SQTL.
These languages are based on a paradigm related to windows in the context of streaming.
They are based on a two phase process: first, the input temporal instance is sliced to produce a sequence of subsequences of the input (a sequence of slices); slices may overlap or not, they may cover or not the input; secondly, temporal queries are evaluated over each slice although with access to the whole input.
These languages need to be refined and further studied from the complexity and the expressivity points of view.
It is not very difficult to use T- WHILE as it is for specifying temporal queries with temporal outputs.
It suffices to extend the definition of a query by allowing the output schema to be a private schema.
However, by definition, we know in advance that these queries defined through T- WHILE programs will always output temporal instances having exactly the size of the input temporal instance.
Thus, an open and exciting issue is the definition of a P-Space temporal language a la T- WHILE.
References [1] S. Abiteboul, K. Compton and V. Vianu.
Queries are easier than you thought (probably).
In Proc.
PODS, pages 23-32, 1992.
[2] S. Abiteboul and A.
Van Gelder.
Optimizing active databases using the split technique.
In Proc.
ICDT, LNCS vol.
646, pages 171-187, 1992.
[3] S. Abiteboul, L. Herr and J.
Van den Bussche.
Temporal Connectives versus Explicit Timestamps in Temporal Query Languages.
In Proc.
of the VLDB International Workshop on Temporal Databases, pages 43-57, 1995.
[4] S. Abiteboul and V. Vianu.
Datalog extensions for database queries and updates.
In Journal of Computer and System Science, 43:62-124, 1991.
[5] S. Abiteboul, V. Vianu.
Computing with First-Order Logic.
In Journal of Computer and System Science, 50(2):309-335, 1995.
[6] A. Arasu, B. Babcock, S. Babu, J. McAlister and J. Widom, Characterizing memory requirements for queries over continuous data streams.
In ACM Trans.
Database Syst., (29):162-194 , 2004.
[8] N. Bidoit and M. Objois.
Temporal Query Languages Expressive Power: muTl versus Twhile, TIME 2005, 74-82, (Revised version in preparation).
[9] N. Bidoit and M. Objois.
STQL : a preliminary proposal for t2t languages, Proc.
TIME 2007, to appear.
[10] C. Areces and P. Blackburn and M. Marx.
Hybrid logics: characterization, interpolation, and complexity, In Journal of Symbolic Logic, 66(3):977-1010, 2001.
[11] A. K. Chandra and D. Harel.
Structure and comlexity of relational queries.
In Journal of Computer and System Science, 25(1):99-128, 1982.
[12] J. Chomicki and D. Toman.
Temporal Logic in Information Systems.
In Logics for databases and information systems, Kluwer Academic Publishers, chapter 3, pages 31-70, 1998.
[13] E. A. Emerson.
Temporal and Modal Logic, In Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics, Jan van Leeuwen, Ed., Elsevier Science Publishers (1990) 995-1072.
[14] M. Grohe, Y. Gurevich, D. Leinders, N. Schweikardt, J. Tyszkiewicz and J. V. den Bussche.
Database Query Processing Using Finite Cursor Machines.
In Proc.
ICDT, pages 284-298, 2007.
[15] M. Grohe, C. Koch and N. Schweikardt.
Tight Lower Bounds for Query Processing on Streaming and External Memory Data.
To appear In Theoretical Computer Science, Special issue for selected papers from ICALP'05, Track B.
[16] http://www.ircam.fr/.
[17] A.R.
Meyer.
Weak monadic second order theory of successor is not elementary recursive.
In Proceedings Logic Colloquium, Lecture Notes in Mathematics, Vol.
453, pp.
132- 154, Springer-Verlag, 1975.
[18] M. Paterson.
Tape bounds for time-bounded Turing machines.
In Journal of Computer and System Science, 6(2):116-124, 1972.
[19] F Neven, Th.
Schwentick and V. Vianu.
Finite state machines for strings over infinite alphabet.
In ACM Trans comput.
Logic, 5(3):403-435, 2004.
[20] A. P. Sistla and E. M. Clarke.
The Complexity of Propositional Linear Temporal Logics.
In Journal of the ACM, 32(3):733-749, 1985.
[21] http://www.cs.auc.dk/TimeCenter/.
[22] W. Thomas.
Languages, automata and logic.
In Handbook of Formal Languages, G. Rozenberg and A. Salomaa editors, chap.
7, 1997.
[23] M. Y. Vardi.
A temporal fixpoint calculus.
In Proceedings 5th ACM Symposium on Principles of Programming Languages, pages 250-259, 1988.
[24] P. Wolper.
Temporal Logic Can Be More Expressive.
In Information and Control, pages 72-99, 1983.
[7] N. Bidoit, S. De Amo, and L. Segoufin.
Order independent temporal properties.
In Journal of Logic and Computation, to appear.
14th International Symposium on Temporal Representation and Reasoning (TIME'07 0-7695-2836-8/07 $20.00 (c) 2007