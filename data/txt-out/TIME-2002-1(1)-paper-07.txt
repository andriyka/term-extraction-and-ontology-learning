A Parameterized Algebra for Event Notification Services Annika Hinze, Agnes Voisard Freie Universitat Berlin fhinze, voisard@inf.fu-berlin.deg Abstract Event notification services are used in various applications such as digital libraries, stock tickers, traffic control, or facility management.
However, to our knowledge, a common semantics of events in event notification services has not been defined so far.
In this paper, we propose a parameterized event algebra which describes the semantics of composite events for event notification systems.
The parameters serve as a basis for flexible handling of duplicates in both primitive and composite events.
1.
Introduction An event notification service informs its users about new events that occurred on providers' sites.
User interests are defined by means of profiles, which may consist of queries regarding primitive events, their time and order of occurrence, and of composite events, which are formed by temporal combinations of events.
Profiles are defined using a Profile Definition Language for Alerting (PDLA).
An example profile in a logistics application is Notify if a sensor reads temperature above 30 AE C three times within a given timespan.
The events entering an event notification system are filtered according to user profiles.
In this paper, we use an event algebra to describe the events that are filtered by an ENS and that can be subscribed to via profiles.
In addition to the fact that only few sophisticated profile languages are defined, the evaluation of languages that seem to follow similar semantics does not always lead to similar results.
One example is the handling of duplicate events: depending on the implementation, in the filtering process, duplicates are either skipped or kept.
In the area of active database systems, the problem of event rule specification has been evaluated with focus on composite events, e.g., [2, 4].
Some ENS systems also implement composite events, e.g.
[5, 6, 9].
The semantics of composite events in active databases and existing application-specific ENS are not sufficient for integrating applications: The implemented algebras do not cover all  necessary event combinations, in particular combinations of subsequent duplicate groups as used in logistics support and facility management.
The systems also lack the necessary flexibility in the event processing to support event providers with slightly different semantics.
Semantics of operators for composite events are not defined in a uniform manner in the numerous application areas.
Our approach, therefore, supports various perceptions.
This is achieved through the introduction of a flexible semantics which is controlled by a set of parameters.
This paper is organized as follows.
Section 2 points out the differences of our approach to active databases and other related work.
In Section 3 introduces our parameterized event algebra.
Finally, Section 4 addresses concluding remarks and gives some directions for future work in this domain.
2.
Concepts An event is the occurrence of a state transition at a certain point in time.
Each event has a timestamp reflecting its occurrence time.
Timestamps are defined within a time system based on an internal clock.
For the sake of simplicity, we assume that all occurring events can be ordered sequentially in a global system of reference.
The system of reference for the time is discrete.
We consider primitive events and composite events, which are formed by combining primitive and composite events.
We further distinguish two types of primitive events: time events and content events.
Time events describe the occurrence of a certain point in time.
Content events involve changes of non-temporal objects.
We do not discuss the definition of primitive events in greater detail.
One approach is the definition by (attribute,value) pairs, e.g., AE e1 = event(sensor = xyz; temperature = 35 C ).
We distinguish events from event classes.
An event class is defined by a set of event properties.
Even though events of the same event class share these properties, they may differ in other event attributes.
User profiles define event classes, e.g., p1 = prof ile(temperature > 30AE C ).
Events are denoted by lower Latin e, while event classes  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIME'02) 1530-1311/02 $17.00 (c) 2002 IEEE  are denoted by upper Latin E .
The fact that an event e i corresponds to an instance of an event class E j is ei 2 Ej .
The timestamp of an event e is denoted t(e).
1 Based upon a notation used, e.g,.
in [1], the matching operator is defined as follows: Definition 1 (Profile Matching @) Consider the event e and a given profile p. It is said that e matches p, denoted p @ e, if all properties of the profile and the event match.
The exemplary event e 1 matches the profile p 1 2 .
3.
Event Algebra This section describes our event algebra.
First, we informally describe the event operators.
The events e 1 and e2 in the descriptions below can be any primitive or composite event, t() refers to occurrence times, and t denotes time spans.
- The disjunction (e 1 je2 ) of events occurs if either e 1 or e2 , t(e1 je2 ) := minft(e1 ); t(e2 )g. - The conjunction (e 1 ; e2 )t occurs when both e 1 and e2 have occurred within a time span t 3 , regardless of the order, t(e1 ; e2 ) := maxft(e1 ); t(e2 )g. - The sequence (e 1 ; e2 )t occurs when e1 occurs before e 2 with t(e2 )  t(e1 ) + t, t(e1 ; e2 ) := t(e2 ).
- The negation e t defines a negative event; e does not occur for an interval [t start ; tend ], tend = tstart + t of time, t(et ) := tend (et ).
- The selection e[i] defines the occurrence of the i th event of a list of events, i 2 N .
Let us assume a profile p = (e1 ; e2 )t and the following history (trace) of events: tr = fe 1 ; e1 ; e2 ; e2 g. It is not automatically clear which pair of events fulfills our profile.
Candidate pairs are the inner two events, or the first and the third.
It is also not clear wether the profile can be matched twice, e.g., by pairs (2,3) and (1,4), or by (1,3) and (2,4).
For different applications, different event-history evaluations could be applied.
As parameters we adopt the modes of event instance selection and consumption from active databases [10].
Event instance selection describes, which events qualify for the complex events, and how duplicated events are handled.
Event instance consumption defines which events are consumed by complex events.
In contrast to active databases, event selection and consumption in ENS cannot be handled independently.
Duplicate events are event instances that belong to the same class.
We introduce the notion of a duplicate set:  1  1 The  time of events that do not occur is set to .
start after the profile definition and for each positively evaluated event p e holds implicitly t(e) > t(p).
3 (e ; e ) refers to an event composition no matter the time of the 1 2 composing events.
It is equivalent to the original conjunction constructor as defined, e.g., in [3].
2 Evaluations  1  @  Definition 2 (duplicate set) Let e1 , e2 be two events with e1 6= e2 .
We then define a duplicate set as the ordered set of events of type e1 that occur in a sequence without any events of type e2 in between, e2 without e1 respectively.
For the instance selection parameter we distinguish the selection of the first/last event of each duplicate set or the consideration of all events.
For the identification of composite events the following holds: Matched events can be consumed by the composite event or they can contribute several times to composite events of the same class.
If events are consumed by composite events, the filtering process could be reapplied after unique composite events have been identified.
We now introduce the terminology for our formal event algebra.
Definition 3 (event space) The set of all possible events known to a system is called the event space E .
The set of all time events is denoted E t .
Definition 4 (trace) A trace tr t1;t2 is a sequence of ordered events e 2 E with defined start- and end-points t1, t2 respectively.
The history of events that a service processes is then tr t0;1 with t0 being the point in time the service started observing events.
As a trace behaves essentially as a list, we can use the operations commonly defined for lists.
For each list we apply an arbitrary local order that assigns an index-number i 2 N to each event.
The elements of a list L can then be accessed by their index-number, and L[i].
Definition 5 (trace view) Let E 1 be a class of events.
The subset tr(E1 ) of a given trace tr is defined as the list of continuously ordered events that contains only events e 2 E1 .
We call this subset a trace view.
The trace view tr(E1 ; E2 ) contains all e1 2 E1 ; e2 2 E2 with e1 2 tr and e2 2 tr.
We also use the shorthand notation tr(e1 ; e2 ).
Note that the events in tr(E 1 ) keep all their attributes including occurrence time, but obtain a new index-number.
We now define a re-numbering on the list tr: Trace Renumbering The list is subdivided into disjunct sublists tr[1]; : : : ; tr[n] each containing successive events of identical types.
Every element of such a sublist is denoted with tr[x; y ], where x 2 N is the number of the sublist and y 2 [1; length(tr[x])] is the index-number of the element within the sublist.
The length of a sublist is defined as the number of list elements.
Disjunctive sublists containing only similar events are referred to as duplicate lists.
Note that we denote (unordered) sets of events with E or E t while tr[] denotes ordered sets or lists of events.
Without loss of generality, we assume tr(e1 ; e2 ) to start with tr[1; 1] = e1 .
The following definition holds for all w 2 [w min ; wmax ], x 2 [1; 1),  Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIME'02) 1530-1311/02 $17.00 (c) 2002 IEEE  2 [1 1), and 2 [  ; z zmin ; zmax ].
The parameters P xy , , wmax , zmin , zmax substantially influence the operator semantics.
Due to space restrictions we only show the formal definition an event sequence, full definition od all operators can be found in [8].
y  wmin  Definition 6 (sequence of events) If two events e 1 ; e2 2 E form a sequence the following condition holds for a given time span t 2 R: (p1 ; p2 )t @ (e1 ; e2 ) ) fp1 @ e1 ; p2 @ e2 ; t(e2 ) 2 (t(e1 ); t(e1 ) + 1]g The set of matching events of a given trace tr is then defined as (p1 ;p2 )t (tr )  @ f( [2 1 ] [2 ])j [2 2 ( 1 2 ) ( 1 ; 2 ) @ ( [2 ]) 8 8 8 8 ^ g tr  tr [2y; w ] tr [2y; w  x  tr e ; e  ;  x;  y;  ; z ; tr  ;  w;  p  z  p  y; w  tr  t  tr  x  x  1; z ]; 1; z ];  4.
Conclusion & Outlook  Pxy  Semantical Variations We now evaluate different approaches for the parameter values, which implement different semantics of the operators.
For consumption modes we distinguish the selection of unique pairs P xy : x = y and the selection of all pairs: P xy : x  y .
For the event instance selection, we distinguish several variations to select events from duplicate lists.
Each has to be evaluated depending on the position of the event relative to the binary operator.
We use the notation anterior and posterior to refer to the two operators, tr ant and trpost denote the respective duplicate lists.
We make the distinction between the selection of the first/last event, or of all of them.
first last  anterior  posterior  min = zmax = 1 zmin = length(trant ) zmax = length(trant ) zmin = 1 zmax = length(trant )  w  w  w  w  z  all  2  8  min = min =  max = 1 max = m  min = 1 wmax = m w  with m N : j > m : t(trpost[:; j ]) > t(trpost[:; :]) + t, where the dots are placeholders for the respective values, t R as defined for the operator.
2  The different cases can be combined, taking as posterior event every first in a duplicate set and as anterior event the respective last duplicate match.
The third approach is a combination of the already introduced dimensions.
We consider unique pairs only, but reapply the filter until all matches are found.
The first matches are, e.g., first/last events of duplicate sets, the second match are second/next-to-last events, and so forth.
Other combinations are plausible.
We only show two intuitive examples.
xy :  P  x  first  z  last  =  The issue of order and time in a distributed environment is crucial and has to be considered for an implementation of this operators.
We distinguish event evaluation at the end of the defined time span vs continuous evaluation of events.
The latter one offers the advantage of early notification.
Here, fast but probably incorrect information is delivered in opposition to correct but later information after the ending of the time frame.
This approach is appropriate in several applications, e.g., catastrophe warning systems for environmental surroundings or other systems for urgent information delivery (for an analysis of information correctness see [7]).
y  min = 1 zmax = min(length(trant ); length(trpost )) wmin = 1 wmax = min(length(trant ); length(trpost )) zmin = length(trant ) zmax = length(trant ) min(m; length(trant )) wmin = m wmax = m min(m; length(trant ))  We proposed a parameterized event algebra for integrating event notification services that support differently structured event sources.
We introduced our event algebra in both an informal and a formal way.
Note that the formalism used here is similar to the one of the relational algebra.
The relational algebra lacks the concept of ordering, therefore we introduced an ordering relation on event traces.
We are currently implementing a prototype of a generic parameterized Event Notification System (GENAS) that is based on the parameterized event algebra introduced here.
GENAS can be adapted to different application fields using various parameter settings.
References [1] A. Carzaniga, D. Rosenblum, and A. Wolf.
Achieving scalability and expressiveness in an internet-scale event notification service.
In PODS, 2000.
[2] S. Chakravarthy and D. Mishra.
Snoop: An Expressive Event Specification Language for Active Databases.
Knowledge & Data Engineering Jour., 14:1-26, 1994.
[3] S. Gatziu and K. Dittrich.
Events in an active object-oriented database system.
In Int.
Workshop on Rules in Database Systems., 1993.
[4] S. Gatziu and K. Dittrich.
Detecting Composite Events in Active DB Systems Using Petri Nets.
In RIDE-ADS, 1994.
[5] A. Geppert and D. Tombros.
Event-based distributed workflow execution with EVE.
Technical Report ifi-96.05, University of Zurich, 1996.
[6] R. Gruber, B. Krishnamurthy, and E. Panagos.
The architecture of the READY event notification service.
In ICDCS workshop, Austin, Texas, 1999.
[7] A. Hinze.
How does the observation strategy influence the correctness of alerting services?
In Proc.
of the BTW (German National Conf.
on Databases), 2001.
[8] A. Hinze and A. Voisard.
A flexible parameter-dependent algebra for event notification services.
Technical Report Number tr-b-02-10, Freie Universitat Berlin, 2002.
[9] C. Liebig, M. Cilia, and A. Buchmann.
Event Composition in Time-dependent Distributed Systems.
In CoopIS, 1999.
[10] D. Zimmer and R. Unland.
On the semantics of complex events inactive database management systems.
In Proc.
of the ICDE, 1999.
Proceedings of the Ninth International Symposium on Temporal Representation and Reasoning (TIME'02) 1530-1311/02 $17.00 (c) 2002 IEEE