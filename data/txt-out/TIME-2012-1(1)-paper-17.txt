2012 19th International Symposium on Temporal Representation and Reasoning  Guarded Ord-Horn: A Tractable Fragment of Quantified Constraint Satisfaction Hubie Chen Departament de Tecnologies Universitat Pompeu Fabra Barcelona, Spain hubie.chen@upf.edu  Michal Wrona Department of Computer and Information Science Linkopings universitet SE-581 83 Linkoping, Sweden michal.wrona@liu.se  as the quantified constraint satisfaction problem (QCSP).
A structure over which the CSP or the QCSP is studied is typically referred to as a constraint language.
Classical examples of problems that follow this paradigm are the 2-SAT and Horn-SAT fragments of propositional logic, and their quantified analogs, Quantified 2-SAT [5] and Quantified Horn-SAT [6]; all of these problems are polynomial-time tractable.
One obtains these problems within the presented framework in particular by taking the constraint language to contain all relations definable by 2-clauses or, respectively, all relations definable by Horn clauses.
Another example of this paradigm is the positive first-order theory of equality [7], which can be obtained by taking the quantified constraint satisfaction problem on the constraint language containing all positively definable relations over equality.
As examples of this paradigm with respect to dense linear orders < without endpoints, consider the following.
* The constraint language with relations {<, <=, =} is known as the point algebra in temporal reasoning; it and extensions thereof have been studied intensely (see for example [8], [4], [9] and the references therein), and both the CSP and QCSP over it are known to be polynomialtime tractable [10].
* Constraints on relations of the form (x < y1 )[?].
.
.[?
](x < yk ) are known as AND/OR precedence constraints, and arise naturally in scheduling applications [3].
* Constraint solving over Ord-Horn clauses is of outstanding importance in temporal and spatial reasoning, as several tractability results there are based into translations into such clauses.
(As a starting point for information on Ord-Horn, we suggest the references [11], [12], [9]).
Ord-Horn clauses are defined as clauses of the form (x1 = y1 [?]
* * * [?]
xk = yk [?]
xRy), where R [?]
{<, <=, =, =} and it is permitted that k = 0 or that xRy is not present.
A structure whose relations are first-order definable over the ordered rationals (Q; <) will here be called a temporal constraint language.
A complete CSP complexity classification of temporal constraint languages was presented by Bodirsky and Kara [13].
This classification result gives a description  Abstract--The first-order theory of dense linear orders without endpoints is well-known to be PSPACE-complete.
We present polynomial-time tractability results for fragments of this theory which are defined by syntactic restriction; in particular, our fragments can be described using the framework of quantified constraint satisfaction over Ord-Horn clauses.
I. I NTRODUCTION The first-order theory of dense linear orders without endpoints is a classical object of study in model theory; it is well-known that this theory is exactly equivalent to the concrete theory of the ordered rationals (Q; <).
The corresponding computational problem of deciding if a sentence belongs to this theory is PSPACE-complete [1, Lecture 21].
This decision problem appears naturally in various areas of computer science: for instance, it forms part of the first-order theories of the rationals and of the reals, which are of interest in computational algebra [2], and many temporal reasoning and related problems studied in scheduling [3] and artificial intelligence [4] admit formulation in this problem.
This theory can also be viewed as the base of and a prototype for (not necessarily linear) orders possessing further structure, such as time intervals, branching time, and spatial regions under the subset ordering.
A natural way to syntactically restrict first-order theories that has proven fruitful in recent complexity studies, and which we pursue in the present work, is the following.
First, expand the structure(s) of interest by first-order definable relations to obtain a structure B; as an example, in the case of the ordered rationals (Q; <), first-order definable relations include those defined by x <= y and (x = y) [?]
(y < z).
Then, consider sentences over the expanded structure, but restrict their syntax so that conjunction ([?])
is the only permitted boolean connective.
In the case where only existential quantification is permitted, this problem is the constraint satisfaction problem (CSP) on B: an instance can be essentially viewed as a prenex formula with only existential quantification, followed by a conjunction of atomic B-formulas, and the problem is to decide if there is an assignment to the variables satisfying all of the atomic formulas, which can be viewed as constraints on the variables.
When both quantifiers are present, this problem is known 1530-1311/12 $26.00 (c) 2012 IEEE DOI 10.1109/TIME.2012.19  99  into LOGSPACE, NLOGSPACE-complete, P-complete, NPcomplete and PSPACE-complete problems.
of the constraint languages whose CSP is polynomial-time tractable, and shows that the remaining languages have an NPcomplete CSP.
The tractable languages include those examples just described.
In contrast to the CSP, where Ord-Horn is tractable, it is known that for the QCSP, there are simple Ord-Horn clauses that (viewed as constraint languages) are intractable [14]; an example is the clause (x = y) [?]
(y = z).
In this paper, we present polynomial-time tractability results for the QCSP on temporal constraint languages defined by Ord-Horn clauses, thus giving extremely positive complexity results on the first-order theory of dense linear orders without endpoints.
We begin by presenting a class of Ord-Horn clauses called Basic Ord-Horn Formulas.
It has been shown algebraically that constraint languages defined by such formulas enjoy the socalled local-to-global property [15].
This is an algorithmically desirable property which (essentially) holds that performing local consistency, a iterative, tractable method of performing local inferences on a conjunction of constraints, results in a computationally wieldy characterization of the global solution space of the constraints.
This property has been intensely studied and is robust in that it admits formulations from multiple viewpoints (see the discussion in [10]); in the finite, this property is exactly the one for which the classical BakerPixley theorem gives logical and algebraic characterizations.
We then define a class of formulas called Guarded OrdHorn (GOH) formulas; these formulas generalize the class of Basic Ord-Horn formulas, and each such formula can be written as the conjunction of Ord-Horn clauses.
The formulas in this class are described using a recursive syntactic definition with Basic Ord-Horn at the base.
Our main tractability result is that constraint languages definable by GOH formulas have a polynomial-time decidable QCSP; in developing this result, we make crucial use of an algebraic characterization of the local-to-global property for Basic Ord-Horn.
An attractive aspect of this tractability result is that the polynomial-time algorithm that we present is conceptually simple and based on novel pebble games.
These pebble games generalize local consistency methods, which have recently received focused attention for the CSP (see [16] for a state-of-the-art result); we believe that this paper will help to bring the study of local consistency methods into focus for the QCSP.
Related work: Quantified constraint satisfaction problems of temporal constraint languages augmented with relations defined by linear inequalities have been studied in [17].
One example of such a problem is the quantified version of the feasibility problem for linear programs.
It is shown that this QCSP is coNP-hard, and contained in PSPACE, but the precise complexity remains open.
The paper presents also a tractable QCSP; the corresponding constraint language does not contain any of the tractable languages presented here.
Charatonik and Wrona [18], [19] studied the QCSP for temporal constraint languages where all relations have a positive first-order definition over the reflexive dense linear order <=.
They showed the complete complexity characterization for the QCSP on these constraint languages and organized them  II.
P RELIMINARIES A. Quantified Constraint Satisfaction Throughout, we assume that each signature is a finite set of relation symbols.
Let t be such a signature.
A first-order t sentence is a quantified constraint sentence if it has the form Q1 v1 .
.
.
Qn vn (ps1 [?]
.
.
.
[?]
psm ), where each Qi is a quantifier from {[?
], [?
]}, and each psi is an atomic t -formula of the form R(x1 , .
.
.
, xk ) where R [?]
t .
Let B be a t -structure with domain B; that is, B has for each relation symbol R in t a relation RB [?]
B k where k is the arity of R; see for example [20].
The quantified constraint satisfaction problem for B, denoted by QCSP(B), is the problem of deciding, given a quantified constraint t sentence Ph, whether or not B |= Ph.
In this paper, we use (Q; <) as a concrete model whose theory is the one of interest.
A temporal relation [13] is a relation R [?]
Qk with a first-order definition in (Q; <); that is, there exists a first-order formula ph(x1 , .
.
.
, xk ) with free variables x1 , .
.
.
, xk such that (a1 , .
.
.
, ak ) [?]
R if and only if ph(a1 , .
.
.
, ak ) is true in (Q; <).
A temporal constraint language is a relational structure B with domain Q where each relation RB of B is a temporal relation.
In this paper we study QCSP(B) only for structures B with a finite signature.
It is well-known and follows from the theorem of RyllNardzewski (see [20]) that all temporal constraint languages are o-categorical.
We say that a k-ary function (also called operation) f : B k - B preserves an m-ary relation R [?]
B m if whenever R(ai1 , .
.
.
, aim ) holds for all 1 <= i <= k, then  R f (a11 , .
.
.
, ak1 ), .
.
.
, f (a1m , .
.
.
, akm ) holds as well.
Let B be a structure, and let ph be a first-order formula with free variables x1 , .
.
.
, xk .
Then we say that f preserves ph (over B) if f preserves the k-ary relation defined by ph over B.
If f preserves all relations of a relational structure B, we say that f is a polymorphism of B (see e.g.
[21] for background on the role of polymorphisms in the study of CSPs).
Unary polymorphisms are called the endomorphisms of B; bijective endomorphisms of B whose inverse is also an endomorphism are called automorphisms of B.
In this paper, use of the term automorphism is assumed to refer to automorphisms of (Q; <), unless otherwise specified.
An orbit is a subset of Q-tuples that is equal to the closure of a tuple t [?]
Qk under all automorphisms.
Example: The operation min : Q2 - Q that maps two rational numbers to the minimum of the two numbers is a polymorphism of the temporal constraint language (Q; <=, <).
It is not a polymorphism of the temporal constraint language (Q; =), since it maps for instance the tuples (1, 0) [?]
= and (0, 1) [?]
= to (0, 0) [?]
/ =.
An interesting relation that is preserved by min is the ternary relation defined by the formula x1 > x2 [?]
x1 > x3 , and the ternary relation U with U (x, y, z) defined by (x = y [?]
y < z) [?]
(x = z [?]
z < y) [?]
(x = y [?]
y = z).
100  Definition 2.1: Let B be any set.
A k-ary operation f : B k - B is called a quasi near-unanimity function (or QNUF) if for all x, y [?]
B we have  Theorem 2.4: [15] For any finite set F of basic OH formulas, there exists a main-injective surjective oligopotent QNUF preserving all formulas in F .
f (x, x, .
.
.
, x, y) = f (x, x, .
.
.
, y, x) = .
.
.
= f (y, x, .
.
.
, x, x) = f (x, .
.
.
, x) .
III.
T RACTABILITY OF G UARDED O RD -H ORN A. Definitions Throughout, we will use GOH as short for Guarded OrdHorn.
Definition 3.1: The set of GOH formulas over a variable set V is defined inductively as follows.
1) Basic OH formulas are GOH.
2) If ps1 and ps2 are GOH formulas, then ps1 [?]
ps2 is a GOH formula.
3) If ps is a GOH formula, then (x1 <= y1 ) [?]
.
.
.
[?]
(xm <= ym )[?]
(x1 = y1 [?]
.
.
.
[?]
xm = ym [?]
ps) is a GOH formula.
Here, it is assumed that the variables xi , yi are contained in V .
We refer to GOH formulas formed according to these rules as formulas of type 1, 2, and 3, respectively.
 Definition 3.2: A relation R [?]
Qn is GOH if there exists a GOH formula ph over the variables {v1 , .
.
.
, vn } such that R(v1 , .
.
.
, vn ) [?]
ph(v1 , .
.
.
, vn ).
A structure B is GOH if it is over a finite signature and each of its relations is GOH, that is, if for every relation symbol S from the signature of B, it  holds that S B is GOH.
We now introduce a normal form for GOH formulas.
Definition 3.3: A GOH formula ph is normal if for each subformula of type 3, it holds that, for each i [?]
[m], the variables xi and yi are different.
 Proposition 3.4: Each GOH formula ph is logically equivalent to a normal GOH formula N (ph).
Proof.
We show how to construct inductively, from any GOH formula ph, a normal GOH formula N (ph).
We consider the three types of GOH formulas in turn.
1) N (ph) = ph 2) N (ps1 [?]
ps2 ) = N (ps1 ) [?]
N (ps2 ) 3) When ph = (x1 <= y1 ) [?]
.
.
.
[?]
(xm <= ym ) [?]
(x1 = y1 [?]
.
.
.
[?]
xm = ym [?]
ps), let i1 , .
.
.
, in be a list of the elements of D = {i | xi , yi are different variables }.
Let N (ph) be the formula (xi1 <= yi1 ) [?]
.
.
.
[?]
(xin <= yin ) [?]
(xi1 = yi1 [?]
.
.
.
[?]
xin = yin [?]
ps), where it is understood that N (ph) = ps if D = [?].
It is clear that any GOH formula ph is equivalent to a normal GOH formula N (ph), over (Q, <).
 Definition 3.5: Let ph be a normal GOH formula.
We define the guards formula of ph, denoted by G(ph), inductively as follows.
We consider the three types of GOH formulas in turn.
1) For a basic OH formula ph: G(ph) = ph 2) G(ps1 [?]
ps2 ) = G(ps1 ) [?]
G(ps2 ) 3) G((x1 <= y1 ) [?]
.
.
.
[?]
(xm <= ym ) [?]
(x1 = y1 [?]
.
.
.
[?]
xm = ym [?]
ps)) = (x1 <= y1 ) [?]
.
.
.
[?]
(xm <= ym ) For an arbitrary GOH formula ph, we define the guards formula of ph as G(ph) = G(N (ph)), where N (ph) is the operator from Proposition 3.4.
   A polymorphism f : B k - B of B is called oligopotent (wrt B) if the mapping f * : B - B defined by f * (x) := f (x, .
.
.
, x) preserves all first-order definable relation of B.
This definition is different from the definition in [22], but equivalent to it (see Proposition 12 in that paper), and more convenient for our purposes.
Theorem 2.2 (follows from Theorem 19 in [22]): Let B be an o-categorical relational structure with an oligopotent k +1ary polymorphism that is a quasi near-unanimity operation, for some k >= 2.
Then every n-ary relation R in B contains all tuples t such that for every subset I of {1, .
.
.
, n} with |I| <= k there is a tuple s [?]
R such that t[i] = s[i] for all i [?]
I.
A simple example of an oligopotent QNUF is the ternary median operation median: Q3 - Q which maps its three arguments to the middle value of those arguments; if two or more arguments are equal to a value c, then the median operation returns c. In particular, median(x, x, x) = x for all x [?]
Q, and hence median is oligopotent.
Let B be a structure with domain B over signature t .
If E [?]
B 2 is an equivalence relation, we write B/E for the factor structure A with signature t , defined as follows.
The domain of A consists of the equivalence classes of E, and for each relation symbol R [?]
t we have RA = {([c1 ], .
.
.
, [ck ]) | (c1 , .
.
.
, ck ) [?]
RB }, where [c] denotes the E-equivalence class of c [?]
D. B.
Basic Ord-Horn Throughout, we use OH as short for Ord-Horn.
Definition 2.3: The set of basic OH formulas over a variable set V is the set containing the following formulas: * x = y, * x <= y, * (x1 = y1 [?]
.
.
.
[?]
xp = yp ), * (x1 = x2 [?].
.
.
x1 = xq )[?
](x1 < y1 )[?
](y1 = y2 [?].
.
.
y1 = yq ).
 It is assumed that the variables x, y, xi , yi are in V .
It has been demonstrated that an oligopotent QNUF with certain desirable properties can be constructed for basic OH formulas.
We describe the result by making use of the following notions from [10, Section 4], adapted to the current context.
Let t [?]
Qk be a tuple, where k >= 3, and let p : [k] - [k] be a permutation such that tp(1) <= * * * <= tp(k) .
If it holds that tp(2) = * * * = tp(k-1) , we say that this value is the main value of t. Not every tuple t [?]
Qk has a main value, but when a tuple has a main value, it is unique.
We define the equivalence relation [?
]m on Qk as follows: t [?
]m t if and only if t = t or t, t have the same main value.
We say that an operation h : Qk - Q is main-injective if for all t, u [?]
Qk , it holds that h(t) = h(u) if and only if t [?
]m u.
101  Clearly, every guards formula is the conjunction of basic OH formulas.
Definition 3.6: Let B be a GOH structure over signature s, and let R(w1 , .
.
.
, wn ) be an atomic formula over s (where the variables w1 , .
.
.
, wn are not necessarily distinct).
We define R(w1 , .
.
.
, wn ) as the formula G(ph(w1 , .
.
.
, wn )), where ph is a GOH formula for RB (as in Definition 3.2).
We extend this notation to quantified constraint sentences by defining, for such a sentence Ph = Qv1 v1 .
.
.
Qvn vn [?
]m i=1 psi , where the psi are atomic formulas, Ph = Qv1 v1 .
.
.
Qvn vn [?
]m  i=1 psi .
We observe that if the sentence Ph is true with respect to a GOH structure B, then the sentence Ph is also true: one can conceive of Ph as a relaxation of Ph.
We will make use of the following consequence of Theorem 2.4.
Corollary 3.7: Let B be a GOH structure over signature s. There exists a main-injective surjective oligopotent QNUF preserving all formulas of the form R(w1 , .
.
.
, wn ), where R(w1 , .
.
.
, wn ) is an atomic formula over s. Proof.
There are clearly a finite number of such formulas of the described form, up to renaming of variables.
Each such formula is the conjunction of basic OH formulas; letting F be the set of all basic formulas that can appear in such a conjunction, the result follows directly from Theorem 2.4.
  corresponding structure pebble is removed.
At the start of the game, no pebbles are in play.
The Duplicator wins if he can play forever in such a way that the mapping from variables to B-elements determined by pebbles is always a partial solution.
The notion of partial solution that we use in formalizing the pebble games used is that of projective homomorphism.
We say that a function f defined on a subset of VPh is a projective homomorphism of Ph if for each atomic formula R(v1 , .
.
.
, vk ) of Ph, there exists an extension of f that satisfies R(v1 , .
.
.
, vk ) over B. Equivalently, such a function f is a projective homomorphism of Ph if for each atomic formula R(v1 , .
.
.
, vk ), there exists a tuple (b1 , .
.
.
, bk ) [?]
RB such that for all vi [?]
dom(f ), it holds that f (vi ) = bi .
We use dom(f ) to denote the domain of a function f .
Similarly, we say that a function f defined on a subset of VPh is a projective homomorphism of Ph if for each formula R(v1 , .
.
.
, vk ) in Ph corresponding to an atomic formula of Ph, there exists an extension of f that satisfies R(v1 , .
.
.
, vk ) over B.
The notion of a (Duplicator) winning strategy for the kpebble game can be formalized in the following way.
Definition 3.8: A winning strategy for the k-pebble game (on Ph) is a set S of projective homomorphisms, each having domain of size less than or equal to k, that satisfies the following conditions.
(1) The partial function with empty domain is an element of S, (2) If f [?]
S and g is a restriction of f , then g [?]
S. (3) If f [?]
S, |dom(f )| < k, v [?]
VPh , and dom(f ) <Ph v, then f can be (v, Qv )-extended in S. We say that an operation f can be (v, Q)-extended in a set of operations S if: * when Q = [?
], there exists an extension g [?]
S of f with domain dom(g) = dom(f ) [?]
{v}, and * when Q = [?
], every extension g of f with domain dom(g) = dom(f ) [?]
{v} is in S.  We next introduce an extension of the k-pebble game where the Spoiler can perform "backmoves" or "backpebbling": he can place a pebble on a variable that does not come after all pebbled variables, and the Duplicator must respond.
Definition 3.9: A winning strategy for the k-pebble game with backmoves (on Ph) is a set S of projective homomorphisms, each having domain of size less than or equal to k, that is a winning strategy for the k-pebble game (Definition 3.8) and in addition satisfy the following condition.
(4) If f [?]
S, |dom(f )| < k, v [?]
Vph , and dom(f ) <Ph v, then there exists an extension g [?]
S of f with domain dom(g) = dom(f ) [?]
{v}.
 The definition of the k-pebble game with backmoves naturally gives rise to an algorithm for deciding whether or not there is a winning strategy for this game.
The algorithm is as follows.
It is clear that, for each fixed k, and any finite structure B, the algorithm runs in polynomial time, measured with  B. Pebble games Throughout this subsection, Ph denotes a quantified constraint sentence Ph = Qv1 v1 .
.
.
Qvn vn ph in prenex form.
We use VPh to denote the set of variables {v1 , .
.
.
, vn } of Ph, and for each variable v [?]
VPh , we use Qv to denote its corresponding quantifier.
We write u <Ph v to indicate that u occurs strictly before v in the quantifier prefix of Ph; we write u <=Ph v to indicate that u <Ph v or u = v. We extend this notation to sets of variables U, W ; we write, for instance, that U <Ph W if u <Ph w for all u [?]
U, w [?]
W , and that U <Ph w for a variable w if U <Ph {w}.
We assume that B is a relational structure and that Ph is a quantified constraint sentence that is an instance of QCSP(B).
Much of the development is relative to the structure B, but we will generally suppress explicitly mentioning the structure B.
In order to establish our tractability result, we will consider a number of pebble games (for more on pebble games in the context of constraint satisfaction, see e.g.
[23]).
The most basic pebble game that we will consider is here referred to simply as the k-pebble game, and is based on the pebble game for quantified constraint sentences defined by Chen and Dalmau [24].
The k-pebble game is played between two players, Spoiler and Duplicator.
Spoiler can use up to k pebbles, and can perform two actions.
First, Spoiler can place a pebble on a variable of the sentence that comes after all variables having pebbles; if it is an existentially quantified variable, Duplicator has to respond by placing a pebble on an element b of the structure B, and if it is a universally quantified variable, the Spoiler also places a pebble on an element b of B of his choosing.
Second, Spoiler can remove a pebble that is on a variable of the sentence, in which case the  102  of S. (2') If f [?]
S and g is a restriction of f to a set of the form {v1 , v2 , .
.
.
, vi }, then g [?]
S. (3') If f [?]
S, dom(f ) = {v1 , v2 , .
.
.
, vi }, and i < n, then f can be (vi+1 , Qvi+1 )-extended in S.  Proposition 3.12: A quantified constraint sentence Ph is true if and only if there exists a winning strategy for the truth pebble game on Ph.
We now show that the maximal winning strategy for the k-pebble game with backmoves fully supports any winning strategy for the truth pebble game, in the following sense.
Proposition 3.13: Let Ph be a quantified constraint sentence.
Let S be the strategy computed by the algorithm for the k-pebble game with backmoves (on Ph).
If there exists a winning strategy T for the truth pebble game (on Ph), then S is nonempty and contains all restrictions of operations in T to domains of size less than or equal to k. Proof.
We prove that, at each stage of the algorithm, all such restrictions of operations in T are contained in S. It is clear that, after step (1) is performed, this holds.
We thus show that if this holds, then no such restriction of an operation in T can be removed from S by one of the removal rules in step (2), as follows.
In each of the following arguments, we suppose that f [?]
S is the restriction of an operation h [?]
T .
* All restrictions of f are restrictions of h, and are hence all contained in S. * Let vj [?]
VPh with |dom(f )| < k and dom(f ) <Ph vj .
We make use of properties (2') and (3') of Definition 3.11.
By property (2'), there exists a restriction h1 [?]
T of h / dom(h1 ).
By such that dom(f ) [?]
dom(h1 ) but vj [?]
possibly repeated application of property (3'), one can obtain h2 [?]
T with domain {v1 , .
.
.
, vj-1 } such that h2 extends h1 , and f is a restriction of h2 .
Since h2 can be (vj , Qvj )-extended in T , the operation f can be (vj , Qvj )-extended in S. * Let v [?]
VPh with |dom(f )| < k and dom(f ) <Ph v. We have that h is defined on v, and hence the restriction of h to dom(f ) [?]
{v} is contained in S.   Algorithm for k-pebble game with backmoves.
Input: a quantified constraint sentence Ph 1.
Let S be the set of all projective homomorphisms of Ph having domain of size less than or equal to k, relative to the structure B of interest.
2.
Repeat until no changes are possible: *  If there exists f [?]
S having a restriction g not in S, then remove f from S.  *  If there exists f [?]
S and v [?]
VPh with |dom(f )| < k and dom(f ) <Ph v such that f cannot be (v, Qv )-extended in S, then remove f from S.  *  If there exists f [?]
S and v [?]
VPh with |dom(f )| < k and dom(f ) <Ph v such that there is no extension g [?]
S of f with domain dom(g) = dom(f ) [?]
{v}, then remove f from S.  3.
Return S.  respect to the input Ph.
This algorithm can be applied to temporal constraint languages B by maintaining, at all times, an orbit representative for each orbit that is present in S, and then performing the described computations using the orbit representatives; this is justified by the fact that the set of all projective homomorphisms is closed under automorphism.
Again, for each fixed k and any temporal constraint language B, the algorithm runs in polynomial time in the input Ph.
In the case that, when the algorithm terminates, the set S is nonempty, we call this resulting strategy S the maximal winning strategy.
The following proposition is straightforward to verify.
Proposition 3.10: Let S be the set returned by the algorithm for the k-pebble game with backmoves on a quantified constraint sentence Ph.
* For any winning strategy T for this game (on Ph), it holds that T [?]
S. * If S = [?
], then there is no winning strategy for this game (on Ph).
We consider one more pebble game, the truth pebble game, which characterizes the truth of a quantified constraint sentence.
Definition 3.11: A winning strategy for the truth pebble game (on Ph = Qv1 v1 .
.
.
Qvn vn ph) is a set S of projective homomorphisms, each having domain of the form {v1 , v2 , .
.
.
, vi } for some i >= 0, that satisfy the following conditions.
(1) The partial function with empty domain is an element  It is straightforward to verify that, for an instance Ph of QCSP(B) and a winning strategy S for one of the pebble games considered in this subsection, the closure of S under the surjective polymorphisms of B is also a winning strategy for the pebble game.
In what follows, we will tacitly assume that winning strategies are closed under such polymorphisms.
C. Algorithm In this subsection, we present our algorithm for Guarded Ord-Horn, and prove its correctness.
Before presenting our algorithm, we introduce a couple of notions.
Let us say that a winning strategy S for the k-pebble game with backmoves (on Ph) implies the equality u = v, where u, v are distinct variables in VPh , if every operation f [?]
103  S with domain dom(f ) = {u, v} has the property that f (u) = f (v).
Our algorithm will detect implied equalities and simplify quantified sentences; the notion of simplification used is as follows.
Let u <Ph v be two variables in VPh .
We use Ph[u - v] to denote the sentence obtained from Ph by eliminating v and its quantifier from the quantifier prefix, and by replacing every instance of v in the quantifier-free part with u.  with backmoves that does not imply any equalities, then the sentence Ph has a winning strategy for the truth pebble game.
We establish Theorem 3.14 via a sequence of lemmas.
In what follows, we assume that the hypotheses of Theorem 3.14 are in effect.
We will make use of the following notion.
Relative to a sentence Ph, let us say that a projective homomorphism f is exinjective ("existentially injective") when for all pairs of variables u, v [?]
dom(f ), if u <Ph v and Qv = [?
], then f (u) = f (v).
We say that a set of projective homomorphisms is exinjective if all of the projective homomorphisms it contains are exinjective.
Lemma 3.15: If the sentence Ph has a winning strategy S for the k-pebble game with backmoves that does not imply any equalities, then this sentence has an exinjective winning strategy for the k-pebble game.
In the proof of this lemma, we will use the notation c, where c [?]
Q, to denote the k-tuple (c, .
.
.
, c) [?]
Qk having all entries equal to c. We will also make use of the following type of operation.
For a constant c [?]
Q, define pc : Q2 - Q to be a surjective operation such that pc (x, y) < pc (x , y  ) if and only if either (1) x < x , or (2) x = x = c and y < y  ; it is easy to see that such operations exist.
See Fig.
1 for an illustration of such an operation.
In this illustration, if we link (x, y), (u, v) [?]
Q2 by an arc from (x, y) to (u, v) then this means that f (x, y) < f (u, v); if (x, y) is linked to (u, v) by an undirected line, then f (x, y) = f (u, v).
Algorithm for QCSP(B) where B is a GOH-structure.
Input: a quantified constraint sentence Ph 1.
Run the algorithm for the k-pebble game with backmoves on Ph, where k is the arity of the QNUF from Corollary 3.7; let S be the result.
2.
If S = [?
], return FALSE.
Otherwise, check to see if S implies any equalities.
If it does, let u = v be an implied equality, with u <Ph v; replace Ph with Ph[u - v]; and return to step 1.
3.
Return TRUE.
Clearly, this algorithm runs in polynomial time: each time it performs a replacement of Ph, one variable is eliminated (and the sentence is shortened), and so it loops at most |VPh | times; and, as previously discussed, the algorithm for the k-pebble game with backmoves runs in time polynomial in the size of the input sentence.
We thus turn to discuss the correctness of the algorithm.
When the algorithm detects an implied equality u = v, with u <Ph v, the variable v must be existentially quantified, since a function with domain {u} can be (v, Qv )-extended in a winning strategy for the pebble game.
Also, in this case, by Proposition 3.13, all functions f contained in winning strategies for the truth pebble game on Ph that are defined on {u, v} set f (u) = f (v).
Since a winning strategy for the truth pebble game on Ph must be a winning strategy for the truth pebble game for Ph, this property also holds for all functions f contained in winning strategies for the truth pebble game on Ph, and so the sentence Ph[u - v] is true if and only if the sentence Ph is true.
We have thus shown that the replacement step preserves the truth of the sentence; it follows by Proposition 3.13 that if the algorithm returns "FALSE", then the input sentence was indeed false.
It remains to show that if the algorithm returns "TRUE", then the sentence is true.
To demonstrate this, it suffices to provide a proof of the following theorem.
Theorem 3.14: Let B be a GOH structure, let k be the arity of the QNUF from Corollary 3.7, and let Ph be a quantified constraint sentence that is an instance of QCSP(B).
If the sentence Ph has a winning strategy for the k-pebble game  c  Fig.
1.
An illustration of an operation pc .
Observe that all such operations pc preserve all basic OH formulas.
We present the following sub-lemma.
Lemma 3.16: Let R be a relation defined by a basic OH formula and c [?]
Q be a constant.
Then pc preserves R. Proof.
In what follows, we write phR for a GOH formula defining R. Moreover, tx denotes a coordinate of t [?]
R that corresponds to a variable x occurring in phR .
A basic OH formula is in one of four forms.
If phR is an equality, then R is preserved by all functions and hence by pc .
We now consider the case where phR is of the form x <= y.
Let t, u [?]
R. Then, by the definition of pc , it is not hard to see that pc (tx , ux ) <= pc (ty , uy ).
Thus pc (t, u) is in R and pc preserves R. If phR is of the form (x1 = y1 [?]
.
.
.
[?]
xp = yp ) and t [?]
R, then there is i [?]
[p] such that txi = tyi .
Assume without loss  104  of generality that txi < tyi .
Let u [?]
R be any tuple.
We now show that pc (t, u) is in R and thereby that R is preserved by pc .
To see this observe that pc (txi , uxi ) < pc (tyi , uyi ).
Finally, let phR be of the form (x1 = x2 [?]
.
.
.
[?]
x1 = xq ) [?]
(x1 < y1 ) [?]
(y1 = y2 [?]
.
.
.
[?]
y1 = yq ).
If t [?]
R, then we have one of the following situations: * there is i [?]
[q] such that tx1 = txi ;  * there is i [?]
[q ] such that ty1 = tyi ; * tx1 < ty1 .
Let u [?]
R. To show that pc (t, u) [?]
R regardless of the reason why t [?]
R we use the same argument as in the case where phR is of the form (x1 = y1 [?]
.
.
.
[?]
xp = yp ).
For each type of a basic OH formula phR we showed that R is preserved by pc .
Thus we proved the lemma.
  By making use of automorphisms and the fact that S is a winning strategy, we can obtain a homomorphism a1 [?]
S with dom(a1 ) = dom(f ) where a1 (y) = -a and a1 = a elsewhere.
Observe that a1 is exinjective, and hence any restriction thereof is also exinjective.
We claim that there is an extension c1 of a1 with dom(c1 ) = dom(a1 ) [?]
{v} where / {-a, a}.
Let b [?]
S be an extension of a1 with c1 (v) [?]
dom(b) = dom(a1 ) [?]
{v}.
If b does not satisfy the desired property, then b(v) [?]
{-a, a}.
Let b1 [?]
S be the restriction of a1 to the set J = {w [?]
dom(a1 ) | a1 (w) = b(v)}.
By the induction hypothesis, b1 can be extended to an exinjective b1 [?]
S with dom(b1 ) = dom(b1 ) [?]
{v}.
By backpebbling, b1 can be extended to an operation b2 [?]
S with dom(b2 ) = dom(f )[?]{v}.
Consider the function pb(v) (b, b2 ).
The function b is equal to b(v) at J [?]
{v}; on that set, the function b2 is equal to b(v) on J, and to a different value at v. We can thus take c1 = pb(v) (b, b2 ).
After application of an automorphism, we have obtained an operation c1 having dom(c1 ) = dom(f ) [?]
{v} where c1 (y) = / {-a, a}, and c1 = a elsewhere.
By a similar -a, c1 (v) [?]
argument, we can obtain an operation c2 having dom(c2 ) = / {-a, a}, and c2 = dom(f ) [?]
{v} where c2 (y) = a, c2 (v) [?]
-a elsewhere.
Suppose that one of the values c1 (v), c2 (v) is strictly greater than a, and that the other is strictly less than -a.
Let d1 , d2 [?]
{c1 , c2 } be such that d1 (v) > a and d2 (v) < -a.
We can find automorphisms g1 , g2 such that g1 (d1 ) is positive on v, and negative elsewhere; and, g2 (d2 ) is positive everywhere.
Consider the function g = q(g1 (d1 ), g2 (d2 ), h, .
.
.
, h), where q is the QNUF from the formulation of Theorem 3.14.
On dom(f ), this g is equal to q(0), since on these variables the values that q is applied to yield the main value 0.
On the other hand, g(v) is not equal to q(0), since on v both g1 (d1 ), g2 (d2 ) are positive, and hence there is no main value.
In other cases, we will demonstrate that there are automorphisms g1 , g2 each of which fixes both -a and a such that g = q(g1 (d1 ), g2 (d2 ), h, .
.
.
, h) is not equal to q(0) on v; this suffices, since for such automorphisms g is equal to q(0) elsewhere.
If both d1 (v), d2 (v) are strictly greater than a, then one can take both g1 , g2 to be the identity automorphisms, as then the tuple q is applied to will have no main value.
Similarly, if both d1 (v), d2 (v) are strictly less than -a, then one can take both g1 , g2 to be the identity automorphisms.
The remaining case is where one or both of d1 (v), d2 (v) is in the interval (-a, a).
Suppose that d1 (v) [?]
(-a, a).
The automorphism g2 can be defined so that g2 (d2 (v)) = 0.
Then, g1 can be defined so that g1 (d1 (v)) is positive if g2 (d2 (v)) is positive, and negative if g2 (d2 (v)) is negative.
The argumentation for the subcase where d2 (v) [?]
(-a, a) is similar.
  Proof.
(Lemma 3.15) Let S  be the set containing all projective homomorphisms in S that are exinjective.
We will show that S  gives the desired exinjective winning strategy.
Let us consider the properties of Definition 3.8.
It is clear that S  inherits properties (1) and (2) from S. Also, S  inherits the property (3) in the case that Qv = [?].
It thus suffices to prove the following claim.
Claim: if f [?]
S is exinjective, |dom(f )| < k, v [?]
VPh , Qv = [?
], and dom(f ) <Ph v, then there is an exinjective extension g [?]
S of f with dom(g) = dom(f ) [?]
{v}.
We prove the claim by induction on |dom(f )|.
For |dom(f )| = 0, the claim is obvious.
For |dom(f )| = 1, the claim follows from the hypothesis that S does not imply any equalities.
So, we suppose that |dom(f )| >= 2.
As S is a winning strategy for the k-pebble game, there exists an extension h [?]
S of f with dom(h) = dom(f ) [?]
{v}.
Let I = {w [?]
dom(f ) | h(v) = f (w)}.
We now consider two cases; it can be remarked that if I = [?
], then one can simply take g = h. Case I = dom(f ): let u [?]
dom(f ) \ I, that is, let u [?]
dom(f ) be a variable such that h(v) = f (u).
Let h1 be the restriction of h to dom(f ) \ {u}.
By the induction hypothesis, there exists an exinjective extension h2 of h1 whose domain dom(h2 ) is equal to dom(h) \ {u} = (dom(f ) [?]
{v}) \ {u}.
By applying a backmove to h2 , we obtain an extension h3 of h2 with dom(h3 ) = dom(h).
Consider the function ph(v) (h, h3 ).
Recall that the definition of the polymorphism pc , where c [?]
Q, is above Lemma 3.16.
The function h is equal to h(v) at I [?]
{v}; on I [?]
{v}, the function h3 is equal to h(v) on I, but equal to a value different from h(v) at v. Hence, the function ph(v) (h, h3 ) is exinjective, but there exists an automorphism b such that b(ph(v) (h, h3 )) = f on dom(f ), and so we can take g = b(ph(v) (h, h3 )).
Case I = dom(f ): let us assume that h is equal to 0 everywhere on its domain; for other values, the same argument will apply under translation by an automorphism.
Observe that, since f is exinjective, all variables of dom(f ), except for possibly the earliest one, are universally quantified.
Let y be the latest occurring variable in dom(f ), which must be universally quantified.
Fix a > 0 to be a positive constant.
Lemma 3.17: If the sentence Ph has an exinjective winning strategy for the k-pebble game then this sentence has an exinjective winning strategy for the truth pebble game.
Proof.
Let S be an exinjective winning strategy for the kpebble game.
Let T be the set containing all exinjective  105  functions f from a subset of VPh to Q such that every restriction of f to a set of size <= k is contained in S. Every function in T is a projective homomorphism by Theorem 2.2.
Clearly, T is non-empty, as S [?]
T , and is closed under restriction.
We will prove the following claim.
Claim: for every function f [?]
T and variable v [?]
VPh with dom(f ) <Ph v, the function f can be (v, Qv )-extended in T .
This claim suffices to give the lemma, as then the set of functions in T having domain of the form {v1 , v2 , .
.
.
, vi } forms the desired exinjective winning strategy for the truth pebble game.
The claim is clear when Qv = [?]
by the definition of T , so let Qv = [?].
We prove the claim by induction on |dom(f )|.
The base case |dom(f )| < k is clear by definition of T , so suppose that |dom(f )| >= k. Let u1 , .
.
.
, uk be distinct elements from dom(f ), and for each i [?]
[k] define fi to be the restriction of f to dom(f ) \ {ui }.
Each fi has, by induction, an exinjective extension gi [?]
T defined on (dom(f ) \ {ui }) [?]
{v}.
Let g be the function on dom(f )[?
](v) defined by g(u) = q(f (u)) for all u [?]
dom(f ), and g(v) = q(g1 (v), .
.
.
, gk (v)).
By the QNUF identities and the fact that each gi is in T , we obtain that g is in T .
Since each of the gi is exinjective, for all i, j [?]
[k] with j = i, it holds that gj (v) = gj (ui ) = f (ui ).
It follows that the tuple (g1 (v), .
.
.
, gk (v)) cannot have as main value any of the values f (u1 ), .
.
.
, f (uk ).
Hence, the function g is exinjective.
 Lemma 3.18: If the sentence Ph has an exinjective winning strategy for the truth pebble game then that strategy is a winning strategy for the truth pebble game on Ph.
Proof.
Let R(t) be an atomic formula from the quantifier-free part of Ph, where t is a tuple of variables, and let ph(t) be the normal GOH formula for R(t).
Let ph (t) be the guards formula of ph(t); the formula ph (t) is the formula for R(t).
The formula ph(t) can be viewed as the conjunction of GOH formulas of types 1 and 3.
We show that each such formula is satisfied by any f [?]
S whose domain contains the variables of t, which suffices.
A basic OH formula is satisfied by f because f satisfies the corresponding identical subformula in ph (t).
Now consider a formula  Proof.
If the algorithm returns "FALSE", falsity of the input sentence follows directly from Proposition 3.13.
If the algorithm returns "TRUE", truth of the input sentence follows directly from Theorem 3.14 and Proposition 3.12.
 ACKNOWLEDGMENT Hubie Chen is supported by the Spanish program "Ramon y Cajal" and MICINN grant TIN2010-20967-C04-02.
R EFERENCES [1] D. Kozen, Theory of Computation.
Springer, 2006.
[2] S. Basu, R. Pollack, and M.-F. Roy, Algorithms in Real Algebraic Geometry, 2nd edition.
Springer-Verlag, 2009.
[3] R. H. Mohring, M. Skutella, and F. Stork, "Scheduling with and/or precedence constraints," SIAM J.
Comput., vol.
33, no.
2, pp.
393-415, 2004.
[4] M. Broxvall and P. Jonsson, "Point algebras for temporal reasoning: Algorithms and complexity," Artif.
Intell., vol.
149, no.
2, pp.
179-220, 2003.
[5] B. Aspvall, M. F. Plass, and R. E. Tarjan, "A linear-time algorithm for testing the truth of certain quantified boolean formulas," Inf.
Process.
Lett., vol.
8, no.
3, pp.
121-123, 1979.
[6] M. Karpinski, H. K. Buning, and P. H. Schmitt, "On the computational complexity of quantified horn clauses," in CSL, 1987, pp.
129-137.
[7] D. Kozen, "Positive first-order logic is NP-complete," IBM Journal of Research and Development, vol.
25, no.
4, pp.
327-332, 1981.
[8] P. van Beek, "Reasoning about qualitative temporal information," Artificial Intelligence, vol.
58, pp.
297-326, 1992.
[9] M. Fisher, D. Gabbay, and L. Vila, Eds., Handbook of Temporal Reasoning in Artificial Intelligence.
Elsevier, 2005.
[10] M. Bodirsky and H. Chen, "Qualitative temporal and spatial reasoning revisited," in CSL'07, 2007, pp.
194-207.
[11] B. Nebel and H.-J.
Burckert, "Reasoning about temporal relations: A maximal tractable subclass of Allen's interval algebra," JACM, vol.
42, no.
1, pp.
43-66, 1995.
[12] P. Balbiani, J.-F. Condotta, and L. F. del Cerro, "Tractability results in the block algebra," J. Log.
Comput., vol.
12, no.
5, pp.
885-909, 2002.
[13] M. Bodirsky and J. Kara, "The complexity of temporal constraint satisfaction problems," Accepted for publication in the Journal of the ACM, 2009, an extended abstract appeared in the proceedings of STOC'08.
[14] M. Bodirsky and H. Chen, "Quantified equality constraints," SIAM Journal on Computing, vol.
39, no.
8, pp.
3682-3699, 2010.
[15] M. Wrona, "Syntactically characterizing local-to-global consistency in ord-horn," in the proceedings of 18th International Conference on Principles and Practice of Constraint Programming.
[16] L. Barto and M. Kozik, "Constraint satisfaction problems of bounded width," in Proceedings of FOCS'09, 2009.
[17] K. Subramani, "On a decision procedure for quantified linear programs," Ann.
Math.
Artif.
Intell., vol.
51, no.
1, pp.
55-77, 2007.
[18] W. Charatonik and M. Wrona, "Tractable quantified constraint satisfaction problems over positive temporal templates," in LPAR, 2008, pp.
543-557.
[19] ----, "Quantified positive temporal constraints," in CSL, 2008, pp.
94- 108.
[20] W. Hodges, A shorter model theory.
Cambridge: Cambridge University Press, 1997.
[21] A. Bulatov, A. Krokhin, and P. G. Jeavons, "Classifying the complexity of constraints using finite algebras," SIAM Journal on Computing, vol.
34, pp.
720-742, 2005.
[22] M. Bodirsky and H. Chen, "Oligomorphic clones," Algebra Universalis, vol.
57, no.
1, pp.
109-125, 2007.
[23] V. Dalmau, P. G. Kolaitis, and M. Y. Vardi, "Constraint satisfaction, bounded treewidth, and finite-variable logics," in Proceedings of CP'02, 2002, pp.
310-326.
[24] H. Chen and V. Dalmau, "From pebble games to tractability: An ambidextrous consistency algorithm for quantified constraint satisfaction," in CSL, 2005, pp.
232-247.
(x1 <= y1 ) [?]
.
.
.
[?]
(xm <= ym ) [?]
(x1 = y1 [?]
.
.
.
[?]
xm = ym [?]
ps) of type 3.
It suffices to show that each inequality xi <= yi is satisfied in a way that x and y are set to different values.
Let u, v [?]
VPh be such that {u, v} = {xi , yi } and u <Ph v. Note that xi , yi are distinct variables, since ph(t) is a normal GOH formula.
We claim that Qv = [?
], which suffices, as the strategy S is exinjective.
Suppose for a contradiction that Qv = [?].
Then the restriction of f to {u} can be extended to a function g [?]
S with dom(g) = {u, v} such that g does not satisfy xi <= yi , contradicting that S is a winning strategy for Ph.
 We can now conclude our main polynomial-time decidability result.
Theorem 3.19: Let B be a GOH structure.
The problem QCSP(B) is polynomial-time decidable.
106