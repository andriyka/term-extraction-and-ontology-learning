Positive and negative results on the decidability of the model-checking problem for an epistemic extension of Timed CTL Catalin Dima* LACL, Universite Paris Est - Universite Paris 12, 61 av.
du General de Gaulle, 94010 Creteil, France  Abstract  agents may observe the exact current absolute time, while perfect recall means that, based on the history of observations they can make on system states, agents are able to distinguish histories, and not only the current global state of the system.
Our focus is on extending some results concerning an epistemic variant of CTL without common knowledge.
In [5] we proved that model-checking formulas in such a logic is nonelementary, and requires a subset construction on the model.
The question one would ask is then whether that construction can be adapted to continuous time, provided that timed automata cannot be determinized [2].
We show that, indeed, model-checking for this timed version of epistemic CTL with synchrony and perfect recall is undecidable.
Our result is even stronger: modelchecking for CTL with "simple" knowledge operators with a continuous-time semantics is undecidable too, even without the freeze quantifiers from TCTL, and the result shows that only one unobservable clock suffices for undecidability.
This also means that undecidability holds even if the agents are only able to observe time passage.
The source of this strong result comes more from the expressive power of the models than from the logic itself, and is strongly related to the impossibility to generalize the subset construction to timed automata.
On the other hand, we show that if agents are able to fully observe clock values - and this includes the observability of the values for the freeze clocks of TCTL - then model-checking becomes decidable.
The proof goes by a straightforward adaptation of the classical algorithm for TCTL model-checking [1], and is based on the fact that, with full clock observability, the subset construction only concerns the "untimed" part of the model.
Previous work on combining epistemic and continuous time expressivity includes [19].
There, a continuous time variant of CTLK is also presented, with a state-based semantics that includes state and clock observability, but not history or absolute time observability.
Therefore, the logic in [19] has a decidable model-checking problem.
However our logic is more expressive, due to its perfect recall semantics.
We present TCTLK, a continuous-time variant of the Computational Tree Logic with knowledge operators, generalizing both TCTL, the continuous-time variant of CTL, and CTLK, the epistemic generalization of CTL.
Formulas are interpreted over timed automata, with a synchronous and perfect recall semantics, and the observability relation requires one to specify what clocks are visible for an agent.
We show that, in general, the model-checking problem for TCTLK is undecidable, even if formulas do not use any clocks - and hence CTLK has an undecidable modelchecking problem when interpreted over timed automata.
On the other hand, we show that, when each agent can see all clock values, model-checking becomes decidable.
1  Introduction  Combinations of temporal and epistemic logics offer a useful setting for the analysis of multi-agent systems.
They have been successfully utilized for model-checking protocols like the Alternating Bit Protocol [16], and the Chaum's Dining Cryptographers Protocol [18, 11], whose functioning is related to the participants' knowledge of the system state.
Algorithms exist for the model-checking problem [17, 12, 5] (to cite only a few) and several tools have been designed for model-checking [13, 7].
In this paper we investigate a possibility to extend these results to the continuous case.
We present a logic, called here TCTLK, which is based on an epistemic extension of the Computational Tree Logic, with the addition of freeze clock variables for expressing time.
Here we consider a synchronous and perfect recall semantics [8, 9], given in terms of timed automata [2].
The observability relations used for defining the epistemic operators include the ability of agents to observe truth values of some atomic propositions (and the inability to observe some others), as well as their ability to observe clock values, as a generalization of the ability to observe only time passage.
Recall that synchrony means that * Partially  supported by the French ANR project SPREADS  1  The semantics of a timed automata will be given here in a weakly-monotonic setting which draws some similarities with the work of [15].
This avoids problems related to the density of real numbers, that lead sometimes authors to consider a "nonstrict" variant of the until operator, as in [3].
We introduce a weakly-monotonic presentation for both trajectories and runs.
Trajectories are, in some sense, annotations of timed words [2] with clock information, and, as such, are a generalization of the concept of word in finite automata.
Runs are continuous presentations of behaviors of timed automata, embodying the possibility to have, in a model, some finite control (locations) which is not captured by formulas.
The observability relation is then introduced using projection and equivalence on trajectories.
Equivalence is needed as there may be several trajectories representing the same behavior, due to the possibility to have silent transitions in a timed automaton.
Also projection cannot be defined directly on runs, as it models "forgetting" some part of the observable state of a system.
We also note that the decidability result would still hold if we use a bounded asynchronous semantics.
The idea is that agents would only have the possibility to observe the integer parts of the clock values, and of the differences between clocks, but not the exact clock values.
The final section contains a brief discussion on this topic.
The rest of the paper is divided as follows: in Section 2 we lay the basis for the semantics of timed multi-agent systems.
Section 3 gives the undecidability result, while Section 4 gives the decidability in the case of full observability of the clock values.
A section with final remarks concludes the paper.
Due to space limitations the proofs are only sketched; a technical report [6] can be consulted for more detailed proofs.
2  A weakly-monotonic semantics for TCTLK  In this section we will give a weakly-monotonic semantics of timed automata, in terms of (continuous) trajectories.
A continuous trajectory is a description of a particular behavior of the automaton, describing at each time point the location in which the automaton is at that time point, and the values of all clocks.
It is, in some sense, similar with words for finite automata.
We will present the "time domain" of a trajectory in a weakly-monotonic fashion [15], in order to accomodate the possibility of a timed automaton to take more than one transition at a given instant.
We will utilize throughout this paper a set X of nonnegative real-valued variables called clocks.
A clock valuation is a mapping v : X - R>=0 .
For any clock valuation v and set of clocks X [?]
X , v[X := 0] denotes the clock valuation defined by v[X := 0](x) = 0 for x [?]
X and v[X := 0](x) = v(x) for x 6[?]
X.
As always, [?
]-a = [?]
for any a [?]
R. Definition 1 A trajectory over X and a set of state symbols  P is a pair T = (I, th), where I is a (finite or infinite) sequence of pairs of sets of state symbols and intervals  * I = Si , [ai-1 , ai ] 1<=i<e with e [?]
N[?]{[?
]}, Si [?]
P, ai-1 , ai [?]
R>=0 , ai-1 <= ai and a0 = 0. and th is a continuous mapping of clock intervals: * th = (thi )1<=i<e with thi : [ai-1 , ai ] x X - R>=0 subject to the following properties.
1.
For all i < e and all t, t' [?]
[ai-1 , ai ], t < t' , and for all x [?]
X , thi (t' , x) = th(t, x) + t' - t. 2.
For all i < e -1 there exists a (possibly empty) set of clocks X [?]
X such that thi+1 (ai , *) = thi (ai , *)[X := 0].
Remark 1 Note that for two successive elements of I, (Si , [ai-1 , ai ]), (Si+1 , [ai , ai+1 ]), intervals are adjacent.
The weakly-monotonic S time domain of a trajectory T = (I, th) is the set Iintv = 1<=i<e {i} x [ai-1 , ai ].
Elements of Iintv will be called weakly-monotonic time points (or w-points for short).
Iintv can be totally-ordered as usual: given (n, t), (n' , t' ) [?]
Iintv , we say that (n, t) precedes (n' , t' ) and denote (n, t) [?]
(n' , t' ) if either n < n' or n = n' and t < t' .
Remark 2 Note that, for some 1 <= i < e, Iintv might contain only one element of the form (i, a).
The intuition behind this is that the i-th state in the trajectory is transient, the system must pass through this state but it rests there for zero amount of time.
Given a trajectory T = (I, th) and some w-point (n, b) [?]
Iintv , we define the suffix of T starting with (n, b), denoted by T [(n, b)..] = I[(n, b)..], th[(n, b)..]), as follows:  ' 1.
I[(n, b)..] = Si+n-1 , [ai-1 , ai' ] 1<=i<e' with e ' = e - n + 1 and ai' = ai+n-1 for all i with 1 <= i < e ' 2. th[(n, b)..] = (thi' )1<=i<e' with thi' (t, x) = thi+n-1 (t, x) for all i with 1 <= i < e ' .
In the same settings, we may define the prefix of T upto (n, b), denoted by T [0..(n, b)] = I[0..(n, b)], th[0..(n, b)]), as follows:  ' 1.
I[0..(n, b)] = Si , [ai-1 , ai' ] 1<=i<n+1 with ai' = ai for i < n, and an' = b.
2. th[0..(n, b)] = (thi' )1<=i<=n is defined by thi' (t, x) = thi (t, x) for all 1 <= i <= n, t [?]
[0, ai' ].
Another useful operation is resetting some clock z at some w-point (k, b): given a trajectory T = (I, th) and some w-point (k, b) [?]
Iintv , the trajectory T [z := 0 at (k, b)] = (I ' , th' ) is defined as follows:  ' * I ' = (Si' , [ai-1 , ai' ])1<=i<e' where e ' = e +1 and Si' = ' Si for i <= k, Si = Si-1 for k < i < e ' and ai' = ai for i < k, ak' = b and ai' = ai-1 for k < i < e ' .
* th' = (thi' )1<=i<e' is defined by   thi (t, z), for i <= k and (i, t) [?]
(k, b) ' thi (t, z) = thi-1 (t, z), if k < i < e ' , [?
]j <= i-1, thj (t, z) = 0   thi-1 (t, z) - thi-1 (b, z), otherwise and, for x 6= z, thi' (t, x) = thi' (t, x) for i <= k and ' (i, t) [?]
(k, b), and thi' (t, x) = thi-1 (t, x) otherwise.
thj = thij )1<=i<ej .
Assume that T2 is stuttering-free.
We say that T2 represents T1 if there exists some surjective increasing function ph : [1..e1 -1] - [1..e2 -1] satisfying the following requirements: 2 .
* For all i < j < e1 , if ph(i) = ph(j) then Si1 = Sj1 = Sph(i)  	 2 * aph(i) = max aj1 | ph(j) = ph(i) .
2 * For all i < e1 and t [?]
[ai-1 , ai ], thph(i) (t, x) = thi1 (t, x).
We also say that two (arbitrary) trajectories T1 , T2 are identical, denoted T1 [?]
T2 , if there exists a third stutteringfree trajectory T3 which represents both T1 and T2 .
Figure 1 shows some trajectory T and T [x := 0 at (2, 2)]: x  A weakly-monotonic semantics of timed automata.
A simple constraint over X is a constraint of the form x [?]
I, where I is an interval with nonnegative integer bounds.
For a simple constraint C and a clock valuation v, we denote as usual v |= C if v satisfies the constraint C.  4 T  3 T [x := 0 at (2, 2) 2  T [x := 0 at (2, 2)  1  1  2  3  4  Time  Figure 1.
Resetting clock x in T at (2,2).
A trajectory is initialized if all the clocks are set to zero at the initial w-point, i.e.for all x [?]
X, a1 (0, x) = 0.
Trajectories and observability.
In this subsection we give the observability relation on trajectories, which represents the essence of the epistemic part of the logic.
This requires the definition of a projection operator on trajectories, which tells what are the clock values and state symbols that are observable by some agent along some trajectory. '
Given a set of clocks X ' [?]
X , a set of states P  [?]
P and a trajectory T = (I, th) where I = Si , [ai-1 , ai ] 1<=i<e and th = thi )1<=i<e , the projection of T defined by (P' , X ' ) is the trajectory T P' ,X ' = (I P' , th X ' ) with I P' = Si [?]
 P' , [ai-1 , ai ] 1<=i<e and th X ' = thi' )1<=i<e where thi' (t, x) = thi (t, x) for all i < e, t [?]
[ai-1 , ai ], and x [?]
X ' .
Our presentation of trajectories has the problem that some behavior can be presented by distinct trajectories: it is what we call the "stuttering" phenomenon.
A trajectory is stuttering-free if either two consecutive intervals in I are labeled with distinct state symbols or if some clock is reset in between the two intervals.
Formally, a trajectory T = (I, th) is stuttering-free if for all i < e-1, if Si 6= Si+1 then there exists x [?]
X with thi+1 (ai , x) = 0 6= thi (ai , x).
Stuttering-free trajectories represent "normal forms" for behaviors of timed automata: consider two trajectories Tj =  j (I j , thj ) (j = 1, 2), where I j = Sij , [ai-1 , aij ] 1<=i<e and j  Definition 2 A timed automaton [2] is a tuple A = (Q, X , P, d, l, Q0 ) where Q is a finite set of locations, X is a finite set of clocks, P is a finite set of state labels, l : Q - 2P is the state-labeling function, Q0 [?]
Q is the set of initial locations, and d is a finite set of tuples called transitions of the form (q, C, X, q ' ), where q, q ' [?]
Q, X [?]
X , and C is a conjunction of simple constraints over X .
Our semantics of timed automata will be given in terms of runs, which are behaviors of timed automata along trajectories.
This is just an extension of the classical notion of a run in a timed automaton, enhanced with the possiblity to have "transient" locations (in which control stays for a zero amount of time) and adapted such that each time point be associated with the current location.
A run in a timed automaton A = (Q, X , S, d, l, Q0 ) is then a pair R = (I, r), where * I is a sequence of pairs of locations and intervals, I = qi , [ai-1 , ai ] 1<=i<e , where e [?]
N [?]
{[?
]}, qi [?]
Q and ai-1 , ai [?]
R>=0 with ai-1 <= ai , and a0 = 0.
* r = (ri )1<=i<e with ri : [ai-1 , ai ] x X - R>=0 .
subject to the following constraints: 1.
For all 1 <= i < e and all t, t' [?]
[ai-1 , ai ], t < t' , and for all x [?]
X , thi (t' , x) = th(t, x) + t' - t. 2.
For all 1 <= i < e - 1 there exists some transition (qi , Ci , Xi , qi+1 ) [?]
d for which ri (ai , *) |= Ci and ri+1 (ai , *) = ri (ai , *)[Xi := 0].
We say that the run R is unbounded if e = [?]
or ae-1 = [?].
At second item of the enumeration above, we say that the transition (qi , Ci , Xi , qi+1 ) is associated with the w-point  (i, ai ) - and also associated with (i + 1, ai ), both being w-points in Iintv for the run R. Similarly to trajectories, prefix and postfix operators can be defined on runs.
Hence, given a run R = (I, r) and some w-point (n, b) [?]
Iintv , the prefix of R upto (n, t) is denoted R[0..(n, b)] = I[0..(n, b)], r[0..(n, b)]) and the suffix of R starting with (n, t) is denoted R[(n, b)..] = I[(n, b)..], r[(n, b)..]).
Reseting some clock along a run, R[z := 0 at (k, b)], can also be defined as for trajectories.
However the result need not always be a run: it is a run only when there exists a loop (qk , C, X, qk ) which can be associated with the wpoint (k, b) in the result R[z := 0 at (k, b)].
 Given a run R = (I, r) with I = qi , [ai-1 , ai ] 1<=i<e , the trajectory generated by R is the  trajectory traj(R) = (I ' , r) where I = l(qi ), [ai-1 , ai ] 1<=i<e .
 A run R = (I, r) with I = qi , [ai-1 , ai ] 1<=i<e and r = (ri )1<=i<e is accepting if the first location q0 is an initial location and the initial clock valuation is a1 (0, x) = 0 for all x [?]
X .
A trajectory T is accepted if it is generated by an accepting run.
(Note that in our timed automata, all locations are "accepting".)
3  TCTLK defined  The logic we investigate here, called the Timed Computational Tree Logic with knowledge operators and with synchronous and perfect recall semantics, denoted in the following as TCTLK, has the following syntax: ph ::= p | C | ph [?]
ph | !ph | ph AU ph | ph E U ph | z in ph | KA ph where p [?]
P, the set of atomic propositions, C is a simple constraint over the set of clocks X , y is some clock in X , and A [?]
Ag a finite set of agents.
The operator z in ph is called the freeze operator.
CTLK is the logic defined by formulas not containing the freeze operator.
The semantics of TCTLK is given in terms of runs in a multi-agent timed system, which is a timed automaton endowed with some partial observability relations, one for each agent A in a finite set of agents Ag.
Each partial observability relation models what is observable by some agent A and is induced by a subset of symbols PA [?]
P and a subset of clocks XA [?]
X .
Definition 3 A timed system with agents in Ag is a tuple M = (A, Z, (PA )A[?
]Ag , (XA )A[?
]Ag ) where A is a timed automaton A = (Q, X , P, d, l, Q0 ), Z [?]
X is a subset of clocks (called freeze clocks) and for all A [?]
Ag, PA [?]
P, XA [?]
X .
It is also assumed that A contains, for each location q [?]
Q and each clock z [?]
Z, a loop (q, true, {z}, q).
Remark 3 Note that the last assumption in Definition 3 implies that for any run R in A and any w-point (k, b) in the run, R[z := 0 at (k, b)] is also a run in A.
This assumption is related with the interpretation of z in ph, requiring the freezed clock to be reset.
The assumption does not represent a strong restriction: we may consider that we are given a timed system M without the clocks Z, and then we enhance M by appending clocks from Z, such that the freeze quantifiers be interpretable.
For each agent A [?]
Ag, the observability relation for A is the following: given two runs R1 and R2 in A, and some w-point (k, b) occuring in both, we say that R1 and R2 cannot be distinguished by A upto (k, b) if traj(R1 )[0..(k, b)] P ,X [?]
traj(R2 )[0..(k, b)] P ,X .
A A A A The semantics of TCTLK formulas is given in terms of tuples (M, R, k, b) consisting of an n-agent system M, an unbounded run R = (I, r) in the underlying timed automaton of M and some w-point (k, b) [?]
Iintv .
The rules defining the semantics of TCTLK formulas are the following: * (M, R, k, b) |= p if p [?]
l(q0 ), q0 being the first location in R. * (M, R, k, b) |= C if v |= C where v is the clock valuation at (k, b) in R, v = rk (b, *) for R = (I, r).
* (M, R, k, b) |= ph1 [?]
ph2 if (M, R, k, b) |= ph1 and (M, R, k, b) |= ph2 .
* (M, R, k, b) |= !ph if (M, R, k, b) 6|= ph.
* (M, R, k, b) |= 0 at (k, b)], k, b) |= ph.
z in ph  if  (M, R[z  :=  * (M, R, k, b) |= KA ph if for any run R' and any w-point (k ' , b) in R' with traj(R' )[0..(k ' , b)] P ,X [?]
traj(R)[0..(k, b)] P ,X A A A A we have that (M, R' , k ' , b) |= ph.
* (M, R, k, b) |= ph1 E U ph2 if there exists some run R' = (I ', r' ) for which R[0..(k, b)] = R' [0..(k, b)] ' and there exists a w-point (k ',b ' ) [?]
Iintv with (k ',b ' )  ' ' ' ' (k, b), (M, R , k , b ) |= ph2 and for all (k '' , b '' ) [?]
Iintv '' '' ' ' '' '' for which (k , b ) [?]
(k , b ), (k , b )  (k, b), we have that (M, R' , k '' , b '' ) |= ph1 .
* (M, R, k, b) |= ph1 AU ph2 if for any run R' = (I ', r' ) for which R[0..(k, b)] = R' [0..(k, b)], there exists ' a w-point (k ' , b ' ) [?]
Iintv with (k ', b ' )  (k, b), ' ' ' ' (M, R , k , b ) |= ph2 and for all (k '' , b '' ) [?]
Iintv for '' '' ' ' '' '' which (k , b ) [?]
(k , b ), (k , b )  (k, b) we have that (M, R' , k '' , b '' ) |= ph1 .
The usual abbreviations apply here too, in particular E 3 ph = true E U ph A3 ph = true AU ph PA ph = !KA !ph  A2 ph = !
E 3 !ph E 2 ph = !
A3 !ph  An example of a TCTLK formula is PA ph[?
]!ph, with ph = z in E 3(z <= 3 [?]
danger).
This might model a situation in which some sensor A might provoke a false alarm, as its observable state would indicate that it's possible that in less than 3 time units the system goes into a dangerous state, whereas this situation cannot occur in the current state.
4  Undecidability of model-checking  In this section we show that the model-checking problem is undecidable for CTLK with the continuous-time semantics.
For a given timed n-agent system M and a formula ph, we denote M |= ph if for any accepting run R in the underlying automaton, we have that (M, R, 0, 0) |= ph.
Definition 4 The model-checking problem for TCTLK (CTLK) over continuous time domains is the following: given a timed n-agent system M and a TCTLK (CTLK) formula ph, does the property M |= ph hold?
Theorem 1 The model-checking problem for CTLK over continuous time domains is undecidable.
Proof: We show that if some 2-counter machine has an infinite computation, then that computation can be simulated with an instance of the model-checking problem.
(We utilize here 2-counter machines as programs utilizing only incrementing, and decrementing instructions for one of the two counters, or tests for zero.)
Each configuration of the 2-counter program will be encoded into a unit-time interval of an accepted trajectory, with the value of each counter being encoded as the number of positions within the interval where some specific atomic proposition holds.
It is assumed that the respective atomic propositions holds only at "sparse" points within any interval.
More specifically, each configuration (l, ct1 , ct2 ) of the 2-counter program, where l is the label of the current instruction, is coded as a unit-length part of a trajectory in which l holds as an atomic proposition.
Also, during this part of the trajectory, there are exactly ct1 point intervals where a new atomic proposition pct1 holds, and exactly ct2 point intervals where pct2 holds.
We need to keep track, within each such unit interval, of the last instruction executed before reaching program label l. This is the role of a set of new propositional symbols pinstr for all the eight type of instructions that may occur: p{ct1 ++} , p{ct2 ++} , p{ct1 --} , p{ct2 --} , p{if ct1 =0} , p{if ct1 6=0} , p{if ct2 =0} , and p{if ct2 6=0} .
Note that we also need to recall that the last step in the program was the negative branch of a test instruction - this is the role of the label p{if ct1 6=0} .
Then each transition from a configuration (l, ct1 , ct2 ) to another configuration (l' , ct'1 , ct'2 ) is encoded as the concatenation of the trajectory which encodes the first config-  uration with the trajectory which encodes the second configuration.
Moreover, the i-th position where pct1 holds in the part of the trajectory corresponding to l is separated by exactly 1 time unit from the i-th position where pct1 holds in the part of the trajectory corresponding to l' .
This unit separation property applies to instructions which do not modify counter ct1 .
It does not apply to the last position when the transition from (l, ct1 , ct2 ) to (l' , ct'1 , ct'2 ) is the effect of the instruction l : ct1++.
In this case, exactly one time unit before the last position of pct1 in the trajectory corresponding to l' we must have a position where pct1 is false.
A similar property holds when the instruction is l : ct1 - -.
In that case, exactly one time unit after the last position of pct1 in the interval corresponding to l we must have a position where pct1 is false.
The above coding is done partly in the timed automaton model, partly in the formula that is checked against the model.
The timed automaton simulates, along some trajectories, the control flow in the 2-counter program, and along some other trajectories, the positions where pct1 and pct2 occur are copied from each unit interval to another.
The use of the temporal and epistemic operators allows us to iteratively construct an accepting trajectory which simulates, in the sense described in the previous paragraphs, the halting computation of the 2-counter program, if it exists.
The first task of the timed automaton is to simulate the control flow, that is, the possible successions of states that may occur if one ignores counter values.
Namely, the timed automaton stays for one time unit in states labeled with some l, then shifts to some other states labeled l' if and only if, in the 2-counter program the control may flow from instruction l to instruction l' .
In the case of test instructions like l : if ct1 = 0 then goto l' , the timed automaton simulates both the positive and the negative branch as follows: * If, during the unit interval along which l holds there is no occurrence of pct1 , then the control goes (after one time unit) to a state labeled l' .
* Otherwise, the control goes to a state labeled l'' , which is the label of the instruction following l in the 2counter program.
It should be noted that there may be several states labeled l: some might be labeled with pct1 , and some not, and similarly with all the other propositional symbols that are used throughout the proof.
The simulation of control flow does not care about counter values: the mechanism used for "copying" the counter value from some unit interval to the next is different.
It involves some branches in the timed automaton which copy just a single occurrence of pct1 within some interval to the next interval, at exactly one time unit distance.
A similar trick needs to be used to specify that some position where pct2 is false occurs exactly one time unit after  a position where pct2 was false.
This requires the use of ---, which, whenever another new propositional symbol - p!ct 2 occurring, signals that exactly one time unit before we had pct2 false.
The previous tricks can be used for copying only one occurrence of a pct2 , resp only one point where pct2 is absent from the location label.
How to copy all the occurrences of pct2 within an interval?
It is here that the TCTLK formula comes into play, and especially the epistemic operators.
We will consider an agent A that is able to observe the truth value for pct2 and for all propositional symbols of the form l or pinstr , with l being a label of some instruction in the 2-counter program, and instr being such an instruction.
On -- or the other hand, A cannot observe the truth value for - pct 2 - - - - p!ct2 .
We also assume that A cannot observe the value of the clock z.
Suppose we have a trajectory T and a w-point (i, b) in T such that T [0..(i, b)] simulates the behavior of the 2-counter program upto the moment when it just finished instruction l1 .
We would like to say that, starting from (i + 1, b) and during the next unit interval, the positions where pct2 holds are the translations by one time unit of the positions where pct2 held in the previous unit interval.
The following formula does this:  --)[?]
E 2 l2 [?]
p{ct1 ++} [?]
pct2 - PA (- pct 2  l [?
]p [?]
!p - P (- (1) p---) 2  {ct1 ++}  ct2  A  !ct2  This formula says that there exists a trajectory (in the timed automaton) that prolonges T starting with (i, b) and such that at each position (j, g) where pct2 holds and we are at label l2 and the last instruction did not modify ct2 , then there must exist a trajectory T ' which A cannot distinguish -- occurs at (j, g).
from T , and in which - pct 2 -- Recall then that, by construction, the occurrence of - pct 2 at (j, g) requires that, exactly one time unit before, pct2 must have been true in T ' .
And, on the other hand, T ' and T must be indistinguishable by A, hence all positions before (i, b) where pct2 holds in T ' must also be positions in T where pct2 holds.
This is exactly what is needed to conclude that for each point (j, g) where pct2 holds in T , during unit interval starting at (i, b), then (j, g) preceded, at one time unit, by a position where pct2 holds.
The second part of the formula 1 specifies that all positions where pct2 is false are translations of positions where pct2 are false in the unit interval right before (i, b).
First, consider the instruction {ct1 + +}, with the last position where pct1 holds in the unit interval labeled l2 not being a one time unit translation of the last position where pct1 held in the previous unit interval.
The idea is to have a new propositional symbol plast ct1 , visible for A, which signals that we have reached the last pct1 within the interval --- would be true, where l2 holds.
Also, at the same time - p!ct 1 signalling that exactly one time unit before pct1 was false.
The formula which ensures that the last occurrence of pct1 is "new" and all the other occurrences are copied is then  ---  E 2 l2 [?]
p{ct1 ++} [?]
pct1 [?]
!plast ct1 - PA (pct1 ) [?]
 (2) p---) l [?
]p [?]
(plast [?]
!p ) - P (- 2  {ct1 ++}  ct1  ct1  A  !ct1  Then, for the instruction {ct1 --}, with the last position where pct1 held in the previous unit interval being no longer copied in the interval where l2 holds, we utilize here symbol plast ct1 that we have seen before and another new propo--- sitional symbol, plast ct1 , not visible to A.
The significance of --- last pct1 is the same as above, while plast ct1 signals that exactly one time unit before we had a position where pct1 held.
The formula which ensures that the last occurrence of pct1 in the previous unit interval is "lost" and all the other occurrences are copied is then the following  -last --  E 2 l2 [?]
p{ct1 --} [?]
(plast ct1 [?]
pct1 ) - PA (pct1 ) [?]
 - P (- p---) l [?
]p [?
]p (3) 2  {ct1 --}  !ct1  A  !ct1  cti the subformula inside E 2 Then, if we denote phl,keep 1 in Formula 1, corresponding to instructions that keep uncti the subforchanged the value of counter cti , and phl,inc 2 mula inside E 2 in Formula 2 corresponding to instructions cti for Formula that increment cti , and similarly for phl,dec 3 3, the actual formula that we will check against the timed automaton A is then ^ ^ ^ cti  cti cti [?]
phl,dec [?]
phl,incr Ph = E 2 !end[?]
phl,keep 3 2 1 cti is taken for all instrucwhere the conjunction for phl,keep 1 tions labeled l which are preceded by an instruction not modifying counter cti , and similarly for all the other conjunctions, and also "end" is the "fictitious" label at the end of the 2-counter program.
Then Ph is satisfied in the timed automaton constructed as above if and only if the given 2-counter machine does not have a halting computation.
Note that our formula utilizes a single agent.
Moreover, the essential ingredient for undecidability is that agent A cannot observe the value for the clock z - observing or not the other two clocks does not change the proof.
5  Model-checking with full observability of clock values  In this section we show how the classical modelchecking algorithm for TCTL can be adapted to TCTLK when all the agents can observe all clock values.
By full observability of clock values we mean that formulas of TCTLK are interpreted over multi-agent systems M = (A, Z, (PA )A[?
]Ag , (XA )A[?
]Ag ) in which XA = X for all  A [?]
Ag.
In the sequel M is the largest constraint occurring in the given timed automaton.
Given a timed automaton A = (Q, X , P, d, l, Q0 ), an X -region in A is a convex set of points r [?]
Rn>=0 (n = card (X )) characterized by a clock constraint of the form ^ ^ ^   x [?]
]M, [?
][ x-y [?]
Ixy [?]
(x [?]
Ix ) [?]
x[?
]Y  x,y[?
]Y  x[?
]X \Y  where Ix are non-negative integer-bound intervals whose upper bound are at most M , and Ixy are integer-bound intervals whose both upper and lower bounds are in between -M and M .
Also Y [?]
X is some set of clocks.
The set of regions in A is denoted RegA .
The region automaton forA is the tuple RA 	 = Qx RegA , dR , S0 where S0 = (q0 , 0X ) | q0 [?]
Q0 with 0 being the region where all clocks are zero, and  dR = (q, r) - (q, r' ) | r 6= r' and [?
]v [?]
r, v ' [?]
r' for which [?
]t [?]
R>=0 with v ' = v + t and 	 [?
]t' < t, v + t' [?]
r [?]
r' (time passage)   [?]
(q, r) - (q ' , r' ) | [?
]v [?]
r, v ' [?]
r' , (q, C, X, q ' ) [?]
d 	 for which v |= C and v ' = v[X := 0] Here dR defines immediate transitions between states in the region automaton.
A run in RA is then simply a sequence of transitions in dR agreeing on intermediary states.
A run R = (I, r) in A is simulated by a run s = (qi-1 , ri-1 ) - (qi , ri ) 1<=i<=n in RA if the following properties hold: * All the w-points in Iintv fall into some state of s, i.e.
for any (k, b) [?]
Iintv there exists some i <= n such that rk (b, *) [?]
ri and the k-th state in I is qi .
* If the w-point (k, b) falls into state (qi-1 , ri-1 ) and the i-transition in s is a time-passage transition, then there exists some t [?]
R>=0 with (k, b + t) [?]
Iintv which falls into state (qi-1 , ri ) (note that in this case qi-1 = qi ).
* All discrete transitions in s correspond to discrete transitions in R: for any interval [ai-1 , ai ] from I, if (i - 1, ai ) falls into state (qj , rj ) then (i, ai ) falls into state (qj+1 , rj+1 ) and the transition associated with (i, ai ) is the same as the transition associated with the (qj , rj ) - (qj+1 , rj+1 ).
Though the region automaton does not represent exactly all runs in A, it has the following important property: Proposition 1 Any run in A is associated with a run in RA , and the reverse holds too.
Theorem 2 The model-checking problem for TCTLK with full observability of clock values is decidable.
Proof: The proof is a modification of the usual proof for TCTL model-checking by inserting a procedure for treating the case of subformulas of the type KA ps.
Recall that TCTL model-checking works by iteratively labeling states in the region automaton with subformulas of the given formula ph.
Here, for treating knowledge subformulas we need also to split some states according to the classes of trajectories along which the respective states can be reached, similar to the discrete-time case [5].
So assume we are given a timed system M = (A, Z, (PA )A[?
]Ag , (XA )A[?
]Ag ) and a formula ph that we want to model-check on M. The technique is to transform the region automaton RA into another region automaton R' which embodies the trajectories of A and in which states may carry, besides region labels, additionnal labels like new propositional symbols representing subformulas of ph or pointers to states in RA which are "identically observable" as the current state.
Labeling some state (q, r) with a new propositional symbol pps signals the fact that on any run R which "passes through" (q, r), at each moment of this pass the subformula ps holds.
That is, (*) For R = (I, r) and (i, t) [?]
Iintv with ri (t, *) [?]
r and with the i-th state in I being q, we have that (M, R, i, t) |= ps.
Due to space limitations, we only recall the construction for z in ps: we label a state (q, r) with pz in ps if and only if the state (q, r[z := 0]) is labeled with pps .
The last construction, for ph = KA ps, no longer labels existing states, but needs to split the states of the given model in order to be able to identify states that have indistinguishable history, as seen by agent A.
So, assume we start with a region automaton R = Q x  RegA , dR , S0 where Q = QxS, S being the extra labeling information appended to each state.
We also consider that the labeling function l in A is extended to the states of the region automaton, so l(q, s, r) = l(q) [?]
P. ' We then construct  the following region automaton R = ' Q x RegA , dR , S0 as follows:  	 Q = (q, Q' ) [?]
Qx2Q | l(q)[?
]PA = l(q ' )[?
]PA [?
]q ' [?]
Q'  	 S0 = (q0 , Q'0 , 0) | (q0 , 0) [?]
S0 	  ' dR = (q1 , Q'1 , r1 ) - (q2 , Q'2 , r2 ) | (q1 , r1 ) - (q2 , r2 ) [?]
dR  where Q'2 = q2' [?]
Q 	| l(q2' ) [?]
PA = l(q2 ) [?]
PA and (q1' , r1 ) - (q2' , r2 ) [?]
dR .
Remark 4 Note that the projection of each state in R' on its first and third component gives a bijection between runs in R and runs in R' .
Hence, any run in the initial timed automaton is simulated by some run in R' and vice-versa.
This property of projection also ensures the fact that the state labeling with the new propositional variables pkh remains correct: for all runs in the given timed automaton and all w-points (k, b) that fall in the state (q, Q' , r), if (q, Q' , r) is labeled with pkh then (M, R, k, b) |= kh.
Then we label each state (q, Q' , r) [?]
QxRegA with KA pps if and only if all the states in Q' are labeled with pps .
(Note that q [?]
Q' by construction.)
The above remark ensures that for any run R in A and any w-point (k, b) within R that fall in the state (q, Q' , r) we must have (M, R, k, b) |= KA ps.
The final observation is that, though the construction of R' modifies the region automaton by modifying the locations component in each state, it can still be combined with the previous procedures for treating temporal operators.
These procedures can be applied to R' since it is associated with the same trajectories as R. This is again a consequence of the Remark 3.
In fact, one may even think of the procedure for obtaining R' as a location-splitting procedure in the given timed automaton.
To end the proof, we only need to check, at the end of the procedure, whether all the initial states in the resulting region automaton are labeled with pph .
The complexity of the above construction is nonelementary in the size of the given model.
This complexity comes from the fact that each epistemic operator induces an exponential blowup in the size of the model.
Note also that the main aspect allowing the modelchecking of TCTLK with full clock observability to be decidable is that we do not need to do subset construction on clock regions.
6  Final remarks and conclusions  We have given an epistemic extension of TCTL, with a synchronous and perfect recall semantics in which agents may observe clock values.
The model-checking problem is undecidable for the new logic, but becomes decidable if any agent may observe all clocks.
The decidability result still holds if we modify the semantics to a more realistic situation with "bounded asynchronous" observability.
This would build on the idea that agents are not able to observe the exact values of clocks, but only whether these values fall in the same region, i.e.
satisfy the same clock constraints.
If one properly defines the observability relation in this case (which would imply taking into account observability of intermediary clock values), then Theorem 2 would have the same proof.
Acknowledgments The author is indebted to Dimitar Guelev for his suggestions for improving the presentation and for his careful reading of the manuscript.
References [1] R. Alur, C. Courcoubetis, and D. L. Dill.
Model-checking in dense real-time.
Inf.
Comput., 104(1):2-34, 1993.
[2] R. Alur and D. Dill.
A theory of timed automata.
Theoretical Computer Science, 126:183-235, 1994.
[3] C. Baier and J. P. Katoen.
Principles of Model Checking.
The MIT Press, 2008.
[4] J. M. Davoren, V. Coulthard, N. Markey, and Th.
Moor.
Nondeterministic temporal logics for general flow systems.
In Proceedings of HSCC 2004, volume 2993 of Lecture Notes in Computer Science, pages 280-295.
Springer, 2004.
[5] C. Dima.
Revisiting satisfiability and model-checking for CTLK with synchrony and perfect recall.
In Proceedings of CLIMA IX, Lecture Notes in Artificial Intelligence, 2008. to appear.
[6] C. Dima.
Positive and negative results on the decidability of the model-checking problem for an epistemic extension of Timed CTL.
Technical report, LACL, Universite Paris 12, 2009.
[7] P. Gammie and R. van der Meyden.
MCK: Model checking the logic of knowledge.
In Proceedings of CAV'04, volume 3114 of Lecture Notes in Computer Science, pages 479-483.
Springer, 2004.
[8] J.Y.
Halpern and M.Y.
Vardi.
The complexity of reasoning about knowledge and time: Extended abstract.
In Proceedings of STOC'86, pages 304-315, 1986.
[9] J.Y.
Halpern and M.Y.
Vardi.
The complexity of reasoning about knowledge and time.
I.
Lower bounds.
Journal of Computer System Sciences, 38(1):195-237, 1989.
[10] T. A. Henzinger and V. S. Prabhu.
Timed alternating-time temporal logic.
In Proceedings of FORMATS'06, volume 4202 of Lecture Notes in Computer Science, pages 1-17.
Springer, 2006.
[11] M. Kacprzak, A. Lomuscio, A. Niewiadomski, W. Penczek, F. Raimondi, and M. Szreter.
Comparing BDD and SAT based techniques for model checking Chaum's Dining Cryptographers Protocol.
Fundamenta Informaticae, 72(1-3):215-234, 2006.
[12] A. Lomuscio and F. Raimondi.
The complexity of model checking concurrent programs against CTLK specifications.
In Proceedings of DALT'06, volume 4327 of Lecture Notes in Computer Science, pages 29-42.
Springer, 2006.
[13] A. Lomuscio and F. Raimondi.
MCMAS: A model checker for multiagent systems.
In Proceedings of TACAS'06, volume 3920 of Lecture Notes in Computer Science, pages 450-454.
Springer, 2006.
[14] J. Ouaknine and J. Worrell.
On metric temporal logic and faulty turing machines.
In Proceedings of FoSSaCS'06, volume 3921 of Lecture Notes in Computer Science, pages 217-230.
Springer, 2006.
[15] P. K. Pandya and Dang Van Hung.
Duration calculus of weakly monotonic time.
In Proceedings of FTRTFT'98, volume 1486 of Lecture Notes in Computer Science, pages 55-64.
Springer, 1998.
[16] F. Raimondi and A. Lomuscio.
Automatic verification of multi-agent systems by model checking via ordered binary decision diagrams.
Journal of Applied Logic, 5(2):235-251, 2005.
[17] R. van der Meyden and N.V. Shilov.
Model checking knowledge and time in systems with perfect recall (extended abstract).
In Proceedings of FSTTCS'99, volume 1738 of Lecture Notes in Computer Science, pages 432-445, 1999.
[18] R. van der Meyden and K. Su.
Symbolic model checking the knowledge of the dining cryptographers.
In Proceedings of CSFW-17, pages 280-.
IEEE Computer Society, 2004.
[19] B. Wozna and A. Lomuscio.
A logic for knowledge, correctness, and real time.
In Proceedings of CLIMA V, volume 3487 of Lecture Notes in Computer Science, pages 1-15.
Springer, 2005.