Using Temporal Logic to Control Search in a Forward Chaining Planner Fahiem Bacchus Dept.
Of Computer Science University Of Waterloo Waterloo, Ontario Canada, N2L 3G1 fbacchus@logo.uwaterloo.ca Abstract: Over the years increasingly sophisticated planning algorithms have been developed.
These have made for more efficient planners, but unfortunately these planners still suffer from combinatorial explosion.
Indeed, recent theoretical results demonstrate that such an explosion is inevitable.
It has long been acknowledged that domain independent planners need domain dependent information to help them plan effectively.
In this work we describe how natural domain information, of a "strategic" nature, can be expressed in a temporal logic, and then utilized to effectively control a forwardchaining planner.
There are numerous advantages to our approach, including a declarative semantics for the search control knowledge; a high degree of modularity (the more search control knowledge utilized the more efficient search becomes); and an independence of this knowledge from the details of the planning algorithm.
We have implemented our ideas in the TLP LAN system, and have been able to demonstrate its remarkable effectiveness in a wide range of planning domains.
1  Introduction  Planners generally employ search to find plans, and planning research has identified a number of different spaces in which search can be performed.
Of these, three of the most common are (1) the forward-chaining search space, (2) the backwardchaining search space, and (3) the space of partially ordered plans.
The forward-chaining space is generated by applying all applicable actions to every state starting with the initial state; the backward-chaining space by regressing the goal conditions back through actions that achieve at least one of the subgoals; and the space of partially ordered plans by applying a collection of plan modification operators to an initial "dummy" plan.
Planners that explore the backward-chaining space or the space of partially ordered plans have an advantage over those that explore the forward-chaining space in that the latter spaces are generated in a "goal directed" manner.
Hence, such This research was supported by the Canadian Government through their IRIS project and NSERC programs.
Fahiem Bacchus is currently on sabbatical leave from the University of Waterloo, Canada.
Froduald Kabanza Dept.
De Math Et Informatique Universite De Sherbrooke Sherbrooke, Quebec Canada, J1K 2R1 kabanza@dmi.usherb.ca planners are intrinsically goal directed: they need never consider actions that are not syntactically relevant to the goal because the spaces they explore do not include such actions.
Partial-order planners have an additional advantage over simple backward chaining planners in that the objects in their search space are partially ordered plans.
This allows these planners to delay ordering actions until they detect an interaction between them.
Linear backward or forward-chaining planners, on the other hand, might be forced into backtracking because they have prematurely committed to an ordering between the actions.
However, both backward-chaining and partial-order planners search in spaces in which knowledge of the state of the world is far less complete than in the forward-chaining space.
For example, even if a backward-chaining planner starts with a completely described initial world and actions that preserve the completeness of this description, it will still have only incomplete knowledge of the world state at the various points of its search space.
Partial order planners also suffer from this problem.
The points of their search space are incomplete partially ordered plans, and at the various stages of an incomplete plan we have only limited knowledge of the state of the world.
On the other hand, the points in the forward-chaining space are world descriptions.
Such descriptions provide a lot of information about the world state, even if the description is incomplete.
As we will demonstrate in this paper, such knowledge can be effectively utilized to control search in this space.
The choice between the various search spaces has been the subject of much recent inquiry [BW94; MDBP92], with current consensus seemingly converging on the space of partially ordered plans,1 mainly because of its goal-directness and least commitment attitude towards action ordering.
However, these studies have only investigated simple heuristic search over these spaces, where domain independent heuristics, like counting the number of unsatisfied sub-goals, are utilized.
Domain independent heuristics cannot take advantage of structural features that might be present in a particular domain.
Theoretical work [ENS92; Sel94] indicates that for the traditional S TRIPS actions used by almost all current planners, 1  Although, see [VB94] for an refreshing counterpoint.
finding a plan is, in general, intractable.
This means that no domain independent planning algorithm can succeed except in very simple (and probably artificial) domains.
More importantly, however, is that there may be many domains where it is feasible to find plans, but where domain structure must be exploited to do so.
This can be verified empirically; e.g., the partial order planner implemented by Soderland et al.
[SBW90] cannot effectively generate plans for reconfiguring more than 5 blocks in the blocks world using domain independent heuristic search.
Nevertheless, the blocks world does have sufficient structure to make it easy to generate good plans in this domain [GN92].
One way of exploiting domain structure during planning is to use domain information to control search.
Hence, a more practical evaluation of the relative merit of various planning algorithms and search spaces would also take into account how easy it is to exploit domain knowledge to control search in that space.
The idea of search control is not new, e.g., it is a prominent part of the P RODIGY planing system [CBE+ 92].
Our work, however, makes a number of new contributions to the notion of search control.
In particular, we demonstrate how search control information can be expressed in a first-order temporal logic, and we develop a method for utilizing this information to control search during planning.
By using a logic we gain the advantage of providing a formal semantics for the search control information.
Furthermore, we would claim that this semantics is quite natural and intuitive.
This differentiates our mechanism for search control from classical state-based heuristics and from the control rules employed by the P RODIGY system.
P RODIGY control rules are implemented as a rule-based system.
Various rules are activated dependent on the properties of the node in the search space that is currently being expanded.
These rules are activated in a particular order and have various effects.
This means that any attempt to give a semantics to these rules would require an operational semantics that makes reference to way in which the rules are utilized.
By using the forward-chaining search space we end up searching in the space of world descriptions.
This allows us to utilize search control knowledge that only makes reference to the properties of these worlds, i.e., to properties of the domain.
Thus the search control knowledge used can be considered to be no different from the description of the domain actions: it is part of our knowledge of the dynamics of the domain.
In contrast, P RODIGY control rules include things like binding selection rules that guide the planner in deciding how to instantiate actions.
Such rules have to do with particular operations of the P RODIGY planning algorithm, and to compose such rules the user must not only possess domain knowledge but also knowledge of the planning algorithm.
Finally, the language in which we express search control knowledge is richer than previous approaches.
Hence, it can capture much more complex control knowledge.
In particular, the control strategies are not restricted to considering only the current state, as are P RODIGY control rules and statebased heuristics.
They can, e.g., consider past states and pass  information forward into future states.
All of these features make the control information employed by our system not only easier to express and understand, but also more effective, sometimes amazingly effective, as we will demonstrate in Section 4.
Using the forward-chaining search space is not, of course, a panacea.
It does, however, seem to better support effective search control.
We have already mentioned two reasons for this: we have access to more information about the world state in this space, and it allows us to express search control information that is independent of the planning algorithm.
We have also found a third advantage during our experiments.
In many domains, humans seem to possess strategies for achieving various kinds of goals.
Such strategies seem to be most often expressed in a "forward-direction".
This makes their use in controlling forward-chaining search straightforward, but exploiting them in the other search spaces not always so.
Due to its support of effective search control, we have found that forward-chaining can in many domains yield planners that are more effective than those based on partial order planning or backwards-chaining regression.
The forward-chaining search space still suffers from the problem that it is not goal directed, and in many of our test domains we have found that some of the search control information we added was designed to recapture goal-directedness.
Much of this kind of search control knowledge can be automatically inferred from the operator descriptions, using ideas like those of [Etz93].
Inferring and learning search control in the form we utilize is an area of research we are currently pursuing.
One of the key advantages of using a logic to express search control knowledge is that it opens the door to reasoning with this knowledge to, e.g., generate further control knowledge or to verify and prove properties of the search control knowledge.
But again this avenue is a topic for future research.
In the rest of the paper we will first describe the temporal logic we use to express domain strategies.
We then describe how knowledge expressed in this language can be used to control forward chaining search.
We have implemented our approach in a system we call TLP LAN, and we describe some of our empirical results with this system next.
We close with a summary of our contributions and a description of some of the extensions to our approach we are currently working on.
2 First-order Linear Temporal Logic We use as our language for expressing strategic knowledge a first-order version of linear temporal logic (LTL) [Eme90].
The language starts with a standard first-order language, L, containing some collection of constant, function, and predicate symbols.
LTL adds to L the following temporal modalities: U (until), 2 (always), 3 (eventually), and (next).
The standard formula formation rules for first-order logic are augmented by the following rules: if f 1 and f2 are formulas then so are f1 U f2 , 2f1 , 3f1 , and f1 .
Note that the first-order and temporal formula formation rules can be applied in any order, so, e.g., quantifiers can scope temporal modalities al-  lowing quantifying into modal contexts.
Our planner works with standard S TRIPS operators and world descriptions, and it takes advantage of the fact that these world descriptions support the efficient testing of various conditions.
In particular, worlds described as lists of positive literals support the efficient evaluation of complex first-order formulas via model-checking [HV91].
Hence, we can express complex conditions as first-order formulas and evaluate their truth in the worlds generated by forward-chaining.
Part of our TLP LAN implementation is a first-order formula evaluator, and TLP LAN allows the user to define predicates by firstorder formulas.
These predicates can in turn be used in temporal control formulas, where they act to detect various conditions in the sequence of worlds explored by the planner.
To ensure that it is computationally effective to evaluate these first-order formulas and at the same time not limit ourselves to finite domains (e.g., we may want to use the integers in our domain axiomatization), we use bounded instead of standard quantification.
In particular, instead of the quantifiers 8x or 9x, we have 8 x: ] and 9 x: ] , where  is an atomic formula2 whose free variables include x.
It is easiest to think about bounded quantifiers semantically: 8 x: ]  for some formula  holds iff  is true for all x such that  (x) holds, and 9 x: ]  holds iff  is true for some x such that  (x) holds.
Computational effectiveness is attained by requiring that in any world the set of satisfying instances of  be finite.
3 The formulas of LTL are interpreted over models of the form M = hs0 fi s1 fi : : :i, i.e., a sequence of states.
Every state si is a model (a first-order interpretation) for the base language L. In addition to the standard rules for the first-order connectives and quantifiers, we have that for a state si in a model M and formulas f1 and f2 :  fi hMfi sii j= f1 U f2 iff there exists j  i such that hMfi sj i j= f2 and for all k, i  k < j we have hMfi sk i j= f1 : f1 is true until f 2 is achieved.
fi hMfi sii j= state.
f1 iff hMfi si+1 i j f1 : f1 is true in the next =  fi hMfi sii j= 3f1 iff there exists j  i such that hMfi sj i j= f1 : f1 is eventually true.
fi hMfi sii j= 2f1 iff for all j  i we have hMfi sj i j= f1 : f1 is always true.
Finally, we say that the model M satisfies a formula f if hMfi s0i j= f .
First-order LTL allows us to express various claims about the sequence of states M. For example, on(Afi B ) asserts that in state s2 we have that A is on B .
Similarly, 2  We also allow to be an atomic formula within the scope of a (described below).
That is, instead of allowing x to range over the entire domain, we only allow it to range over the elements satisfying .
Thus, the underlying domain may be infinite, but any particular quantification over it is finite.
Also we allow formulas of the form 9 x: ] where  is implicitly taken to be TRUE.
GOAL modality 3  2:holding C asserts that we are never in a state where we are holding C , and 2 on Bfi C ) on Bfi C U on Afi B asserts that whenever we enter a state in which B is on C it remains on C until A is on B , i.e., on Bfi C is preserved until we achieve on Afi B .
Quantification allows even greater expressiveness, e.g., 8 x clear x clear x asserts that ev(  )  (  (  )  (  (  (  (  )  (  )))  )  )  :  (  )]  ( )  ery object that is clear in the current state remains clear in the next state.
We are going to use LTL formulas to express search control information (domain strategies).
Search control generally needs to take into account properties of the goal, and we have found a need to make reference to requirements of the goal in our LTL formulas.
To accomplish this we augment the base language L with a goal modality.
In particular, to the base language L we add the following formula formation rule: if f is a formula of L then so is GOAL(f ).
If the agent's goal is expressed by the first order formula , then semantically this modality is a modality of entailment from  and any state constraints.
That is, GOAL (f ) is true iff  ^  j= f , where  are the set of conditions true in every state, i.e., the set of state constraints.
However, testing if GOAL (f ) is true given an arbitrary goal formula  is intractable (in general, it requires theorem proving).
Our implemented planning system TLP LAN allows the goal modality to be used only when goals are sets of positive literals, and it computes goal formulas by assuming that these literals describe a "goal world" using a closed world assumption.
For example, if the goal is the set of literals fon(Afi B ), on(Bfi C )g then these are assumed to be the only positive literals that are true in the goal world, every other atomic formula is false by the closed world assumption.
For example clear(A) is false in the goal world.
Intuitively, it is not a necessary requirement of the goal.
TLP LAN can then use its firstorder formula evaluator over this goal world, so the formula GOAL (9 y:on(Afi y )] ) will also evaluate to true.
If, however, we had as our goal fP (A)g and the state constraint that in all states P (A) ) Q(A), then, in its current implementation, TLP LAN will incorrectly (according to the above semantics) conclude that GOAL (Q(A)) is false.
That is, TLP LAN cannot currently handle state constraints over the goal world.
3 Expressing Search Control Information Any LTL formula specifies a property of a sequence of states: it is satisfied by some sequences and falsified by others.
In planning we are dealing with sequences of executable actions, but to each such sequence there corresponds a sequence of worlds: the worlds we pass through as we execute the actions.
These worlds act as models for the language L. Hence, we can check the truth of an LTL formula given a plan, by checking its truth in the sequence of world visited by that plan using standard model checking techniques developed in the program verification area (see, e.g., [CG87]).4 Hence, if 4 LTL formulas  actually require an infinite sequence of worlds as their model.
In the context of standard planning languages, where a plan consists of a finite sequence of actions, we can terminate every finite sequence of actions with an infinitely replicated "do nothing"  we have a domain strategy for the goal fon(Bfi A)fi on(Cfi B )g like "if we achieve on(Bfi A) then preserve it until on(Cfi B ) is achieved", we could express this information as the LTL formula 2(on(Bfi A) ) on(Bfi A) U on(Cfi B )) and check its truth against candidate plans, rejecting any plans that violate this condition.
What we need is an incremental way of checking our control strategies against the partial plans generated as we search for a correct plan.
If one of our partial plans violates our control strategy we can reject it, thus pruning all of its extensions from the search space.
We have developed a mechanism for doing incremental checking of an LTL formula.
The key to this method is the progression algorithm given in Table 1.
In the algorithm quantified formulas are progressed by progressing all of their instances.
This algorithm is characterized by the following theorem: Theorem 3.1 Let M = hs0 fi s1 fi : : :i be any LTL model.
Then, we have for any LTL formula f , hMfi si i j= f if and only if hMfi si+1i j= f + .
The progression algorithm admits the following implementation strategy, used in TLP LAN.
Every world generated during our search of the forward-chaining space is labeled with an LTL formula f , with the initial world being labeled with a user supplied LTL control formula that expresses a control strategy for this domain.
When we expand a world w we progress its formula f through w using the given algorithm, generating a new formula f + .
This new formula becomes the label of all of w's successor worlds (the worlds generated by applying all applicable actions to w).
If f progresses to FALSE , (i.e., f + is FALSE ), then Theorem 3.1 shows that none of the sequences of worlds emanating from w can satisfy our LTL formula.
Hence, we can mark w as a dead-end in the search space and prune all of its successors.
The complexity of evaluating Clause 2 of the progression algorithm depends on the form of the world descriptions.
It requires us to test an atemporal formula in the current world.
Hence, its complexity depends on two things, the complexity of the atemporal formula and the form of the world description.
If the worlds are incompletely described and represented simply as a first-order formula that characterizes some of its properties, then this clause will require theorem proving to evaluate.
If the world is described as a set of atomic formulas and a collection of horn clauses, and if the formula is quantifier free then evaluating the formula in the world might still be tractable.
The efficiency of this step is important however, as we must use this algorithm at every world expanded during plan search.
In our current implementation of TLP LAN we use worlds that are described as sets of positive literals, and we employ a closed world assumption: every positive literal not in this set is assumed to be false.
In this way we need make no restrictions on the atemporal formulas that can appear in our LTL control formula.
In particular, we can use arbitrary first-order action.
This corresponds to infinitely replicating the final world in the sequence of worlds visited by the plan.
Inputs: An LTL formula f and a world w (generated by forward-chaining).
Output: A new formula f + , also expressed as an LTL formula, representing the progression of f through the world w.  Algorithm Progress(f ,w) 1.
Case 2. f =  2 L (i.e.,  contains no temporal modalities): f + := TRUE if w j= ffi FALSE otherwise.
3 f = f1 ^ f2 : f + := Progress(f1 fi w) ^ Progress(f2 fi w) 4. f = :f1: f + := :Progress(f1 fi w) 5. f = f1 : f + := f1 6. f = f1 U f2 : f + := Progress(f2 fi w) _ (Progress(f1 fi w) ^ f ) 7. f = 3f1: f + := Progress(f1 fi w) _ f 8. f = 2f1 : f + := V Progress(f1 fi w) ^ f 9. f = 8 x: ] f1 : f + := fc:wj=(c)g Progress(f1 (x=c)fi w) W 10. f = 9 x: ] f1 : f + := fc:wj=(c)g Progress(f1 (x=c)fi w) Table 1: The progression algorithm.
formulas in our LTL control.
With worlds described by (assumed to be) complete sets of positive literals, we can employ model-checking instead of theorem proving to determine the truth of these formulas in any world, and thus evaluate clause 2 efficiently.
4 Empirical Results Blocks World.
Our first empirical results come from the blocks world, which we describe using the four operators given in table 2.
If we run our planner with the vacuous search control formula 2TRUE 5 , and exploring candidate plans in a depth-first manner, rejecting plans with state cycles, we obtain the performance given in Figure 1.
Each data point represents the average time required to solve 5 randomly generated blocks world problems (in CPU seconds on a SUN1000), where the initial state and the goal state were independently randomly generated.
The same problems were also run using S NLP, a partial order planner [MR91; SBW90], using domain independent heuristic search.
The graph demonstrates that both of these planners hit a computational wall at or before 6 blocks.6 S NLP failed to solve 4 of the six block problems posed; the times shown on the graph include the time taken by the runs that failed.7 5 This formula is satisfied by every sequence, and hence it provides no pruning of the search space.
6 We can note that with 5 blocks and a holding predicate there are only 866 different configurations of the blocks world.
This number jumps to 7057 when we have 6 blocks, and to 65990 when we have 7 blocks.
7 That is, S NLP exceeded the resource bounds we set (on the number of nodes in the search tree).
Note that by including these times in the data we are making S NLP's performance seem better than it really is: S NLP would have taken strictly more time to solve these problems than the numbers indicate.
The same comment applies to the tests described below.
Operator pickup (x) putdown (x) stack (xfi y) unstack (xfi y)  Preconditions and Deletes ontable(x), clear(x), handempty.
holding(x).
holding(x), clear(y).
on(xfi y), clear(x), handempty.
Adds holding(x).
ontable(x), clear(x), handempty.
on(xfi y), clear(x), handempty.
holding(x), clear(y).
Table 2: Blocks World operators.
400 SNLP TLPlan  Time (CPU sec.)
350 300 250 200 150 100 50 0 0  1  2  3  4  5  6  Number of Blocks  Figure 1: Performance of blind search in the blocks world This shows that domain independent heuristic search does not work well in this domain, even for the sophisticated S NLP algorithm.
Domain independent heuristics have difficult exploiting the special structure of blocks world.
Nevertheless, the blocks world does have a special structure that makes planning in this domain easy [GN92], and it is easy to come up with effective control strategies.
A basic one is that towers in the blocks world can be build from the bottom up.
That is, if we have built a good base we need never disassemble that base to achieve the goal.
We can write a firstorder formula that defines when a block x is a good tower, i.e., a good base that need not be disassembled.
4  goodtower(x) = clear(x) ^ goodtowerbelow(x)  4  goodtowerbelow(x) = (ontable(x) ^ : GOAL (9 y :on(xfi y )] _ holding(x))) _ 9 y:on(xfi y)] :GOAL(ontable(x) _ holding(x)) ^ :GOAL(clear(y)) ^ 8 z :GOAL(on(xfi z ))] z = y ^ 8 z :GOAL(on(zfi y))] z = x ^ goodtowerbelow(y) A block x satisfies the predicate goodtower(x) if it is on top of a tower, i.e., it is clear, and the tower below it does not violate any goal conditions.
The various tests for the violation of a goal condition are given in the definition of goodtowerbelow.
If x is on the table, the goal cannot require that it be on another block y nor can it require that the robot be holding x.
On the other hand, if x is on another block y, then x should not be required to be on the table, nor should the robot be required to hold it, nor should y be required to be clear, any block that is  required to be below x should be y, any block that is required to be on y should be x, and finally the tower below y cannot violate any goal conditions.
Our planner can take this first-order definition of a predicate (rewritten in Lisp syntax) as input.
And we can then use this predicate in an LTL control formula where during the operation of the progression algorithm (Table 1) its first-order definition will be evaluated in the current world for various instantiations of its "parameter" x.
Hence, we can use a strategy of preserving good towers by setting our LTL control formula to  2 8 x clear x (  :  (  )]  goodtower(x) )  goodtowerabove(x))fi  (1)  where the predicate goodtowerabove is defined in a manner that is symmetric to goodtowerbelow.
In any world the formula will prune all successor worlds in which a good tower x is destroyed, either by picking up x or by stacking a new block y on x that results in a violation of a goal condition.
Note also that by our definition of goodtower, a tower will be a good tower if none of its blocks are mentioned in the goal: such a tower of irrelevant blocks cannot violate any goal conditions.
Hence, this control rule also stops the planner from considering actions that unstack towers of irrelevant blocks.
What about towers that are not good towers?
Clearly they violate some goal condition.
Hence, there is no point in stacking more blocks on top of them as eventually we must disassemble these towers.
We can define: badtower(x)  4 clear x  =  (  )  ^ :goodtower(x)  And we can augment our control strategy to prevent growing  bad towers, by using the formula:    2 8 x clear x :  ( )]  goodtower(x) ) goodtowerabove(x) ^ badtower(x) ) (:9 y:on(yfi x)] )  (2)  This control formula stops the placement of additional blocks onto a bad tower.
With this control formula only blocks on top of bad towers can be picked up.
This is what we want, as bad towers must be disassembled.
However, a single block on the table that is not intended to be on the table is also a bad tower, and there is no point in picking up such a block unless its final position is ready.
Adding this insight we arrive at our final control strategy for the blocks world:    2 8 x clear x :  ( )]  goodtower(x) ) goodtowerabove(x) ^ ;badtower(x) ) (:9 y:on(yfi x)] ) ^ ontable(x)  ^ 9 y:GOAL(on(xfi y))]:goodtower(y) ) (:holding(x))  (3)  The performance of our planner with these three different control formulas is shown in Figure 2.
As in Figure 1 each data point represents the average time taken to solve 5 randomly generated blocks world problems.
This figure also shows the performance of the P RODIGY planner on these problems.
This planner, like TLP LAN, was run with a collection of hand written search control rules.
In this domain our method proved to be more effective than that of P RODIGY.
In fact, it is not difficult to show that the final control rule yields an O(n2) blocks world planner (where n is the number of blocks in the world).
In particular, the planner can find a near optimal plan (at most twice the length of the optimal) using depth-first search without ever having to backtrack.
Furthermore, there is always an optimal plan admitted by this control formula.
Hence, if we employ breadth-first search our planner will find an optimal plan.
However, finding an optimal plan is known to be NP-hard [GN92].
P RODIGY employed 11 different control rules some of which have similar intuitive content to our control formulas, but with others that required an understanding the P RODIGY planning algorithm.
We would claim that our final control formula is easily understood by anyone familiar with the blocks world.
P RODIGY does end-means analysis, so at every node in its search space it has available a world description.
It would be possible to use our control formulas on this world description.
However, most of the search performed by P RODIGY is a goal regressive search to find an action applicable to the current world.
It is this part of the search that seems to be hard to control.
Bounded Blocks World.
We have also implemented a bounded blocks world in which the table has a limited amount of space.
Dealing with resource constraints of this kind is  fairly easy for a forward-chaining planner, but much more difficult for partial order planners.8 A strategy capable of generating good plans in polynomial time can be written for this domain also, but it is more complex than our strategy for the unconstrained blocks world.
But even very simple strategies can be amazingly effective.
With no search control at all TLP LAN took an average of 470 CPU seconds to solve 10 different randomly generated six block problems when the table had space for 3 blocks.
When we changed the strategy to a simple "trigger" rule (trigger rules are rules that take advantage of fortuitous situations but do not attempt to achieve these situations) the average dropped to 0.48 seconds!
The particular rule we added was: whenever a block is clear and its final position is ready, move it there immediately.
This rule is easily expressed as an LTL formula.
Figure 3 plots the average time taken by TLP LAN to solve 10 random n block reconfiguration problems in the bounded blocks world where the table has space for 3 blocks.
The graph shows TLP LAN's performance using no control knowledge, the simple trigger rule given above, and a complete backtrack-free strategy.
Schedule World.
Another domain we have tested is the P RODIGY scheduling domain.
This domain has a large number of actions and the branching factor of the forward chaining space is large.
Nevertheless, we were able to write a conjunction of natural control formulas that allowed TLP LAN to generate good schedules without backtracking.
In this domain the task is to schedule a collection of objects on various machines to achieve various machining effects.
One example of the control formulas we used is, 8 x:object(x)] 2(polish(x) ^ :polish(x)) ) 2:polish(x), where polish is true of an object x if x is being polished in the current world.
This formula prohibits action sequences where an object is polished twice (basically the transition from being polished to when polishing stops prohibits future polishing).
Another use of the control formulas was to detect impossible goals.
For example, 8 x:object(x)] 8 s:GOAL(shape(xfi s))] s = cylindrical _ 2shape(xfi s).
In the domain the only shape we can create are cylinders.
This formula, when progressed through the initial state, checks every object for which the goal mentions a desired shape to ensure that the desired shape is cylindrical.
If it is not then the object must have that shape in the current state (i.e., in the initial state) and in all subsequent states.
Hence, when we pose a goal such as shape(Afi cone), the planner will immediately detect the impossibility of achieving this goal unless A starts off being cone shaped.
The performance of TLP LAN and S NLP (using domain independent heuristics) is shown in Figure 4.9 The data points in the figure show the average time taken to solve 10 random problems.
The x-axis plots the number of new features the goal requires (i.e., the 8  Resource constraints are beyond the capabilities of S NLP, but see [YC94] for a partial order planner with some ability to deal with resource constraints.
9 We were unable to obtain the P RODIGY control rules for this domain; hence, we omitted P RODIGY from this comparison.
400  Time (CPU sec.)
350 300 250 200 150 Prodigy 4.0 Control Formula 1 Control Formula 2 Control Formula 3  100 50 0 0  5  10  15  20  25  30  35  40  45  50  Number of Blocks  Figure 2: Performance of search control in the blocks world 400  Time (CPU sec.)
350 300 250 200 150 100  No Control Tigger Rule Complete Strategy  50 0 0  5  10  15  20  25  30  35  40  Number of Blocks  Figure 3: Performance of TLP LAN in the bounded blocks World number of machining operations that must be scheduled).10 In the experiments the number of objects are just sufficient to allow goals involving that number of new features (in this domain we can only add a limited number of new features to each object).
TLP LAN was able to solve all of the problems at each data point.
However, S NLP failed to solve 4 of the 3 new feature problems.
It is important to note that we are not using our experiments to claim that TLP LAN is a superior planner to S NLP (or P RODIGY).
After all, in the experiments described above, TLP LAN is being run with extensive control knowledge while S NLP was not.
Hence, it should be expected to outperform S NLP.
What we are claiming is that (1) domain independent heuristic search in real domains is totally inadequate, (2) planning can be effective in these domains with the addition of natural domain dependent search control knowledge, and (3) the TLP LAN approach to search control knowledge in particular is an effective way to utilize such knowledge.
These points are borne out by the data we have presented.
We have only incomplete evidence, given from the blocks world, that our approach to specifying search control knowledge is superior to 10 In this test we did not pose any impossible goals; so did not take advantage of the TLP LAN control formulas designed to detect impyossible goals.
P RODIGY's.
However, we are currently engaging in a more systematic comparison.
What is very clear at this point however, is that our LTL control formulas are much easier to understand, and their behavior easier to predict, than P RODIGY control rules.
In conclusion, we have demonstrated that search control knowledge for forward chaining planners can be expressed in a logical formalism and utilized effectively to produce efficient planners for a number of domains.
We are currently working on extending our planner so that it can plan for temporally extended goals (e.g., maintenance goals) and quantified goals.
TLP LAN is not yet capable of generating plans that satisfy all such goals.
This is due to its handling of eventuality goals like 3p.
If we pose the goal q, then our current implementation will search for a plan whose final state satisfies q.
The temporal formula 3p will be used only as a search control formula, and since it involves only an eventuality that can be postponed indefinitely, this will have no pruning effect.
Hence, our implementation could return a plan that achieves q in the final state but never passes through a state satisfying p. A more sophisticated implementation is required to ensure that eventualities are eventually satisfied and not postponed indefinitely.
In addition, we are working on applying our planner to some practical problem domains.
Finally,  400  Time (CPU sec.)
350 300 250 200 150 100  SNLP  50  TLPlan  0 0  5  10  15  20  25  30  Number of new features  Figure 4: Performance in the Schedule world.
as mentioned above, we are working on automatically generating search control knowledge from operator descriptions along the lines of [Etz93], and on a more systematic comparison with the P RODIGY system.
Acknowledgments: thanks to Adam Grove for extensive discussions; David McAllister for insights into inductive definitions; John McCarthy for the idea of trigger rules; Manuela Veloso and Jim Blythe for help with P RODIGY; and Hector Levesque, Nir Friedman and Jeff Siskind, David Etherington, Oren Ertzioni, and Dan Weld for various useful insights and comments on previous versions.
References [BW94]  A. Barrett and D.S.
Weld.
Partial-order planning: evaluating possible efficiency gains.
Artificial Intelligence, 67(1):71-112, 1994.
[CBE+ 92] J.G.
Carbonell, J. Blythe, O. Etzioni, Y. Gill, R. Joseph, D. Khan, C. Knoblock, S. Minton, A. Perez, S. Reilly, M. Veloso, and X. Wang.
Prodigy 4.0: The manual and turorial.
Technical Report CMU-CS-92-150, School of Computer Science, Carnegie Mellon University, 1992.
[CG87]  E. M. Clarke and O. Grumberg.
Research on automatic verification of finite-state concurrent systems.
In Joe F. Traub, Nils J. Nilsson, and Barbara J. Grozf, editors, Annual Review of Computing Science.
Annual Reviews Inc., 1987.
[Eme90]  E. A. Emerson.
Temporal and modal logic.
In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Volume B, chapter 16, pages 997-1072.
MIT, 1990.
[ENS92]  K. Erol, D.S.
Nau, and V.S.
Subrahmanian.
On the complexity of domain-independent planning.
In Proceedings of the AAAI National Conference, pages 381-386, 1992.
[Etz93]  Oren Etzioni.
Acquiring search-control knowledge via static analysis.
Artificial Intelligence, 62(2):255-302, 1993.
[GN92]  N. Gupta and D.S.
Nau.
On the complexity of blocksworld planning.
Artificial Intelligence, 56:223-254, 1992.
[HV91]  J. Y. Halpern and M. Y. Vardi.
Model checking vs. theorem proving: a manifesto.
In Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning, pages 325-334, 1991.
[MDBP92] S. Minton, M. Drummond, J. Bresina, and A. Phillips.
Total order vs. partial order planning: Factors influencing performance.
In Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning, pages 83-82, 1992.
[MR91]  D. McAllester and D. Rosenblitt.
Systematic nonlinear planning.
In Proceedings of the AAAI National Conference, pages 634-639, 1991.
[SBW90]  S. Soderland, T. Barrett, and D. Weld.
The SNLP planner implementation.
Contact bug-snlp@cs.washington.edu, 1990.
[Sel94]  B. Selman.
Near-optimal plans, tractability and reactivity.
In Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning, pages 521-529, 1994.
[VB94]  M. Veloso and J. Blythe.
Linkability: Examining causal link commitments in partial-order planning.
In Proceedings of the Second International Conference on AI Planning Systems, 1994.
[YC94]  Q. Yang and A. Chan.
Delaying variable binding committments in planning.
In Proceedings of the Second International Conference on AI Planning Systems, 1994.