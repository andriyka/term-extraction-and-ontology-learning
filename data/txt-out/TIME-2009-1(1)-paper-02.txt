Logical Methods in Computer Science Vol.
7 (2:12) 2011, pp.
1a21 www.lmcs-online.org  Submitted Published  Jan. 14, 2010 Nov. 16, 2011  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a OLAF BEYERSDORFF a , ARNE MEIER b , MARTIN MUNDHENK c , THOMAS SCHNEIDER d , MICHAEL THOMAS e , AND HERIBERT VOLLMER f a,b,e,f  Theoretical Computer Science, Leibniz University of Hannover, Germany e-mail address: {beyersdorff, meier, thomas, vollmer}@thi.uni-hannover.de  c  Computer Science, University of Jena, Germany e-mail address: martin.mundhenk@uni-jena.de  d  Computer Science, Saarland University, Germany e-mail address: schneider@ps.uni-saarland.de  Revision Note.
This is a revised and corrected version of the article originally published on May 17, 2011.
Abstract.
The model checking problem for CTL is known to be P-complete (Clarke, Emerson, and Sistla (1986), see Schnoebelen (2002)).
We consider fragments of CTL obtained by restricting the use of temporal modalities or the use of negationsarestrictions already studied for LTL by Sistla and Clarke (1985) and Markey (2004).
For all these fragments, except for the trivial case without any temporal operator, we systematically prove model checking to be either inherently sequential (P-complete) or very efficiently parallelizable (LOGCFL-complete).
For most fragments, however, model checking for CTL is already P-complete.
Hence our results indicate that, in cases where the combined complexity is of relevance, approaching CTL model checking by parallelism cannot be expected to result in any significant speedup.
We also completely determine the complexity of the model checking problem for all fragments of the extensions ECTL, CTL+ , and ECTL+ .
1998 ACM Subject Classification: D.2.4, F.3.1, I.2.2, I.2.4.
Key words and phrases: Model checking, temporal logic, complexity.
a A preliminary version of this paper appeared in the proceedings of the conference TIMEa09 [BMM+ 09].
Supported in part by grants DFG VO 630/6-1, VO 630/6-2, DAAD-ARC D/08/08881, and BC-ARC 1323.  l  LOGICAL METHODS IN COMPUTER SCIENCE  DOI:10.2168/LMCS-7 (2:12) 2011  c O. Beyersdorff, A. Meier, M. Mundhenk, T. Schneider, M. Thomas, and H. Vollmer  CC  Creative Commons  2  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  1.
Introduction Temporal logic was introduced by Pnueli [Pnu77] as a formalism to specify and verify properties of concurrent programs.
Computation Tree Logic (CTL), the logic of branching time, goes back to Emerson and Clarke [EC82] and contains temporal operators for expressing that an event occurs at some time in the future (F), always in the future (G), in the next point of time (X), always in the future until another event holds (U), or as long as it is not released by the occurrence of another event (R), as well as path quantifiers (E, A) for speaking about computation paths.
The full language obtained by these operators and quantifiers is called CTLa [EH86].
In CTL, the interaction between the temporal operators and path quantifiers is restricted.
The temporal operators in CTL are obtained by path quantifiers followed directly by any temporal operator, e.g., AF and AU are CTL-operators.
Because they start with the universal path quantifier, they are called universal CTL-operators.
Accordingly, EX and EG are examples for existential CTL-operators.
Since properties are largely verified automatically, the computational complexity of reasoning tasks is of great interest.
Model checking (MC)athe problem of verifying whether a given formula holds in a state of a given modelais one of the most important reasoning tasks [Sch03].
It is intractable for CTLa (PSPACE-complete [EL87, Sch03]), but tractable for CTL (complete for polynomial time [CES86, Sch03]).
Although model checking for CTL is tractable, its P-hardness means that it is presumably not efficiently parallelizable.
We therefore search for fragments of CTL with a model checking problem of lower complexity.
We will consider all subsets of CTL-operators, and examine the complexity of the model checking problems for all resulting fragments of CTL.
Further, we consider three additional restrictions affecting the use of negation and study the extensions ECTL, CTL+ , and their combination ECTL+ .
The complexity of model checking for fragments of temporal logics has been examined in the literature: Markey [Mar04] considered satisfiability and model checking for fragments of Linear Temporal Logic (LTL).
Under systematic restrictions to the temporal operators, the use of negation, and the interaction of future and past operators, Markey classified the two decision problems into NP-complete, coNP-complete, and PSPACE-complete.
Further, [BMS+ 09] examined model checking for all fragments of LTL obtained by restricting the set of temporal operators and propositional connectives.
The resulting classification separated cases where model checking is tractable from those where it is intractable.
For model checking paths in LTL an AC1 (LOGDCFL) algorithm is presented in [KF09].
Concerning CTL and its extension ECTL, our results in this paper show that most restricted versions of the model checking problem exhibit the same hardness as the general problem.
More precisely, we show that apart from the trivial case where CTL-operators are completely absent, the complexity of CTL model checking is a dichotomy: it is either Pcomplete or LOGCFL-complete.
Unfortunately, the latter case only occurs for a few rather weak fragments and hence there is not much hope that in practice, model checking can be sped up by using parallelismait is inherently sequential.
Put as a simple rule, model checking for CTL is P-complete for every fragment that allows to express a universal and an existential CTL-operator.
Only for fragments involving the operators EX and EF (or alternatively AX and AG) model checking is LOGCFL-complete.
This is visualized in Figure 4 in Section 5.
Recall that LOGCFL is defined as the class of problems logspace-reducible to context-free languages, and NL a LOGCFL a NC2 a P.  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  3  Hence, in contrast to inherently sequential P-hard tasks, problems in LOGCFL have very efficient parallel algorithms.
For the extensions CTL+ and ECTL+ , the situation is more complex.
In general, model checking CTL+ and ECTL+ is ap2 -complete [LMS01].
We show that for T a {A, E, X}, both model checking problems restricted to operators from T remain tractable, while for T * {A, E, X}, they become ap2 -complete.
Yet, for negation restricted fragments with only existential or only universal path quantifiers, we observe a complexity decrease to NP- resp.
coNP-completeness.
This paper is organized as follows: Section 2 introduces CTL, its model checking problems, and the non-basics of complexity theory we use.
Section 3 contains our main results, separated into upper and lower bounds.
We also provide a refined analysis of the reductions between different model checking problems with restricted use of negation.
The results are then generalized to extensions of CTL in Section 4.
Finally, Section 5 concludes with a graphical overview of the results.
2.
Preliminaries 2.1.
Temporal Logic.
We inductively define CTLa -formulae as follows.
Let IS be a finite set of atomic propositions.
The symbols used are the atomic propositions in IS, the constant symbols a$?, aL, the Boolean connectives AZ, aSS, and a", and the temporal operator symbols A, E, X, F, G, U, and R. A and E are called a path quantifiers, temporal operators aside from A and E are pure temporal operators.
The atomic propositions and the constants a$?
and aL are atomic formulae.
There are two kinds of formulae, state formulae and path formulae.
Each atomic formula is a state formula, and each state formula is a path formula.
If D, D are state formulae and D, D are path formulae, then AZD, (D aSS D), (D a" D), AD, ED are state formulae, and AZD, (D aSS D), (D a" D), XD, FD, GD, [DUD], and [DRD] are path formulae.
The set of CTLa -formulae (or formulae) consists of all state formulae.
A Kripke structure is a triple K = (W, R, IV), where W is a finite set of states, R a W A W a total relation (i.e., for each w a W , there exists a wa, such that (w, wa, ) a R), and IV : W a P(IS) is a labelling function.
A path x is an infinite sequence x = (x1 , x2 , .
.
.)
a W D such that (xi , xi+1 ) a R, for all i aL 1.
For a path x = (x1 , x2 , .
.
.)
we denote by xi the path (xi , xi+1 , .
.
.).
Let K = (W, R, IV) be a Kripke structure, w a W be a state, and x = (x1 , x2 , .
.
. )
a W D be a path.
Further, let D, D be state formulae and D, D be path formulae.
The truth of a CTLa -formula w.r.t.
K is inductively defined as follows: K, w |= a$?
always, K, w |= aL never, K, w |= p iff p a IS and p a IV(w), K, w |= AZD iff K, w 6|= D, K, w |= (D aSS D) iff K, w |= D and K, w |= D, K, w |= (D a" D) iff K, w |= D or K, w |= D, K, w |= AD iff K, x |= D for all paths x = (x1 , x2 , .
.
.)
with x1 = w, K, x |= D iff K, x1 |= D, K, x |= AZD iff K, x 6|= D, K, x |= (D aSS D) iff K, x |= D and K, x |= D,  4  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  AX, AF, AR  AX, AG, AU  AF, AR  AX, AU  AG, AU  AX, AF, AG  AU  AX, AF  AF, AG  AX, AG  AF  AX  AG  AX, AR  AR  a  Figure 1: The expressive power of CTL(T ).
K, x |= (D a" D) iff K, x |= D or K, x |= D, K, x |= XD iff K, x2 |= D K, x |= [DUD] iff there is a k a N such that K, xk |= D and K, xi |= D for 1 a$?
i < k. The semantics of the remaining temporal operators is defined via the equivalences: ED aA AZAAZD, FD aA [a$?UD], GD aA AZFAZD, and [DRD] aA AZ[AZDUAZD].
A state formula D is satisfied by a Kripke structure K if there exists w a W such that K, w |= D. We will also denoted this by K |= D. We use CTLa (T ) to denote the set of CTLa -formulae using the Boolean connectives {aSS, a", AZ}, and the temporal operators in T only.
If T does not contain any quantifiers, then including any pure temporal operators in T is meaningless.
A CTL-formula is a CTLa -formula in which each path quantifier is followed by exactly one pure temporal operator and each pure temporal operator is preceded by exactly one path quantifier.
The set of CTL-formulae forms a strict subset of the set of all CTLa -formulae.
For example, AGEFp is a CTL-formula, but A(GFp aSS Fq) is not.
CTL is less expressive than CTLa [EH85, EH86].
Pairs of path quantifiers and pure temporal operators are called CTL-operators.
The operators AX, AF, AG, AU, and AR are universal CTL-operators, and EX, EF, EG, EU, and ER are existential CTL-operators.
Let ALL denote the set of all universal and existential CTL-operators.
Note that A[DUD] aA AFD aSS AZE[AZDU(AZD aSS AZD)], and thus E[DRD] aA EGD a" E[DU(D aSS D)].
Hence {AX, AF, AR} is a minimal set of operators for CTL (in presence of all Boolean connectives), whereas {AX, AG, AU} is not [Lar95].
By CTL(T ) we denote the set of CTL-formulae using the connectives {aSS, a", AZ} and the CTL-operators in T only.
Figure 1 shows the structure of sets of CTL-operators with respect to their expressive power.
MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  5  Moreover, we define the following fragments of CTL(T ).
a CTLpos (T ) (positive) CTL-operators may not occur in the scope of a negation.
a CTLa.n.
(T ) (atomic negation) Negation signs appear only directly in front of atomic propositions.
a CTLmon (T ) (monotone) No negation signs allowed.
This restricted use of negation was introduced and studied in the context of linear temporal logic, LTL, by Sistla and Clarke [SC85] and Markey [Mar04].
Their original notation was e ) for CTLa.n.
(T ) and L+ (T ) for CTLpos (T ).
L(T  2.2.
Model Checking.
Now we define the model checking problems for the above mentioned fragments of CTL.
Let L be CTL, CTLmon , CTLa.n.
, or CTLpos .
Problem: L-MC(T ) Input: A Kripke structure K = (W, R, IV), a state w a W , and an L(T )-formula D. Question: Does K, w |= D hold?
2.3.
Complexity Theory.
We assume familiarity with standard notions of complexity theory as introduced in, e.g., [Pap94].
Next we will introduce the notions from circuit complexity that we use for our results.
All reductions in this paper are a$?cd -reductions defined as follows: A language A is constant-depth reducible to B, A a$?cd B, if there is a logtime-uniform AC0 -circuit family with oracle gates for B that decides membership in A.
That is, there is a circuit family C = (C1 , C2 , C3 , .
.
. )
such that a for every n, Cn computes the characteristic function of A for inputs of length n, a there is a polynomial p and a constant d such that for all input lengths n, the size of Cn is bounded by p(n) and the depth of Cn is bounded by d, a each circuit Cn consists of unbounded fan-in AND and OR gates, negation gates, and gates that compute the characteristic function of B (the oracle gates), a there is a linear-time Turing machine M that can check the structure of the circuit family, i.e., given a tuple hn, g, t, hi where n, g, h are binary numbers and t a {AND, OR, NOT, ORACLE}, M accepts if Cn contains a gate g of type t with predecessor h. Circuit families C with this last property are called logtime-uniform (the name stems from the fact that the time needed by M is linear in the length of its input tuple, hence logarithmic in n).
For background information we refer to [RV97, Vol99].
We easily obtain the following relations between model checking for fragments of CTL with restricted negation: Lemma 2.1.
For every set T of CTL-operators, we have CTLmon -MC(T ) a$?cd CTLa.n.
-MC(T ) a$?cd CTLpos -MC(T ).
Further, for model checking, atomic negation can be eluded, that is, CTLa.n.
-MC(T ) a$?cd CTLmon -MC(T ).
6  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Proof.
The first part is straightforward, using the identity function as reduction function.
For the second part, let K = (W, R, IV) be a Kripke structure and let D be a CTLa.n.
(T )formula over the propositions IS = {p1 , .
.
.
, pn }.
Every negation in D appears inside a negative literal.
We obtain Da, by replacing every negative literal AZpi with a fresh atomic proposition qi .
Further define K a, = (W, R, IV a, ), where IV a, (w) = IV(w) aS {qi | pi a / IV(w)}.
Obviously, K, w |= D iff K a, , w |= Da, for all w a W .
The mapping (K, w, D) 7a (K a, , w, Da, ) can be performed by an AC0 -circuit.
In Section 3.3, we complete the picture by proving CTLpos -MC(T ) a$?cd CTLmon -MC(T ).
The class P consists of all languages that have a polynomial-time decision algorithm.
A problem is P-complete if it is in P and every other problem in P reduces to it.
P-complete problems are sometimes referred to as inherently sequential, because P-complete problems most likely (formally: if P 6= NC) do not possess NC-algorithms, that is, algorithms running in polylogarithmic time on a parallel computer with a polynomial number of processors.
Formally, NC contains all problems solvable by polynomial-size polylogarithmic-depth logtime-uniform families of circuits with bounded fan-in AND, OR, NOT gates.
There is an NC-algorithm for parsing context-free languages, that is, CFL a NC.
Therefore, complexity theorists have studied the class LOGCFL of all problems reducible to context-free languages (the name aLOGCFLa refers to the original definition of the class in terms of logspace-reductions, however it is known that the class does not change if instead, as everywhere else in this paper, a$?cd -reductions are used).
Hence, LOGCFL a NC (even LOGCFL a NC2 , the second level of the NC-hierarchy, where the depth of the occurring circuits is restricted to O(log2 n)).
The class LOGCFL has a number of different maybe even somewhat surprising characterizations, e.g., languages in LOGCFL are those that can be decided by nondeterministic Turing machines operating in polynomial time that have a worktape of logarithmic size and additionally a stack whose size is not bounded.
More important for this paper is the characterization of LOGCFL as those problems computable by SAC1 circuit families, that is, families of circuits that a have polynomial size and logarithmic depth, a consist of unbounded fan-in OR gates and bounded fan-in AND gates and negation gates, but the latter are only allowed at the input-level, a are logtime-uniform (as defined above).
Since the class LOGCFL is known to be closed under complementation, the second condition can equivalently be replaced to allow unbounded fan-in AND gates and restrict the fan-in of OR gates to be bounded.
To summarize: NC1 a L a NL a LOGCFL = SAC1 a NC2 ; and problems in these classes possess very efficient parallel algorithms: they can be solved in time O(log2 n) on a parallel machine with a tractable number of processors.
For more background on these and related complexity classes, we refer the reader to [Vol99].
3.
Model Checking CTL and CTLpos This section contains our main results on the complexity of model checking for CTL and CTLpos .
We defer the analysis of the fragments CTLa.n.
and CTLmon to Section 3.3, where  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  7  we will see that their model-checking problems are computationally equivalent to model checking for CTLpos .
While model checking for CTL in general is known to be polynomial time solvable and in fact P-complete [CES86, Sch03], we improve the lower bound by showing that only one temporal operator is sufficient to obtain hardness for P. Theorem 3.1.
For each nonempty set T of CTL-operators, CTL-MC(T ) is P-complete.
If T = a, then CTL-MC(T ) is NC1 -complete.
If we consider only formulae from CTLpos , where no CTL-operators are allowed inside the scope of a negation, the situation changes and the complexity of model checking exhibits a dichotomous behavior.
As long as EG or AF are expressible the model checking problem remains P-complete.
Otherwise, its complexity drops to LOGCFL.
Theorem 3.2.
Let T be any set of CTL-operators.
Then CTLpos -MC(T ) is a NC1 -complete if T = a, a LOGCFL-complete if a ( T a {EX, EF} or a ( T a {AX, AG}, and a P-complete otherwise.
We split the proofs of Theorems 3.1 and 3.2 into the upper and lower bounds in the following two subsections.
3.1.
Upper Bounds.
In general, model checking for CTL is known to be solvable in P [CES86].
While this upper bound also applies to CTLpos -MC(T ) (for every T ), we improve it for positive CTL-formulae using only EX and EF, or only AX and AG.
Proposition 3.3.
Let T be a set of CTL-operators such that T a {EX, EF} or T a {AX, AG}.
Then CTLpos -MC(T ) is in LOGCFL.
Proof.
First consider the case T a {EX, EF}.
We claim that Algorithm 1 recursively decides whether the Kripke structure K = (W, R, IV) satisfies the CTLpos (T )-formula D in state w0 a W .
There, S is a stack that stores pairs (D, w) a CTLpos (T ) A W and Ra denotes the transitive closure of R. Algorithm 1 always terminates because each subformula of D is pushed to the stack S at most once.
For correctness, an induction on the structure of formulae shows that Algorithm 1 returns false if and only if for the most recently popped pair (D, w) from S, we have K, w 6|= D. Thence, in particular, Algorithm 1 returns true iff K, w |= D. Algorithm 1 can be implemented on a nondeterministic polynomial-time Turing machine that besides its (unbounded) stack uses only logarithmic memory for the local variables.
Thus CTLpos -MC(T ) is in LOGCFL.
The case T a {AX, AG} is analogous and follows from closure of LOGCFL under complementation.
Finally, for the trivial case where no CTL-operators are present, model checking CTL(a)formulae is equivalent to the problem of evaluating a propositional formula.
This problem is known to be solvable in NC1 [Bus87].
8  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  Algorithm 1 Determine whether K, w0 |= D. Require: a Kripke structure K = (W, R, IV), w0 a W , D a CTLpos (T ) 1: push(S, (D, w0 )) 2: while S is not empty do 3: (D, w) a pop(S) 4: if D is a propositional formula then 5: if D evaluates to false in w under IV then 6: return false 7: end if 8: else if D = Ia aSS I, then 9: push(S, (I,, w)) 10: push(S, (Ia, w)) 11: else if D = Ia a" I, then 12: nondet.
push(S, (Ia, w)) or push(S, (I,, w)) 13: else if D = EXIa then 14: nondet.
choose wa, a {wa, | (w, wa, ) a R} 15: push(S, (Ia, wa, )) 16: else if D = EFIa then 17: nondet.
choose wa, a {wa, | (w, wa, ) a Ra } 18: push(S, (Ia, wa, )) 19: end if 20: end while 21: return true 3.2.
Lower Bounds.
The P-hardness of model checking for CTL was first stated in [Sch03].
We improve this lower bound and concentrate on the smallest fragments of monotone CTLa w.r.t.
CTL-operatorsawith P-hard model checking.
Proposition 3.4.
Let T denote a set of CTL-operators.
Then CTLmon -MC(T ) is P-hard if T contains an existential and a universal CTL-operator.
Proof.
First, assume that T = {AX, EX}.
We give a generic reduction from the word problem for alternating Turing machines working in logarithmic space, which follows the same line as the classical proof idea (see [Sch03, Theorem 3.8]), and which we will modify in order to be useful for other combinations of CTL-operators.
Let M be an alternating logspace Turing machine, and let x be an input to M .
We may assume w.l.o.g.
that each transition of M leads from an existential to a universal configuration and vice versa.
Further we may assume that each computation of M ends after the same number p(n) of steps, where p is a polynomial and n is the length of M as input.
Furthermore we may assume that there exists a polynomial q such that q(n) is the number of configurations of M on any input of length n. Let c1 , .
.
.
, cq(n) be an enumeration of all possible configurations of M on input x, starting with the initial configuration c1 .
We construct a Kripke structure K := (W, R, IV)  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  9  by defining the set W := {cji | 1 a$?
i a$?
q(n), 0 a$?
j a$?
p(n)} and the relation R a W A W as   	  M reaches configuration ck from ci in one step, 0 a$?
j < p(n) R := (cji , cj+1 ) k   	 aS (cji , cji )  cji has no successor, 1 a$?
i a$?
q(n), 0 a$?
j < p(n) 	  p(n) p(n)  aS (ci , ci )  1 a$?
i a$?
q(n) .
The labelling function IV is defined for all cji a W as  {t}, if ci is an accepting configuration and j = p(n) j IV(ci ) := a, otherwise where t is the only atom used by this labelling.
It then holds that    M accepts x aa K, c01 |= D1 D2 AV AV AV Dp(n) (t) AV AV AV ,  where Di (x) := AX(x) if M as configurations before the ith step are universal, and Di (x) := EX(x) otherwise.
Notice that the constructed CTL-formula does not contain any Boolean connective.
Since p(n) and q(n) are polynomials, the size of K and D is polynomial in the size of (M, x).
Moreover, K and D can be constructed from M and x using AC0 -circuits.
Thus, A a$?cd CTLmon -MC({AX, EX}) for all A a ALOGSPACE = P. For T = {AF, EG} we modify the above reduction by defining the labelling function IV and the formula Di as follows:  {dj , t}, if ci is an accepting configuration and j = p(n) IV(cji ) := {dj }, otherwise  (3.1) AF(di aSS x), if M as configurations before step i are universal, Di (x) := EG(Di a" x), otherwise,  where dj are W atomic propositions encoding the atime stampsa of the respective configurations and Di = i6=ja{0,...,p(n)} dj .
For the combinations of T being one of {AF, EF}, {AF, EX}, {AG, EG}, {AG, EX}, {AX, EF}, and {AX, EG}, the P-hardness of CTLmon -MC(T ) is obtained using analogous modifications to IV and the Di as.
For the remaining combinations involving the until or the release operator, observe that w.r.t.
the Kripke structure K as defined in (3.1), AF(di aSS x) and EG(Di a" x) are equivalent to A[dia1 Ux] and E[dia1 Ux], and that R and U are duals.
In the presence of arbitrary negation, universal operators are definable by existential operators and vice versa.
Hence, from Proposition 3.4 we obtain the following corollary.
Corollary 3.5.
The model checking problem CTL-MC(T ) is P-hard for each nonempty set T of CTL-operators.
Returning to monotone CTL, in most cases even one operator suffices to make model checking P-hard: Proposition 3.6.
Let T denote a set of CTL-operators.
Then CTLmon -MC(T ) is P-hard if T contains at least one of the operators EG, EU, ER, AF, AU, or AR.
Proof.
We modify the proof of Proposition 3.4 to work with EG only.
The remaining fragments follow from the closure of P under complementation and FD aA AZGAZD aA [a$?UD], [DUD] aA AZ[AZDRAZD].
10  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  0 d 0 c1  0 d 0 c2  0 d 0 c1  AVAVAV 1 d 1 c1  d1  c12  1 d 1 c1  d0 d1  AVAVAV c21  d2  2 d 2 c2  c21  d2  d1  .. .
p(n) dp(n c1 )  p(n t,d c2 ) p(n)  c0  AVAVAV d0  q(n)  d2  .. .
d1  c2  p(n) dp(n c1 )  AVAVAV d2  .. .
.. .
AVAVAV t,d  cp(n)  q p(n) (n)  layer 1  d2  .. .
q p(n) (n)  layer 2  c2  d2  .. .
.. .
.. .
q(n)  .. .
p(n t,d c2 ) p(n)  t,d  z  AVAVAV  p(n) dp(n c1  cp(n)  q(n)  2 d 2 c2  )  AVAVAV  c1  d1  c21  c2  p(n t,d c2 ) p(n)  AVAVAV  q(n)  q(n)  q(n)  c12  c1  AVAVAV  q(n)  c0  d0  1 d 1 c1  d1 AVAVAV  q(n)  .. .
.. .
AVAVAV  q(n)  c12 c1  0 d 0 c2  c0  2 d 2 c2  AVAVAV .. .
0 d 0 c1  0 d 0 c2  AVAVAV  p(n) t,d cq(n) p(n)  layer q(  n) +  1  Figure 2: The Kripke structure K a, ; dashed (resp.
solid) arrows correspond to transitions leaving existential (resp.
universal) configurations.
Let the machine M , the word x, the polynomials p, q, and K be as above.
Further assume w.l.o.g.
that M branches only binary in each step.
Denote by Wa (resp.
Wa ) the set of states corresponding to existential (resp.
universal) configurations.
The purpose of the introduced layers below is to ensure the uniqueness of the successors of universal configurations which is essential in the construction of Di later.
We construct a Kripke structure K a, := (W a, , R, IV) consisting of q(n) + 1 layers and a atrapa as follows: let W a, := W A {1, .
.
.
, q(n) + 1} aS {z}.
The transition relation R a W a, A W a, is defined as      cj a Wa , M reaches ck from ci in one step, j j+1  i R := (ci , a), (ck , a)  1 a$?
a a$?
q(n) + 1, 0 a$?
j < p(n)   dLa j dLz j+1  j (c , a), (c , i) , dL, i k   c a Wa , M reaches ck and cka, from ci indL" j+1 aS (cj+1 , i), (c , q(n) + 1) ,  i a, k  dLl kj+1 dLz  one step, ck a$?
cka, , 0 a$?
j < p(n) (cka, , q(n) + 1), z  p(n)  	 p(n) aS  (ci 	, a), (ci , a) | 1 a$?
i a$?
q(n), 1 a$?
a a$?
q(n) + 1 aS (z, z) .
That is, the arcs leaving an existential configurations ci lead to the successor configurations of ci inside each layer; while any universal configuration ci has exactly one outgoing arc pointing to its (lexicographically) first successor configuration in the layer i, from where another arc leads to the second successor of ci in layer q(n) + 1, which in turn has an outgoing arc to the state z (see Figure 2).
The labelling function IV is defined as IV(z) := {z}, IV((cji , a)) := {a, dj , t} if ci is an accepting configuration, and otherwise IV((cji , a)) := {a, dj } for (1 a$?
a a$?
q(n) + 1).
Define ( EG(dia1 a" (di aSS x) a" z), if M as configurations before step i are universal, Di (x) := EG(Di a" x), if M as configurations before step i are existential,  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  11  W and Di = i6=ja{0,...,p(n)} dj .
The correctness of the equivalence K, w |= AF(di aSS x) iff  K a, , (w, a) |= EG dia1 a" (di aSS x) a" z) , for all w a Wa , 1 a$?
a a$?
q(n) + 1 and 1 a$?
i a$?
p(n) can be verified through the following observations.
a: if di and x hold in all successors of w in K, then there exists a path from (w, a) to both of the series-connected successors reaching the trap and looping there.
This is the only possibility for the path as neither dia1 nor di hold below that level.
As in each successor configuration the subformula di aSS x must be satisfied the composition of the Di s ensures that in each such state there must start an EG-path for each universal successor.
a: the only path which satisfies at least one of the three disjuncts ranges through both series-connected successor configurations and ends in the trap.
For each of the two successor states di and x hold.
Thus AF(di aSS x) is true in the state w in the structure K. From this, it easily follows that for    M accepts x aa K a, , (c01 , 1) |= D1 D2 AV AV AV Dp(n) (t) AV AV AV .
As we essentially only duplicated the set of states in K and R can be constructed from all triples of states in W a, , K a, remains AC0 constructible.
Concluding A a$?cd CTLmon -MC({EG}) for all A a P.  By Lemma 2.1, CTLmon -MC(T ) a$?cd CTLpos -MC(T ) and hence the above results directly translate to model checking for CTLpos : for any set T of temporal operators, CTLpos -MC(T ) is P-hard if T * {EX, EF} or if T * {AX, AG}.
These results cannot be improved w.r.t.
T , as for T a {EX, EF} and T a {AX, AG} we obtain a LOGCFL upper bound for model checking from Proposition 3.3.
In the following proposition we prove the matching LOGCFL lower bound.
Proposition 3.7.
For every nonempty set T of CTL-operators, the model checking problem CTLmon -MC(T ) is LOGCFL-hard.
Proof.
As explained in Section 2.3, LOGCFL can be characterized as the set of languages recognizable by logtime-uniform SAC1 circuits, i.e., circuits of logarithmic depth and polynomial size consisting of a"-gates with unbounded fan-in and aSS-gates with fan-in 2.
For every single CTL-operator O, we will show that CTLmon -MC(T ) is LOGCFL-hard for all T a {O} by giving a generic a$?cd -reduction f from the word problem for SAC1 circuits to CTLmon -MC(T ).
First, consider EX a T .
Let C be a logtime-uniform SAC1 circuit of depth a with n inputs and let x = x1 .
.
.
xn a {0, 1}n .
Assume w.l.o.g.
that C is connected, layered into alternating layers of aSS-gates and a"-gates, and that the output gate of C is an a"gate.
We number the layers bottom-up, that is, the layer containing (only) the output gate has level 0, whereas the input-gates and negations of the input-gates are situated in layer a. Denote the graph of C by G = (V, E), where V := Vin a VaSS a Va" is partitioned into the sets corresponding to the (possibly negated) input-gates, the aSS-gates, and the a"-gates, respectively.
G is acyclic and directed with paths leading from the input to the output gates.
From (V, E) we construct a Kripke structure that allows to distinguish the two predecessors of an aSS-gate from each other.
This will be required to model proof trees using CTLmon ({EX})-formulae.
12  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  i For i a {1, 2}, let Vini := {v i | v a Vin }, Va"i := {v i | v a Va" } and define Vin,a" := Vini aS Va"i .
Further define  	 i E a, := (v, ui ) a VaSS A Vin,a" | (u, v) a E and u is the ith predecessor of v [  	  	 i (v i , u) a Vin,a" A VaSS | (u, v) a E , aS (v, v) | v a Vin1 aS Vin2 aS ia{1,2}  where the ordering of the predecessors is implicitly given in the encoding of C. We now 1 aS V 2 aS V , transition define a Kripke structure K := (V a, , E a, , IV) with states V a, := Vin,a" aSS in,a" relation E a, , and labelling function IV : V a, a P({1, 2, t}), dLa i i dL' dL,{i, t}, if (v = vinj a Vin and xj = 1) or (v = v inj a Vin and xj = 0), IV(v) := {i}, if (v = vinj a Vini and xj = 0) or (v = v inj a Vini and xj = 1) or v a Va"i , dL' dLl a, otherwise, where i = 1, 2, j = 1, .
.
.
, n and vin1 , .
.
.
, vinn , v in1 , .
.
.
, v inn enumerate the input gates and their negations.
The formula D that is to be evaluated on K will consist of atomic propositions 1, 2 and t, Boolean connectives aSS and a", and the CTL-operator EX.
To construct D we recursively define formulae (Di )0a$?ia$?a by dLa dL' if i = a, dL,t, Di := EXDi+1 , if i is even (a"-layers), dL' dLlV i=1,2 EX(i aSS Di+1 ), if i is odd (aSS-layers).
We define the reduction function f as the mapping (C, x) 7a (K, v0 , D), where v0 is the node corresponding to the output gate of C and D := D0 .
We stress that the size of D is polynomial, for the depth of C is logarithmic only.
Clearly, each minimal accepting subtree (cf.
[Ruz80] or [Vol99, Definition 4.15]) of C on input x translates into a sub-structure K a, of K such that K a, , v0 |= D, where (1) K a, includes v0 , (2) K a, includes one successor for every node corresponding to an a"-gate, and (3) K a, includes the two successors of every node corresponding to an aSS-gate.
As C(x) = 1 iff there exists a minimal accepting subtree of C on x, the LOGCFL-hardness of CTLmon -MC(T ) for EX a T follows.
Second, consider EF a T .
We have to extend our Kripke structure to contain information about the depth of the corresponding gate.
We may assume w.l.o.g.
that C is encoded such that each gate contains an additional counter holding the distance to the output gate (which is equal to the number of the layer it is contained in, cf.
[Vol99]).
We extend IV to encode this distance i, 1 a$?
i a$?
a, into the adepth-propositionsa di as in the proof of Proposition 3.4.
Denote this modified Kripke structure by K a, .
Further, we define (Da,i )0a$?ia$?a as dLa dL' if i = a, dL,t, a, a, Di := EF(di+1 aSS Di+1 ), if i is even, dL' dLlV a, i=1,2 EF(di+1 aSS i aSS Di+1 ), if i is odd.
Redefining the reduction f as (C, x) 7a (K a, , v0 , Da,0 ) hence yields the LOGCFL-hardness of CTLmon -MC(T ) for EF a T .
Third, consider AX a T .
Consider the reduction in case 1 for CTLmon ({EX})-formulae, and let f (C, x) = (K, v0 , D) be the value computed by the reduction function.
It holds that  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  13  C(x) = 1 iff K, v0 |= D, and equivalently C(x) = 0 iff K, v0 |= AZD.
Let Da, be the formula obtained from AZD by multiplying the negation into the formula.
Then Da, is a CTLa.n.
({AX})formula.
Since LOGCFL is closed under complement, it follows that CTLa.n.
-MC({AX}) is LOGCFL-hard.
Using Lemma 2.1, we obtain that CTLmon -MC({AX}) is LOGCFL-hard, too.
An analogous argument works for the case AG a T .
The remaining fragments are even P-complete by Proposition 3.6.
Using Lemma 2.1 we obtain LOGCFL-hardness of CTLpos -MC(T ) for all nonempty sets T of CTL-operators.
In the absence of CTL-operators, the lower bound for the model checking problem again follows from the lower bound for evaluating monotone propositional formulae.
This problem is known to be hard for NC1 [Bus87, Sch10].
3.3.
The Power of Negation.
We will now show that model checking for the fragments CTLa.n.
and CTLpos is computationally equivalent to model checking for CTLmon , for any set T of CTL-operators.
Since we consider a$?cd -reductions, this is not immediate.
From Lemma 2.1 it follows that the hardness results for CTLmon -MC(T ) also hold for CTLa.n.
-MC(T ) and CTLpos -MC(T ).
Moreover, the algorithms for CTLpos -MC(T ) also work for CTLmon -MC(T ) and CTLa.n.
-MC(T ) without using more computation resources.
Both observations together yield the same completeness results for all CTL-fragments with restricted negations.
Theorem 3.8.
Let T be any set of CTL-operators.
Then CTLmon -MC(T ), CTLa.n.
-MC(T ), and CTLpos -MC(T ) are a NC1 -complete if T is empty, a LOGCFL-complete if a ( T a {EX, EF} or a ( T a {AX, AG}, a P-complete otherwise.
Moreover, the problems CTLmon -MC(T ), CTLa.n.
-MC(T ), and CTLpos -MC(T ) are equivalent w.r.t.
a$?cd -reductions.
This equivalence extends Lemma 2.1.
We remark that this equivalence is not straightforward.
Simply applying de Morganas laws to transform one problem into another requires counting the number of negations on top of aSS- and a"-connectives.
This counting cannot be achieved by an AC0 -circuit and does not lead to the aspired reduction.
Here we obtain equivalence of the problems as a consequence of our generic hardness proofs in Section 3.2.
4.
Model Checking Extensions of CTL It has been argued that CTL lacks the ability to express fairness properties.
To address this shortcoming, Emerson and Halpern introduced ECTL in [EH86].
ECTL extends CTL a with the F-operator, which states that for every moment in the future, the enclosed formula will eventually be satisfied again: for a Kripke structure K, a path x = (x1 , x2 , .
.
.
), and a path formula D a K, x |= FD iff K, xi |= FD for all i a N. a  The dual operator G is defined analogously.
As for CTL, model checking for ECTL is known to be tractable.
Moreover, our next result shows that even for all fragments, model checking for ECTL is not harder than for CTL.
14  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  a  Algorithm 2 Case distinction for EF a  1: 2: 3: 4:  else if D = EFIa then nondet.
choose k a$?
|W | and a path (wi )1a$?ia$?k such that (w, w1 ) a Ra , (wk , w1 ) a R nondet.
choose some 1 a$?
i a$?
k and push(S, (Ia, wi )) end if  Theorem 4.1.
Let T be a set of temporal operators.
Then ECTL-MC(T ) aAcd CTL-MC(T a, ) a and ECTLpos -MC(T ) aAcd CTLpos -MC(T a, ), where T a, is obtained from T by substituting F a with F and G with G. a  a  Proof.
For the upper bounds, notice that ECTL-MC(ALL aS {EF, AF}) a P. It thus remains a a to show that ECTLpos -MC(T ) a LOGCFL for T a {EX, EF, EF} and T a {AX, AG, AG} a a First, consider the case that T a {EX, EF, EF}.
We modify Algorithm 1 to handle EF by extending the case distinction in lines 4a19 with the code fragment given in Algorithm 1. a The algorithm for T a {AX, AG, AG} is analogous and membership in LOGCFL follows from its closure under complementation.
For the lower bounds, we extend the proofs of Propositions 3.4, 3.6 and 3.7 to handle a a a a sets T involving also the operators AF, AG, EF, and EG.
Therefore, we only need modify the accessibility relation R of respective Kripke structure K to be reflexive.
The hardness a a results follow by replacing F with F and G with G in the respective reductions.
First consider the case that T contains an existential and a universal operator, say a a T = {AF, EG}.
Let M , x, and p be defined as in the proof of Proposition 3.4.
We map (M, x) to (KE, c01 , D1 ), where KE = (W, R, IV) is the reflexive closure of the Kripke  structure K defined   0 for the P-hardness of CTL-MC({AF, EG}), c1 a W , and D := D1 D2 AV AV AV Dp(n) (t) AV AV AV , where ( a AF(di aSS x), if M as configurations in step i are universal, Di (x) := a EG(Di a" x), otherwise, In KE it now holds that di a IV(w) and (w, wa, ) a R together imply that either w = wa, or a di a / IV(wa, ).
Hence, for all w a W and 1 a$?
i a$?
p(|x|), KE, w |= AF(di aSSx) iff K, w |= AF(di aSSx), a W W and KE, w |= EG( i6=ja{0,...,p(n)} dj a" x) iff K, w |= EG( i6=ja{0,...,p(n)} dj a" x).
From this, correctness of the reduction follows.
The P-hardness of CTL-MC(T ) for the remaining fragments follows analogously.
a As for T a {EX, EF, EF}, we will show that ECTLmon -MC(T ) is LOGCFL-hard under a a$?cd -reductions for T = {EF}.
Let C, x, and a be as in the proof of Proposition 3.7.
We map the pair (C, x) to the triple (KE a, , v0 , D0 ), where KE a, = (V a, , E a, , IV) is the reflexive closure of the Kripke structure K a, defined for the LOGCFL-hardness of CTL-MC({EF}), v0 a V a, , and D0 is recursively defined via (Da,i )0a$?ia$?a as dLa dL' if i = a, dL,t,a Di := EF(di+1 aSS Di+1 ), if i is even, dL' a dLlV i=1,2 EF(di+1 aSS i aSS Di+1 ), if i is odd.
Again, we have that in KE a, , di a IV(v) and (v, v a, ) a E a, together imply that either v = v a, or a di a / IV(v a, ).
It hence follows KE a, , v |= EF(di aSS Di ) iff K a, , v |= EF(di aSS Di ), for all v a V a, and  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  a  15  a  1 a$?
i a$?
a.
We conclude that ECTLmon -MC({EF}) is LOGCFL-hard.
The case T = {AG} follows analogously.
We will now consider CTL+ , the extension of CTL by Boolean combinations of path formulae which is defined as follows.
A CTL+ -formula is a CTLa -formula where each pure temporal operator in a state formula occurs in the scope of a path quantifier.
The set of all CTL-formulae is a strict subset of the set of all CTL+ -formulae, which again forms a strict subset of the set of all CTLa -formulae.
For example, AGEFp and A(Gp aSS Fq) are CTL+ -formulae, but AGFp is not.
However, CTL is as expressive as CTL+ [EH85].
By CTL+ (T ) we denote the set of CTL+ -formulae using the connectives {aSS, a", AZ} and temporal operators in T only.
Analogous to the fragments CTLpos (T ), CTLa.n.
(T ), + + and CTLmon (T ), we define CTL+ pos (T ), CTLa.n.
(T ), and CTLmon (T ) as those fragments + of CTL (T ) that disallow temporal operators in the scope of negations, contain negation signs only directly in front of atomic propositions, and do not contain negation signs at all, respectively.
In contrast to CTL, model checking for CTL+ is not tractable, but ap2 -complete [LMS01].
Below we classify the complexity of model checking for both the full and the positive fragments of CTL+ .
Theorem 4.2.
Let T be a set of temporal operators containing at least one path quantifier.
Then CTL+ -MC(T ) is a NC1 -complete if T a {A, E}, a P-complete if {X} ( T a {A, E, X}, and a ap2 -complete otherwise.
Proof.
If T a {A, E} then deciding CTL+ -MC(T ) is equivalent to the problem of evaluating a propositional formula, which is known to be NC1 -complete [Bus87, Sch10].
If {X} ( T a {A, E, X}, then CTL+ -MC(T ) can be solved using a labelling algorithm: Let K = (W, R, IV) be a Kripke structure, and D be a CTL+ ({A, E, X})-formula.
Assume w.l.o.g.
that D starts with an E and that it does not contain any Aas.
Compute K, w |= D for all w a W and all subformulae ED of D such that D is free of path quantifiers, and replace ED in D with a new proposition pD while extending the labelling function IV such that pD a IV(w) aa K, w |= D. Repeat this step until D is free of path quantifiers and denote the resulting (propositional) formula by Da, .
To decide whether K, w |= D for some w a W , it now suffices to check whether Da, is satisfied by the assignment implied by IV(w).
As for all of the above subformulae ED of D, D a CTL+ ({X}), it follows that K, w |= D can be determined in polynomial time in the size of K and D. Considering that the number of labelling steps is at most O(|D| AV |W |) it follows that CTL+ -MC(T ) is in P. The P-hardness follows from CTL-MC({EX}) a$?cd CTL+ -MC({E, X}) resp.
CTL-MC({AX}) a$?cd CTL+ -MC({A, X}).
For all other possible sets T , we have T aS{E, A} = 6 a and T aS{F, G, U} = 6 a. Consequently, each of the temporal operators A, E, F, and G can be expressed in CTL+ (T ).
The claim now follows from [LMS01].
For the positive fragments of CTL+ we obtain a more complex picture: Theorem 4.3.
Let T be a set of temporal operators containing at least one path quantifier.
Then CTL+ pos -MC(T ) is a NC1 -complete if T a {A, E}, a LOGCFL-complete if T = {A, X} or T = {E, X},  16  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  a P-complete if T = {A, E, X}, a NP-complete if E a T , A 6a T and T contains a pure temporal operator aside from X, a coNP-complete if A a T , E 6a T and T contains a pure temporal operator aside from X, and a ap2 -complete otherwise.
Proof.
The first and third claim follow from Theorem 4.2 and the monotone formula value problem being NC1 -complete [Sch10].
For the second claim, consider the case T = {E, X}.
It is straightforward to adopt Algorithm 1 to guess a successor wa, of the current state once for every path quantifier E that has been read and decompose the formula w.r.t.
wa, .
For T = {A, X} analogous arguments hold.
The fourth claim can be solved with a labelling algorithm analogously to the algorithm for CTL+ -MC({A, E, X}).
In this case, however, whole paths need to be guessed in the Kripke structures.
Hence, we obtain a polynomial time algorithm deciding CTL+ pos -MC(T ) using an oracle B a NP (resp.
B a coNP) .
This algorithm is furthermore a monotone a$?pT reduction from CTL+ pos -MC(T ) to B, in the sense that for any deterministic oracle Turing machine M that executes the algorithm, A a B =a L(M, A) a L(M, B), where L(M, X) is the language recognized by M with oracle X.
Both NP and coNP are closed under monotone a$?pT -reductions [Sel82].
We thus conclude that CTL+ pos -MC(T ) a NP (resp.
CTL+ -MC(T ) a coNP).
pos As for the NP-hardness of CTL+ pos -MC(T ), note that the reduction from 3SAT to LTL-MC({F}), the model checking problem for linear temporal logic using the F-operator only, given by Sistla and Clarke in [SC85] is a reduction to CTL+ pos -MC({E, F}) indeed.
The NP-hardness of CTL+ -MC({E, G}) is obtained by a similar reduction: let D be a pos Vn propositional formula in 3CNF, i.e., D = i=1 Ci with Ci = ai1 a" ai2 a" ai3 and aij = xk or aij = W AZxk for all 1 a$?
i a$?
n, all 1 Wa$?
j a$?
3, and some 1 a$?
k a$?
m. Recall that for a set A, A denotes the disjunction aaA a.
We map D to the triple (K, y0 , D), where W V W K = (W, R, IV) is the Kripke structure given in (4.1) and D := E ni=1 3j=1 G (IS \ {azaij }) with IS := {y0 , yi , xi , xi | 1 a$?
i a$?
m} and azaij denoting the complementary literal of aij .
W := {y0 } aS {xi , xi , yi | 1 a$?
i a$?
m},  R := {(yia1 , xi ), (xi , yi ), (yia1 , xi ), (xi , yi ) | 1 a$?
i a$?
m} aS {(ym , ym )},  (4.1)  IV(w) := {w} for all w a W. Note that the above reductions prove hardness for CTL+ mon -MC(T ) already.
The coNP+ hardness of CTL+ pos -MC({A, G}) and CTLpos -MC({A, F}) follows from the same reductions.
As for the the last claim, note that the ap2 -hardness of CTL+ -MC({A, E, F, G}) carries + over to CTL+ mon -MC({A, E, F, G}), because any CTL ({A, E, F, G})-formula can be trans+ formed into a CTLa.n.
({A, E, F, G})-formula, in which all negated atoms AZp may be replaced by fresh propositions p that are mapped into all states of the Kripke structure whose label does not contain p. It thus remains to prove the ap2 -hardness of CTL+ pos -MC({A, E, F}) and + + CTLpos -MC({A, E, G}).
Consider CTLpos -MC({A, E, G}).
Laroussinie et al.
reduce from SNSAT, that is the problem to decide, given disjoint sets Z1 , .
.
.
, Zn of propositional variables from {z1 , .
.
.
, zp } and a list D1 (Z1 ), D2 (x1 , Z2 ), .
.
.
, Dn (x1 , .
.
.
, xn , Zn ) of formulae in  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  xn  xna1  s00 n  cn  cna1  xna1  s11 n  x1  AVAVAV  z1  z2  AVAVAV  zp  s11 1  z1  z2  AVAVAV  zp  c1 s10 1  s10 2  s11 na1  s00 1  s01 1  ... s10 na1  s10 n  s00 2  s01 2  s01 na1  s01 n  xn  AVAVAV  s00 na1  17  s11 2  x1  Figure 3: Extended version of the Kripke structure constructed in [LMS01, Figure 3].
conjunctive normal form, whether xn holds in the unique valuation D defined by D(xi ) = a$?
aa Di (x1 , .
.
.
, xia1 , Zi ) is satisfiable.
(4.2)  An instance I of SNSAT is transformed to the Kripke structure K depicted in Figure 3 and the formula D2na1 that is recursively defined as  _ n n n _ _  01 10 11 x a 6 D ) a" s a" s a" s ) aSS F( xi a E AZF (s00 Dk := E G i ka1 i i i i |  i=1  i=1  i=1  {z  (A)  aSS G |  n ^  AZci  i=1  {z  (B)    }  aSS  n  ^  Fxi a  i=1  ^_ j  {z  |  m  (C)  }  Fai,j,m   }  ,  V W for 1 a$?
k a$?
n, D0 := a$?, and Di = j m ai,j,m, where the ai,j,mas are literals over {x1 , .
.
.
, xn }aS Zi .
Note that the structure K from Figure 3 differs from the Kripke structure constructed in [LMS01] in that we introduce different labels ci and sji for 1 a$?
i a$?
n and j a {00, 01, 10, 11}, as we need to distinguish between the states later on.
The intuitive interpretation of (B) is that the existentially quantified path does actually encode an assignment of {x1 , .
.
.
, xn } to {aL, a$?
}, while (C) states that this assignment coincides with D on all propositions that are set to a$?.
Lastly (A) expresses the recursion inherent in the definition of SNSAT.
It holds that I a SNSAT aa K, xn |= D2na1 (see [LMS01] for the correctness of this argument).
We modify the given reduction to not use F. First note that Dka1 occurs negatively in Dk .
We will therefore consider the formulae D2na1 , D2na3 , .
.
.
, D1 and AZD2na2 , AZD2na4 , .
.
.
, AZD2 separately.
In D2na1 , D2na3 , .
.
.
, D1 replace n n n n _ _ ^ _  00 01 10 11 ci a" AZDka1 ) , xi a E G (AZsi aSS AZsi aSS AZsi aSS AZsi ) aSS G( xi a" a (A) with G i=1  i=1  n   ^ ^_ _ GAZxi a" G (IS \ {azai,j,m}) ; a (C) with i=1  j  i=1  m  and in AZD2na2 , AZD2na4 , .
.
.
, AZD2 replace _ _ _  (IS \ {xi }) a" A G( IS \ {ci }) a" G(ci a" Dka1 , G a (A) with 1a$?ia$?n  i=1  18  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  a (B) with a (C) with  n _  G  i=2 n  _  _ 01 01 11 (IS \ {s00 i , si , sia1 , sia1 }), and  G   _ _^ (IS \ {xi }) aSS GAZai,j,m ,  j m 00 01 10 {xi , xi , ci , si , si , si , s11 i |  i=1  1 a$?
i a$?
n} aS {zi , z i | 1 a$?
i a$?
p} is the set of all where IS := propositions used in K. Denote the resulting formulae by Dka, , k aL 0.
In Dka, , all negations are atomic and only the temporal operators E, A and G are used.
To verify that K, xk |= Dk aa K, xk |= Dka, for all 0 a$?
k < 2n, consider Dk with k odd first.
Suppose K, xk |= Dk .
Then, by (A), there exists a path D in K such that whenever some xi is labelled in the current state Dp , then there exists a path D a, starting in Dp that never visits any state labelled with sji , 1 a$?
i a$?
n, j a {00, 01, 10, 11}, and eventually falsifies Dka1 because it reaches a state where neither xi nor ci holds for all 1 a$?
i a$?
n. Hence, by construction of K, D a, has to visit the states labelled with ci and xi for i such that xi a IV(Dp ).
This is equivalent to the existence of a path D a, starting in Dp which never visits any state labelled with sji , 1 a$?
i a$?
n, j a {00, 01, 10, 11}, and that falsifies Dka1 if the current state is not labelled with ci or xi for all 1 a$?
i a$?
n. Hence the substitution performed on (A) does not alter the set of states in K on which the formula is satisfied.
The formula (C), on the other hand, states that whenever the path D quantified by the outmost E in Dk visits the state labelled xi , then for every clause j in the ith formula Di of given SNSAT instance at least one literal ai,j,m occurs in the labels on D (i.e., Di is satisfied by the assignment induced by D).
The path D is guaranteed to visit either a state labelled xi or a state labelled xi but not both, by virtue of the subformula (B).
Therefore, the eventual satisfaction of xi is equivalent to globally satisfying AZxi , whereas the satisfaction of Di can be asserted by requiring that for any clause some literal is globally absent from the labels on D. Thus the substitution performed on (C) does not alter the set of states on which the formula is satisfied either.
Concluding, K, xk |= Dk aa K, xk |= Dka, for all odd 0 a$?
k < 2n.
Now, if k is even, then  _ n n n _ _  00 01 10 11 xi aSS A F (si a" si a" si a" si ) a" G( xi a Dka1 ) AZDk aA A F |  i=1  i=1  i=1  {z  }  (A)  n n   _  _ _^ a" F ci a" Fxi aSS GAZai,j,m .
|  i=1  {z  (B)  }  i=1  |  j  {z  m  (C)  }  Here, (A) asserts that on all paths D there is a state Dp such that xi a IV(Dp ) for some 1 a$?
i a$?
n and all paths D a, starting in Dp eventually visit a state labelled with sji , 1 a$?
i a$?
n, j a {00, 01, 10, 11}, or satisfy Dka1 whenever xi a IV(Dp ) for some 1 a$?
i a$?
n. By construction of K, this is equivalent to stating the all paths D a, either pass the state labelled ci and globally satisfy As for the states  or  in K the formula Wndo not pass the state labelled Wn ci .
W Wn ci a" Dka1 F i=1 xi aSS D aA i=1 F xi aSS D is satisfied iff i=1 G (IS \ {xi }) a" D is satisfied, the set of when substituting (A) with k is satisfied remains unaltered  W states inWK on which the DW . })
a" A G( IS \ {c }) a" G(c a" D G (IS \ {x i i i ka1 1a$?ia$?n  MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  19  Similarly, the set ofW statesWin K on which the Dk is satisfied remains unaltered when 01 01 11 substituting (B) with ni=2 G (IS \ {s00 i , si , sia1 , sia1 }), as any path in K that visits a 01 01 11 state labelled with some ci cannot pass via states labelled with s00 i , si , sia1 , or sia1 .
W V Wn W Finally, the equivalence of Dk with i=1 G (IS \ {xi }) aSS j m GAZai,j,m follows from arguments similar to those for the (C) part in the case that k is odd.
We conclude that p K, xk |= Dk aa K, xk |= Dka, for all 0 a$?
k < 2n.
Hence, CTL+ pos -MC({A, E, G}) is a2 -hard.
p + For T = {A, E, F} similar modifications show that CTLpos -MC(T ) is a2 -hard, too.
This concludes to proof of Theorem 4.3.
Finally consider ECTL+ , the combination of ECTL and CTL+ .
One can adapt the a a above hardness and membership proofs to hold for F and G instead of F and G: For example, a to establish the ap2 -hardness of ECTL+ pos -MC(T ) in case T = {A, E, G} we modify K such that the states labelled xn and xn are reachable from zp and z p and assert that (a) the path quantified by the outmost path quantifier in Dk , 1 a$?
i < 2n, additionally satisfies a Vn a that all but a i=1 (GAZxi a" GAZxi ) and (b) whenever xi is labelled,a then there exists a path a finite number of times satisfies xi .
The changes if F is available instead of G follow by the duality principle of these operators.
For its model checking problem we hence obtain: Corollary 4.4.
Let T be a set of temporal operators containing at least one path quantifier a a and let T a, by obtained from T by substituting F with F and G with G. Then ECTL+ -MC(T ) aAcd + CTL+ -MC(T a, ) and ECTL+ pos -MC(T ) aAcd CTLpos -MC(T ).
5.
Conclusion We have shown (Theorem 3.2) that model checking for CTLpos (T ) is already P-complete for most fragments of CTL.
Only for some weak fragments, model checking becomes easier: if T a {EX, EF} or T a {AX, AG}, then CTLpos -MC(T ) is LOGCFL-complete.
In the case that no CTL-operators are used, NC1 -completeness of evaluating propositional formulae applies.
As a direct consequence (Theorem 3.1), model checking for CTL(T ) is P-complete for every nonempty T .
This shows that for the majority of interesting fragments, model checking CTL(T ) is inherently sequential and cannot be sped up using parallelism.
While all the results above can be transferred to ECTL (Theorem 4.1), CTL+ and ECTL+ exhibit different properties.
For both logics, the general model checking problem was shown to be complete for ap2 in [LMS01].
Here we proved that model checking fragments of CTL+ (T ) and ECTL+ (T ) for T a {A, E, X} remains tractable, while the existential and + the universal fragments of CTL+ pos (T ) and ECTLpos (T ) containing temporal operators other than X are complete for NP and coNP, respectively.
Instead of restricting only the use of negation as done in this paper, one might go one step further and restrict the allowed Boolean connectives in an arbitrary way.
One might, e.g., allow the exclusive-OR as the only propositional connective.
This has been done for the case of linear temporal logic LTL in [BMS+ 09], where the complexity of LTL-MC(T, B) for an arbitrary set T of temporal operators and B of propositional connectives was studied.
For example, restricting the Boolean connectives to only one of the functions AND or OR leads to many NL-complete fragments in the presence of certain sets of temporal operators.
However a full classification is still open.
Considering the CTL variants considered in this paper, plus CTLa , over arbitrary sets of Boolean operators would be one way to generalise our results.
In the case of CTL+ and  20  O. BEYERSDORFF, A. MEIER, M. MUNDHENK, T. SCHNEIDER, M. THOMAS, AND H. VOLLMER  EX, EF  LOGCFL-c.
AX, AG, O  EX, EF  O  NC1 -c.  P-c.  ALL  EX, EF, O  AX, AG  LOGCFL-c.
AX, AG  O = AF, AU, AR, EG, EU, ER  Figure 4: Complexity of CTLpos -MC(T ) for all sets T of CTL-operators (depicted as a afinite automatona where states indicate completeness results and arrows indicate an increase of the set of CTL-operators).
CTLa , where model checking is intractable [EL87, Sch03, LMS01], such a more fine-grained complexity analysis could help draw a tighter border between fragments with tractable and intractable model checking problems.
As for the corresponding satisfiability problems CTL-SAT(T, B) and CTLa -SAT(T, B), their complexity has been determinedawith respect to the set of Boolean operators, completelyain [MMTV09].
Throughout this paper, we have assumed that the formula and the Kripke structure are part of the input and can vary in size.
The case where the complexity is measured in terms of the size of the formula (or the Kripke structure), and the other component is assumed to be fixed, is usually referred to as specification complexity (or system complexity).
Our approach measures the joint complexity.
In applications, where usually the structure is significantly bigger than the specification, an analysis of the system complexity becomes interesting.
For system complexity, model checking for CTL and CTLa is already NLcomplete [BVW94, KVW00].
Still, the hope for a significant drop of system complexity justifies a systematic analysis of fragments of these logics.
References +  [BMM 09] O. Beyersdorff, A. Meier, M. Mundhenk, T. Schneider, M. Thomas, and H. Vollmer.
Model checking CTL is almost always inherently sequential.
In Proc.
16th International Symposium on Temporal Representation and Reasoning.
IEEE Computer Society Press, 2009.
[BMS+ 09] M. Bauland, M. Mundhenk, T. Schneider, H. Schnoor, I. Schnoor, and H. Vollmer.
The tractability of model checking for LTL: the good, the bad, and the ugly fragments.
In Proc.
5th Methods for Modalities, volume 231 of Electronic Notes in Theoretical Computer Science, pages 277a292, 2009.
[Bus87] S. R. Buss.
The Boolean formula value problem is in ALOGTIME.
In Proc.
19th Symposium on Theory of Computing, pages 123a131.
ACM Press, 1987.
[BVW94] O. Bernholtz, M. Vardi, and P. Wolper.
An automata-theoretic approach to branching-time model checking (extended abstract).
In Proc.
6th International Conference on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, pages 142a155.
Springer, 1994.
[CES86] E. Clarke, E. A. Emerson, and A. Sistla.
Automatic verification of finite-state concurrent systems using temporal logic specifications.
ACM Transactions on Programming Languages and Systems, 8(2):244a263, 1986.
[EC82] E. A. Emerson and E. M. Clarke.
Using branching time temporal logic to synthesize synchronization skeletons.
Science of Computer Programming, 2(3):241a266, 1982.
MODEL CHECKING CTL IS ALMOST ALWAYS INHERENTLY SEQUENTIAL a  21  [EH85]  E. A. Emerson and J. Y. Halpern.
Decision procedures and expressiveness in the temporal logic of branching time.
Journal of Computer and System Sciences, 30(1):1a24, 1985.
[EH86] E. A. Emerson and J. Y. Halpern.
aSometimesa and anot nevera revisited: on branching versus linear time temporal logic.
Journal of the ACM, 33(1):151a178, 1986.
[EL87] E. A. Emerson and C.-L. Lei.
Modalities for model checking: Branching time logic strikes back.
Science of Computer Programming, 8(3):275a306, 1987.
[KF09] L. Kuhtz and B. Finkbeiner.
LTL Path Checking is Efficiently Parallelizable.
International Colloquium on Automata, Languages and Programming, 2009.
[KVW00] O. Kupferman, M. Y. Vardi, and P. Wolper.
An automata-theoretic approach to branching-time model checking.
Journal of the ACM, 47(2):312a360, 2000.
[Lar95] F. Laroussinie.
About the expressive power of CTL combinators.
Information Processing Letters, 54(6):343a345, 1995.
[LMS01] F. Laroussinie, N. Markey, and P. Schnoebelen.
Model checking CTL+ and FCTL is hard.
In Proc.
4th Foundations of Software Science and Computation Structure, volume 2030 of Lecture Notes in Computer Science, pages 318a331.
Springer Verlag, 2001.
[Mar04] N. Markey.
Past is for free: on the complexity of verifying linear temporal properties with past.
Acta Informatica, 40(6-7):431a458, 2004.
[MMTV09] A. Meier, M. Mundhenk, M. Thomas, and H. Vollmer.
The complexity of satisfiability for fragments of CTL and CTLa .
International Journal of Foundations of Computer Science, 20(5):901a 918, 2009.
[Pap94] C. H. Papadimitriou.
Computational Complexity.
Addison-Wesley, Reading, MA, 1994.
[Pnu77] A. Pnueli.
The temporal logic of programs.
In Proc.
18th Symposium on Foundations of Computer Science, pages 46a57.
IEEE Computer Society Press, 1977.
[Ruz80] W. L. Ruzzo.
Tree-size bounded alternation.
Journal of Computer and System Sciences, 21:218a 235, 1980.
[RV97] K. Regan and H. Vollmer.
Gap-languages and log-time complexity classes.
Theoretical Computer Science, 188:101a116, 1997.
[SC85] A. Sistla and E. Clarke.
The complexity of propositional linear temporal logics.
Journal of the ACM, 32(3):733a749, 1985.
[Sch03] Ph.
Schnoebelen.
The Complexity of Temporal Logic Model Checking, volume 4 of Advances in Modal Logic, pages 393a436.
Kingas College Publications, 2003.
[Sch10] H. Schnoor.
The complexity of model checking for Boolean formulas.
Int.
Journal on Foundations of Computer Science, 21(3):289a309, 2010.
[Sel82] A. L. Selman.
Reductions on NP and P-selective sets.
Theoretical Computer Science, 19:287a304, 1982.
[Vol99] H. Vollmer.
Introduction to Circuit Complexity a A Uniform Approach.
Texts in Theoretical Computer Science.
Springer Verlag, Berlin Heidelberg, 1999.
This work is licensed under the Creative Commons Attribution-NoDerivs License.
To view a copy of this license, visit http://creativecommons.org/licenses/by-nd/2.0/ or send a letter to Creative Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or Eisenacher Strasse 2, 10777 Berlin, Germany