Data & Knowledge Engineering 44 (2003) 219a238 www.elsevier.com/locate/datak  Deciding LTL over Mazurkiewicz traces Benedikt Bollig a, Martin Leucker  b,*,1  a  b  Lehrstuhl faZur Informatik II, RWTH Aachen, 52074 Aachen, Germany Department of Computer and Information Science, University of Pennsylvania, Philadelphia PA 19104, USA Received 10 December 2001; accepted 3 July 2002  Abstract Linear temporal logic (LTL) has become a well established tool for specifying the dynamic behaviour of reactive systems with an interleaving semantics, and the automataatheoretic approach has proven to be a very useful mechanism for performing automatic veridZcation in this setting.
Especially alternating automata turned out to be a powerful tool in constructing edZcient yet simple to understand decision procedures and directly yield further on-the-dZy model checking procedures.
In this paper, we exhibit a decision procedure for LTL over Mazurkiewicz traces that generalises the classical automataatheoretic approach to a LTL interpreted no longer over sequences but certain partial orders.
SpecidZcally, we construct a (linear) alternating BaZ uchi automaton (ABA) accepting the set of linearisations of traces satisfying the formula at hand.
The salient point of our technique is to apply a notion of independence-rewriting to formulas of the logic.
Furthermore, we show that the class of linear and trace-consistent ABA corresponds exactly to LTL formulas over Mazurkiewicz traces, lifting a similar result from LaZ oding and Thomas formulated in the framework of LTL over words.
 2002 Elsevier Science B.V. All rights reserved.
Keywords: LTL; Model checking; Mazurkiewicz traces; Alternating automata  *  Corresponding author.
E-mail addresses: bollig@informatik.rwth-aachen.de (B. Bollig), leucker@cis.upenn.edu (M. Leucker).
1 Part of this work was done during the second authoras stay at BRICS and RWTH Aachen.
He is grateful for the hospitality and the overall support.
0169-023X/03/$ - see front matter  2002 Elsevier Science B.V. All rights reserved.
PII: S 0 1 6 9 - 0 2 3 X ( 0 2 ) 0 0 1 3 6 - 2  220  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  1.
Introduction Linear time temporal logic (LTL) as proposed by Pnueli [17] has become a well established tool for specifying the dynamic behaviour of distributed systems.
The traditional approach towards automatic program veridZcation is model checking specidZcations in LTL.
A basic feature of LTL has been that its formulas are interpreted over sequences.
Typically, such a sequence will model a computation of a system: a sequence of states visited by the system or a sequence of actions executed by the system during the course of the computation.
The automataatheoretic approach of Vardi and Wolper [22] for satisdZability checking has proven to be very useful and edZcient for performing the automatic program veridZcation.
In its purest form, this amounts to the construction of a BaZ uchi automaton accepting precisely the set of sequences that satisdZes the specidZcation expressed as an assertion of LTL.
In the last years, a shift towards the employment of alternating automata for dedZning decision procedures took place.
Alternating automata provide simple, edZcient, and easy to understand decision procedures.
They have proven to be useful for dedZning satisdZability algorithms for LTL over words [23], branching time logics [2,12] over dZnite transition systems, and the l-calculus over (indZnite) predZx-recognisable graphs [11].
The idea is that the states of the automaton are constructed essentially from the subformula closure of the specidZcation formula, and the automaton operates in a tableau-like fashion.
The satisdZability problem is then solved by checking whether the constructed automaton accepts any strings.
This approach forms the conceptual basis of many veridZcation algorithms.
Several tools (e.g., SPIN [8]) being employed in industry are built upon this translation from formulas to automata.
To improve performance, however, a number of substantial optimisations must be incorporated.
One observation is that the state space of the product automaton needs seldomly to be fully constructed.
Often the answer to the veridZcation problem can be established by investigating only a subset of states, and this subset might be considerably smaller than the entire state space.
This is the main idea underlying the so-called on-the-dZy veridZcation techniques.
To support on-the-dZy checking, an automaton corresponding to a formula should be dedZned in a topadown manner.
This means that, given a formula u and one of its subformulas w, a part of the automaton Au should be constructible without constructing Aw , where Ag denotes the automaton accepting the models of g. In this way, the automaton for a given formula and an underlying transition system may only be constructed partly viz if the model-checking or satisdZability question can already be answered by considering this part.
In many applications, the computations of a distributed system will constitute interleavings of the occurrences of causally independent actions.
Consequently, the computations can be naturally grouped together into equivalence classes where two computations are equated in case they are two didZerent interleavings of the same partially ordered stretch of behaviour.
It turns out that many of the properties expressed as LTL-formulas happen to have the so called aaall-or-noneaa property.
Either all members of an equivalence class of computations will have the desired property or none will do (aaleads to deadlockaa is one such property).
For verifying such properties, one has to check them for just one member of each equivalence class.
This is the insight underlying many of the partial-order based veridZcation methods (e.g., [16,21]).
As may be guessed, the importance of these methods lies in the fact that via these methods  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  221  the computational resources required for the veridZcation task can often be dramatically reduced.
Often, the equivalence classes of computations generated by a distributed system constitute objects called Mazurkiewicz traces [4,15].
They can be canonically represented as restricted labelled partial orders.
This opens up an alternative way of exploiting the non-sequential nature of the computations of a distributed system and the attendant partial-order based methods.
It consists of developing LTLs that can be interpreted directly over Mazurkiewicz traces.
In these logics, every specidZcation is guaranteed to have the aaall-or-noneaa property and hence can be subjected to the partial-order based reduction methods during the veridZcation process.
A number of LTLs to be interpreted over Mazurkiewicz traces directly (e.g., [1,19,20]) has been proposed starting with TrPTL [19].
There are several possible routes towards extending LTLs to traces.
TrPTL is based on locations, where one reasons explicitly about a distribution of computing agents cooperating through some communication structure given as an alphabet distribution.
Another option [1] is to view events as the partial-order computation points in time, and base the specidZcations upon the relationship between individual events.
Together, these paradigms constitute the local trace logics.
In contrast, in the global view of computations, condZgurations are seen as instantaneous snapshots of the system at hand.
In this sense, a condZguration is a global view capturing a collection of simultaneous local views.
The aarightaa temporal logic for traces should be equal in expressive power to dZrst-order logic for traces (FO).
It follows from [5] that such a logic would capture exactly those properties of LTL that have the aaall-or-noneaa property and hence are amenable to partial-order veridZcation.
However, none of the local logics are known to be expressively equivalent to FO.
This led Thiagarajan and Walukiewicz to dedZne the condZguration based LTrL [20], which they indeed prove equivalent to FO.
LTrL was later redZned [3] to a straightforward formulation of LTL for traces essentially extending Kampas Theorem [10] to the setting of traces.
While both the event based and location based logics have elegant (exponential-time) decision procedures smoothly extending the classical automataatheoretic approach to the setting of traces, no such smooth extension exists for global logics such as LTL.
The essence of this anomaly is the complications that arise as a consequence of the fact that the satisdZability problem for LTL has a non-elementary lower bound [24].
However, experience [9] has shown that decision procedures can still be useful in practice despite discouraging lower bounds.
Gastin et al.
[6,7] do give a direct decision procedure for LTL based on automata.
However, the construction of the automaton corresponding to a given LTL-specidZcation u proceeds by induction on u, thus in a bottomaup manner.
Hence it is not an extension of the classical automataa theoretic approach, and more important, it requires the construction of the full automaton, so optimisations such as on-the-dZy checking cannot be applied.
A further drawback is its high complexity.
While an exponential blow-up is unavoidable for nested until-formulas, the procedure has also an exponential blow-up for every negation.
Since nested until-formulas are rare in specidZcations but negations are typical for specifying unwanted behaviour, this limits the practical applicability of this procedure.
In this paper, we propose a decision procedure for LTL for traces directly extending the classical approach [23].
Our procedure is based upon an extended subformula closure and independence  222  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  rewriting of formulas of LTL.
We employ this to construct a tableau-style alternating BaZ uchi automaton (ABA) accepting the set of linearisations of traces satisfying the specidZcation at hand.
In this sense, our procedure dZlls the missing gap for global trace logics by extending the classical approach to this last remaining case.
Our procedure corresponds exactly to the version given in [23] when restricted to an empty independence relation.
Furthermore, our automata can be constructed on-the-dZy, which is crucial.
Last but not least, for the fragment of LTL without untilformulas, our procedure is exponential.
In [14], it was shown that word languages dedZnable by LTL-formulas over words correspond to the languages of linear ABA.
We prove that our construction yields a linear BaZ uchi automaton as well.
Furthermore, we show that our linear BaZ uchi automata accept trace-consistent languages.
Conversely, we show that the class of trace-consistent languages dedZnable by linear ABA coincides with the class of languages that are dedZnable by LTL-formulas over Mazurkiewicz traces for a given dependency relation.
In other words, LTL-dedZnable trace languages correspond to languages dedZnable by trace-consistent linear ABA.
The results of this paper will also appear in an extended version in [13].
In the next section, we recall Mazurkiewicz traces and some related notions that will play a crucial r^ ole for our present purposes.
In Section 3, we introduce the basic object of our study, LTL, and interpret it directly over the domain of Mazurkiewicz traces.
Following this, we give in Section 4 a brief account of ABA underlying our decision procedure to be presented in Section 5.
There we supply a proof of correctness of our construction before giving a few concluding remarks in Section 6.
2.
Mazurkiewicz traces A (Mazurkiewicz) trace alphabet is a pair AdegR; IA, where R, the alphabet, is a dZnite set and I  R fi R is an irredZexive and symmetric independence relation.
Usually, R consists of the actions performed by a distributed system while I captures a static notion of causal independence between actions.
We dedZne D Az AdegR fi RA  I to be the dependency relation, which is then redZexive and symmetric.
For the rest of the section, we dZx a trace alphabet AdegR; IA.
We will use aIb to denote that the actions a and b are independent, i.e., that Adega; bA 2 I, and use similar notation for Adega; bA 2 D. We extend the notion to sets of actions X , Y  R, and let XIY denote the fact that each pair of actions a 2 X and b 2 Y is independent.
Moreover, XDY will denote that X is dependent on Y, i.e., that there exists a pair of actions a 2 X and b 2 Y with a and b dependent.
For convenience, we will write fagIY as aIY etc.
For the purpose of interpreting LTL over traces, we will adopt the viewpoint that traces are restricted labelled partial orders of events and hence have an explicit representation of causality and concurrency.
Let T Az AdegE; 6 ; kA be a R-labelled poset.
In other words, AdegE; 6 A is a poset and k : E !
R is a labelling function.
k can be extended to subsets of E in the straightforward manner.
For e 2 E, we dedZne # e Az fx 2 Ejx 6 eg and " e Az fx 2 Eje 6 xg.
We let U be the covering relation given by xUy idZ x < y and for all z 2 E, x 6 z 6 y implies x Az z or z Az y.
B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  223  A (Mazurkiewicz) trace over AdegR; IA is a R-labelled poset T Az AdegE; 6 ; kA satisfying: aV # e is a dZnite set for each e 2 E. aV For every e, e0 2 E, eUe0 implies kAdegeADkAdege0 A. aV For every e, e0 2 E, kAdegeADkAdege0 A implies e 6 e0 or e0 6 e. We shall let TRAdegR; IA denote the class of traces over AdegR; IA.
As usual, a trace language L is a subset of traces, i.e., L  TRAdegR; IA.
Throughout the paper we will not distinguish between isomorphic elements in TRAdegR; IA.
We will refer to members of E as events.
Let T Az AdegE; 6 ; kA be a trace over AdegR; IA.
The dZnite predZxes of T, to be called condZgurations, will play a crucial r^ ole in S what follows.
A condZguration of T is a dZnite subset of events c  E with # c Az c where # c Az e2c # e. The set of condZgurations of T will be denoted CT .
Trivially, ; 2 CT for any trace T. CT can be equipped with a natural transition relation !T  CT fi R fi CT given a by: c !T c0 idZ there exists an e 2 E such that kAdegeA Az a, e 62 c and c0 Az c [ feg.
CondZgurations of CT are the trace-theoretic analogues of dZnite predZxes of strings.
As will become apparent in Section 3, the formulas of LTL are to be interpreted at condZgurations of traces.
In its original formulation [15], Mazurkiewicz introduced traces as certain equivalence classes of strings, and this correspondence turns out to be essential to our developments here.
To bring this out, let R be the set of dZnite strings over R and Rx be the set of (countably) indZnite strings generated by R with x Az f0; 1; 2; .
.
.g.
We set R1 Az R [ Rx and denote the empty word by e. We let w, w0 range over Rx and u, v with or without primes range over R .
Finally, we take prf(w) to be the set of dZnite predZxes of w and let alphAdegwA denote the set of actions occurring in w. Next, let T Az AdegE; 6 ; kA 2 TRAdegR; IA.
Then w 2 R1 is a linearisation of T idZ there exists a map q: prfAdegwA !
CT , such that the following conditions are met: aV qAdegeA Az ;.
a aV qAdegvA !T qAdegvaA for each va 2 prfAdegwA.
aV For every e 2 E, there exists some u 2 prfAdegwA such that e 2 qAdeguA.
The function q will be called a run map of the linearisation w. Note that the run map of a linearisation is unique.
In what follows, we shall take linAdegT A to be the set of linearisations of the trace T. A set p  R is called a D-clique idZ p fi p  D. The equivalence relation  R1 fi R1 induced by I is given by: w  w0 idZ wp Az w0 p for every D-clique p. Here and elsewhere, if X  R, wX is the sequence obtained by erasing from w all occurrences of letters in R  X .
We take A"w to denote the -equivalence class of w 2 R1 .
It is not hard to show that elements of TRAdegR; IA and -equivalence classes are two representations of the same object: A labelled partial-order T 2 TRAdegR; IA is represented by linAdegT A and vice versa (see [4] for a proof of this fact and a more thorough account of traces).
We exploit this duality of representation and let Tw denote the trace corresponding to A"w .
Moreover, for each v 2 prfAdegwA we will use cv to denote the condZguration of CTw given by qAdegvA.
To illustrate these concepts, consider the trace alphabet AdegR; IA with R Az fa; b; dg and I Az fAdega; bA; Adegb; aAg.
An example trace T over AdegR; IA is depicted in Fig.
1 with smaller elements (with respect to 6 ) appearing below larger elements.
Furthermore, it can easily be veridZed that  224  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  Fig.
1.
A trace over AdegR; IA.
abdbabd 2 linAdegT A so T Az Tabdbabd , but adabbbd 62 linAdegT A.
The condZguration c 2 CT consists of the dZrst two aas, dZrst d, dZrst two bas and is also denoted by cabdab , which is identical to cbadab as abdab  badab.
We transfer considering traces as equivalence classes to the level of languages and call a word language L  Rx trace-consistent if for all words w, w0 2 Rx with w  w0 , it holds w 2 L idZ w0 2 L. 3.
LTL for Mazurkiewicz traces In this section, we bring out the syntax and semantics of the linear time temporal logic LTL, which will be our basic object of study.
It was originally introduced for strings by Pnueli [17].
It was later equipped with a trace semantics [20] and proved expressively equivalent to dZrst-order logic for traces by Diekert and Gastin [3], and this is the version we will consider here.
The formulas of LTL are parameterised by a trace alphabet AdegR; IA and are dedZned inductively as follows: LTLAdegR; IA ::Az ttj:uju _ wjhaiujuUw;  a 2 R:  Formulas of LTLAdegR; IA are interpreted over condZgurations of traces over AdegR; IA.
More precisely, given a trace T 2 TRAdegR; IA, a condZguration c 2 CT , and a formula u 2 LTLAdegR; IA, the notion of T , c  u is dedZned inductively via: aV aV aV aV aV  T ; c  tt.
T ; c  :u idZ T ; c 2 u. T ; c  u _ w idZ T ; c  u or T ; c  w. a T ; c  haiu idZ there exists a c0 2 CT such that c !T c0 and T ; c0  u. T ; c  uUw idZ there exists a c0 2 CT with c  c0 such that T ; c0  w and all c00 2 CT with c  c00  c0 satisfy u.
We will freely use the standard abbreviations such as e.g., ff Az :tt, u ^ w Az :Adeg:u _ :wA.
Furthermore, we sometimes abbreviate T ,;  u by T  u.
All models of a formula u 2 LTLAdegR; IA constitute a subset of TRAdegR; IA, thus a language.
It is denoted by LAdeguA and is called the language  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  225  dedZned by u.
Furthermore, every formula dedZnes an x-language viz the set fw 2 linAdegT AjT  ug, which is also indicated by LAdeguA.
A simple example of a formula of LTL is u Az haihbiw.
Note that for the trace of Fig.
1 it holds that T  u if and only if T ,cab  w. Moreover, u is equivalent to u0 Az hbihaiw over this particular trace alphabet because aIb, i.e., the models of u and u0 and coincide.
Such considerations will play a prominent r^ ole when we dedZne the decision procedure in Section 5.
For bringing out the decision procedure itself, it will be convenient to assume that the syntax of LTL is augmented with an indexed until operator UUZ w where Z  R and U Az fuY11 ; .
.
.
; uYnn g is a dZnite set of indexed formulas with Yi  R. Formally, it will have the following semantics: aV T ; c  UUZ w idZ there exists a c0 2 CT with c  c0 such that T ; c0  w and kAdegc0  cAIZ, and, for each 1 6 i 6 n and every c00 with c  c00  c0 and kAdegc00  cAIYi , it holds c00  ui .
Hence, a trace satisdZes the formula UUZ w in the condZguration c idZ there is a future condZguration c0 satisfying w and all the actions from c to c0 are independent from the actions in Z.
Furthermore, the condZgurations between c and c0 which can be reached from c by performing actions independent of Yi all satisfy ui .
Note that uUw can be identidZed with fu; gU; w and we will not always make this distinction explicit.
It is not hard to see that UUZ w is expressible within FO, so this indexed modality is derivable within LTL itself.
We remark that, in case of the empty independence relation, LTLAdegR; IA and LTL interpreted over words (denoted by LTLAdegRA) coincide in the expected manner.
Thus, we identify LTL over words with LTLAdegRA, especially in the proof of Theorem 13, and save the work for introducing LTL over words formally.
4.
Alternating BaZ uchi automata Alternating automata extend non-deterministic automata by universal choices.
The transition function denotes no longer a set of possible next states but a (positive) Boolean combination.
In this section, we recall the notion of alternating automata along the lines of [23] where ABA are used for model checking LTL over strings.
However, we modidZed the dedZnition of a run to redZect the ideas presented in [14].
For a dZnite set X of variables, let BAz AdegX A be the set of positive Boolean formulas over X, i.e., the smallest set such that aV X  BAz AdegX A aV tt, ff 2 BAz AdegX A aV u, w 2 BAz AdegX A ) u ^ w 2 BAz AdegX A, u _ w 2 BAz AdegX A.
In the following, we assume for every positive Boolean formula that it is in disjunctive normal form and that it is reduced with respect to idempotence and commutation.
Hence, for a set X with jX j jX j elements, the size of BAz AdegX A is bounded by 22 .
This can easily be seen by considering the formulas as sets of sets.
226  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  We say that a set Y  X satisdZes (or is a model of) a formula u 2 BAz AdegX A idZ u evaluates to tt when the variables in Y are assigned to tt and the members of X n Y are assigned to ff.
A model is called minimal if none of its proper subsets is a model.
For example, fq1 ; q3 g as well as fq2 ; q3 g are minimal models of the formula Adegq1 _ q2 A ^ q3 .
Later in our construction, logical formulas will take over the r^ ole of states.
Therefore, we should formally distinguish between disjunctions of formulas and disjunctions of states.
However, to simplify our presentation, we identify these disjunctions when the context makes clear which one is meant.
In particular, given a formula u in disjunctive normal form, u Az _ ^ uij where no uij is a (top level) disjunction or conjunction, we identify u with the positive Boolean combination of states uij .
To avoid confusion, we sometimes write stAdeguA to denote fuij j _ ^uij g. An ABA over an alphabet R is a tuple A Az AdegQ; R; d; q0 ; F A such that Q is a dZnite non-empty set of states, q0 2 Q is an initial state, F  Q is a set of accepting states and d : Q fi R !
BAz AdegQA is a transition function.
Because of universal quantidZcation, a run over an indZnite string is no longer a sequence but a labelled directed acyclic graph.
A nodeas label redZects one of the current states of the automaton, and the edges redZect transitions of the automaton with respect to the input string.
Hence, this graph should have a unique aarootaa labelled with q0 .
Furthermore, it has to be divisible into aalevelsaa i 2 N corresponding to the ith input letter.
Every node except the root must have a aapredecessoraa.
For a node v, the labels of nodes of level i Az 1 connected with v should further be a model for the transition in state lAdegvA reading the ith letter.
More precisely: A run over an indZnite string w Az a0 a1 .
.
.
2 Rx is a Q-labelled directed acyclic graph AdegV ; EA such that there exist labellings l : V !
Q and h : V !
N which satisfy the following properties.
aV aV aV aV aV  h1 Adeg0A S Az fvg with lAdegvA Az q0 .
E  i2N Adegh1 AdegiA fi h1 Adegi Az 1AA.
For every v0 2 V with hAdegv0 A P 1, fv 2 V jAdegv; v0 A 2 Eg 6Az ;.
For every v; v0 2 V , v 6Az v0 , lAdegvA Az lAdegv0 A implies hAdegvA 6Az hAdegv0 A.
For every v 2 V , flAdegv0 AjAdegv; v0 A 2 Eg is a minimal model of dAdeglAdegvA; ahAdegvA A.
A run AdegV ; EA is accepting if every maximal dZnite path ends in a node v 2 V with dAdeglAdegvA; ahAdegvA A Az tt and every maximal indZnite path, wrt the labelling l, visits at least one dZnal state indZnitely often.
The language LAdegAA of an automaton A is determined by all strings for which an accepting run of A exists.
Let us dedZne a subclass of alternating automata corresponding to LTL formulas over words, as shown in [14].
The transition graph of an ABA A Az AdegQ; R; d; q0 ; F A is the graph AdegQ; EA such that Adegq; q0 A 2 E idZ there is an action a such that for dAdegq; aA Az _ ^ qij , the state q0 is one of the qij .
2 The automaton is called linear idZ its transition graph has only trivial cycles.
Finally, we call an ABA A trace-consistent if its language LAdegAA is trace-consistent.
We will show that linear trace-consistent automata correspond to LTL formulas over Mazurkiewicz traces.
Obviously, every BaZ uchi automaton can be turned into an equivalent (wrt the accepted language) ABA.
Vice versa, for every ABA, an equivalent BaZ uchi automaton can be constructed with  2  Silently considering tt and ff as states here.
B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  227  an exponential blow-up.
The construction is described for example in [23].
Hence, it is easy to see that the emptiness problem for ABAs is exponential in its number of states.
5.
A decision procedure for LTL We have now set the scene to bring out our decision procedure for LTL.
Our procedure generalises the classical approach by constructing an ABA Au accepting the set of linearisations of traces satisfying a given formula u.
The states of this automaton are derived from an extended subformula closure, which we dZrst dedZne.
Following this, we dedZne a notion of independencerewriting of such formulas, and this will eventually become the transition relation of Au .
We pin down the details of our construction and give a proof of correctness.
Then we consider the complexity of our decision procedure and point out the correspondence between linear traceconsistent alternating automata and LTL over Mazurkiewicz traces.
5.1.
The construction In essence, we will construct an automaton Au that accepts a string w 2 Rx whenever the corresponding trace Tw satisdZes u.
To appreciate the developments to come, we commence with a small example.
Consider the example formula u Az haihbiw of Section 3.
Suppose that w is of the form abv for some v 2 Rx .
It is then not hard to see that Tw , ;  u if and only if Tw ; ca  hbiw.
Consider now instead w0 Az bav.
Since the underlying domain is traces, Tw0 might still satisfy u even though the dZrst action is a b and not an a, because aIb.
In fact, Tw0 , ;  u exactly when Tw0 ; cb  haiw.
In this sense, the proof obligation at the empty condZguration, aahaihbiwaa, has been transformed by b to the proof obligation aahaiwaa at cb ; the a-action still has to be witnessed, but the present b has been matched.
(Note by the way that either both or none of w and w0 should be accepted, because w  w0 and hence Tw Az Tw0 .)
In edZect, our automaton proceeds in this way by aaindependence-rewritingaa the proof obligations by the actions read.
The state space thus consists of all subformulas together with formulas obtained by transformations as described above.
We will call this set the extended closure of u. DedZnition 1.
Let g be a formula of LTL.
We take ecl(g) to be the least set that satisdZes the following: aV aV aV aV  g itself is contained in its closure.
For u _ w 2 eclAdeggA, it also contains the closure of u and of w. For haiu 2 eclAdeggA, it also contains the closure of u as well as haiu0 for every u0 2 eclAdeguA.
For u 2 eclAdeggA, it also contains :u 2 eclAdeggA.
We identify ::u with u.
Hence, eclAdeggA is closed under negation.
aV For uUw 2 eclAdeggA, the closure contains eclAdeguA as well as eclAdegwA.
Furthermore, for all Z  R, all w0 2 eclAdegwA, and all U  fu0Y ju0 2 eclAdeguA; Y  Rg the closure contains UU Z w0 .
aV The closure is closed under positive Boolean combinations, i.e., BAz AdegeclAdeggAA  eclAdeggA.
Intuitively, the extended closure of a formula u contains all formulas which may be obtained by substituting a subformula w of u by w0 where w0 is a positive Boolean combination of formulas  228  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  derived from w by applying this rule.
This is because our automaton will be dedZned in the way that before it is considering a formula u it may consider a subformula w of u, transforming this into a positive Boolean combination of new formulas w0 .
This result is processed in the way that w is substituted by w0 within u.
We assume that all positive Boolean formulas are in disjunctive normal form and moreover that they are reduced wrt idempotence and commutation.
With these assumptions we can prove the following crucial result.
Proposition 2. eclAdeggA is a finite set for each formula g of LTL.
Proof.
The proof proceeds by a standard induction.
The claim is obvious for atomic formulas.
For g Az haiu, the extended closure of g contains the extended closure of u and for every element u0 of eclAdeguA also haiu0 .
Thus, we get jeclAdeguAj !
2 elements.
Since the extended closure contains for every element also a negated one, we get another factor 2.
Now, positive Boolean combination yields jeclAdeguAj!2!2 .
For g Az fuY11 ; .
.
.
; uYnn gUZ w, a double exponential blow-up.
Altogether, we have jeclAdeggAj 6 22 it can be veridZed that jeclAdeggAj is bounded by  P fi n  22  2  2  iAz1  AdegjeclAdegui Aj!2jRj A  jeclAdegwAj !2jRj !22  !2  :  The three factors are upper bounds for the derivatives of f!
!
!g, UZ , and w, resp., and the powers bound their positive Boolean combination.
 We will refer to formulas of this set as extended formulas.
Furthermore, we will say that a formula is a diamond-formula in case it is of the form haiu for some extended formula u and some a 2 R. In a similar vein, we let the until-formulas consist of those of the form UUZ w with U being a dZnite set of extended formulas, w a single extended formula and Z  R. For extended formulas, we will make use of the important notion of its dual, which is obtained as usual by applying de Morganas laws to push negations inwards as far as possible.
DedZnition 3.
The dual of an (extended) formula is given inductively as follows: aV aV aV aV aV aV  tt Az ff, ff Az tt.
:u Az u. u _ w Az u ^ w, u ^ w Az u _ w. haiu Az :haiu.
uUw Az :AdeguUwA.
UUZ w Az :AdegUUZ wA.
We are now set to introduce the operator k  k , which will constitute the transition relation of the alternating automaton.
Essentially, kuka is to be thought of as the independence-rewriting of u by the action a.
It follows from the intuition conveyed earlier that it should be the case that khaiuka is u.
Then, for the case where aIb, khbiuka Az hbiu0 where u0 Az kuka .
Of course, whenever aDb and the actions  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  229  are not identical, then khbiuka must be ff because b cannot be a next action.
DedZnition 4 formally captures this intuition.
DedZnition 4.
For each extended formula u and each action a, the operator kuka yields a formula of BAz AdegeclAdeguAA and is dedZned inductively via: kttka Az tt: ku _ wka Az kuka _ kwka : k:uka Az kuka : 8 <u khbiuka Az hbikuka : ff  if a Az b if aIb if aDb; a 6Az b:  Note that since eclAdeggA is closed under positive Boolean combination, we have eclAdeggA Az BAz AdegeclAdeggAA.
We now only need to specify the case of kUUZ wka .
This turns out to be inherently more complex, and before providing the precise dedZnition, we carefully analyse the semantics of the indexed until modality in Fig.
2.
For this purpose, consider some trace T be given and suppose c; c0 2 CT such that c  c0 .
Furthermore, let c00 be a condZguration between c and c0 (Fig.
2(i)).
Suppose, we can augment c by an a-labelled event e to obtain a successor condZguration c000 of c, a i.e., c!c000 .
Then c000  c00  c0 or c000 6 c00 but c000  c0 or c000 6 c0 , as shown in Fig.
2(a)a(c) resp.
In case (b), it is obvious that kAdegc00  cAIa and for case (c), we have kAdegc0  cAIa (as well as kAdegc00  cAIa).
The situation shown in Fig.
2 can, in other words, be described in the following manner: The action a is (a) neither in the future of c00 nor of c0 (case (a)), (b) in the future of c00 (case (b)), or (c) in the future of c00 as well as of c0 (case (c)).
Consider a formula uUw, which is to be checked in the condZguration c. In case (c), we have to employ a for verifying w as well as u.
Note that for case (c), we get two subcases depending upon whether c0 Az c or c0 # c. While w is not relevant to the dZrst case, u is required to hold in the  Fig.
2.
CondZguration and actions.
230  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  condZgurations between c and c0 .
Note that these condZgurations are reached by actions independent of a.
For case (a), we have to employ a for verifying u in condZguration c but not for c00 .
In case (b), we have to prove u considering a in the condZguration c00 , which might be equal to c as well as didZerent from c. Note that in the latter case, every event of c00  c is independent of a. Consequently, we dedZne the rewriting operator for a formula UUZ w as follows.
DedZnition 5 (extends DedZnition 4).
Let n o W1 Az kwka W2 Az kukYa [fag juY 2 U UZ[fag kwka : Moreover, we set W0 Az W1 _ W2 .
Let n o kUka Az kukaY [fag juY 2 U [ uY juY 2 U; aIY and U1 Az ^uY 2U kuka  U2 Az kUka UZ w  and U0 Az U1 ^ U2 .
Then we dedZne   0 W if aDZ; Z kUU wka Az W0 _ U0 else aIZ: Note that W0 captures case (c) in which an action a is employed for verifying w under the assumption that c0 Az c AdegW1 A or not (W2 ).
U0 covers the idea that a is not in the future of c0 but is employed for verifying the obligations in U.
It is not hard to verify that k  k is well-dedZned.
However, to show the correctness of our construction, the following proposition is essential.
Suppose that we have given one linearisation of a trace and one formula and we want to check the formula wrt the trace obtained from the linearisation.
According to the following proposition it is possible to consider the word action by action and to modify the formula according to the rewriting operator.
Proposition 6.
Let g be any formula of LTLAdegR; IA.
Then for all w 2 Rx and for all v 2 R , a 2 R, w0 2 Rx with vaw0  w Tw ; cv  g if and only if Tw ; cva  kgka : Proof.
The proof proceeds by induction on the formula g. We only show the most important cases as the other cases follow in a similar manner.
The cases where g Az tt or g Az ff are trivial.
Suppose g Az u _ w. Then Tw ; cv  u _ w means by dedZnition that Tw ; cv  u or Tw ; cv  w. By induction, this is equivalent to Tw ; cva  kuka or Tw ; cva  kwka , which is equivalent to Tw ; cva  ku _ wka by dedZnition of the rewrite operator.
Suppose g Az :u.
By dedZnition, Tw ; cv  :u idZ not Tw ; cv  u.
Induction yields Tw ; cva 2 kuka , which means Tw ; cva  :kuka .
The dual of a formula is obviously logically equivalent to the negation of the formula so that the previous statement is equivalent to Tw ; cva  kuka .
B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  231  Suppose g Az hbiu.
By dedZnition, Tw ; cv  hbiu if and only if there is a condZguration c0 such that b cv !
c0 Az cvb and Tw ; c0  u.
We consider three didZerent cases: aV b Az a: then c0 Az cva .
Hence Tw ; cva  u. b a aV bAz 6 a, bDa: then cv !
c0 and cv !
cva .
However, then w is not a linearisation of the trace, which is a contradiction.
aV bIa: Tw ; cvb  u is by induction equivalent to Tw ; cvba  kuka .
Since aIb, this means Tw ; cvab  kuka , which is equivalent to Tw ; cva  hbikuka .
Putting together all the cases we get that Tw ; cv  hbiu if and only if Tw ; cva  khbiuka .
The most involved case is g Az UUZ w. Let U Az fuY11 ; .
.
.
; uYNN g. Recall that Tw ; cv  fuY11 ; .
.
.
; uYNN gUZ w if and only if 9x 2 R ; y 2 Rx ; aw0  xy; xIZ; such that Tw ; cvx  w; and 8i 2 f1; .
.
.
; N g; 8x1 ; x2 2 R with x1 x2  x; x1 IYi ; x2 6Az e; it holds Tw ; cvx1  ui : We consider here only the case where aIAdegYi [ ZA.
The other cases follow similarly.
Let us dZrst discuss the implication from left to right: we consider the following cases for x: aV x Az e: then Tw ; cvx  w means Tw ; cv  w, which implies by induction Tw ; cva  kwka .
This shows AdegW1 A. aV x 6Az e, a 62 alphAdegxA: We consider the cases for w and ui simultaneously. )
I:H :  ) ) )  aIx Tw ; cvx  w Tw ; cvxa  kwka Tw ; cvax  kwka 9x 2 R ; xIAdegZ [ fagA Tw ; cvax  kwka  ) I:H :  ) ) )  aIx1 Tw ; cvx1  ui Tw ; cvx1 a  kui ka Tw ; cvax1  kui ka 8x1 ; x2 2 R ; x1 x2  x; x1 IAdegYi [ fagA x2 6Az e; Tw ; cvax1  kui ka  Hence, Tw ; cva  fkukaY [fag juY 2 UgUZ[fag kwka , which shows (W2 ).
aV x 6Az e, a 2 alphAdegxA: We easily see that x  ax0 and a, x0 IZ and Tw ; cvax0  w. We will show AdegU1 A and AdegU2 A.
Let us consider x1 .
If x1 Az e then Tw ; cv  ui implies by induction Tw ; cva  kui ka .
If x1 6Az e and a 62 alphAdegx1 A, we see that aIx1 and x1 IYi .
Hence, x1 IAdegYi [ fagA.
Now, Tw ; cvx1  ui yields by induction Tw ; cvx1 a  kui ka proving Tw ; cvax1  kui ka since aIx1 .
For the case x1 6Az e but a 2 alphAdegx1 A, we see that x1  ax01 and Tw ; cvax01  ui .
Summing up the cases for x1 , we get Tw ; cva  kUka UZ w, which shows AdegU2 A, and Tw ; cva  kuka for all uY 2 U, which shows AdegU1 A.
Altogether, we showed that W0 or U0 hold in the until case proving the aaifaa-part.
Now, let us consider the implication from right to left: suppose Tw ; cva  kUUZ wka , i.e., Tw ; cva  W1 _ W2 _ U0 :  232  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  We discuss the disjunction by drawing the conclusions of each formula aV Tw ; cva  kwka : this implies by induction that Tw ; cv  w. Hence, Tw ; cv  UUZ w. Y [fag juY 2 UgUZ[fag kwka : Then there exist x; y, xIAdegZ [ fagA, w  vaxy such that aV Tw ; cva  fkuka Tw ; cvax  kwka .
Since xIa also Tw ; cvxa  kwka , which yields by induction Tw ; cvx  w. We further know that for every proper predZx (modulo ) x1 of x with x1 IAdegY [ fagA, we have Tw ; cvax1  kuka .
Then Tw ; cvx1 a  kuka and, by induction, Tw ; cvx1  u.
Hence, Tw ; cv  UUZ w. aV Tw ; cva  ^uY 2U kuka ^ kUka UZ w: We dZrst obtain by induction that Tw ; cv  u for every uY 2 U.
Let us consider Tw ; cva  AdegfkukYa [fag juY 2 Ug [ fuY juY 2 U; aIY gAUZ w: It implies that there is an x0 , independent of Z, such that Tw ; cvax0  w. Since we are in the case of aIZ, we conclude that there is an x, xIZ(x  ax0 ) such that Tw ; cvx  w. Now, consider x1 x2  x, x2 6Az e. For every x1 IAdegY [ fagA, x1 a predZx of x0 , we know Tw ; cvax1  kuka and, by induction, Tw ; cvx1  u.
For x0 Az e, we already know Tw ; cv  u.
For x1 IY and x1 Da, we obtain x1  ax01 , x01 IY , since cva is a valid condZguration.
By Tw ; cvax01  u we deduce Tw ; cvx1  u.
Altogether, this shows Tw ; cv  UUZ w. This concludes the proof.
 We can now dZnally bring the dedZnition of the ABA Au corresponding to a formula u 2 LTLAdegR; IA as follows.
DedZnition 7.
Given a formula u 2 LTLAdegR; IA, the ABA Au is the tuple AdegQ; R; d; q0 ; F A where aV aV aV aV  Q Az eclAdeguA is the set of states.
dAdegq; aA Az kqka is the transition function.
q0 Az u is the initial state.
F Az f:wj:w 2 eclAdeguAg is the set of accepting states.
Note that we dedZned the set of dZnal states to be all negated formulas.
The intuitive idea is that failing to prove a proposition indZnitely often sudZces to assume that its negation is true.
In the work of Vardi [23], one could likewise take all negated formulas as dZnal states.
Since in the case of LTL over words, only until-formulas may occur indZnitely often, the set of dZnal states is there restricted to negated until-formulas.
The correctness of the construction is summarised in the following theorem, which is the main contribution of the paper.
Theorem 8.
Let u be a formula of LTLAdegR; IA and let its ABA be given as Au Az AdegQ; R; d; q0 ; F A.
Then w 2 LAdegAu A if and only if Tw ; ;  u for every w 2 Rx .
In other words, LAdegAu A Az LAdeguA.
B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  233  Proof.
For w 2 Rx , we have to show that Au has an accepting run on w idZ Tw  u.
Note that every run has (at most) three types of paths: aV dZnite paths ending in tt, aV indZnite paths on which from some point on every node is labelled by an until- or diamondformula, or aV indZnite paths on which from some point on every node is labelled by a negated until- or diamond- formula.
Let us give a sketch of the proof.
For w 2 eclAdeguA and w Az aw0 2 Rx , let dAdegw; wA be the extension of d dedZned by dAdegw; aw0 A Az dAdegdAdegw; aA; w0 A.
By Proposition 6, dAdegu; wA Az dAdegdAdegu; aA; w0 A Az dAdegkuka ; w0 A and Tw ; cfi  u idZ Tw ; ca  kuka .
Now, consider an accepting run of Au .
Its dZnite paths end in tt, thus all proof obligations are proved.
Conversely, a run should be accepted only if the dZnite paths end in tt, i.e., that all proof obligations are proved.
Now, let us consider the indZnite paths of a run.
These can only occur by unwinding a (negated) until-formula indZnitely often or by reading actions independent of the one given within a diamond-formula.
This can be accepted idZ the underlying until-formula or diamond-formula is preceded by a negation.
This is captured by the acceptance condition for indZnite paths given by the dZnal states of the automaton.
 5.2.
State space To simplify the presentation, we have dedZned the state space of our automaton in a straightforward manner and presented a simple argument to show that it is dZnite.
Thus, we indeed obtained a decision procedure.
Now, let us take a closer look to the states that are really needed in our construction.
In other words, let us consider the states that are reachable from the initial state.
Given a formula u 2 LTLAdegR; IA, a state w of Au , and a set Y  R, let reachY AdegwA denote the set of states reachable from w in Au by words whose actions are independent of Y.
More precisely, reachY AdegwA Az fw0 j9w 2 R ; wIY : w0 2 stAdegdAdegw; wAAg; where d is the extension of d dedZned in the obvious manner.
Proposition 9.
Given u 2 LTLAdegR; IA, we get upper bounds for the number of states reachable from a state of Au wrt Y inductively as follows: aV aV aV aV aV  jreachY AdegttAj Az 1 jreachY AdegffAj Az 1 jreachY Adeg:wAj Az jreachY AdegwAj jreachY Adegw1 _ w2 Aj 6 jreachY Adegw1 Aj Az jreachY Adegw2 Aj jreachY Adegw1 ^ w2 Aj 6 jreachY Adegw1 Aj Az jreachY Adegw2 Aj   jreachY AdegwAj Az jreachY [fag AdegwAj Az 1 aV jreachY AdeghaiwAj 6 jreachY [fag AdegwAj Az 1  if aIY if aDY  234  aV  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  jreachY AdegfuY11 ; .
.
.
; uYnn gUZ wAj 6 22  Pn  iAz1  AdegjreachY Adegui Aj!2jRj A  !
2jRj !
22  jreachY AdegwAj  :  Proof.
The obvious cases are if the state formula is tt or dZ.
Since negation is shifted inwards by the dual operator , the states reachable from :w are the same states as reachable from w, except that every state is preceded by :.
Thus, the cardinality is the same.
Given haiw, assume a to be independent of Y.
Reading an action dependent on but didZerent from a (and independent of Y) yields the state dZ and in our formula the 1.
Reading a yields the state w, thus, the states reachable from w are obviously reachable from haiw AdegjreachY AdegwAjA.
The last possibility is reading an action b independent of a and Y.
This yields formulas of the form haiw0 where w0 is obtained by rewriting w by actions independent of Y and a.
Since haiw0 distributes over disjunctions and conjunctions, we get the same number of states as obtained by considering the states reachable from w by words independent of Y [ fag (jreachY [fag AdegwAj).
The bound for until-formulas follows by a simple combinatorial argument.
Before and after the U within an until-formula, only positive Boolean combinations of derivations of respectively U and w may occur, and the U is indexed with subsets of R.  Let us call the fragment of LTL dedZned without until-formulas HennessyaMilner fragment.
Proposition 10.
Given a formula w from the HennessyaMilner fragment of LTLAdegR; IA, we obtain reachY AdegwA 6 jwjjRY j .
Proof.
The proof follows a simple induction of which we pick out two cases: aV Applying Proposition 9, the induction hypothesis, and the binomial formula, jRY j  jreachY Adegw1 _ w2 Aj 6 jreachY Adegw1 Aj Az jreachY Adegw2 Aj 6 jw1 j  jRY j  Az jw2 j  3  6 Adegjw1 j Az jw2 j Az 1A  jRY j  :  aV Assuming aIY , jreachY AdeghaiwAj 6 jreachY AdegwAj Az jreachY [fag AdegwAj Az 1 6 jwjjRY j Az jwjjRY j1 Az 1 6 Adegjwj Az 1AjRY j :    Due to the exponential blow-up the construction of an equivalent BaZ uchi automaton for Au causes, we conclude.
Theorem 11.
Checking satisfiability of a formula from the HennessyaMilner fragment of LTLAdegR; IA can be done in exponential time.
5.3.
LTL and linear automata Now we characterise LTLAdegR; IA as equivalent to that subclass of ABA that we called traceconsistent linear ABA, and we start observing the linearity of the above construction.
3  Adega Az bAn Az   fi n ni i a b. iAz0 i  Pn  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  235  Proposition 12.
Given u 2 LTLAdegR; IA, Au is linear.
Proof.
We have to show that the transition function only admits trivial cycles.
Therefore we dedZne a well-founded strict ordering relation 4 & on the states of our automaton and show that kwka yields a Boolean combination of strictly smaller states or w. For a formula g 2 LTLAdegR; IA, & eclAdeggA fi eclAdeggA is inductively dedZned by aV aV aV aV aV  u & haiu, haiu & haiw if u & w, u & :w if u & w, wY11 & wY22 if w1 ' w2 and Y1 ( Y2 and one of the orderings is strict, i.e., w1 & w2 or Y1 )Y2 , _ ^ uij & _ ^ wij if fuij g ) fwij g where ) is the (strict) (multi-)set ordering induced by &, i.e., M1 ) M2 idZ there exist a set X and an element m 2 M2 with m0 & m for all m0 2 X such that M1 Az AdegM2  fmgA [ X .
In other words, a set M1 is smaller than M2 if an element of M2 is replaced by a set of smaller elements resulting in M1 .
aV w0 & UUZ w if w0 & w, aV _ ^ uij & UUZ w if fuRij g ) U, aV U1 UZ1 w1 & U2 UZ2 w2 if U1 )U2 and Z1 ( Z2 and w1 ' w2 and one of the orderings is strict, i.e., U1 ) U2 or Z1 )Z2 or w1 & w2 , where ) is the redZexive closure of ),  and contains its transitive closure.
Here, ' is the redZexive closure of &.
We easily verify that, given formulas u, w 2 eclAdeggA, an action a 2 R, and a minimal model W of kwka with u 2 W, it holds u ' w and furthermore that for arbitrary u; w 2 eclAdeggA, u &Az w implies u 6Az w. We conclude the linearity of our construction.
 Theorem 13.
Let A Az AdegQ; R; d; q0 ; F A be a trace-consistent linear ABA.
There is a formula u 2 LTLAdegR; IA such that Tw ; ;  u if and only if w 2 LAdegAA for every w 2 Rx .
In other words, LAdeguA Az LAdegAA.
Before we are going to prove the previous theorem, let us mention two facts: Proposition 14.
Let A Az AdegQ; R; d; q0 ; F A be a linear ABA.
There is a formula u 2 LTLAdegRA such that LAdeguA Az LAdegAA.
Proposition 15.
Let L  Rx and I  R fi R be an independence relation.
Then the following statements are equivalent.
1.
L is trace-consistent wrt I and LTLAdegRA-definable.
2. fTw jw 2 Lg is FOAdegR; IA-definable.
3. fTw jw 2 Lg is LTLAdegR; IA-definable.
4  That is, a transitive and acyclic relation.
236  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  Proposition 14 was independently shown by [18] and [14].
As aforementioned in the introduction, the equivalence of (1) and (2) traces back to [5], that one between (2) and (3) back to [3].
Now, we are ready to prove Theorem 13.
Proof.
In accordance with Proposition 14, given a trace-consistent linear ABA A, there is a formula w 2 LTLAdegRA satisfying LAdegwA Az LAdegAA where LAdegwA is likewise trace consistent.
Employing the equivalences from Proposition 15, it immediately follows the existence of a formula u 2 LTLAdegR; IA with Tw ; ;  u if and only if w 2 LAdegAA for every w 2 Rx .
 Let us bring out two important consequences of the last theorem: 1.
Given an LTL formula u over Mazurkiewicz traces, it is simple to construct a trace-consistent LTL formula w over words dedZning the same set of x-words.
Just construct Au , and for Au , a corresponding formula w according to the proof given in [14].
2.
Partial-order reduction techniques work for LTL over Mazurkiewicz traces.
Given an LTL formula u over Mazurkiewicz traces, consider its automaton Au .
It is a linear trace-consistent automaton over words.
For this kind automata, several powerful partial-order reduction techniques have been developed, which will have the same success here [16].
Hence, specifying with LTL over Mazurkiewicz traces promisesaadespite the bad worst-case runtime of its decision procedureaaedZcient veridZcation tasks in practice.
Note that the dZrst item even implies that the languages dedZnable by LTL-formulas over Mazurkiewicz traces are FO-dedZnable over Mazurkiewicz traces.
Thus, we obtained one direction of the expressive completeness proof given in [3].
6.
Conclusion We have exhibited a decision procedure demonstrating that the classical automataatheoretic approach can be generalised to condZguration based temporal logics for traces such as LTL.
In particular, Theorem 8 asserts that it is possible to directly construct an ABA accepting the set of linearisations of traces satisfying the formula at hand.
The main idea underlying this construction is to use a notion of independence-rewriting to an extended subformula closure.
It easily follows from [24] that this closure must be of nonelementary size and, moreover, that this is unavoidable for any decision procedure directly generalising the classical automataatheoretic approach.
Our approach clearly yields an optimal (non-elementary) decision procedure and shares this similarity with [7].
We are sure that an actual implementation of our approach would compare favourably due to the fact that the automata need not necessarily be constructed in full and especially because it avoids an exponential blow-up for negation.
We showed that trace-consistent linear automata correspond to LTL over Mazurkiewicz traces wrt language dedZnability, transferring a similar result shown in [14] from the setting of words to the setting of traces.
As a consequence, it is quite natural to construct trace-consistent linear  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  237  automata as a tool to answer the satisdZability problem, and our approach exactly follows this idea.
It is easy to adapt our decision procedure for the unary fragment of LTL, where the untilmodality is replaced by an eventually-modality with the obvious semantics.
Unfortunately, it remains an open question whether the decision procedure obtained in this way is optimal.
Acknowledgement We would like to thank Jesper G. Henriksen for fruitful discussions and valuable comments on this work.
References [1] R. Alur, D. Peled, W. Penczek, Model checking of causality properties, in: Proceedings of the 10th Annual IEEE Symposium on Logic in Computer Science (LICSa95), IEEE Computer Society Press, San Diego, California, 1995, pp.
90a100.
[2] O. Bernholtz, M.Y.
Vardi, P. Wolper, An automataatheoretic approach to branching-time model checking, in: D.L.
dill (Ed.
), Proceedings of the 6th International Conference on Computer-Aided VeridZcation (CAVa94), vol.
818 of Lecture Notes in Computer Science, Springer, 1994, pp.
142a155.
[3] V. Diekert, P. Gastin, LTL is expressively complete for Mazurkiewicz traces, in: Proceedings of International Colloquim on Automata, Languages and Programming (ICALPa2000), vol.
1853 Lecture Notes in Computer Science, Springer, 2000, pp.
211a222.
[4] V. Diekert, G. Rozenberg (Eds.
), The Book of Traces, World ScientidZc, Singapore, 1995.
[5] W. Ebinger, A. Muscholl, Logical dedZnability on indZnite traces, Theor.
Comput.
Sci.
154 (1) (1996) 67a84.
[6] P. Gastin, R. Meyer, A. Petit, A (non-elementary) modular decision procedure for LTrL, in: MFCS: Symposium on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science, vol.
1450, 1998.
[7] P. Gastin, R. Meyer, A. Petit.
A (non-elementary) modular decision procedure for LTrL.
Technical report, LSV, ENS de Cachan, 1998, extended version of MFCSa98.
[8] J.-C. Gregoire, G.J.
Holzmann, D.A.
Peled, (Eds.
), The Spin VeridZcation System, vol.
32 of DIMACS series, American Mathematical Society, 1997, ISBN 0-8218-0680-7, p. 203.
[9] J.G.
Henriksen, J.L.
Jensen, M.E.
JA,rgensen, N. Klarlund, R. Paige, T. Rauhe, A. Sandholm, Mona: Monadic second-order logic in practice, in: E. Brinksma, R. Cleaveland, K.G.
Larsen, T. Margaria, B. StedZan (Eds.
), Tools and Algorithms for the Construction and Analysis of Systems, vol.
1019 of Lecture Notes in Computer Science, Springer, 1995, pp.
89a110.
[10] H.W.
Kamp.
Tense Logic and the Theory of Linear Order, Ph.D. thesis, University of California, Los Angeles, 1968.
[11] O. Kupferman, M.Y.
Vardi, An automataatheoretic approach to reasonings about indZnite-state systems, in: E.A.
Emerson, A.P.
Sistla (Eds.
), Proceedings of the 12th International Conference on Computer-Aided VeridZcation (CAVa00), vol.
1855 of Lecture Notes in Computer Science, Springer, 2000.
[12] O. Kupferman, M.Y.
Vardi, P. Wolfer, An automataatheoretic approach to branching-time model checking, J. ACM 47 (2) (2000) 312a360.
[13] M. Leucker, Logics for Mazurkiewicz traces.
Ph.D. thesis, Lehrstuhl faZ ur Informatik II, RWTH Aachen, 2002.
Also appeared as Technical Report 2002-10, RWTH Aachen.
[14] C. LaZ oding, W. Thomas, Altering automata and logics over indZnte words, in: Proceedings of the IFIP International Conference on Theoretical Computer Science, IFIP TCS2000, vol.
1872 of Lecture Notes in Computer Science, Springer, 2000, pp.
521a535.
[15] A. Mazurkiewicz, Concurrent program schemes and their interpretations, DAIMI Rep. PB 78, Aarhus, 1977.
238  B. Bollig, M. Leucker / Data & Knowledge Engineering 44 (2003) 219a238  [16] D. Peled, Ten years of partial order reduction, in: Proceedings of 10th International Conference on ComputerAideds VeridZcation (CAVa98), vol.
1427 of Lecture Notes in Computer Science, Springer, Vancouver, BC, Canada, 1998, pp.
17a28.
[17] A. Pneuli, The temporal logic of programs, in: Proceedings of the 18th IEEE Symposium on the Foundations of Computer Science (FOCS-77), Providence, Rhode Island, October 31aNovember 2, 1977, IEEE Computer Society Press.
[18] S. Rohde, Alternating automata and the temporal logic of ordinals, Ph.D. thesis, University of Illinois at UrbanaChampaign, 1997.
[19] P.S.
Thiagarajan, A trace based extension of linear time temporal logic, in: Proceedings of the Ninth Annual IEEE Symposium on Logic in Computer Science, Paris, France, 4a7 July, IEEE Computer Society Press, 1994, pp.
438a 447.
[20] P.S.
Thiagarajan, I. Walukiewicz, An expressively complete linear time temporal logic for Mazurkiewicz traces.
in: Proceedings, Twelth Annual IEEE Symposium on Logic in Computer Science, Warsaw, Poland, 29 Junea2 July, IEEE Computer Society Press, 1997, pp.
183a194.
[21] A. Valmari, A stubborn attack on state explosion, in: E.M. Clarke, R.P.
Kurshan (Eds.
), Proceedings of Computer-Aided VeridZcation (CAVa90), vol.
531 of Lecture Notes in Computer Science, Springer, Berlin, Germany, 1991, pp.
156a165.
[22] M.Y.
Vardi, P. Wolper, An automataatheoretic approach to automatic program veridZcation, in: Symposium on Logic in Computer Science (LICSa86), IEEE Computer Society Press, Washington, DC , USA, 1986, pp.
332a345.
[23] M.Y.
Vardi, in: An AutomataaTheoretic Approach to Linear Temporal Logic, vol.
1043 of Lecture Notes in Computer Science, Springer, New York, NY, USA, 1996, pp.
238a266.
[24] I. Walukiewicz, DidZcult condZgurationsaaon the complexity of LTrL, in: K.G.
Larsen, S. Skyum, G. Winskel (Eds.
), Proceedings of 25th International Colloquium on Automata, Languages and Programming (ICALPa98), vol.
1443 of Lecture Notes in Computer Science, 1998, pp.
140a151.
Benedikt Bollig received his M.Sc.
degree (Dipl.-Inform.)
in Computer Science in 2000 from the University of Technology Aachen (RWTH Aachen).
He is currently doing his Ph.D. degree in Computer Science at Lehrstuhl faZ ur Informatik II, RWTH Aachen.
His research interests include model checking, Mazurkiewicz traces, and message sequence charts.
Martin Leucker received his M.Sc.
degree (Dipl.-Math.)
in Mathematics in 1996 from the University of Technology Aachen (RWTH Aachen).
He got his Ph.D. degree (Dr. rer.
nat.)
at Lehrstuhl faZ ur Informatik II, RWTH Aachen.
In his thesis, he studied several logics for Mazurkiewicz traces.
Currently, he is a postdoctoral researcher at the University of Pennsylvania, USA.