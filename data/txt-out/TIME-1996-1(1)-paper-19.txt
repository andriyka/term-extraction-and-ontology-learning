Temporal Reasoning in a Meta Constraint Logic Programming Architecture Evelina Lamma, Michela Milano  Paola Mello  DEIS UniversitA di Bologna Bologna 40136, Italy  Istituto di Ingegneria Universitii di Ferrara Ferrara 41100, Italy  Abstract  or in determining an equivalent minimal representation, or in computing the transitive closure of the network.
All the researchers who have worked in the temporal reasoning field have proposed algorithms for solving these problems (see, for example, [2,9,26,29]) but, in general, they did not focus on defining a programming paradigm and architecture for solving these problems.
In this paper, we show how Constraint Logic Programming [14,15] on finite domains (CLP(FD)) can be a flexible and suitable tool for temporal reasoning thanks to its efficient constraint propagation mechanism.
However, CLP presents some limitations in the treatment of both quantitative and qualitative temporal constraints.
On one hand, CLP has a limited embedded propagation mechanism (arc-conszstency) which cannot be changed by the user.
On the other hand, qualitative constraints can be expressed but not propagated (in order to find, for example, the minimal network) in a CLP(FD) framework.
We overcome this drawbacks by integrating both kinds of reasoning (as in the Meiri's Framework [all) in a flexible and modular architecture.
Our meta architecture contains two finite domain constraint solvers which cooperate and exchange knowledge in order to deal with both kinds of constraints: The object level treats quantitative information, while the meta level handles qualitative information by reasoning on the (passive) constraints of the object level.
The contribution of this paper mainly concerns:  Constraint Logic Programming (CLP) is a powerful programming paradigm combining the advantages of Logic Programming and the eficiency of constraint solving.
However, CLP presents some limitations in dealing with temporal reasoning.
First, it uses an "arc consistencym propagation algorithm which cannot be changed by the user and it is too weak in many temporal frameworks.
Second, CLP is not able to deal with qualitative temporal constraints.
In this paper, we show how to overcome these limitations.
In particular, we present a way of performing a path-consistency check without changing the propagation algorithm of the constraint solver.
In addition, we show how to integrate qualitative and quantitative temporal reasoning by using a two module meta CLP architecture.
Each module is a finite domain constraint solver (CLP(FD)).
The object system (extended with the path-consistency algorithm) performs quantitative reasoning, while the meta-level reasons on constraints of the underlying system thus performing qualitative reasoning.
In this way, we can benefit of the eficiency of the constraint handling mechanism of CLP and the modularity, flexibility and scalability of meta-architectures.
1  Introduction  Temporal reasoning plays a central role in many Artificial Intelligence applications such as planning, scheduling, and natural language understanding.
Several frameworks have been proposed in order to deal with this form of reasoning, most notably Allen's Interval Algebra [a], W a i n and Kautz's Point Algebra [as], Dechter, Meiri and Pearl's STP and TCSP (91 and Dean and McDermott's Time Map Management [8].
In addition, some promising approaches have been proposed in order to integrate qualitative and quantitative temporal reasoning [16,21].
In these frameworks the representation of the problem is given in terms of a constraint graph where nodes are the variables of the problem, i.e., points or intervals, and arcs are constraints, i.e., temporal relations between pairs of variables (each n-ary relation among n variables can be represented in terms of binary constraints).
Given a constraint graph, we are interested either in determining whether the graph is consistent,  0  0  a way of handling qualitative temporal constraint propagation by adding a meta constraint solver reasoning on constraints of the underlying system, as proposed by Tsang [25] with metaconstraznt graphs.
In this way, we can benefit of the efficiency of the constraint handling mechanism provided by CLP, and  128 0-8186-7528/96 $5.00 0 1996 IEEE  a way of performing a path-consistency algorithm not by changing the propagation algorithm of the constraint solver as in [6], but by performing an arc-consistency on the so called "arc-variables" and "path-equivalent" constraints;  the modularity, flexibility and scalability of metaarchitectures.
The paper is organized as follows.
In Section 2 we will sketch some features of the CLP(FD) paradigm while focusing on its limitations for treating qualitative temporal reasoning.
Then, we propose how to overcome these limitations.
Section 3 is devoted to the architecture of the general purpose temporal reasoner, i.e., the qualitative and the quantitative modules and their interactions.
Section 4 is devoted to an example.
Conclusions and a mention of future works follow.
of absolute locations on the time line and bound on distance constraints (see [9]).
Temporal intervals can be expressed as pairs of points linked by the relation Ii, < Isup,where Iinf and Isup are the starting and ending points of the interval I .
According to the classification of Meiri [21], we can represent augmented Continuous Point Algebra (CPA) and Point Algebra (PA) networks on discrete domains.
The augmented CPA networks on discrete domains require an arc consistency algorithm for deciding the consistency and an arc+pathconsistency algorithm for computing the minimal domains.
CLP(FD) solvers like CHIP [lo] or ECLiPSe [ll]provide only an arc consistency algorithm.
In section 3.1 we propose a way of performing path consistency not by changing the consistency algorithm of the solver, but by adding what we call "arc-variables" and ('path-equivalent'' constraints.
On the other hand, deciding the consistency of PA networks on discrete domains is a NP-complete problem.
Therefore, we can apply a path consistency algorithm just as a preprocessing technique for reducing the search space.
Another limitation of CLP(FD) concerns its capability of representing qualitative constraints such as x < y, but its inadequacy of reasoning about them.
This inadequacy arises for three reasons that we have identified and called the composataon problem, the zntersectaon problem and the qualatatave-quantitatave problem:  Constraint Logic Programming  2  Constraint Logic Programming (CLP) is a class of programming langua es combining the advantages of Logic Programming fLP) ([ZO]) and the efficiency of constraint solving.
In this paper we focus on CLP on finite domains CLP(FD) [15].
In this framework, variables range on a finite domain which is initially set to [O..max].
These domains are gradually reduced by the propagation of constraints.
Inconsistency is detected when a domain becomes empty.
As an example, let us suppose that we have three variables X, Y , Z ranging on the domain [1..103, and the constraint X < Y which produces the propagation: D X = [1..9] and D y = [2..10] and the constraint Y < Z which produces the propagation: D y = [2..9] and D z = [3..10].
The fact that D y has changed produces the final propagation of constraints leading to the reduction of the domains of X , Y , 2 to: D x = [1..8], D y = [2..9], D z = [3..10].
This propagation is named "arc-consistency" and ensures that, for each value of a variable domain D x , there exists at least one value in each other domain which is consistent with the constraints mentioning the variable X .
2.1  Composition: in the example of Section 2, when the propagation terminates, we are not able to infer information on the relationship that holds between X and Z starting from the domains DX = [1..8] and Dz = [3..10].
CLP is not able to build the transitive closure of the temporal network.
The information that should be inferred from the two constraints X < Y and Y < Z is the relation X < Z .
This relation should be inferred from the transitivity rule, and, in particular, it is the result of the composition of constraints, see for example [2,29].
CLP(FD) and its Limitations for Temporal Reasoning  CLP has a very efficient constraint handling mechanism which can be suitably used for representing and reasoning on constraint-based temporal frameworks.
CLP(FD) is able to express directly quantitative temporal reasoning.
In fact, we can interpret the const raint s: (X E [3..16]) A (y E [1..19]) A ( X - 2 7) A (Z- y 5 16) in a temporal reasoning context.
We can see the variables x and y as temporal points which have a temporal location on the discrete time line (see [3]).
In particular, x is a temporal point located somewhere between 3 and 16 time units, y between 1 and 19.
The last two constraints link the distance of the time points to range between 7 and 16 time units.
The propagation of constraints leads to the reduction of the variables' domains to': (x E [4..16]) A (y E [1..13]) while suspending the two passive constraints (Z - y 2 7) A (X - y 5 16).
Therefore, with CLP(FD) we can express quantitative constraints between temporal points, i.e., ranges  Intersection: the second problem of CLP on finite domains is related to the first and concerns the computation of the minimal network.
The constraints X < Y ,Y < Z and X 5 Z are consistent but not minimal.
A constraint solver should be able, in this case, to compose the first two constraints and intersect the result with the third constraint leading to X < 2.
Qualitative-Quantitative: another limit at ion of CLP on finite domains is that it deletes values according to constraints, but it does not reduce constraints on the basis of variable domain values.
Suppose that we state that X 5 Y , X and Y being temporal points ranging on DX = [1..5] and DY = [6..10] respectively.
It can be seen immediately that X and Y cannot be equal because there does not exist any pair of values from Dx and from D y that "supports" the constraint.
Therefore, the tightest constraint that holds between X and Y is X < Y.
A constraint solver on finite domains propagates constraints and simply concludes that the constraint is satisfied without simplifying it.
These constraints are called active constraints  129  2.2 How t o Overcome these Problems In the previous Section, we have underlined that CLP(FD) presents some limitations for qualitative reasoning and a limited consistency algorithm for quantitative reasoning.
Therefore, we propose an approach based on a meta-architecture [1,5] that solves the above mentioned limitations.
We use a constraint solver on finite domains for handling quantitative constraints, and a meta-constraint solver for qualitative temporal constraints.
On one hand, we extend the object level solver with the concept of "arc-variables" and "path-equivalent" constraints for reaching path-consistency without modifying the algorithm of the constraint solver.
On the other hand, we solve the qualitative reasoning limitations by building a meta-constraint solver where variables are relations.
On meta-level, unary constraints restrict a meta-variable to take its values from a finite domain of relations.
For each pair of variables X and Y (nodes of the graph) we have a meta-variable, namely R x y , ranging on a finite domain of relations.
This domain contains the relations that hold between X and Y.Suppose that X <_ Y , then the domain of the meta-variable Rxy is the powerset of the possible constraints holdin between X and Y , namely D X Y = [{<I,{=I, {<, =,!
0 1 .
Intersection and composition are embedded in the meta-constraint solver as primitive operations.
Therefore, the general purpose temporal reasoner is composed by two constraint solvers propagating their "own" constraints, and interacting each other in order to perform a more powerful propagation.
3  A General Purpose Temporal Reasoner based on CLP  In this section, we explain how the two modules propagate qualitative and quantitative constraints, and how they interact.
An extended version of this paper including theoretical issues and proofs is available [17].
3.1  Quantitative Constraint Solver  The quantitative module is a CLP(FD) constraint solver.
CLP on finite domains can express unary constraints between points such as: Pi E 1 and binary constraints between pairs of points such as: (Pz-Pj)E I .
The qualitative constraints of a CPA (or PA) network can be translated in bound on distance constraints (see [all).
Therefore, we now concentrate on bound on distance constraints.
Let us see an example: if variable X ranges on the domain DX = [10..20] and variable Y ranges on the domain D y = [40..50] and the constraint 2 = Y - X is stated, then the constraint solver is able to associate with the variable 2 the domain D z = [20..40].
Again, if the variable X ranges on the domain Dx = [10..20] and the variable 2 on the domain D z = [30..40], then the propagation of the constraint 2 = Y - X associates with the variable Y the domain D y = [40..60] These constraints, after the propagation, are delayed because variables are not yet instantiated and may cause further propagations.
This propagation is that  performed in the STP framework [9].
In STP we use continuous domains while in this case we use discrete domains.
However, the propagation, in this case, can be performed only on upper and lower bounds of each domain.
Therefore, the mechanism is the same.
Now we explain how bound on distance constraints are propagated in the temporal reasoner.
We refer to an example given by Dechter, Meiri and Pearl in [9].
We have four temporal variables, namely XI, Xz, X 3 , X4, and a time point X O representing the "beginning of the world".
The constraints defined by the problem are: 10 10 60  < Xi-Xo 5  5  X3-x~  2 0 , 30 40 70.
< 20,  2 x4-xo 5  < Xz-Xi 5  x4-x3  5 5  40, 50,  These constraints can be written as: % The f i r s t eleven c o n s t r a i n t s % a r e s t a t e d by t h e problem Xi::10..20, X4 : :60.
.70, 2 2 3 : : 10.
.20  zzi=xz-xi,  Z2i::30..40, 243 9  : :40.
.50, Z43=X4-X3,  z23=x2-x3  5  z42=x4-x2  9  z 4 1 = x 4 - x 1 ,z31=x3-x1,  % The following c o n s t r a i n t s perform % a path-consistency equivalent algorithm 231=221-223, 221'z24-(-241), Z42=z43-223, 241=z42-(-Z21,)  231=(-243)-(-241), 243 =241-z31, z42=241-z21,  221=Z23-(-231), 243=242-(-223)  241=243-(-231)  z23=z21-z31,  9  3  z23=(-z42)-(-z43)  *  where the predicate symbol :: associates a variable Var with a domain Domain in the following way: Var .. .
.
Domain.
The variables 221, 2 2 3 , 243, 242, 241 and 231 are called "arc-variables" because they refer to arcs.
The first eleven constraints define the structure of the problem.
In their paper [9] the authors have shown that the Floyd- Warshall's all-pairs shortest-paths algorithm represents a complete algorithm for determining the consistency of a STP and for computing the minimal network.
Moreover, they have shown that for STP this algorithm is equivalent to the path consistency algorithm.
On the other hand, a CLP(FD) solver performs a lower consistency check: an arc consistency algorithm which does not check all the paths of the network given the variables of the problem.
However, if we add to a program some constraints (the last 12 constraints in the example above, i.e., the "path-equivalent" constraints) describing the paths in the graph and we apply arc-consistency on them, we are able to obtain path consistency.
Theorem 3.1 Let G=(V,A) be a graph where each node represents a varaable (temporal poant) of the problem and each arc, linkzng a paw of vartables, as a bznary constraant definzng the mammal and mammal dastance between the two poants.
Let us consider three varaables X, Y and Z linked b y the following bound on distance constraints: a1  SX -  bi <X c1  130  <z  -Z  5 a2, 5 bp,  - Y  C2,  Y  <  pair of variables X { r l , .
.
.
, r,}Y and X{r' , .. .
, & } Y , whose symbol is =m, is the powerset of the set theoretic intersection between the two vectors { T I , .
.
.
, r,} and { r i , .
.
.
rh}.
A meta-variable representing the possible relations between X and Y is associated with each constraint.
Therefore, the intersection of metavariables Rxy =m R h y (corresponding to the two constraints) imposes the meta-variables to be equal by intersecting their domains.
For example, if the meta-variable RXY has an associated domain: D x y = [{<}, {=}, {<,=}, {}] because of the existence of the qualitative constraint X 5 Y 2 ,and the meta-variable RkY has an associated domain D k y = [{>}, (>, =}, {=}, because of the existence of the qualitative constraint X 2 Y , then the intersection between the two constraints is performed by a meta-unification Rxy =m R k y that leads to the following propagation of constraints: Dxy = Dku = corresponding to the qualitative domain X = Y in the finite domain constraint solver.
The composition should be defined directly in the constraint solver via a transitivity table (see [2,29]).
The composition is represented by the symbol +m and it is defined as following.
The composition of two meta-variables R x z and Rzy admits only those values rSy for which there exists r,, E Dxz and rty E Dzy such that rzy = rzz@rzVwhere the symbol 8 represents the composition of primitive constraints and is defined by the transitivity table on the constraints of D, see [2,29].
The "tighter" relation is represented by the symbol cm.A set of constraints C' is tighter than another set of constraints C" if each pair of values allowed by C' is also allowed by C".
In our case, the relation tighter can be translated into the set inclusion.
It is worth noting that, as in the quantitative solver, we should perform an arc consistency on the metavariables representing arcs of the object level graph.
In fact, the constraint Rxy =m R x z +m Rzy performs a composition of R x z and Rzy in the way defined above, and intersects the computed domain with the domain of R x y .
This constraint behaves in the same way of the constraint X Y = X Z Z Y described in Section 3.1.
Notice that the qualitative constraint solver can work independently from the quantitative part.
For example the following qualitative program:  The path through nodes X, Y and Z is path consistent i f f the following unary constraints are arc consistent: XY :: a1..a2, xz :: bl..b2, ZY :: c1..c2, XY = xz + ZY,  where XY = X-Y, X Z = X-Z and ZY = Z-Y.
Proof.
: Refer to [17].
Without modifying the CLP(FD) solver, we are able to reach the same result obtained by [6] which, instead, modifies the structure of the CLP(FD) solver for achieving path-consistency.
The result of the computation of the abovementioned example consists of delayed constraints in which each variable is associated with the minimal domain:  I}{  E{=}, I}{  X1::10..20, x2::40.,50, X3::20..30, X4::60..70, &1::30..40, &1::10..20, &1::50..60, &3::10..20, &2::20..30, &::40.
.50.
Therefore, with CLP(FD) we are able to solve a STP, to determine its consistency and to compute the minimal network associated with, provided that we add some "path-equivalent" constraints.
We are currently studying a way of performing whatever kind of consistency by adding constraint solvers as meta-levels, see [I81* As concerns the complexity of the above meutioned computation, we have proved [17] that it is equal to the complexity of a path consistency algorithm augmented by the overhead of creating arc variables and path equivalent constraints.
This result is mainly due to the fact that in the STP framework variables ranges on convex intervals, and arc consistency can modify the lower and upper bound of each domain, thus avoiding the domain values enumeration.
3.2  Qualitative Constraint Solver  +  The qualitative module is a meta-constraint solver on finite domains of relations.
A meta-variable Rxy is automatically generated each time a new qualitative constraint between variables X and Y is introduced.
Qualitative constraints are disjunctions of primitive constraints between variables.
If X and Y are points, primitive constraints are point algebra relations [29] (with or without the constraint f ) .
If X and Y are intervals the primitive constraints are interval algebra relations [2].
The intervals will be translated in their starting and ending points.
Therefore, if between variables X and Y we have a relation of the kind: ( X rl Y ) V .
.
.
V ( X r, Y ) which can be written as: X { r l , .
.
.
, r,}Y where ris are primitive qualitative relations, then the system automatically creates a meta-variable Rxy whose domain contains unary constraints which link the variables to Dxy is the powerset of { r l , .. .
, rn}.
take their values from a set of relations, and binary The meta constraint solver has two operations: in2The symbol {} is useful for detecting inconsistencies in qualtersection and composition of qualitative Constraints.
itative reasoning.
The intersection of two constraints, linking the same  131  that should be performed when a change in a quantitative domain influences a qualitative domain.
First of all, every time a new constraint is encountered in the object system, its meta-representation should be added to the meta constraint store.
In addition, each time a variable domain changes due to the object system propagation, a linking rule provides a propagation in the meta system.
This propagation is much more computational expensive and leads to the deletion of constraints that are not supported by variable domain values.
We should check for each constraint linking two variables X and Y , if there exists at least one couples of values 2 E DX and y E D y that supports the constraints between X and Y , represented by the meta-variable Rxy .
In other words, this propagation checks if the set:  constraints containing operations on meta-variables, i.e., intersection and composition, or meta-relations such as the tighter relation.
Therefore, in the metalevel we can express the Vilain and Kautz's Point Algcbra [29] which deals with qualitative relations between temporal points.
It is worth noting that qualitative information, except for the relation #, can be translated into nondisjunctive bound on distance constraints.
For example, the constraint X Y can be translated in -a5 X - Y 5 0.
However, a CLP(FD) solver does not translate this constraint in this way since it applies an "arc-consistency", and therefore the distance of the two variables does not necessarily range on - a .
.
O .
For example, if we have X :: [0..10] and Y :: [-6..30], Y 5 X , 2 = X - Y , the CLP(FD) solver propagates the constraints thus resulting in X :: [0..10], Y :: [-6..10], 2 :: [-lo.. + 161.
Therefore, we need to change the propagation algorithm if we want to achieve 2 :: [0..16].
Second, we gain in expressiveness since the user can express the fact that the relation that holds between variables X and Y should be tighter than the relation that holds between, say, 2 and A'.The user can also query the system by asking a feasible scenario for qualitative temporal information (we will show this feature in the example in section 4 .
This query can be straightforwardly implemented i we have a finite domain of relations at meta level, also using domain dependent heuristics embedded in the meta level.
<  ~ = { ( x , Y ) E DXx D Y I X R X YY} is not empty.
The notation 2 Rxy y represents the "application" of one of the constraints in the domain of the meta-variable Rxy to 2 and y.
For example, suppose that X has an associated domain Dx = [ 3 .
.
5 ] ,Y the domain D y = [6..9] and X and Y are related by the constraint X 5 Y , which is represented by the meta-variable RXY ranging on the domain DXY = [{<}, {=}, {<, =}, {}].
Intuitively, the constraint "equal" is no longer entailed by the values of the domains of X and Y .
In fact, while the set S is not empty for the value < of Rxy because it contains, for example, the couples (3,6), (3,7), (3,8) and so on, the set S is empty for the value = of Rxy.
Therefore, the quantztatzve-guulztatzve propagation deletes from the domain of Rxy the values containing the constraint =.
This process is general, but very heavy handled.
If we work in a specific domain we can make use of special purpose techniques for the interaction between qualitative and quantitative constraints, see [17].
2  3.3  Interactions between Qualitative and Quantitative solvers  One of the most interesting parts of the temporal reasoner concerns the integration of qualitative and quantitative constraint solvers.
This integration concerns the propagation of quantitative constraints when qualitative domains are modified and the propagation of qualitative constraints when quantitative domains are modified.
For this part, our propagation method is different from the Meiri's propagation technique but it is straightforward in a Constraint Logic Programming paradigm.
We have defined two linking rules which ensure that a propagation in the quantitative solver is reflected in the qualitative solver and vice versa.
Due to space limitations, we do not describe formally these linking rules (reported in [17]),but we give an informal idea of the propagation adopted.
The qualatatave-quantztatave propagation, denoted in section 4 with qual-quan, is straightforward.
It is equivalent to the addition in a CLP program of a new qualitative constraint.
For example, if variables X and Y are constrained by X 5 Y , they have an associated meta-variable Rxy ranging on D x y = [{< }, {=}, {<, =j , {)I.
Suppose now that, for the propagation of constraints in the meta constraint solver, the domain D x y is reduced to D x y = [{<},{I].
In the quantitative solver the propagation is performed by adding the new constraint X < Y to the constraint store.
This new constraint may cause further propagations on quantitative domains.
The quantatatzve-qualatatwe interaction, denoted in section 4 with quan-qual, concerns the propagation  4 One Example In this Section we present one example which applies to this architecture, taken from Meiri's paper [all, which handles both qualitative and quantitative temporal knowledge.
In the example, we represent points as CLP domain variables while intervals are represented by their starting and ending points I- arid I+ linked by the constraint I- < I+.
The relations between intervals are the usual Allen's relations [a]: starts (symbol s), durin (symbol d), overlaps (symbol o), before (symbol <?, equal (symbol =), finishes (symbol f ) , meets (symbol m) and their inverses (si, di, 01, >, =, fi, m i respectively).
John and Fred usually work at U local ofice, zn whach case John takes less than 20 mznutes and Fred 1520 manutes to get to work.
Twace a week John works a t the maan ofice, an whach case he takes at least 60 manutes.
Today John left home between 7:05 and 7:lO a.m., and Fred arraved a t work between 7:50 and 7:55 a.m. John and Fred met at the traffic laght on thew way to work.
132  The representation of the problem should be written in a configuration file.
This file contains information about the above-mentioned story: interval(J, (J-,J+)), interval(F, (F-,F+)), point (PO), origin (PO) arc(J, F, [s,si,o,oi,f,fi,d,di,=I), distance(J-, PO, Dl), distance(F+, PO, D2), distance(F+, F-, D3), distance( J+, J-, D4), D1::0..5, D2::50..55, D3::15..20, D4::0..20,60..max.
In this case, the propagation of meta-constraints does not change the meta variable domains.
The quantitative solver transforms the distance constraints in quantitative relations for the CLP(FD) solver.
Moreover, it generates all the possible paths of the graph (see section 3.1) and performs arc consistency on them.
Therefore, the quantitative level constraints are the following:  where J is the interval representing the event John going to work, F is the interval representing the event Fred going to work and origin(P0) is a predicate which holds iff PO is the beginning of the world.
The result of the propagation is the same as that reported by Meiri, but it is interesting to follow the two solvers' steps in order to understand their behavior.
A pre-processing additional module interval-point translates the relations of the Interval Algebra in relations between their starting and ending points.
The interval-interval relation:  The propagation of object level constraints leads to the following domains:  5-::0..5, F+::50..55, D3::15..20, D4::0..20,60..max1 D3 = F+ - F-, D4 = J+ - J-, D5 = F- - J-, D6 = F+ - J+, D7 = F+ - J-, D8 = F- - J+, D5=D8+D4, D5=D7-D3, D6=D7-D4, D6=D3+D8.
5-::0..5, F+::50..55, J+::60..max, F-::30..40, D3::15..20, D4::60..max, D5::25..40, D6::-max..-5, D7::45..55, D8::-max..-20  arc(J, F, Cs,si,o,oi,f ,fi,d,di,=l), The fourth step concerns the qualitative-quantitative and quantitative-qualitative propagations.
The qual-quan interaction (see section 3.3) adds the constraints: J+ > F-, J- < F+, J- < J+, F- < F+ which do not alter the variable domains because they are already consistent with the constraints.
On the other hand, the propagation quan-qual (see section 3.3) alters the meta-variable domains and, in particular, the meta-variables representing the following constraints J- [<,=,>I F-, J+ [<,=,>I F+.
In fact, the domain of J-: : O .
.5 and the domain of F-: :30..40 entail only the constraint J- < Fwhile the domain of J+: :60.
.max and the domain of F+: :50.
.55 entail only the constraint J+ > F+.
The propagation of constraints reduces the meta-variables domains.
This reduction leads to another propagation in the meta-constraint solver but this latest propagation does not alter any other meta variable domain (the meta-constraint graph reaches the quiescence).
In the last step the module interval-point translates the relations between starting and ending points in relations of the Interval Algebra.
In particular, the only relation entailed by the starting and ending point constraints is F during J .
After having determined the minimal network representing the above-mentioned problem, we can be interested in finding a feasible scenario, i.e., an arrangement of the temporal objects along the time line which is consistent with the given constraints, see [27].
is translated into six point-point relations: arc(J-, arc(J+, arc(J+, arc(J-, arc(J-, arc(J-, arc(F-,  F-, [ < , = , > I ) ,  F+, [ < , = , > I ) , F-, [>I), F+, [<I), F+, [<I), J+, [<I),  F+, [<I).
Notice that the constraints J- [<,=,>I F-, and J+ [<,=,>I F+, are not added to the quantitative program because they do not restrict the variable domains.
.__ .__.
These relations are automatically transformed by quan-qual in meta-variables of the meta-constraint  solver:  linked by meta-constraints:  133  values is committed at the end of the computation, thus preventing failures and reducing the search space.
In our architecture this problem can be solved in a straightforward way.
In fact, the CLP(FD) primitive indomain(X), when applied to a domain variable X, instantiates X to a feasible value of its domain.
The propagation then eliminates, from other variable domains, those values which are incompatible with X.
At the end of the propagation, either all the variables are instantiated or another indomain occurs, until there are no more unbounded variables.
In our example, we can instantiate the starting and ending points of the intervals I and J in order to obtain a feasible scenario.
The clause: scenario ([I ) .
scenario ( C V a r I Others] 1 :indomain (Var) ,  5  Conclusions and Future Works  We have presented a Constraint Logic Programming two level architecture for both quantitative and qualitative temporal reasoning.
The architecture is structured into two communicating modules: a finite domain constraint solver for the quantitative reasoning and a meta constraint solver for handling qualitative reasoning.
The object level constraint solver has been extended in order to perform a path consistency check not by changing the solver consistency algorithm but by adding "arc-variables" and "path-equivalent" constraints.
The meta constraint solver reasons on the constraints of the quantitative module and is able to perform operations on them such as composition and intersection and to state relations between constraints, e.g., the tighter relation.
In this paper we have discussed the structure of the two solvers and the relations and interactions between the two.
This architecture has been implemented by using the finite domain library of ECLiPSe [ll],a CLP language developed by ECRC.
Some related works have been studied and discussed in [17].
Here, we list some of the most relevant: As concerns temporal reasoning, there are many related works.
First of all W a i n and Kautz' point algebra, Allen Interval Algebra [a], the Meiri's framework [21] and Tsang work on meta graphs [25] are the starting points for our work.
As far as the integration of CLP(FD) and temporal reasoning is concerned, we have very interesting works.
T .
Fruhwirth in [13] describes how to treat qualitative and quantitative temporal reasoning with Constraint Handling Rules.
Another related work is presented in [24] where the integration of qualitative and quantitative reasoning is performed by extending a single constraint solver.
A third work, described in [19], concerns the integration in a finite domain constraint solver of the Interval Algebra qualitative constraints.
All these approaches are based on a flat architecture while our approach is based on a meta architecture thus gaining in modularity and flexibility.
Finally, as regards the path consistency in CLP FD , a related work is [6] which embeds in a CLP FD solver the path consistency algorithm.
We do not c ange the CLP(FD) propagation algorithm, but we simply add new variables and constraints.
We are generalizing this idea by using a several level meta architecture for reaching whatever consistency algorithm, see [18].
scenario (Others) .
instantiates the temporal points of the problem [Var I Others] to feasible values.
Usually, according to the first f a i l principle [as], the variable to be instantiated next is the variable with the smallest domain (the most constrained variable).
Therefore, in the implementation we used this heuristics.
Other scenarios can be found by using the backtracking mechanism of CLP.
The same problem can be handled in a qualitative network.
Each meta-variable represents a set of relations between variables linked by an arc.
We could be interested in finding a feasible scenario, i.e., an arrangement of the temporal relations between objects which is consistent with the other constraints, see [25].
In this case, the next variable to be instantiated could be the most constrained one, i.e., the variable with the minimum sized domain.
Therefore, the above-mentioned clause s c e n a r i o can be used also for qualitative constraints.
In the example above, the consistent scenario has been already found because meta-variables have no disjunctive constraint but each meta-variable is instantiated to a single primitive relation.
In fact, we have the following qualitative constraint s : J+ > F-, 3- < F+, J- < J + , F- < F + , J- < F-, J+ > F+.
tb  In qualitative networks, a very important problem is to decide which value to try next.
Usually, the ordering of the values according to their restriction is a domain dependent problem.
Tsang [25] proposes some orderings of temporal interval-interval relations, e.g., the more restrictive relations are those imposing a greater number of point-point constraints between  Future work is devoted t o generalize this framework  their starting and ending points or in planning prob-  in order be able to apply it to different domains without changing its structure.
A possible instance can be for example a CLP(Interva1s) as the object-level system [4] and a qualitative solver performing the Interval Algebra reasoning as the meta system.
This is a work in progress.
We intend to apply the system to a real life application of scheduling and planning as the one described in [7].
lems the more restrictive relations are those minimizing the overall duration of the schedules generated.
In this case, the "tighter" relations between the constraints of the qualitative constraint solver can be useful in order to decide which value to try next.
It is worth mentioning that in applications like least-commitment planning or scheduling the qualitative temporal constraints should be instantiated before quantitative constraints.
The choice of the variable  134  Acknowledgments  [14] J.Jaffar, J .L.Lassez, "Constraint Logic Programming", Proceedzngs of the Conference on Prznczple of Programming Languages, 1987.
This work has been partially supported by the M.U.R.S.T.
Project 60% (Minister0 dell'Universitb della Ricerca Scientifica e Tecnologica).
We would like to thank Helene Pokidine who helped us in implementing the system and anonymous referees for very useful comments on the first version of this paper.
[15] J.Jaffar, M.J.Maher, "Constraint Logic Programming: a Survey", Journal of Logzc Programmzng on 10 years of Logzc Programmzng, Vo1.19/20, pp.
503-582, 1994.
References L .Aiello, C.Cecchi, D Sartini, "Represent ation and  [IS] H.A.Kautz, P.B.Ladkin, "Integrating Metric and Qualitative Temporal Reasoning", Proceedzngs AAAI91, pp.241-246, 1991.
Use of Metaknowledge", Proceedings of the IEEE, Vol.
74, NO.
10, pp.
1304-1321, 1986.
[17] E.Lamma, P.Mello, M.Milano, "A Meta Constraint Logic Programming Architecture for Qualitative and Quantitative Temporal Reasoning", Tech.Report DEIS-LIA-95-001, 1995, www-lia.unibo.it/Research/TechReport.html.
J.F.Allen, "Maintaining Knowledge About Temporal Intervals", Communications of the A CM, Vol.
26, pp.
832-843, 1983.
J.F.Allen, P.J.Haves.
"A Common-Sense Theorv of Action'and Tige" Proceedings of IJCAI85, p6.
528-531, 1985.
[18] E.Lamma, P.Mello, M.Milano, "A Multi-Level CLP Architecture for Consistency Techniques", Submztted for pubblzcatzon.
F.Benhamon, D.McAllester, P.Van Hentenryck, "CLP(Interva1s) Revisited", Tech.
Report CS-9418 Computer Sczence Department, Brown University, 1994.
[191 J .Lever, B.Richards, R.Hirsh, "Temporal Reasoning and Constraint Solving", Delzverable CHIC, ESPRIT Project EP5291, IC-Park, 1992  K.A.Bowen, R.A. Kowalski, "Amalgamating Language and Metalanguage in Logic Programming" in Logzc Programmzng, K.Clark and S.Tarnlund Eds., Accademic Press NY, pp.
153-173, 1982.
[20] J.W.Lloyd, Foundataon of Logzc Programmzng", Second Extended Edition, Springer-Verlag, 1987.
[all I.Meiri, "Combining Qualitative and Quantitative Constraints in Temporal Reasoning", Proceedzngs of AAAI91, pp.260-267, 1991.
P.Codognet, G.Nardiello, "Path Consistency in clp(FD)" , in Proceedzngs of the Fzrst Internatzonal Conference Constraint in Computatzonal Logzcs CCL94, pp.
201-216, 1994.
[22] A.K.
Mackworth, "Consistency in Networks of Relations", Artzficzal Intellzgence, vo1.8, pp.
99118, 1977.
A.Dalfiume, E.Lamma, P.Mello, M.Milano, "A Constraint Logic Programming Application to a Distributed Train Scheduling Problem" , Proceedings of the Conference on Practical Applzcatzon of Prolog, pp.163-182, 1995.
[23] R.Mohr, T.C.Henderson, "Arc and Path Consistency Revisited", Artzjiczal Intellagence, Vo1.28, pp.
225-233, 1986.
[24] F.A.Barber, R.Berlanga, R.Fordellas, F. Ibaiiez, G.Martin, F.Toledo, "Integration of Metric and Symbolic Temporal Constraints in CLP" , unpublashed manuscrzpt.
T.L.Dean, D.W .McDermott , "Temporal Data Base Management", Artificzal Intellzgence, Vol.
32, pp.
1-55, 1987.
R.Dechter, I.Meiri, J.Pear1, "Temporal Constraint Networks" , Artificzal Intellzgence, Vol.
49, pp.
6195, 1991.
[25] E.P.K.Tsang, "The Consistent Labeling Problem in Temporal Reasoning" , Proceedzngs of AAAI87, pp.251-255, 1987.
[lo] M. Dincbas, P. Van Hentenryck, M. Simonis, A. Aggoun, T. Graf, F. Berthier, "The Constraint Logic Programming Language CHIP", Proceedings of the Internatzonal Conference on Fzfth Generation Computer System (FGCS88), pp.693702,1988.
[26] P-VanBeek, R.Cohen, "Exact and Approximate Reasoning about Temporal Relations", Computatzonal Intellzgence, V0l.6, pp.132-144, 1990.
[27] P.VanBeek, "Reasoning about Qualitative Temporal Information", in Artzficial Intellzgence, V01.58, pp.
297-326, 1992.
[ll] ECL'PS" User Manual Release 3.3, ECRC, 1992.
[28] P.Van Hentenryck, Constraznt Satzsfactaon zn Logzc Programmzng, MIT Press, 1989.
1121 E.C.
Freuder, "Synthesizing Constraint Expressions", Communzcatzon ofthe ACM, vol.
21, N o l l , 1978, pp.
958-966.
[29] M.B.Vilain, H.Kautz, "Constraint Propagation Algorithms for Temporal Reasoning" Proceedzngs of AAAI89, pp.
377-382, 1989.
[13] T. Friihwirth, "Temporal reasoning with con-  straint handling rules", Tech.
Report ECRC-94-05, ECRC, 1994.
135