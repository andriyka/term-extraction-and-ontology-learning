Representing Interaction of Agents at Different Time Granularities* Edjard Mota & David Robertson Department of Artificial Intelligence The University of Edinburgh 80 South Bridge, Edinburgh EH1 1HN Scotland email: { edjardm,dr}@aisb.ed.ac.uk March 12, 1996 Abstract  The scaling up process is highly relevant to the development of of simulation models of ecosystems.
Many factors make scaling difficult for ecological modellers but a major obstacle is that each individual model is devised to run on its own, single-level, time scale.
It is argued in [a] that the use of a temporal logic-based language to specify such simulation models as agents can provide better representations for the behaviour and interaction of eco-agents working at different scales of time.
The usefulness of using NatureTime logic for the specification of such agents has already been shown [ 3 ] .
In this paper we present some results on the representation of interacting agents developed in [4], which extends the NatureTime logic.
We also address some new problems to be tackled when asynchronous agents are introduced into the environment where there are other interacting objects.
In Section 2, we present one example as a motivation for this work, and we also address some related works.
In Section 3, we make a brief presentation of the NatureTime logic.
In Section 4,we show how to enhance the logic with mechanisms for the representation of interacting eco-agents.
In Section 5, we show an application of NatureTime to the specification and simulation of eco-agents working at different time granularities.
Finally in Section 6 we give some concluding remarks.
I n this paper we describe NatureTime logic which we use t o represent and reason about the behaviour of interacting agents (an an ecological domain), which behave ut different time granularities.
Although the traditional application fields of temporal representation and reasoning still raise many interesting theoretical issues, we have been investigating some practical problems of ecological systems which suit different representations of t i m e than those embodied in traditional simulation models of ecosystems.
These seem well suited t o reconstruction using temporal logic programs.
1  Introduction  An understanding of the world generally needs a way to represent processes at different levels of granularity [l].This may be done in relation to time, space, and the structural organisation of things we are interested in observing, representing and in many cases simulating.
In relation to time and space, it is common that that processes working at finer levels of time can only be observed if we also change to a finer level of space, in order to observe the changes they may produce in the environment.
An interesting aspect of these levels of abstraction is to observe how things, which happen at the lowest levels will affect the others at higher levels of granularity.
This process is usually called scaling up.
Things become complicated when the higher levels also affect, at longer periods of time, the lower levels.
2 2.1  Example: ''We have a model of tree growth, expressed on a weekly time scale.
This must interact with a model of a insect pest which moves up and down the tree on a daily time scale.
The tree has its growth rate reduced  "This work and the first author (on leave for PhD from the Department of Computer Science of the University of Amazonas, Manaus, Brazil) are sponsored by the Brazilian Ministry of Education, grant no 01723/93-8/CAPES.
72 0-8186-7528/96 $5.00 0 1996 IEEE  Motivation and Related Works Two Interacting Ecological Agents  by 0.02 every day the pest moves above 8 meters.
The pest moves continuously up and down, at a rate of 2 meters per day, reversing direction when it reaches the top or bottom".
collections to specify other collections by using two operators, sltctng and dicing, in order to select intervals from collections of intervals.
Each such a primitive is defined by specifying the intervals of which it is composed.
In this approach, circular aspects of time can be obtained from the b-values which are treated as if they were a circular list.
Although this approach was shown to be useful for reasoning about scheduling, it does not deal with different granularities of time.
In [9, 101 there is proposed a many-sorted first order logic augmented with temporal operators and a metric on time to deal with time granularity.
This is achieved by introducing contextual and projectzon operations into topological logic [ll].
This has been applied in the context of planning systems [12], to achieve plan actions at different scales of time and reduce the computational complexity of such systems.
In a parallel work to ours, [13] proposes an interesting framework of time based on the notion of calendars as being cyclic temporal objects.
The difference is in the way in which such temporal objects are conceived.
This approach, as the others does not include the cyclical aspect of time in their models.
The theory developed in [14] was an attempt to provide a logic based language to represent concepts of time, following closely the forms of expression used informally in descriptions of ecological systems in a target domain.
Many of these descriptions include the idea of cyclical processes at many levels of time granularity.
In the next section we will summarise the time theory developed to deal with these.
This example shows an interaction between two entities working at different time scales.
The types of question that we might want to answer in problems like this are: "what is the value of the attribute of each agent at an specific time?"
or " when will some attribute of either agent have a certain fixed value?".
The behaviour of each of these agents could be represented by means of differential equations, which is an expressive way of representing the continuity of their behaviour.
But a continuous representation of time is not always best for ecological models.
For example, if we want to represent the behaviour of agents which immigrate and emigrate from one population to another, then it is difficult to represent this using continuous functions.
A more usual way of modelling the changes in the state of such agents is to perform them at the time step of their corresponding granularity.
This yields a discrete approximation to continuous models.
However, a discrete approach does not allow us to compute the value of some attribute at a time in between two consecutive time steps.
To overcome this, interpolation could be needed.
In this case we have to assume that there is no interaction between the agents that may affect the attributes in question.
Otherwise, we cannot estimate the next value in the consecutive time step.
Such a future value will depend on the value we are trying to find for the time in between the future and the past.
In this work we just take the value of the most recent temporal entity in the past.
3  A Linear-Cyclic Hierarchy of Time  In this section we will briefly present the time hierarchy of the NatureTime.
We refer to [14] for more details about the temporal reasoning interpreter, which is basically a standard Prolog meta-interpreter with restricted forms of unification on temporal labels.
3.1 Basic Assumptions By analysing the temporal knowledge about seasonal cycles of ecological knowledge [15], as in sentences like "Coffee is harvested from August up to April", a hierarchy of time cycles was proposed in [14] in order to represent and reason about cyclical events.
A natural mathematical structure for representing cycles is modular arithmetic (also called clock arithmetic [16]).
For instance, years are modular sets of months, [lunar] months are sets of days, and so on.
Note that this hierarchy of cycles also allows us to define many levels of temporal granularity.
2.2 Related Work Granularity is very important if we intend to look at the world at different levels of abstraction, when switching from one level to another may be necessary for the comprehension of the phenomena being observed [l].
A theoretical analysis of hierarchical time intervals was proposed in [5], where an elaboration over the interval calculus [6] is done to achieve a time framework where units of time can be specified.
This work extends the idea of convex to union-of-convex intervals [7], where there may exist gaps between convex intervals.
This allows the representation of collections of intervals and limited expressions of cyclicity.
However, it was not implemented, as far as we know, so the pragmatics of using it for computation are obscure.
A similar approach was proposed in [SI, where the basic idea in this approach is to use a set of primitive  3.2  Elements of the Language  The language is Prolog based enhanced with some special symbols, terms, and a unification algorithm for  73  .
temporal labels, which also works over terms of second order which not include predicate symbols.
Vocabulary - It is formed by symbols for variables, Constants, functions and predicates as follows.
a temporal t e r m (TT) is a temporal variable s E Ct, , or a temporal constant et E CT , or a temporal  function symbol forms.
L, of constants.
a cyclzcal anterval i ( s...t , m ) ,where s , t E at and m E TC  a finite set .Cf of non-temporal function symbols of the form f", where n is the arity of the function.
a smallest temporal entaty t ( t 1 , .. .
, t k ) , where for n as the number of elements in 7c, then k 5 n , each ti E Z ' , and each i correspond to exactly one element of 7 c .
a finite set .Ct, of temporal constants defined as {lowest,f l o w t i m e , i n f i n i t y , smallest} U 7 c , where 7c = { c l , .
.
.
, c,}, and each ci is a special constant or names of temporal classes.
a lznear interval s1 ...SZ, where s1 and in the form t ( t l , ,.
.
, t k ) .
a finite set C, of predicate symbols p r , i '1 1, where n > 0 is the arity of p i , where mod-temp-class is special predicate symbol of arity 3, and o n is a special predicate of arity 2.  the propositional connectives for conjunction, disjunction, and implication are represented here by &, v, and c==, respectively.
The truth value for true is represented by TI and false by 1. the temporal symbol "@" .
Classes of Expressions - By using these symbols we define the following classes of expressions.
By using these symbols we define the following classes of expressions, where the capital letters A, B , C are used for formulae.
.
a logical t e r m is recursively defined as -  are  Examplesof TT are, for example, i ( l l...5, m o n t h ) to mean interval of t i m e between November and May, p ( 1 , d a y ) a f t e r t ( 1 7 , 7 , 1 9 9 4 ) one day after 17th July, 1994, day( 1 ) of week means all Mondays, and l a s t ( d a y ( 2 ) of week of m o n t h ( 2 ) of year( 1996)) means the last Monday of February of 1996.
The collection interval is more general than a cyclical interval in the sense that it may define cyclical and noncyclical intervals.
For instance, d a y ( 2 ) of week of m o n t h represents all Mondays of all months.
However, d a y ( 2 ) of week o f m o n t h ( 2 ) of y e a r ( l 9 9 6 ) is not cyclical because it represents the sequence of days 5th112th,19th, and 26th of February 1996.
Z of integers is also part of the vocabulary.
- a variable E E  s2  a collectaon anterval * a where a E Tc.
* f t ( n ) , where f t E C t f , and n E Z ' , and f t corresponds to one unique symbol a E 7 c .
For instance, the function symbol of w e e k ( 1 ) corresponds to a week of 7c * a(.)
of S, where f t E Ltj (same as previous item), and n E Zt,and S is a collectton anterval.
a finite set of temporal function symbols f,", where n is the arity of the function, C t f = {p', i2,tn,...',plus', a f t e r 2 , before', of'}, where ...', plus', a f t e r 2 , before', o f 2 are all of arity 2 but written using infix notation.
the set  C f t in one of the following  a peraod, recursively defined as a 1) sangle perzod p ( s , m ) where s E Z and m 6 7 , ; 2) a composzte perzod P p l u s PI,where P is sangle peraod, and PI is a persod term.
two countably infinite sets of variables C, and Ct,, where xi , y i , zi are variables of C,, si , ti, ui are variables of Ct,.
a finite set  ft E  .
C, is a term  a pure temporal expression (PTE) -  a constant c E Cc  -  if t l , .
.
.
,t , are terms and f E L f and has arity n , then f n ( t l , .
.
.
,trL)is a term.
t , if t is a TT, but not a period t e r m .
p a f t e r t , where p is a peraod term, and and t is a pure temporal expression.
Examples of PTE are p ( 3 , m o n t h ) a f t e r i(10 ...11, m o n t h ) , p ( 2 4 ,y e a r ) a f t e r t ( 1 7 , 7 , 1 9 7 0 ) , hour(4) o f d a y ( 1 ) of w e e k ( 1 ) of m o n t h ( 3 ) .
Examples of logical terms are m a i z e , g r a s s , h e i g h t ( t r e e ( t l ) ) , biomass( f orest( f i ) ) .
74  .
an atomic formula (AF) is -  T and I are atomic formulae  if t e r m l , .
.
.
,t e r m , are logical terms and p" E C,, then p n ( t e r m l , .
.
.
, t e r m , ) is an atomic formula  .
classical atomic formulae can be annotated with a  PTE by using the temporal operators "@" , forming an atomic temporal formula (ATF), i.e.
-  A, if A is an AF, then it is an ATF.
T , where A is an AF and T is a PTE, is an ATF  - A @  For instance, h a r v e s t e d ( m a i z e , h i g h l a n d s ) @ i(12...1, month) means that maize is harvested throughout the whole interval of time from December u p to January.
.
body is in one of the forms A 8~ B , A V B , or C , where A and B are bodies and C an ATF.
A typical example of a body is time-between(i(2 ...4, month),p ( 3 , m o n t h ) ) & h a r v e s t e d ( m a i z e , high-lands) @ i( 12.. .l , month).
hierarchy (the properties of this relation are described in the Appendix A), T is the set of integers ordered by the binary relation of precedence <.
The set T h is composed of two sets M h and F ( m c ~.
., .
, me,}.
The second is called fluctuating MTC, and the former is the main time hierarchy which is induced by the following relations.
.
mc,+l =def moddemp-class( flow-time, cn, i n f i n i t y ) , where cn E TC .
mc, =def moddemp-class(c,,c,-1,m0),where 1 < a 5 n , c t , c t - ~E Tc,and m, E Zt .
mcl = d e f mod-temp-clcass(cl, lowest, smallest), where c1 E Ti.
Each ca is called the name of the class m e z .
The flow of time is a sequence of instances of c,, where each one denotes a stage in a cycle and therefore can recur.
For instance, a simple hierarchy which includes temporal classes for a simplified calendar model of time could be defined as follows.
mod-temp-class( f l o w h m e , year, i n f i n i t y ) .
mod-temp-class(year, month, 12).
moddemp-class(month, day, 30).
mod-temp-class(da y , lowestdevel, smallest).
A view of this hierarchy is depicted in in Figure 1.
...  ...
year(!)
year(m)  ...  .
a well formed temporal formula (WFTF) is  A is an ATF, then A is a WFTF with an e m p t y body if A is an ATF and B # T I L ,and B is a  - if -  body then A (=: B is a WFTF, and A is called the head A WFTF where its head is an AF, and body is formed only by AF is a Prolog clause with no temporal contents.
An example of a WFTF is harvested(Crop)@ p ( D , C ) a f t e r T planted(Crop) @ T .
Which means if a Crop is planted throughout and interval T, then it is harvested a D units C of time after T.  The Linear-Cyclic Hierarchy Struct ure The temporal structure used is a 5-tuple LCH = d e j t ( T h , E , +, TI<), where T h is a finite partially ordered  3.3  set of modular temporal classes (MTCs), C is a non empty set of temporal entities (or units of time), { is a binary relation of temporal succession within the  +  ...  4  onth( 12)  Figure 1: A view of the Linear-Cyclic Hierarchy of time.
The inner circles represent lower levels of time granularity like d a y and m o n t h , while the outest circles represent the highest level, like year.
These relations define the flow of time, represented by f l o w - t i m e , as a linear and infinite ( i n f i n i t y ) sequence of years, year as a MTC of 12 month, month as a MTC of 30 d a y s , d a y as the smallest ( s m a l l e s t ) time interval.
Note that in this hierarchy we consider months as regular MTC, which is not the case in the real calendar.
Although the logic allows us to define real calendars, we will omit it from this paper.
3.4 A Meta-Interpreter for NatureTirne In this section we present a meta-interpreter based on [17] for the NatureTime rather than a formal semantics.
As we treat temporal reasoning as a problem of unifying PTEs, then we need to control the part of the unification which deals with it.
Because of" this, the standard s o l v e / l predicate is changed to be a binary relation solve/2.
Basically, the meta-interpreter  2.  accepts queries which are temporal formulae.
It succeeds if the query holds throughout some interval within the given PTE.
Since it may not hold across the entire interval it is necessary to also show what the restricted PTE is - hence the second argument.
In this way we have the following meta-interpreter.
3.
S = i(sl ...s2,C) and T = tl ...tz, if there is one time instance 5'' = s8 ...si of S, and T and S' unify.
soZve(A 63 T1, A 0 T3) : T A = (- & -), A 0 T2, temp-unify(T1,T2, T3).
solue(A 62 T , A B RT) : A = (A1 & AZ), solue(A1 0 -,A1 0 T l ) , solue(A2 0 -,A2 0 T2), tempunify(T1,T2, RTl), temp-unify(T,RT1, RT).
solwe(A & B,A1 & B1) : solue(A,Al), solue(B,B1).
solue(A or B , R ) : (solve(A,R ) ;  4.
T = tl ...t2 and also unify.
4  4.1 Dealing with Simulation Clauses The type of temporal knowledge in a simulation model can usually be represented in a standard clause schemata we call simulation clause.
If A is the specification of a simulation model it is usually in the form  As clauses 3 and 4 are just another way to re-write the standard clauses for logical conjunction and disjunction, we assume their usual interpretation.
We have the following interpretation.
A' @ P after T  -+=  A is true throughout T3, if A is not a composite  A@T& R ( A ,A').
event, and A is true throughout T2, and T3 is the temporal unification of T1 and T2.
-  5-  where P is normally in the form p(1, C) and C is a modular temporal class of the time hierarchy, and the predicate R is intended to represent the sequence of formulae which involves A and A' to produce their relationship within the flow of time.
Finally, A and A' have the same predicate symbol and the same arity.
Usually they are in the form value(Attribute,Agent, V ) ,i.e.
the value of an Agent's Attribute is V .
In order to allow NatureTime to reason about those queries of 2 , taking into account this particular type of clause, we have the following solution.
A is true throughout T  if, A is a composite event consisting of A1 & A2, and A1 is true throughout T1, and A2 is true throughout T2, and RT1 is the temporal unification of T1 and T2, and RT is the temporal unification of T and RT1.
A is true throughout T3 if, the A 62 T2 is the head of a temporal Horn clause with body Precondition, and the body can be solved, and T3 is the temporal unification of T1 and T2.
Briefly, the temporal unification concerns with the reduction of P T E to canonical forms of TT, and then unifying them by performing modular or linear matching using the usual relation between time intervals [6].
The TTs S and T unify if one of the following cases applies.
1.
N a t u r e T i m e for Eco-Agent Specification  This section shows an extension of the metainterpreter of the NatureTime for reasoning about the state of an agent at any time in between two consecutive time steps.
To this, we take some advantage of a common way of representing simulation models.
solve(B, R ) ) .
2  S = i(s1...s 2 , C ) , then S and T  The timeinstance creates one linear instance of a cyclical interval.
As a cyclical interval represents a collection of linear intervals, there may exist many instances of it in the level of linear intervals.
solve(A @ T1, A @ T3) : A B T2 Precondition, solue(Precondition,-), temp-unify(T1,T2,T3).
1-  i(sl ... t1,C) and T = i(t1... t2,C), and mod-temp-class(-,C , M ) holds, M is an integer, and i(s ...t , C ) is the modular match between S and T .
S =  1. check if the given temporal entity is a fixed time 2. check if there is a simulation clause such that the formula matches with some part of its body, and that the proposition A has the same structure (i,e.
S = s1...s2 and T = tl ...t2, then either they overlap or one is included into the other.
the same predicate symbol and same number of arguments),  76  ~  (J  3. find one solution for A1 @ Ti, where Ti is a variable  Art.= v  4. if the solution found is the proposition searched within the the specified interval, then the search stops.
,I, OP (Observer Process) ,  I  ,  5. otherwise, it the PTE of the head of the simulation clause is the future of T then the last state of A is assumed to be the required value, and the search stops.
6. otherwise the constraints represented in the R relation are attempted to be solved, and the future state of A1 throughout interval Ti is the head of the simulation clause, and we back to step 4.
4.2  Representing Agents  Interaction  state 1  state 2  state k  Figure 2: Interaction between agents A; and Aj , where the OP of Ai get the list L of values of Attj during a period k units of time.
Between  As NatureTime offers mechanisms for specifying simulation models working at different levels of time granularity, and ecological systems usually involve entities acting on their own clocks, then an ecosystem modelled in such a logic is a straightforward representation of an agent's behaviour in the sense of multiagent systems (MAS).
Such a view is the same as in [18].
In what follows, we consider that agent's attributes which depend on processes specified at a certain scale of time will have their state changed only at that level.
If an agent A; acting at a coarse level of time interacts with other Aj working at lower level, and the result of this interaction is that an attribute Attj of Aj affects and attribute Att; of A; , then A; has to find out the sequence of values for Atti.
For instance, the model of a tree for the example we gave should find out the sequence of values for the bug's position during the period of time in which its attribute is assumed to be constant.
The MAS approach we are using takes into account that an agent may "read", or observe the value of the attributes of other agents if such information is relevant to its behaviour.
Thus each agent may need a process dedicated to obtaining such information.
We will call this observer process (OP).
In our case, the OP will get all the values of Attj, in a list L , during an specific period of time of the length of L , and then the agent A; will compute the influence of these values on its attribute Att;.
This idea is depicted in Figure 2.
Note that the OP needs to know the time scale of the agent Aj in order to know how to relate both scales of time.
Thus, every agent must specify the scale of time of the internal processes responsible for  its behaviour, and also a dependency relation between attribute and process.
This will be done by using the predicates scale(time,Agent, Process, C ) ,where C is a MTC, and depend(Attribute,Process).
In this way, we extend the language by introducing a builtin predicate which is specified in the level of the meta-interpreter.
This is the predicate progress/4 for representing the progress observed of the value of an attribute Att of an agent Obj, from a given temporal entity T during a given period of time P , and the progress will return in a list.
A simple specification of the progress/4 predicate can be, for example, as follows.
progress(value(Att,Obj,V ) @ TP, , [VIR]): depend(Att,Proc), scale(time, Obi, Proc, C ) , solue(walue(Att,Obj, V ) @ T , -), future(?
: p, U ) , progression(value(Att,Obj,V ) @ T,T f ,C,R) progression(- @ T ,T f ,C, [ 1) : next( T ,C,T f ) .
progression(value(Att,Obj, Vi) 0 Ti,T f ,C, [VjlR]): 1 next(Ti, C , T f ) , value(Att, Obj, V j ) B p ( 1,C ) a f der Ti vulue(Att, Obj, Vi) @ Ti & Constraints,  -  solue(Constraints, -), nezt(Ti,C ,T j ) , progression(value(Att,Obj,V j ) @ T j ,T f , C , R).
5  Representing the Tree and Bug Interaction  For the sake of simplicity, we will assume that both eco-agents start their behaviour at the same time.
In this way we have the following facts in our KB.
77  This just shows the behaviour of both through the flow of time.
For a query about the value of the tree's height at any time we will have the following results, as expected.
growth-rate(tree, 0.5).
scale(time, bug, movement, day).
scale(time, tree, growing, week).
depend(height, growing).
vaZue(height, tree, 6) Q t ( l , l , 1).
vaZue(pos, bug, 6) 0 t ( l , l , l ) .
I : value(height, tree, H) 0 t(10,1,1).
>> value(height, tree, 9.44) Q t(10,1,1) 1 : value(height, tree, H ) @ t(10,2,1).
>> value(height, tree, 11.199999999999998) 0 t(10,2,1)  The specification of the tree's growing process can be, for example, as follows.
value(height(tree), H )  p(1, week) a f t e r T  (Q  e= value(height, tree, Hi)(3 T & scale(time, bug, movement, Scale) & progress(value(pos(bug, -), -) Q T , p ( l , week), Scale, L ) & growth-rate(tree, GR) & influence(GR, L , RealGR) & ( H i s H i RealGR).
+-  The specification of the bug's movement can as follows.
value(pos,bug, 6) (3 t ( l , l , 1).
value(pos,bug, PB) 0 p(1, day) a f t e r T  +==  oalue(pos, bug, P B i ) B T & value(height, tree, H) B T & new-pos(PBi, H , PB).
new-pos(PosI,H, Pos2) : Posl 5 H , Pos2 is P o s l 4- 2.
Note that queries were for time values in between two synchronous time steps of the tree's growing.
6  Concluding Remarks  In this section we make a brief analysis on the results obtained, the limitations still to be overcome.
Extension of NatureTime avoids re-computation of pure temporal expressions already computed by the recursive definition.
To our knowledge this is a new technique for controlling the search taking into account a restrict form of clause.
A limitation of the p r o g r e s s / 3 is that it is assumed that all processes working synchronously rather than asynchronously.
This is depicted in Figure 3, where the lines for P i and P2 represent their clock, and each mark is the time point in which the attributes they change are updated.
The n e w q o s l 3 simply changes the bug's position according to its behaviour as specified in the Example.
For this specification we have the following results for the simulation of the bug's position.
I : value(pos, bug, Pos) B T .
>>  value(pos,bug, 6) Q t ( l , l , 1)  >> ,.. >>  value(pos,bug, 8)  Figure 3: Interacting process PI and Pz where in a) they are synchronous and in b) asynchronous.
I : more.
I  @I  t(2,1,1)  For instance, if another agent is introduced at time t(5,1,1) and needs to know the value of the tree every week, the PO for this agent would get the list [9] as the value of the height of the tree.
However the correct list should be [9,9.44] because the new agent was introduced asynchronously in relation to the other agents.
Although the use of the logic for the specification of more complex problems sometimes leads to inefficient local computations, the modularity of computational logic allows us to think in terms of distributing the computation over a set of agents, each one with its own time granularity.
We have already done some  value(pos, bug, 8) Q t(8,1,1) : more.
For the tree's growing process we have.
I : value(height, tree, H ) 0 T .
>> vaZue(height, tree, 9)  I : more.
(3  t ( l , l , 1)  >> value(height, tree, 9.44) 0 t(8,1,1) ... >> value(hezght, tree, 11.199999999999998) Q  t(6,2,1)  I : more.
>> vaZue(height, tree, 11.639999999999997) 0 t(13,2,1)  78  experiments [2] that strengthen our belief in the value of this type of architecture.
Acknowledgements - We would like to thank very much to Robert Muetzelfeldt for his contribution to our understanding on ecology.
We also like to thanks Alan Smaill for his valuable contributions on the time theory.
Finally, we thank to the patiency of the referees who carefully read and gave valuable comments for this final version.
[ll] N. Rescher and A. Urquhart, Temporal Logzc.
Springer Verlag, 1971.
[12] S. Badaloni and M. Berati, "Dealing with time granularity in a temporal planning system," in First Internatzonal Conference on Temporal Logic, (Bonn, Germany), pp.
101-116, SpringerVerlag, July 1994.
[13] D. Cukierman and J. Delgrand, "A language to express time intervals and repetition," in Proceedzngs of the of 2nd Internatzonal Workshop on Temporal Representatzon and Reasonang, (Melbourne Beach, Florida - USA), April 1995.
References [l]J. R. Hobbs, "Granularity," in Proceedings of the of the IJCAI, pp.
1-4, 1985.
[a]  E. Mota, "Time granularity in simulation models within a multi-agent system."
DAI Discussion Paper 158, Department of Artificial Intelligence, University of Edinburgh, April 1995.
[14] E. Mota, "Temporal representation of ecological domains," DAI TP- 31, Department of Artificial Intelligence, University of Edinburgh, 1994.
[3] E. Mota, M. Haggith, A. Smaill, and D. Robertson, "Time granularity in simulation models of ecological systems," in Workshop on Excutable Temporal Logics- Montreal, Canada, DAI RP740, Edinburgh University, 1995.
[15] M. Haggith, D. Robertson, D. Walker, F. Sinclair, and R. Muetzelfeldt, "TEAK - tools for eliciting agroforestry knowledge," in Brztzsh Computer Society Symposaum of I T - Enabled Charge an Developing Countrzes, 1992.
[4] E. Mota, D. Robertson, and R. Muezelfeldt, "On the granular aspects of time in simulation models," TP-39, Detartment of Artificial Intelligence/University of Edinburgh, 1995.
[16] N. L. Biggs, Dzscrete Mathematzcs.
Oxford Science Publication, 1987.
[17] L. Sterling and E. Shapiro, The Art of Prolog.
The MIT Press, 1986.
[5] P. Ladkin, "Primitives units for time specification," in Proceedings of the AAAI, pp.
354-359, 1986.
[18] M. Fisher, "Representing and executing agentbased systems," in ECAI Workshop on Agent Theorzes,A rchztectures and Languages (ATAL), (Amsterdam, Netherlands), August 1994.
[6] J. F. Allen, "Maintaining knowledge about temporal intervals,)' Communications of the ACM, vol.
26, no.
11, 1983.
A  Properties  Cra  t  P. Ladkin, "Time representation: A taxonomy of interval relations," in Proceedings of the AAAI, pp.
360-366, 1986.
Properties of + - In what follows, means the MTC of level i defined with modular value mi.
This relation establish a sub-division relationship between  B. Leban, D. D. McDonald, and D.R.
Foster, "A representation for collections of temporal intervals," in Proceedings of the AAAI, pp.
367-371, 1986.
MTCs.
The  +t relation has the following properties.
transitzve - if err,Cy' and Crk are MTCs and  Crk Cj"j  E. Ciapessoni, E. Corsetti, A. Montanari, and P. S. Pietro, "Embedding time granularity in a logical specification language for synchronous real-time systems," Science of Computer Programming, vol.
20, no.
1, pp.
141-171, 1993.
0  t  and Cj"j t- C r , then  Cr'  reflexwe - if is a MTC then C r z MTC can be subdivided in itself)  anti-symetrzc - if and  A. Montanari, "A metric and layered temporal logic for time granularity, syncrony and asyncrony."
Unplished work of the First International Conference on Temporal Logic, July 1994.
79  Crk { Cyi.
Cy  Cyi, Cj"'  CY', then C?'
+t Cr' (every  are MTCs, and i # j ,  2 Cy.