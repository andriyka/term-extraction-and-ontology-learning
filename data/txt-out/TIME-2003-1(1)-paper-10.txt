University of Nebraska - Lincoln  DigitalCommons@University of Nebraska - Lincoln CSE Conference and Workshop Papers  Computer Science and Engineering, Department of  1-1-2003  A New Efficient Algorithm for Solving the Simple Temporal Problem Lin Xu University of Nebraska - Lincoln, lxu@cse.unl.edu  Berthe Y. Choueiry University of Nebraska - Lincoln, choueiry@cse.unl.edu  Follow this and additional works at: http://digitalcommons.unl.edu/cseconfwork Part of the Computer Sciences Commons Xu, Lin and Choueiry, Berthe Y., "A New Efficient Algorithm for Solving the Simple Temporal Problem" (2003).
CSE Conference and Workshop Papers.
Paper 164. http://digitalcommons.unl.edu/cseconfwork/164  This Article is brought to you for free and open access by the Computer Science and Engineering, Department of at DigitalCommons@University of Nebraska - Lincoln.
It has been accepted for inclusion in CSE Conference and Workshop Papers by an authorized administrator of DigitalCommons@University of Nebraska - Lincoln.
Xu & Choueiry in 10th International Symposium on Temporal Representation and Reasoning and Fourth International Conference on Temporal Logic (TIME-ICTL 03).
Pages 212-222.
Editors, Mark Reynolds and Abdul Sattar.
Copyright 2003,IEEE Computer Society Press.
Used by permission.
A New Efficient Algorithm for Solving the Simple Temporal Problem Lin XU and Berthe Y. CHOUEIRY Constraint Systems Laboratory Department of Computer Science and Engineering University of Nebraska-Lincoln lxu|choueiry @cse.unl.edu   1 Abstract  ment [12].
Further, an efficient STP solver is a crucial component for solving the Temporal Constraint Satisfaction Problem (TCSP) because the search process designed by Dechter et al.
[8] for solving the TCSP requires solving an STP at each node expansion.
Thus, the performance of the overall process depends heavily on the performance of solving an STP.
In this paper, we propose a new algorithm, STP-solver, for solving the STP and demonstrate empirically that it constitutes a dramatic improvement over previously used algorithms.
We achieve this by first combining the results developed by Bliek and Sam-Haroud [1] for general Constraint Satisfaction Problems (CSPs) with a new strategy for constraint propagation, which restricts the propagation effort to the triangles of the triangulated constraint network instead of its edges.
Then, we apply the resulting mechanism to solve the STP.
The triangulation of the graph and the convexity of the constraints in the STP guarantee that STP-solver is complete and sound for proving the consistency of the STP and for finding the minimal (and decomposable) network.
This paper is structured as follows.
Section 3 recalls the main properties of a CSP and shows how we use them in our study.
Section 4 discusses the algorithms for solving the STP and explains the advantages of the STP-solver.
Section 5 describes our experiments and results, and summarizes our observations.
Section 6 concludes this paper.
In this paper we propose a new efficient algorithm, the STP-solver, for computing the minimal network of the Simple Temporal Problem (STP).
This algorithm achieves high performance by exploiting a topological property of the constraint graph (i.e., triangulation) and a semantic property of the constraints (i.e., convexity) in light of the results reported by Bliek and Sam-Haroud [1], which were presented for general CSPs and have not yet been applied to temporal networks.
Importantly, we design the constraint propagation in STP-solver to operate on triangles instead of operating on edges and implicitly guarantee the decomposition of the constraint graph according to its articulation points.
We also provide extensive empirical evaluations of all known algorithms for solving the STP on sets of randomly generated problems.
Our experiments demonstrate significant improvements of STPsolver, in terms of number of constraint checks and CPU time, over previously reported algorithms such as the Floyd-Warshall algorithm (F-W) [5; 8], Directed-Path Consistency (DPC) [8], and Partial Path-Consistency (PPC) [1].
          2 Introduction    Many critical applications in planning and scheduling rely on an efficient handling of temporal information represented as a Simple Temporal Problem (STP) [6; 8; 3].
The efficiency of the constraint propagation in such a network is particularly crucial in autonomous space applications as demonstrated by the Deep Space 1 Remote Agent experi-  3 Background A Constraint Satisfaction Problem (CSP) is defined as follows.
Given a set of variables, each 1  termines whether or not a network is path consistent without necessarily producing a tight network as with PC.
Since PPC operates on the edges of the triangulated graph (fewer than those of the complete graph), it realizes significant computational savings, especially in sparse networks.
Minimality: Minimality, the central problem in CSPs, is a property stronger than path consistency.
It guarantees that all the binary constraints are as explicit (i.e., tight) as possible [11].
Decomposability: Decomposability is stronger than minimality and guarantees that a solution to the CSP can be found backtrack-free.
This is a highly desirable property and guarantees the tractability of the CSP.
Consistency: In contrast to the above, the consistency property guarantees only the existence of a solution.
Note that decomposability is a sufficient condition for consistency.
Decomposition into biconnected components: The decomposition of the constraint graph into its biconnected components according to its articulation points3 is a known technique for enhancing the performance of solving a CSP in general.
It provides an upper bound, in the size of the largest biconnected component, to the search effort [9].
We establish that the new solver we introduce, STP, implicitly decomposes the constraint graph into its biconnected components without using articulation point.
This important observation justifies its high performance.
with a set of possible values defining its domain, and a set of constraints that restrict the combinations of values that the variables can be assigned at the same time, the task is to assign a value to each variable such that all constraints are simultaneously satisfied.
Path consistency, as we discuss below, is an important property of a CSP.
Recently Bliek and Sam-Haroud [1] proposed the Partial Path Consistency (PPC) algorithm, which determines whether or not a network is path consistent.
Since PPC operates on the triangulated constraint graph 1 , it realizes significant computational savings over previously known algorithms, especially for sparse networks.
In this paper, we first improve the propagation mechanism of the PPC algorithm by making it operate on triangles instead of individual edges.
We then use the improved version to solve the STP.
In the next section, we recall the main properties of a CSP and discuss them in light of the STP.
3.1 Main CSP properties The general properties of constraint graphs and the main algorithms for achieving them are outlined below.
Path consistency: This property ensures that given two values for any two variables that satisfy the constraint between these variables, we can find values for variables in any path of any length (possibly infinite) that satisfy the constraints along the path [11].
In general CSPs, path-consistency algorithms PC (e.g., PC-1 [11] and PC-2 [10]) are used to enforce path consistency by tightening the binary constraints.
(They also tighten the domains, thus enforcing strong path-consistency.)
Montanari established that these algorithms, which consider only paths of length two, on a complete graph2 guarantee a path-consistent network [11].
The Directional Path-Consistency (DPC) algorithm, which achieves path consistency along a given ordering of the variables in the search process, was proposed by Dechter [7] as an efficient approximation of PC; it guarantees path consistency only in the direction that matters, which is that of search.
Recently Bliek and Sam-Haroud [1] proposed the Partial Path Consistency (PPC) algorithm, which de-    3.2 Properties of the STP  fi 		        '&  1 A graph is triangulated if every cycle of length strictly greater than 3 possesses a chord.
2 If the graph is not complete, it is made so by adding universal constraints between non-adjacent edges.
    A Simple Temporal Problem (STP) is defined by a graph where is a set of vertices representing time points; is a set of edges representing constraints between two time points and ; and is a set of constraint labels for the edges; see Figure 1 (left).
A constraint label of edge is a unique interval , , and denotes a constraint of bounded difference ( .
A Temporal Constraint Satisfaction Problem (TCSP) is defined by a similar graph = , where each edge label = , , is a set of disjoint intervals denoting a disjunction of              	 "!
$#&%  ( ' )  *+	",	 -  .0/2714 365 	/)719 85 ::-: /)714>;<5 =  3 An articulation point of a graph is a vertex whose removal disconnects the graph.
A graph with an articulation point is separable, otherwise it is biconnected.
2      constraints of bounded differences between and , see Figure 1 (right).
We assume that the intervals in 2  e1,2 1  I1,2 = [3, 5]  e1,2 1  component can be solved independently.
If all the components are found to be consistent, then the entire network is consistent.
If any of the components is not consistent, then the overall temporal network is not consistent.
The minimal network of the original problem is obtained by the union of the minimal networks of the individual biconnected components.
When the constraint graph is sparse, this property is particularly attractive.
This allows us to process the components in parallel, by independent agents.
Thus, decomposition into biconnected components is particularly attractive in the case of STPs, especially for large problems with sparse graphs.
We show that this decomposition is implicit and automatic in our STP-solver.
2  I1,2 = {[3, 5], [6, 9], ...}  Figure 1.
Left: STP.
Right: TCSP.
a label are ordered in a canonical way.
In this paper we focus on STPs, but we are integrating our results into an algorithm for solving TCSPs.
Below, we show how we exploit the properties of Section 3.1 in the context of the STP.
Triangulation of network and convexity constraints.
In addition to proposing PPC, Bliek and Sam-Haroud also showed that when the constraints are convex, the PC algorithm (operating on the complete graph) and the PPC algorithm (operating on the triangulated graph) yield the same labeling for the edges common to both graphs.
This important feature of the PPC algorithm has never been exploited before in the context of STPs, in which the constraintsa linear inequalitiesaare indeed convex.
Our STP-solver exploits this result and yields significant savings of the computational efforts over previously available techniques for establishing path consistency of the STP.
Distribution of composition over intersection.
The two operators on binary constraints for establishing path consistency are constraint composition and constraint intersection  .
Montanari showed that when constraint composition is distributive over constraint intersection, PC guarantees not only path consistency but also minimality and decomposabilility [11].
In the case of the STP, constraint composition is interval addition, and constraint intersection is interval intersection, which verify the distributivity as noted by Dechter et al.
[8].
Therefore we can deduce that the PPC algorithm and the STP-solver, guarantee the minimality and decomposability of the STP.
DPC does not guarantee the path-consistency, minimality or decomposability of the constraint network, however, and this is an important feature, it can be used to determine the consistency of the STP.
Decomposition into biconnected components.
In the special case of the TCSP, and a fortiori the STP, Dechter et al.
[8] showed that each biconnected    4 STP algorithms Here we discuss four different algorithms to solve STPs.
The first two solvers, F-W and DPC, have been extensively studied.
However, their performance in combination with a decomposition strategy according to articulation points has never been compared before.
The third STP solver we study is PPC, which has never before been used on temporal reasoning problems.
Finally, we introduce our new solver, STP.
    4.1 F-W & DPC with articulation points The Floyd-Warshall (F-W) algorithm for computing all-pairs shortest-paths is a special case of the PC algorithm.
F-W is applied to the distance graph of an STP to compute its minimal network in  fi .
As discussed in Section 3, DPC is a single pass algorithm and weaker than PC.
It does not necessarily yield a path consistent, minimal, or decomposable network, but it determines if the STP is consistent.
DPC can be more efficient than F-W; instead of  fi , DPC can determine the consistency of STP in  fi	  , where   is the maximum number of parents that a node has in the induced graph along the ordering , which can be substantially smaller than  .
We modify the F-W and DPC algorithms to exploit the existence of articulation points in the temporal network.
First, we identify the biconnected components [5], then we execute a particular STP solver on each component, independently.
This          3     8        yields two algorithms, F-W+AP and DPC+AP, respectively.
It is easy to show that F-W+AP and DPC+AP never check more constraints than F-W and DPC.
In fact, for a sparse network, our experiments show that they check substantially less.
We also show empirically that, even in the absence of articulation points, F-W+AP and DPC+AP almost never require more CPU time than the original algorithms; when they do, the difference is insignificant due to the overhead for finding the articulation points.
PPC was introduced for general CSPs by Bliek and Sam-Haroud [1] who showed that the pathconsistency property can be determined in constraint graphs by triangulating them instead of completing them.
They showed a significant improvement in performance in comparison to PC in sparse networks.
They also established that, for convex constraints, both PPC and PC compute the same labeling for the edges common to both graphs.
Since the constraints in the STP (constraints of bounded difference) are convex, we apply for the first time PPC to solve a continuous domain problem and compute the minimal network of the STP.
As specified in Figure 2, the PPC algorithm starts by triangulating the constraint graph , then iterates over a queue  of all edges, including those edges added to the temporal graph by the triangulation process.
It pops an arbitrary edge fi in from the queue, recovers all triangles  which participates, and updates its label by composing the intervals and and intersecting the result of this composition with the interval .
We slightly modify the original algorithm to allow it to update all three edges at once and to terminate when the queue is empty or inconsistency is found.
The distributivity property of interval addition over interval intersection guarantees that running PPC on an STP results in the tightest possible labeling (i.e., minimal) of the existing edges.
    4.3    ;   	      	   Do    	 ;       ! ;  "     1      5 	     and Enqueue &     When  $% # 1 5     	      Then    '  1 5                 %    (  #     When and Enqueue     1 5  '   	  '    'Then      	 1 5           '    '    '    % When '  #   Then 	 '  and Enqueue 1 	  False5 When   ,   or '  is empty Then consistency  Figure 2.
The PPC algorithm, slightly improved to consider simultaneously all three edges in a triangle.
is not as tight as it could be, given the labels of the other edges in the triangle, the label is tightened accordingly.
This process may require tightening the other edges in the triangle as shown in Figure 3.
In B  B  [2, 6]  [6, 9]  [6, 9]  A  B [2, 7]  [2, 7]     ;  	    Return consistency End  4.2 PPC algorithm for STPs       PPC ( ): Begin consistency True Triangulate ( ) edges in While consistency Do Dequeue( ) is a subgraph of Forall such that  C [2, 12]  A  [6, 9]  C  [8, 12]  A  C  [8, 12]  Figure 3.
An example of updating edges.
The      	  	    label of edge BC then that of AC are updated.
this example we can see that it is worth considering all three edges of a given triangle simultaneously and updating them sequentially.
This observation is the basis of our first improvement to PPC, and is already integrated in the algorithm of Figure 2.
When the label of an edge in a given triangle is updated, PPC triggers constraint propagation over all the triangles in which any of the edges of the original triangle participate.
This is clearly an overkill since only the triangles in which the updated edges participate need to considered.
This observation was the motivation for our new algorithm.
While all existing methods consider the temporal network as composed of edges, our new algorithm considers the STP as composed of triangles (see Figure 4).
The graph of the temporal network  STP algorithm  The goal of PPC is to make the labels of the edges of the triangulated constraint graph as tight as possible.
When the label of an edge in a triangle 4  c  b  A = <a, b, c>  work, using for example the algorithm devised in [13], which may result in new edges.
We add these edges to the original constraint graph as universal   constraints setting their label to .
Then we put all the triangles into a queue, 	 , of size     )4 .
We check every triangle in the fi  is not minimal, queue.
If a given triangle  then we update one or more of its edges.
We then retrieve all the adjacent triangles that contain any of the updated edges and add them to 	 if they are not already there.
Finally, we remove  fi  from the queue, and repeat this process until 	 is empty or inconsistency is found.
C = <b, c, e> d a  E = <c, d, e>  f e  B = <a, b, e>  D = <a, c, e>    Figure 4.
The temporal graph as a graph of triangles.
  4.4 Features of  "	  	    STP  We summarize the features of STP as follows: STP has the same pruning power as F-W with less effort.
STP achieves minimality on the triangulated graph, without requiring the completion of the graph, which is necessary for F-W.
This yields dramatic gains in the computational effort.
STP automatically decomposes the graph into its biconnected components.
The decomposition of the graph into its biconnected components is an effective technique to bind the search effort and enhance the performance of solving a CSP.
Our experiments of Figure 7 and 8 and Table 2 and 3 show how such a strategy can improve the performance of the F-W algorithm, even when the articulation points must be explicitly identified.
Because constraints propagate through triangles, PPC and consequently STP implicitely exploit the decomposition into biconnected components.
Consider a triangulated temporal network composed of two sets of nodes !
= #" , $ , $ , , $&% and ' = " , ( , ( , , () , and " is the articulation point.
Suppose that edges exist only between nodes in either !
or ' .
Since no edges connect these two sets, there obviously are no triangles that connect them.
All triangles are either in set !
or in set ' .
As shown in Figure 4, two triangles in the graph of triangles can only be connected by a common edge.
Therefore, no triangle in set !
is connected to a triangle in set ' .
When PPC and consequently STP propagate constraints through neighboring triangles, no updates in set !
may affect triangles in set ' .
As a result, PPC and STP implicitly guarantee that ar      Proposition 4.1.
A tree-structured STP is decomposable and consistent, and its edge labels are minimal.
  We call our new algorithm STP, although it is applicable to general CSPs and would more correctly be called PPC.
The new algorithm is shown in Figure 5.
First, we triangulate the temporal net      STP ( ): Begin consistency True Triangulate the graph of all triangles in While consistency Do empty list First( )  	    	 	         	        	 ;   	      !
 "     1      5 	     and Enqueue      When  $% # 1 5     	      Then    '  1 5               %   and Enqueue 1       5 When   #  '   	  '    'Then      	    '1   Then  '  5 	  '   and Enqueue  '     When '  % #    1 	 False5 When   ,   or '  is empty Then consistency When consistency     fi Do For 	 fi   	  all triangles  fi  	 fi    containing       For    Do    )            Then Enqueue(     ,    	 Unless  Remove(  ) Return consistency ;    8 ::-: =  .
3 8 ::-: =  .
3    End  Figure 5.
The   6   	  	  is replaced by a graph of triangles.
Each triangle is represented by a node, and two nodes are connected if and only if the triangles they represent have a common edge.
Thus STP appears as an AC3-like algorithm [10] on this graph of triangles.
If an edge of the original constraint graph is not a part of any triangle, it is omitted from the graph of triangles.
Indeed, an edge that does not appear in any triangle has no effect on the constraint propagation in the STP and thus can be safely omitted from the graph of triangles.
Consequently:    ( 	     STP algorithm.
4 Note  5  that  *,+.-0/2143//6587,99:+<;  ticulation points in the graph (if any), are expoited, as if the network was decomposed into its biconnected components without actually decomposing it.
STP is cheaper than PPC.
STP and PPC use the same idea of Bliek and Sam-Haroud [1]; however, STP is more careful about how updates are propagated and thus exploits triangulation of the graph more effectively than PPC.
Although propagation of PPC occurs through triangles, PPC does not have a mechanism to record which triangles really need to be checked.
This inability causes some unnecessary constraint checks and a waste of CPU time.
Our improvement in solving the STP directly benefits the task of solving the TCSP.
TCSP is NP-hard and is solved with backtrack search.
Every node expansion in the search tree needs to solve an STP.
Thus a good STP solver is crucial for solving the TCSP.
We are currently demonstrating this idea and showing how the decomposition into independent components is particularly useful in this context.
  ment point.
The results, measured in terms of the number of constraint checks and CPU time, were averaged over the number of instances and showed a precision of 5%.
The detailed data of the above experiments on the instances generated by GenSTP1 and SPRAND are shown in Table 2 and 3.
The CPU time measurements are made in msec, with a clock resolution of 10 msec.
    5.1 Experiments conducted Using the 50-node problems generated by GenSTP-1, we conducted the following experiments: Managing the queue in STP.
The manner in which triangles are inserted in the queue affects the performance of STP.
We tested three heuristics for adding the triangles to the queue: at the front of queue ( STP-front), at the end of queue ( STP-back), and random insertion into the queue ( STP-random).
All three strategies resulted in the same output (i.e., the same label of the edges).
The results in terms of constraint checks are presented in Figure 6.
The results show that STP-back consistently performs the least number of constraint checks.
This can be informally in          5 Empirical evaluations    We implemented the following six algorithms in Common Lisp.
Floyd-Warshall (F-W), DirectedPath Consistency (DPC), and in combination with a mechanism for detecting and exploiting articulation points, F-W+AP and DPC+AP, Partial Path Consistency (PPC), and our new triangle-based solver ( STP).
We used three generators of random STPs: GenSTP-1, SPRAND, and GenSTP-2.
GenSTP1 is our own generator.
We designed it to guarantee that graphs are connected and that at least 80% of the generated instances are consistent.
SPRAND is one class of STPs generated by the public domain library SPLIB, [4].
All the problems we generate with SPRAND have a cycle connecting all the nodes (i.e., a structural constraint).
This guarantees strong connectivity and the absence of any articulation points.
Finally, GenSTP-2 is a generator given to us by Ioannis Tsamardinos and was used in [14].
GenSTP-2 does not enforce the existence of a structural constraint.
The density of  the temporal     fi	      fi  fi     .
network is defined as  fi( Table 1 summarizes the characteristics of the problems tested, including the size of the instances and the number of samples generated for each measure-    GenSTP-1: 50 nodes    'STP-front  &RQVWUDLQWVFKHFNV           'STP-random   'STP-back                          'HQVLW\  Figure 6.
Constraint   Checks for STP-back and    STP-front, STP-random.
terpreted as follows.
It is more effective to propagate the constraints as early as possible across the network, in a asweepinga manner.
Interestingly, we noticed that quiescence was consistently reached in 7 or fewer iterations.
We use STP-back in the rest of our study.
Computing the minimal network.
F-W, F-W+AP,        6  Table 1.
Parameters of problems generated.
Generator  #Nodes  GenSTP-1  50, 100 50, 100 50 100 100 257 513 256 512  SPRAND  GenSTP-2  Problem size Density Range Step [0.01, 0.1] 0.01 [0.2, 0.9] 0.1 [200, 2000] 200 [400, 1400] 200 [1600, 2800] 400 0.016 0.008 0.016 0.008  #Edges Range Step  768 1536 3 256 = 768 3 512 = 1536    Samples per point 100 100 100 100 100 5 5 5 5  Results Table 2 and Figure 6, 7, 8 Table 3  Figure 9 Figure 9    GenSTP-1: 50 nodes  F-W    GenSTP-1: 50 nodes    F-W      &38WLPHV  &RQVWUDLQWVFKHFNV    F-W+AP      PPC    PPC F-W+AP     'STP        'STP                                        'HQVLW\              'HQVLW\  Figure 7.
Constraint Checks (left) and CPU time (right) for F-W, F-W+AP, PPC, and    STP.
5.2 Observations  PPC and STP (but not DPC) result in the labels of the common edges, the minimal labels.
Figure 7 shows that STP clearly and significantly dominates all others, for all values of density.
  From the above experiments, we draw the following observations: Using articulation points.
Dechter et al.
[8] showed that decomposing the temporal network into its biconnected components is particularly effective in enhancing the performance of search.
It is worth recalling that this decomposition does not affect the quality of the solution: the same edge labels are found with and without decomposition.
Figure 7 and 8 show that only F-W realizes significant savings when the density is low.
In contrast, decompostion into biconnected components does not benefit the DPC solver to the same extent.
This can be explained by the fact that the cost of DPC is bounded by  	   , where  is the maximum number of parents that a   node has in the induced graph.
Decomposition does not significantly change the induced width    ; the total cost of solving the subproblems is not sig-    Saving on the constraint checks.
DPC does not necessarily yield the minimal network, but it can determine whether or not the network is consistent in significantly fewer constraint checks than F-W.
Figure 8 shows that STP, which is more powerful in terms of pruning power and yields the minimal network, dominates DPC-like strategies when density is less than 50%.
  Effect of problem size.
In order to compare the performance of these different solvers on larger problems, we tested them on larger problems generated by SPRAND and GenSTP-2.
Figure 9 and 10 show the ratio of the number of constraint checks and that of the CPU time needed for all six strategies in reference to the values needed for F-W.     7     8      Table 2.
Experimental results for STP solvers on random STP generated by GenSTP-1.
Density 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9  F-W CC CPU (s) 122200.5 0.822 123001.5 0.8347 120339.99 0.8389 120044.01 0.8063 117382.5 0.7935 120075.49 0.8209 120940.51 0.8637 116800 0.7862 115321.5 0.7778 116336.5 0.7947 108926.5 0.7335 120195.99 0.8113 106959.5 0.7213 108896.5 0.7487 109074.99 0.7376 109592 0.7502 107428.51 0.7298 108566.5 0.741  Random STP generated by GenSTP-1 with 50 nodes F-W+AP DPC DPC+AP CC CPU (s) CC CPU (s) CC CPU (s) 29924.05 0.2091 1777.03 0.1168 744.44 0.0307 59091.93 0.4026 3572.7 0.1304 2364.62 0.0683 79195.61 0.5297 4769.95 0.1376 3833.36 0.0945 90934.63 0.6029 6411.11 0.1547 5525.58 0.1176 99076.94 0.6591 8106.14 0.161 7510.24 0.1394 108975.06 0.7251 10204.46 0.1804 9746.2 0.1679 113426.05 0.756 11487.391 0.189 11175.431 0.1818 112267.63 0.7598 11715.94 0.1894 11447.12 0.181 112951.92 0.7525 13024.311 0.1976 12915.95 0.1986 114676.23 0.7617 14072.08 0.2115 13975.311 0.207 108852.99 0.7342 21203.27 0.2717 21203.262 0.2705 120195.99 0.8019 28912.988 0.347 28912.988 0.3442 106959.5 0.7147 27121.85 0.3313 27121.85 0.3252 108896.5 0.732 29731.49 0.3506 29731.49 0.3514 109074.99 0.7314 31533.85 0.3732 31533.85 0.3692 109592 0.7294 32002.16 0.3795 32002.16 0.3725 107428.51 0.7116 32391.83 0.3816 32391.83 0.3719 108566.5 0.7207 33249.992 0.3925 33249.992 0.3796  976155.06 955417 944883 920881.06 931483.06 886372.94 916842 924955.94 935953 895177 883597 860400 833850 879490.06 891914.06 866636 847892 854969  486223.66 737264.25 855073.25 879589.9 918906.56 879934.7 914465.9 924361.94 935805.6 894583 883597 860400 833850 879490.06 891914.06 866636 847892 854969  8.3611 8.2284 7.9927 7.8254 7.8308 7.5324 7.7882 7.907 7.9439 7.7186 7.5387 7.4074 7.1203 7.554 7.6565 7.4485 7.3271 7.3954  Random STP generated by GenSTP-1 with 100 nodes 4.088 21574.19 1.0156 14401.68 0.5275 6.2037 45044.293 1.3432 39022.73 0.9329 7.142 71363.34 1.3655 67750.06 1.2528 7.3463 89384.945 1.4859 87387.805 1.4347 7.71 115620.83 1.7429 114994.93 1.7121 7.3403 116526.336 1.6933 116144.984 1.6616 7.6159 145073.03 1.9288 144846.11 1.9396 7.7039 148479.61 1.9416 148393.72 1.9335 7.7978 167192.17 2.1092 167192.17 2.1225 7.4615 165887.34 2.086 165803.48 2.0561 7.3604 218225.31 2.4666 218225.31 2.4527 7.1667 232372.25 2.5446 232372.25 2.5384 6.9936 240254.4 2.6094 240254.4 2.5553 7.3287 262964.03 2.8133 262964.03 2.7976 7.4904 276184.53 2.9108 276184.53 2.8815 7.3051 267027.4 2.8092 267027.4 2.8233 7.2994 258738.61 2.733 258738.61 2.6769 7.3383 266861.47 2.8032 266861.47 2.7704    PPC CC CPU (s) 273.97 0.0039 837.9 0.0109 1532.55 0.02 2529.68 0.03 3766.13 0.0433 5207.57 0.0599 6679.19 0.0782 7861.92 0.0879 9240.66 0.1031 10857.08 0.1247 23677.2 0.2624 41404.09 0.4637 43483.79 0.4958 53446.668 0.6162 57422.24 0.6662 62265.727 0.7224 64625.727 0.7439 67977.31 0.7931  CC 125.75 409.64 761.71 1270.41 1910.97 2622.19 3445.79 4109 4800.74 5705.62 12631.6 22206.16 23388.791 28504.24 30716.22 33464.38 34257.42 36429.34  CPU (s) 0.0025 0.0045 0.0091 0.0115 0.0188 0.0269 0.0358 0.0424 0.0531 0.0649 0.1533 0.2676 0.291 0.3553 0.4083 0.4269 0.443 0.4616  4424.22 14764.17 31849.158 49463.91 72491.46 85443.125 113607.77 129904.16 161399.25 165634.69 320976.06 396075.3 446748.47 520176.78 564749.56 554381.6 552344.1 568128.25  2225.99 7803.66 16698.209 26350.969 38301.637 45141.34 61303.09 70892.98 86110.63 90790.92 175113.86 219178.31 247012.77 287163 309157.75 303306.12 299997.22 309514.87  0.0108 0.0772 0.1795 0.3076 0.472 0.5847 0.8185 0.9267 1.1857 1.2733 2.6166 3.3071 3.805 4.4565 4.7986 4.7356 4.8764 4.9663  0.0586 0.2035 0.3818 0.5777 0.8411 1.0262 1.3013 1.4633 1.8614 1.9312 3.7723 4.7658 5.4984 6.4435 6.734 6.5875 6.4986 6.7406  STP     nificantly smaller than that of solving the original problem.
When density is high, the network cannot be decomposed, and F-W+AP and DPC+AP perform almost the same as F-W and DPC, respectively.
The problems generated by SPRAND cannot be decomposed because of the existence of a cycle that connects all nodes (i.e., structural constraint).
Indeed, Table 3 shows the same number of constraint checks for the algorithms with and without articulation points.
However, the required effort for finding these articulation points is negligible, as CPU times are the same within the resolution of the clock.
Improvements due to PPC: Given the constraint semantics, PPC is guaranteed to yield the same labels as F-W and F-W+AP on their common edges.
Since PPC operates on the triangulated graph, it performs significantly better for low density values than F-W, which operates on the complete graph, and even F-W+AP, which exploits the existence of articulation points.
When the constraint density increases, the number of triangles in the graph also increases and so does the cost of PPC.
However, the number of constraint checks and, to some extent, the CPU time for PPC remain less than those for F-W and F-W+AP, which quickly reach a stable  value,  fi .
For the larger problems generated by SPRAND and GenSTP-2), Figure 9 and 10 show the PPC outperforms DPC and DPC+AP, which in turn outperform F-W and F-W+AP.
Note, however, that DPC and DPC+AP do not yield the tightest network.
A comparison of Figure 9 and 10 shows that the performance of PPC is better on problems generated by GenSTP-2 than on those generated by SPRAND.
This is due to the existence of a cycle connecting all the nodes in problems generated by SPRAND, which prevents decompositions and causes the triangulation process to add relatively more edges.
Improvements due to STP.
As a refinement of PPC, STP exploits the benefits of triangulation to a greater degree than PPC does.
Experimental results show that STP has always better performance than PPC in all experiments we performed (Figure7 and Table 2 and 3).
For high density values, STP can show a worse performance than DPC (Figure 8).
However, this slight degradation is misleading since it does not account for the output of these two algorithms.
Indeed, STP guarantees the minimal network and DPC does not.
Hence, the performance of the former remains superior.
The           8  Table 3.
Experimental results for STP solvers on random STP generated by SPRAND.
Number of Edges 200 400 600 800 1000 1200 1400 1600 1800 2000  CC 125000 125000 125000 125000 125000 125000 125000 125000 125000 125000  F-W CPU (s) 0.8467 0.8492 0.8441 0.8467 0.8457 0.8521 0.8501 0.8513 0.8553 0.8621  400 600 800 1000 1200 1400 1600 2000 2400 2800  1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000  8.5076 8.5019 8.5177 8.5218 8.6507 8.6643 8.7028 8.7978 8.5296 8.8195  F-W+AP CC CPU (s) 125000 0.8255 125000 0.8301 125000 0.8244 125000 0.8274 125000 0.8281 125000 0.8242 125000 0.8243 125000 0.8331 125000 0.8343 125000 0.8363 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000  Random STP generated by SPRAND with 50 nodes DPC DPC+AP CC CPU (s) CC CPU (s) 21824.031 0.2798 21824.031 0.2847 30981.5 0.3677 30981.5 0.3732 34524.73 0.4044 34524.73 0.4035 36254.89 0.4255 36254.89 0.4176 37302.24 0.4369 37302.24 0.4318 38020.63 0.4473 38020.63 0.4382 38502.508 0.4556 38502.508 0.4442 38902.95 0.4647 38902.95 0.4458 39166.152 0.4694 39166.152 0.4532 39381.36 0.4577 39381.36 0.4519  Random STP generated by SPRAND with 100 nodes 8.3707 167877.39 2.1703 167877.39 2.1947 8.3572 218599.22 2.5686 218599.22 2.5723 8.3523 245378.12 2.775 245378.12 2.7759 8.3476 263177.97 2.9213 263177.97 2.9205 8.3242 275036.7 3.0351 275036.7 3.0053 8.3216 283548.44 3.0986 283548.44 3.0367 8.3169 289520.4 3.1461 289520.4 3.082 8.3284 298104.53 3.2074 298104.53 3.148 8.3569 303608.8 3.2493 303608.8 3.2088 8.341 307894.12 3.2842 307894.12 3.2199      PPC CC CPU (s) 20247.77 0.236 42313.25 0.4893 56231.418 0.6606 64894.547 0.7594 69790.15 0.825 73899.914 0.8671 76743 0.9067 79116.336 0.927 80540.03 0.9526 81024.4 0.9536  CC 12111.471 25902.35 34142.043 39436.86 42623.07 44889.09 46354.59 47597.69 48321.05 48789.93  STP CPU (s) 0.1595 0.347 0.4656 0.5334 0.5697 0.5796 0.608 0.6287 0.6306 0.6291  144819.36 241016.73 318725.3 380805.94 434212.72 474789.12 512087.9 565111.94 599295 631238.44  85055.414 146966.83 198716.12 236103.58 268235.28 292905.87 313113.25 343748.66 365377.84 382691  1.4427 2.5927 3.441 4.1202 4.6083 4.886 5.4773 6.0293 5.9462 6.1807  1.7659 2.8585 3.7333 4.4388 5.0349 5.4202 6.1406 6.9515 6.7189 7.3478    GenSTP-1: 50 nodes  GenSTP-1: 50 nodes         &38WLPHV  &RQVWUDLQWFKHNV    DPC+AP      DPC       DPC+AP  'STP    'STP  DPC                                           'HQVLW\              'HQVLW\    Figure 8.
Constraint Checks (left) and CPU time (right) for DPC, DPC+AP, and  STP.
of the original TCSP and thus has a lower density than the TCSP.
This supports the importance of an efficient STP solver for low density networks.
We expect the combination of STP with a TCSP solver to improve dramatically the performance of current TCSP solvers.
experiments on large problems, shown in Figure 9 and 10, demonstrate that STP is the absolute winner over all algorithms.
A comparison of Figure 9 and 10 shows that STP, like PPC, is sensitive to the structure of the temporal graph (i.e., the existence of a cycle).
It is more effective on problems generated with GenSTP-2 than on those generated with SPRAND.
      6 Conclusion and future work  5.3 Significance of our results We introduced STP, a new efficient algorithm for solving the STP.
Our algorithm advantageously exploits previous results reported in the literature and binds them via a new strategy for constraint propagation based on triangles.
We demonstrated that this algorithm outperforms all previous ones in terms of pruning power and performance.
We are currently integrating our new STP solver with a TCSP solver to improve the performance of the latter.
More importantly, STP solver provides us   In practice, most real-world applications exhibit typically STPs with large size and low density [2].
The performance of an STP solver in these situations becomes extremely important.
STP is perfect for this kind of job.
Its outstanding performance under low density is particularly advantageous and makes it the best algorithm developed to date.
Further, when solving a TCSP with search, the STP examined at each node in the search tree is a subgraph     9     (       Constraint Checks    (   (    (    (  (  CPU time    (       (  (  GenSTP-2: 256 nodes 512 nodes    5DWLRFRPSDUHWR):  5DWLRFRPSDUHWR):  (    GenSTP-2: 256 nodes 512 nodes  (   '3&$3  ):  ( (  (    (  '3&  ( (    (  (  '3&   33&  9DULRXV673VROYHUV  '673  (  (    '3&$3  ):    ):$3  ( (  (  ):$3    33&  9DULRXV673VROYHUV  '673  Figure 9.
Constraint Checks (left) and CPU time (right) for STP solvers, problems generated by GenSTP-2.
 (  SPRAND: 257 nodes 513 nodes    5DWLRFRPSDUHWR):  5DWLRFRPSDUHWR):    (    Constraint Checks     ( (    ( (    ( (  ( (    '3&  '3&$3    (  (    (  (  (  '3&   33&  (  '3&$3  (   ):  ):$3  9DULRXV673VROYHUV  '673  (  (    (  9DULRXV673VROYHUV  (    (  ):$3  (  CPU time    ):  (  SPRAND: 257 nodes 513 nodes     33&  '673  Figure 10.
Constraint Checks (left) and CPU time (right) for STP solvers, problems generated by SPRAND.
  with a new perspective on temporal problems as composed by a set of triangles, where two triangles are connected if and only if they have one common edge.
Constraint propagation can be carried out according to this new graph of triangles.
We are exploiting this idea to improve the search performance of the TCSP solver.
Proc.
of the 16 IJCAI, pages 456a461, Stockholm, Sweden, 1999.
Acknowledgments: We are indebted to Mark Boddy, Paul Morris, Nicola Muscettola and Ioannis Tsamardinos for sharing data and information on the STP, and to Deb Derrick for editorial help.
This work is supported by a grant from NASA-Nebraska, the CAREER Award #0133568 from the National Science Foundation, and a gift from Honeywell Laboratories.
[ 2]  Mark Boddy.
Personal communication, 2002.
[ 3]  Amedeo Cesta, Angelo Oddi, and Stephen Smith.
A constraint-based method for project scheduling with time windows.
Journal of Heuristics, 8(1):109a136, April 2002.
[ 4]  Boris V. Cherkasskyn, Andrew V. Goldberg, and Tomasz Radzik.
Shortest Paths Algorithms: Theory and Experimental Evaluation.
Mathematical Programming, 73:129a174, 1996.
[ 5]  Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest.
Introduction to Algorithms.
McGraw-Hill Book Co & MIT Press, 2001.
[ 6]  Thomas Dean and Drew McDermott.
Temporal Data Base Management.
Artificial Intelligence, 32:1a55, 1987.
[ 7]  Rina Dechter.
Constraint Processing.
Manuscript, forthcoming, 2003.
References [ 1]  Christian Bliek and Djamilla Sam-Haroud.
Path Consistency for Triangulated Constraint Graphs.
In  10  [ 8]  Rina Dechter, Itay Meiri, and Judea Pearl.
Temporal Constraint Networks.
Artificial Intelligence, 49:61a 95, 1991.
[ 9]  Eugene C. Freuder.
A Sufficient Condition for Backtrack-Bounded Search.
JACM, 32 (4):755a 761, 1985.
[10] Alan K. Mackworth.
Consistency in Networks of Relations.
Artificial Intelligence, 8:99a118, 1977.
[11] Ugo Montanari.
Networks of Constraints: Fundamental Properties and Application to Picture Processing.
Information Sciences, 7:95a132, 1974.
[12] Nicolas Muscettola, Paul Morris, and Ioannis Tsamardinos.
Reformulating Temporal Plans for Efficient Execution.
In Sixth International Conference on Principles of Knowledge Representation and Reasoning (KRa98), pages 444a452, Trento Italy, 1998.
[13] U. KjASrulff.
Triagulation of Graphs - Algorithms Giving Small Total State Space.
Research Report R-90-09, Aalborg University, Denmark, 1990.
[14] Ioannis Tsamardinos.
Reformulating Temporal Plans for Efficient Excution.
Masteras thesis, Intelligent Systems Program, University of Pittsburgh, 1998.
11