arXiv:0812.1967v1 [cs.LO] 10 Dec 2008  Decomposition of Decidable First-Order Logics over Integers and Realsa Florent Bouchy, Alain Finkel LSV, ENS Cachan, CNRS CNRS UMR 8643, Cachan, France {bouchy,finkel}@lsv.ens-cachan.fr  JASrA'me Leroux Laboratoire Bordelais de Recherche en Informatique CNRS UMR 5800, Talence, France leroux@labri.fr  Abstract  we want to be able to use integers as parameters for a concise representation of pure reals : for instance, reals are used for the values of clocks and integers for expressing the parameters in CPDBM.
We tackle the issue of representing infinite sets of realvalued vectors.
This paper introduces an operator for combining integer and real sets.
Using this operator, we decompose three well-known logics extending Presburger with reals.
Our decomposition splits a logic into two parts : one integer, and one decimal (i.e.
on the interval [0, 1[).
We also give a basis for an implementation of our representation.
Fortunately, the first-order additive logic over integers and reals is decidable.
Nevertheless, the algorithmic of sets combining integers and reals does not seem simple, even when it is based on finite automata like Real Vector Automata [13, 16] or weak RVA [8], or based on quantifier elimination [29].
1 Introduction  For that matter, the algorithmic of Presburger (using finite automata) and variations of DBM are quite efficient.
Hence, our idea is to reduce the algorithmic difficulty of the first-order additive logic of integers and reals (and of some subclasses and decidable extensions) by decomposing a complex set of integers and reals into a finite union of sums of integer sets and decimal sets.
By decimal, we mean numbers in the dense inteval [0, 1[ ; then, we define a new class of sets as follows.
Given n sets of integers (Zi )0a$?ia$?n and n sets of decimals (Di )0a$?ia$?n , we introduce the operator finite union of sums, which builds the finite unions of the sums Zi + Di .
This class is shown stable under boolean operations, cartesian product, quantification and reordering if both of the two initial classes are also stable.
Verification (and model-checking in particular) of infinite systems like timed automata [1] (and hybrid systems) and counter systems [5] need good symbolic representation classes ; by good, we mean having closure properties (by first-order logic operators) and decidability results (for testing inclusion and emptiness).
Presburger arithmetic [27, 23] enjoys such good properties, and some efficient implementations (using finite automata) have been intensively used for the analysis of counter systems [6, 20, 14, 15].
Despite the fact that the complete arithmetic on reals is decidable [28], only some restricted classes of the firstorder additive logic of reals (DBM, CPDBM, finite unions of convex polyhedra) have been used for the analysis of timed automata.
This is mainly due to the fact that the algorithmic complexity of DBM is polynomial, which is the basis of efficient verification algorithms for timed automata in U PPA AL [11, 25].
One of our aims is then to re-use, in combining the best representations of these two initial sets (Zi )0a$?ia$?n and (Di )0a$?ia$?n , the best libraries dealing with them to efficiently handle finite unions of (Zi + Di )0a$?ia$?n (for instance : P RES TAF [7] for the integers and PPL [4] for the reals).
However, we would like to be able to use both integers and reals, for at least two reasons.
First, we want to analyse timed counter systems [2, 3, 13] in which the reachability sets contain vectors with both integers and reals.
Second,  We show that three of the main classes of mixed integer and real sets are in fact finite unions of sums of well-known classes.
We prove that finite unions of sums of Presburger set of integers, and sets definable in the first-order additive logic of decimals are exactly the sets definable in the  a Work supported by the Agence Nationale de la Recherche, grant ANR-06-SETIN-001.
1  (ci,j , asi,j ) means that ri a rj asi,j ci,j , where ri , rj are clocks.
Thus, each element of a DBM represents a diagonal constraint (i.e.
a bounded difference).
Finally, terms that do not represent any actual constraint are symbolized by ci,j = +a.
first-order logic of integers and reals.
The finite unions of CPDBM are expressible as the finite unions of sums of Presburger-definable sets and DBM-definable decimal sets.
Moreover, when we go beyond Presburger by considering RVA, we show that the class of sets representable by RVA in basis b is the finite unions of sums of Presburger extended with a predicate Vb (which gives integer powers in base b) and the additive logic of decimals extended with a predicate Wb (which, similarily to Vb , gives negative powers in base b).
2.2 About extensions of DBM On the following example taken from [9], the timed automaton features 2 clocks x and y, and a unique location.
The automatonas behaviour is very simple : y is reset to 0 as soon as it reaches 1, while x flows continually.
In the initial state, the clocks are both set to 0.
Moreover, an invariant in the location ensures that y never exceeds 1.
2 Representations mixing integers and reals In this section, we motivate our work with a small example of timed automaton.
We show that extracting integers from reals can yield more concise formula than pure reals.
Then we introduce an operator combining integer and real sets of vectors.
y := 0 x := 0 x aL 1 aSS y = 1, y := 0  (y a$?
1)  2.1 Timed Automata and DBM The clock diagram associated to the automaton explicitely shows this behaviour :  In order to study real-life systems involving behaviours that depend on time elapsing, timed automata are probably the most used and well-known model for such systems.
As described in [1], the basic idea of timed automata is to add real-valued variables (called clocks) to finite automata.
These clocks model temporal behaviours of the system, flowing at a universal constant rate ; each clock can be compared to an integer constant, and possibly reset to 0.
The only other guard allowed is called a diagonal constraint, consisting in comparing the difference of two clocks to an integer constant.
As the clocksa values are unbounded, the state-space generated by a timed automaton is infinite ; therefore, regions are used to model a finite abstraction of the systemas behaviour.
Practically intractable because of its size, the region graph is then implemented as zones in most verification tools [11, 25, 18, 24] modelling such real-time systems.
y 2 1 0  1  2  3  4  5  x  A classical forward analysis [17] is considered here, by computing the reachable states (i.e.
location A clock values) from the initial one (where x = y = 0).
Then, we build the corresponding zones, each zone being represented by a DBM ; here, we have an infinite yet countable set of DBM as follows.
Note that in this example as is always a$?
; therefore, we will omit it in the matrices.
dLa dL' dL' dL,  Technically, zones are represented by Difference Bound Matrices (DBM) [12, 21] in these tools.
A DBM is a square matrix representing the constraints between n clocks defining a zone.
Here, we see a DBM as a tuple (c, as), where c = (ci,j )0a$?i,ja$?n , as = (asi,j )0a$?i,ja$?n , ci,j a Z aS {+a}, and asi,j a {a$?, <}.
Each element of this tuple is an element of the square matrix, defining a DBM set as follows : ^ ri a rj asi,j ci,j } Rc,as = {r a Rn |  dL' dL' dLl  0 0 x y  dLT  x  0 ai dLi + 1 0 1 ai  y  dLs 0 idL, 0  dLz dL' dL' dL" dL' dL' dLz  iaL0  In order to make the state-space computable, abstraction techniques are used to get a finite number of zones.
The abstraction being used in most model-checkers is based on maximum constants : a clock cas valuation is considered equal to a as soon as it exceeds the maximal constant to which c is ever compared.
On the example, if a guarded transition x aL 106 leads to another state, then the clock diagram becomes as follows :  0a$?i,ja$?n  In order to deal with constraints involving only one clock, the fictive clock r0 is always set to the value 0.
An element 2  y  the union of the following three sums suffices :   {0, .
.
.
, 106 a 1} A {0} +  [ {106 } A {0} +  [ {106 + 1, .
.
.
, a} A {0} +  2 1 0  1  More formally, of DBM : dLadLa dL' x dL' dLT 0 dL' dL' dL,0 dL,dL' 0 ai dL' x dLi + 1 0 dL' dL' dL' dL' dLldLl y 1 ai  2  AV AV AV 106  x  this abstraction yields the following set  dLz dL' dLs dL' dL"  0  y  0 idL, dL' dL' dLz 0  0a$?ia$?106  ,  0  dLT  0  x dLa y  1  x  a 0 a106  This latter symbolic representation of such a reachability set is much smaller than DBM.
Indeed, representing zones with DBM implies memorizing a possibly huge number of matrices, depending on the maximal constant for the clocks (one million, in this example).
However, by introducing integers to express periodicity, we can reduce the representation to three small combinations of intervals.
Moreover, we can even get rid of the abstraction, so as to get an exact representation for the same cost.
CPDBM also have these advantages, but are undecidable because of the multiplication.
Hence, let us specify a little more what is our representation : we take finite unions of reals, real numbers being decomposed as sums of integers and smaller reals (called decimals).
These integers and reals can be defined using quantification, addition, and boolean operators.
dLz dL' dLsdL' dL' 0 dL" adL,dL' dL' dLz 0 dL' y  This set of DBM is finite, but remains huge : 106 + 2 matrices need to be computed and memorized, which seems exaggerated, a fortiori for such a simple example.
In [9], a more elaborate abstraction is proposed : the clocksa maximal constants are no more global to the system, but location-dependent.
Another abstraction technique is proposed in [10], distinguishing between upper and lower bounds within maximal constants.
To the best of our knowledge, these are the only zone-based abstraction techniques ; in each of them, the number of DBM still heavily depends on maximal constants.
Actually, our approach comes down to representing sets of real numbers by extracting their integer components ; the interesting point is that adding integers to real sets can simplify their representation and ease their handling.
One might think that adding integers to such a first-order real logic would make it undecidable, but section 3 proves the opposite.
Before that, we need to formalize our representation.
Writing here such an infinite or huge number of DBM would have been impossible ; therefore, we naturally used a parametric representation of these DBM.
Actually, this idea is also used by Constrained Parametric DBM (CPDBM) [2], which is the data structure implemented in the TR E X [3] model-checker.
CPDBM are indeed a more expressive version of DBM, extended in two steps.
First, we consider PDBM, in which ci,j constants become ti,j arithmetical terms (the parameters).
Such arithmetical terms t are given by the grammar t ::= 0 | 1 | x | t a t | t + t | t a t, where x belongs to a set X of real variables.
Second, a PDBM becomes a CPDBM as terms are constrained by quantifier-free first-order formulas D. Such formulas are defined by D ::= t a$?
t | AZD | D a" D | Is_int(t) (where the predicate Is_int(t) is true iff t is an integer).
Each of the two sets of matrices hereinabove is in fact a single CPDBM.
2.3 Composing integers and reals Notations.
The set [0, 1[ is denoted by D in the sequel.
We also call a decimal (number) any d a D, and a decimal set any D a D. We write x to denote a vector (x1 , .
.
.
, xn ).
Sometimes, in order to be concise, we use FO (.
.
. )
to denote the sets represented by this first-order logic.
However, it does not make our statements incorrect, because we mostly discuss the expressive power of such logics.
Consider now another way to represent the set of reachable clock values.
On the second diagram showing the abstraction, we can see an obvious regular pattern along x, , , and .
We define defined by three shapes : = {(x, y) a [0, 1]2 | x = y}, each shape as follows : = {(x, y) a [0, 1]2 | x aL y}, and = {(x, y) a [0, 1]2 }.
If we want to represent the same set as the previous abstracted zones, but without DBM, we can express the periodicity of each pattern with integers.
To formalize it, taking  Let Z a P(Zn ) and D a P(Dn ) ; we will assume in this paper that we are using nadimensional vectors, with n a N. We denote by1 Z a D the class of real vectors p [ (Zi + Di ), with (Zi , Di ) a Z A D R a Rn s.t.
R = i=1  1 The  symbol a is sometimes used for the disjoint union, but we do not use such unions in this paper.
3  S Definition 5.
A class R a naN P(Rn ) is stable if it is closed under boolean operations, cartesian product, quantification, and reordering.
and p aL 1.
Here are some examples of simple sets that might be often used, written as finite unions of sums of integers and decimals :  Notice that taking the union of two such sets is trivial, as they are already unions of integer and decimal parts.
Then, observe that (Z1 +D1 )aS(Z2 +D2 ) = (Z1 aSZ2 )+(D1 aSD2 ) for any Z1 , Z2 a Zn and for any D1 , D2 a Dn ; thus, the stability by union of Zn a Dn provides the stability by intersection.
From the equality (Z1 + D1 )\(Z2 + D2 ) = ((Z1 \Z2 ) + D1 ) aS (Z1 + (D1 \D2 )) we get the stability by difference.
The stability by cartesian product is provided by (Z1 + D1 ) A (Z2 + D2 ) = (Z1 A Z2 ) + (D1 A D2 ).
The stability by projection comes from ai R = (ai Z) + (ai D), where R = Z + D. Finally, the stability by reordering is obtained thanks to D(Z + D) = (DZ) + (DD).
We have proved the following proposition, which is later used in the proofs of theorem 7 and proposition 10 :  Example 1.
The empty set a is written a + a.
The set Rn is written Zn + Dn .
The set Zn is written Zn + {0}.
Example 2.
The set R= = {r a R2 | r1 = r2 } is written {z a Z2 | z1 = z2 } + {d a D2 | d1 = d2 } Example 3.
The set Ra$?
= {r a R2 | r1 a$?
r2 } is written : {z a Z2 | z1 a$?
z2 } + {d a D2 | d1 a$?
d2 } [ {z a Z2 | z1 < z2 } + {d a D2 | d1 > d2 }  3 Example S 4.
The set R+ 3= {r a R | r1 + r2 = r3 } is written ca{0,1} {z a Z | z1 + z2 + c = z3 } + {d a D3 | d1 + d2 = d3 + c}, where c denotes a carry.
Proposition 6 (Stability).
The class Z a D is stable if Z and D are stable.
The limits of our representation can be seen with the following counter-example.
Consider the set   a  [ 1 {j} + R = ; note that we use j + 1 j+1 j=1  3 First-order additive logic over integers and reals Using at the same time integers and reals in the whole arithmetic is known to be undecidable.
However, when multiplication is left apart, the first-order additive logic is decidable ; its decidability has been suggested by BAzchi, then proved by [16] with automata and by [29] using quantifier elimination.
Actually, it can be seen as the Presburger logic [27] extended to the reals.
This firstorder logic FO (R, Z, +, a$?)
can encode complex linear constraints combining both integral and real variables.
In this section we prove that sets definable in this logic can be decomposed into finite unions of Z + R where Z is definable in FO (Z, +, a$?)
and R is definable in FO (D, +, a$?).
This result proves that complex linear constraints combining integral and real variables can be decomposed into linear constraints over integers, and linear constraints over reals.
More precisely, we prove the following decomposition :  (and not simply j) to avoid the case where the decimal part is 1j = 1 for j = 1 (because it would not be a decimal, i.e.
in [0, 1[).
Our representation can not deal with such a set ; indeed, despite the fact that it is a union of sums of integers and decimals, we can see that the union is inherently infinite.
We insist on the finiteness of the union in our representation, mainly for implementability reasons ; this will be discussed in section 5.
Now, let us consider S S the stability of our representation.
We prove2 that if Z a naN P(Zn ) and D a naN P(Dn ) are stable by theSclassical first order operations then the class Z a D = naN Zn a Dn where Zn = Z aS P(Zn ) and Dn = D aS P(Dn ) is also stable by these operations.
The operations we consider are : boolean combinations (union, intersection, difference), cartesian product, quantification, and reordering.
We use the following definitions for these last two operations.
First, quantification is done by projecting away variables from the considered vector : aR a Rn , ai R = {(r1 , .
.
.
, ria1 , ri+1 , .
.
.
, rn ) | ari (r1 , .
.
.
, ria1 , ri , ri+1 , .
.
.
, rn ) a R}.
Second, a reordering is a mere permutation function D of the variables order in a vector : aR a Rn , DR = {(rD(1) , .
.
.
, rD(n) ) | (r1 , .
.
.
, rn ) a R}.
Then, we introduce a generic definition for stability :  Theorem 7.
FO (R, Z, +, a$?)
FO (D, +, a$?).
=  FO (Z, +, a$?)
a  Proof.
First of all, observe that any set definable in the logic FO (Z, +, a$?)
a FO (D, +, a$?)
is also definable in FO (R, Z, +, a$?).
Conversely, the sets R and Z, the function + : R A R a R and the predicate a$?
are definable in FO (Z, +, a$?)
a FO (D, +, a$?)
from examples 1, 2, 3, 4.
Thus, stability by first order operations provides the inclusion FO (R, Z, +, a$?)
a FO (Z, +, a$?)
a FO (D, +, a$?).
We deduce the equality.
2 Here we have to take unions, depending on the number of dimensions, for a technical purpose : the projection of a component in the vector.
4  formula D(x)Sdenoting a set Z a Zn and let us prove that Z + D is a CP-DBM+ set.
Observe that r a Z + D if and only if there exists z a Z such thatVr a z a D. The condition r a z a D is equivalent to 0a$?i,ja$?n ri a rj asi,j ci,j +zi azj .
Let us consider the Presburger formula D(p) := az a Zn pi,j = ci,j + zi a zj and observe that RD,as = Z + D. We have proved the inclusion a.
For the converse inclusion, let us consider a CP-DBM+ set RD,as .
Let Zd = Zn aS (RD,as a d) indexed by d a Dn .
Observe that Zd is actually the following set of vectors : dLz dLa dL" ^ [ dL, zi a zj asi,j ci,j + (dj a di ) z a Zn | Zd = dLz dLl  Now, let us recall that sets definable in the Presburger logic FO (Z, +, a$?)
can be characterized thanks to linear sets [23].
In fact, a set Z a Zn is definable in this logic if and only if it is equal to a finite union of linear sets b + P a finite subset of Zn , and P a denotes where b a Zn , P is a P k the set of finite sums i=1 pi with p1 , .
.
.
, pk a P and k a N. This geometrical characterization can be extended to the class of sets definable in FO (Z, +, a$?
)aFO (D, +, a$?)
by introducing the class of polyhedral convex sets.
A set C a Rn is said polyhedral convex if C is defined by a finite conjunction of formulas hIa, xi as c where Ia a Zn , asa {a$?, <} and c a Z.
Recall that a Fourier-Motzkin quantification elimination proves that a set C a Rn is definable in FO (R, +, a$?)
if and only if it is equal to a finite union of polyhedral convex sets.
In [22], the authors have proved the following geometrical characterization : A set R a Rn is definable in FO (R, Z, +, a$?)
if and only if it is equal to a finite union of sets of the form C + P a where C a Rn is a polyhedral convex set and P is a finite subset of Zn .
0a$?i,ja$?n  c|=D  Since dj a di a ]a1, 1[ and zi a zj , ci,j a Z we deduce that zi a zj asi,j ci,j + (dj a di ) is equivalent to zi a zj a$?
ci,j if di a dj asi,j 0 and it is equivalent to zi a zj a$?
ci,j a 1 otherwise.
Given a matrix m = (mi,j )0a$?i,ja$?n such that mi,j a {0, 1} for any 0 a$?
i, j a$?
n, we denote by Im and Dm the following sets: ^ zi a zj a$?
ci,j a mi,j } Im = {z a Zn | ac D(c) aSS  3.1 Decomposing DBM-based representations  0a$?i,ja$?n  In this section, we characterize an extension of DBM.
We S denote by DBMD the finite Sunions of DBM sets which are included in Dn .
Notice that DBMD is stable by first order operations, thanks to a Fourier-Motzkin quantifier elimination.
Dm = {d a D | n  ^  (di a dj asi,j 0 aa mi,j = 0)}  0a$?i,ja$?n  Note that set and Zd = Im for any S Dm is a DBM S d a Dm .
n D = From S we deduce that R = D m D,as m daDn Zd + We have proved that RD,as is defin{d} = m Im + Dm .
S able in FO (Z, +, a$?)
a DBMD .
A CP-DBML is a DBM where the vector c is no longer a constant, but a vector of parameters constrained by a formula D(c) defined in a logic L. More precisely, a CPDBML is a tuple (D, as) representing a set RD,as s.t.
: [ Rc,as RD,as =  4 Beyond Presburger We have just shown our decomposition to be working on FO (R, Z, +, a$?)
and below.
Now, we prove that it can also be used on more expressive logics.
We take the example of Real Vector Automata (RVA) [16], which is, to the best of our knowledge, the most expressive decidable implemented representation for sets of real and integer vectors.
RVA are used in the tool LASH [14, 15].
In this section, the class of sets representable by RVA is proved decomposable into our formalism.
c|=D  As introduced in [2], CPDBM correspond to CP-DBML where L is the first-order arithmetic without quantifiers ; in particular, multiplication is allowed in this formalism.
In this section, we study another variation of DBM : CP-DBM+ , which is CP-DBML where L is the decidable Presburger logic FO (Z, +, a$?).
That is, CP-DBM+ are CPDBM with S quantifiers but without multiplication.
We denote by CP-DBM+ the finite unions of RD,as , i.e.
finite unions of CP-DBM+ sets.
Let b aL 2 be an integer called the basis of decomposition.
We denote by ILb = {0, .
.
.
, ba1} the finite set of digits and by Sb = {0, b a 1} the set of sign digits.
An infinite word D = sa1 .
.
.
ak aak+1 ak+2 .
.
.
over the alphabet ILnb aS{a} is said b-correct if s a Sbn and ai a ILnb for any i aL 1.
In this case, D is called a most significant digit first decomposition of the following real vector Db (D) a Rn : dLs dLT X s + bai ai dL, Db (D) = bk dL 1ab  We show that finite unions of CP-DBM+ sets are in fact a combination of Presburger-definable sets and finite unions of DBM decimal sets : S Proposition 8.
We have CP-DBM+ = FO (Z, +, a$?)
a S DBMD .
Proof.
Let us first prove the inclusion a.
Let us consider a DBM (c, as) denoting a set D a Dn and a Presburger  iaL1  5  (i.e.
without Wb ).
Just remark that FO (R, Z, +, a$?, Vb ) = FO (Z, +, a$?, Vb ) a FO (D, +, a$?).
Finally, note that weak RVA are used in the tool LIRA [8], whose benchmarks show very efficient computation times for sets defined in FO (R, Z, +, a$?).
A Real Vector Automaton (RVA) in basis b is a BAzchi automaton A over the alphabet ILnb aS {a} such that the language Lan(A) recognized by A contains only b-correct words.
The set JAK represented by A is defined by JAK = {Db (D) | D a Lan(A)}.
A set R a Rn is said brecognizable if there exists a RVA A in basis b such that R = JAK.
5 Towards an implementation  According to [16], the class of b-recognizable sets can be logically characterized by FO (R, Z, +, a$?, Xb ) where Xb is an additional predicate.
The predicate Xb over R3 is such that Xb (x, u, a) is true if and only if there exists a most significant digit first decomposition D = sa1 .
.
.
ak a ak+1 .
.
.
of x and an integer i a N such that ai = a and u = bkai .
From an implementation perspective, our decomposition has been designed to fit G ENEPIas requirements.
G ENEPI [26] is a modular framework supporting Presburger-based solvers and model-checkers, distributed under GNU Public License.
Its core consists of a plugin manager, which computes generic operations (such as boolean operations, quantification, satisfiability) on sets encoded as the solutions of Presburger-like formulas.
Different implementations of these operations can be used as plugins ; existing ones include P RES TAF, LIRA, LASH, MONA, OMEGA, and PPL.
We have begun to design a plugin for our decomposition, which uses two existing plugins : one for the integer part, and one for the decimal part.
Theorem 9.
[16] A set R a Rn is b-recognizable if and only if it is definable in FO (R, Z, +, a$?, Xb ).
In order to provide a decompostion of FO (R, Z, +, a$?, Xb ), the predicate Xb is proved expressible by two valuation functions Vb and Wb where : aV Vb : Z\{0} a Z is the integer valuation function introduced in [19] and defined by Vb (z) = bj , where j a Z is the greatest integer such that baj z a Z.
Once this plugin is ready, any combination of two other plugins is possible : for example, one could try P RES TAF over integers and PPL over decimals.
One could even be curious and study the efficiency of two instances of LIRA plugins, each one working on its own part (integer or decimal).
Another benefit, coming from the new decomposition of RVA, would be to use the LASH plugin only on one part, and manage the other one differently : this might improve the effectiveness of RVA, which are very expressive but not really efficient in practice.
So far, our first tests on small conjunctions of linear constraints show execution times close to the ones of LIRA.
aV Wb : D\{0} a D is the decimal valuation function defined by Wb (d) = bj , where j a Z is the least integer such that baj d 6a D. By expressing Xb in FO (R, Z, +, a$?, Vb , Wb ) and Vb , Wb in FO (R, Z, +, a$?, Xb ) we deduce that FO (R, Z, +, a$?, Xb ) = FO (R, Z, +, a$?, Vb , Wb ).
Finally, from proposition 6 and theorem 7, we get the following proposition.
Proposition 10.
FO (R, Z, +, a$?, Xb ) FO (Z, +, a$?, Vb ) a FO (D, +, a$?, Wb ).
=  What we need now for an implementation is a unique way to represent sets.
Indeed, in order to avoid unduly complicated representations of sets, we have to make our representation canonical.
Therefore, let us set the theoretical framework we use in practice.
Moreover, it is clear that the logic FO (Z, +, a$?, Vb ) a FO (D, +, a$?, Wb ) extends FO (Z, +, a$?)
a FO (D, +, a$?).
However, even if the function Wb is crucial to logically characterize the class of b-recognizable sets, this predicate is not used in practice.
In fact, in order to get efficient algorithms for manipulating BAzchi automata (more precisely, minimization and determinization), we only consider sets R a Rn that can be represented by a weak RVA [14].
Recall that a BAzchi automaton A is said weak if any strongly connected component S satisfies S a F or S aS F = a, where F is the set of accepting states.
Unfortunately, the class of sets R a Rn representable by a weak RVA is not logically characterized since this class is not stable by first order operations (because of projection).
In practice, since any set R a Rn definable in FO (R, Z, +, a$?, Vb ) can be represented by a weak RVA, the RVA symbolic representation is only used for representing sets in this logic  Let Z a P(Zn ) and D a P(Dn ).
Notice that if R = (Z +D1 )aS(Z +D2 ), then R = Z +D with D = D1 aSD2 ; we will always suppose that D is closed under union wlog.
Then, notice that R a Rn can be represented by a partially defined function fR such that : fR : Z aa D Zi 7aa Di This  functionas interpretation is defined as p   [ Zi + fR (Zi ) , which matches the natuJfR K = i=1  6  fa$?
(Za$? )
= Da$?
and fa$?
(Z) = a otherwise where:  ral writing of R introduced in section 2.3.
Note that this representation fR is not unique.
Z< = {z a Z2 | z1 < z2 } Za$?
= {z a Z2 | z1 a$?
z2 }  For technical reasons, we extend fR to a totally defined function fR s.t.
fR (Z) = a if Z a / dom(fR ) and fR (Z) = fR (Z) otherwise.
Moreover, we define the support of fR as supp(fR ) = {Z | fR (Z) 6= a}.
In the remainder of this paper, we will use without ambiguity the notation fR instead of fR .
D> = {d a D2 | d1 > d2 }  Da$?
= {d a D2 | d1 a$?
d2 }  Example 16.
The set R+ = {r a R3 | r1 + r2 = r3 } is represented by the IDF f+ defined by f+ (Z0 ) = D0 , f+ (Z1 ) = D1 , f+ (a) = D3 \(D1 aS D2 ) and f+ (Z) = a otherwise where (intuitively c a {0, 1} denotes a carry) : Zc = {z a Z3 | z1 + z2 + c = z3 }  Dc = {d a D3 | d1 + d2 = d3 + c}  We are now able to represent the set R with a function we wish to handle.
Therefore, we want to identify fR and JfR K : in order to do so, this latter interpretation has to be an injection.
Generally, this is not the case : using the previous definitions, we could have different writings of JfR K. However, if the images by fR are disjoint, then the interpretation JfR K is an injection.
Finally, for effectivity reasons, we will only consider functions whose support is finite.
In the remainder of this section, we formalize this reasoning.
Let FZaD = {f : Z aa D | supp(f ) is finite}.
Observe that any set in JIDFZn aDn K is in Zn aDn .
The converse is obtained by proving the following proposition : Proposition 17 (Closure by union).
Let R a JIDFZn aaDn K. Then, for any Z a Zn and D a Dn , we also have R aS (Z + D) a JIDFZn aDn K. Proof.
We consider an IDF f : Zn aa Dn such that Jf K = R and two sets Z a Zn and D a Dn .
We must prove that there exists an IDF f a, : Zn aa Dn such that Jf a, K = Ra, with Ra, = RaS(Z+D).
We consider the following function:  Definition 11.
The interpretation function J.K associates to every f a FZaD a set  of real vectors defined by [ Z + f (Z) .
Jf K =  f a, : Zn Z  Zasupp(f )  Notice that since supp(f ) is finite, FZaD do not suffice to represent every set of real vectors, as shown in the counter-example on page 4.
Let us now restrict ourselves to the functions we handle :  a,  aa  Dn  aa f (Z a, )\D  [  Z a,a, | Z a,a, aSZ=Z a,    f (Z a,a, ) aS D    As expected we are going to prove that f a, is an IDF such that Jf a, K = Ra, .SWe first show that f a, is an IDF.
First of all observe that Z a, f a, (Z a, ) = Dn .
Next, let Z1a, , Z2a, a Zn such that f a, (Z1a, ) aS f a, (Z2a, ) 6= a then either (f (Z1a, )\D) aS (f (Z2a, )\D) 6= a or there exists Z1a,a, , Z2a,a, such that Z1a,a, aS Z = Z1a, and Z2a,a, aS Z = Z2a, and (f (Z1a,a, ) aS D) aS (f (Z2a,a, ) aS D) 6= a since the other cases are not possible.
But (f (Z1a, )\D) aS (f (Z2a, )\D) 6= a implies f (Z1a, ) aS f (Z2a, ) 6= a and since f is an IDF we get Z1a, = Z2a, .
And (f (Z1a,a, )aSD)aS(f (Z2a,a, )aSD) 6= a implies Z1a,a, = Z2a,a, and in particular Z1a, = Z2a, .
We have proved that f a, is an IDF.
Finally, equality Jf a, K = Ra, comes from: [ Jf a, K = (Z a, + f a, (Z a, ))  Definition 12.
An IDF (Integer-Decimal Function) is a S function f a FZaD such that Z f (Z) = Dn and such that Z 6= Z a, =a f (Z) aS f (Z a, ) = a.
We denote them all by IDFZaD = {f a FZaD | f is an IDF}.
We also write JIDFZaD K = {Jf K | f a IDFZaD }.
The sets from examples 1, 2, 3, 4 are represented by the following IDF : Example 13.
The empty set a is represented by the IDF faL defined by faL (Z) = a for any Z 6= a and by faL (a) = Dn .
The set Rn is represented by the IDF fa$?
(also noted fRn ) defined by fa$?
(Zn ) = Dn and fa$?
(Z) = a otherwise.
The set Zn is represented by the IDF fZn defined by fZn (Zn ) = {0} and fZn (Z) = a otherwise.
Za,  =  [  (Z a, + (f (Z a, )\D))  Za,  [  Z a,a, | Z a,a, aSZ=Z a,  Example 14.
The set R= = {r a R2 | r1 = r2 } is represented by the IDF f= defined by f= (Z= ) = D= , f= (a) = D2 \D= and f= (Z) = a otherwise, where:  =   (Z a, + (f (Z a,a, ) aS D))  [ [ (Z a, + (f (Z a, )\D)) ((Z a,a, aS Z) + (f (Z a,a, ) aS D)) Za,  Z a,a,  [ = (Z a,a, + ((f (Z a,a, )\D) aS (f (Z a,a, ) aS D)))  Z= = {z a Z2 | z1 = z2 } D= = {d a D2 | d1 = d2 }  Z a,a,  [ aS (Z + D aS ( f (Z a,a, )))  Example 15.
The set Ra$?
= {r a R2 | r1 a$?
r2 } is represented by the IDF fa$?
defined by fa$?
(Z< ) = D> ,  Z a,a,  = Jf K aS (Z + D) 7  no algorithm computing directly the convex hull of a set defined in FO (R, Z, +, a$?)
; but thanks to our decomposition, the problem reduces to the computation of the convex hull of Presburger-definable sets (as automata [19] or as semi-linear sets [23]), and the convex hull of sets definable in FO (D, +, a$?)
(as finite unions of convex sets, using Fourier-Motzkin).
We can push this reasoning to other symbolic representations and to other operations, such as upward or downward closure.
Hence, we have just proved the following proposition : Proposition 18.
Zn a Dn = JIDFZn aDn K Let us prove that this new representation is canonical : Proposition 19.
For any f1 , f2 a IDFZaD , Jf1 K = Jf2 K =a f1 = f2 .
Proof.
Consider Z1 a Zn and let us prove that f1 (Z1 ) a f2 (Z1 ).
Naturally, we can assume that f1 (Z1 ) 6= a since otherwise the inclusion is immediate.
In this case, there exists d a f1 (Z1 ).
As (f2 (Z))Z forms a sharing of Dn , there exists Z2 such that d a f2 (Z2 ).
Let us prove that Z1 a Z2 .
We can assume that Z1 6= a.
Let z1 a Z1 and observe that r1 = z1 + d a Jf1 K and from Jf1 K = Jf2 K we get r1 a Jf2 K. Thus, there exists Z2a, such that r1 a Z2a, + f2 (Z2a, ).
Since Z2a, a Zn and f2 (Z2a, ) a Dn we get z1 a Z2a, and d a f2 (Z2a, ).
As (f2 (Z))Z forms a sharing of Dn and d a f2 (Z2 ) aS f2 (Z2a, ) we get Z2 = Z2a, .
In particular z1 a Z2 and we have proved that Z1 a Z2 .
The other inclusion Z2 a Z1 is obtained symetrically.
We have proved that Z1 = Z2 .
Therefore, f1 (Z1 ) a f2 (Z1 ) for any Z1 .
By symmetry we deduce that f1 (Z) = f2 (Z) for any Z.
Therefore f1 = f2 .
Globally, this method of separating integers and reals would speed up the software development process, because of the ease of using already existing plugins.
As mentioned above, one can test the combination of any pair of plugins (provided thereas at least one working on reals and another one on integers).
Furthermore, a very interesting point is that a programmer can test his new plugin for real sets directly in G ENEPI, and then extend its expressivity by coupling it with P RES TAF or another plugin handling integer sets.
Obviously, the converse (extending an integer plugin to the reals) is also possible in the same fashion.
References [1] R. Alur and D. L. Dill.
A theory of timed automata.
Theoretical Computer Science, 126(2):183a235, 1994.
[2] A. Annichini, E. Asarin, and A. Bouajjani.
Symbolic techniques for parametric reasoning about counter and clock systems.
In Computer Aided Verification, 12th International Conference, CAV 2000, Chicago, IL, USA, July 15-19, 2000, Proceedings, volume 1855 of Lecture Notes in Computer Science, pages 419a434.
Springer, 2000.
[3] A. Annichini, A. Bouajjani, and M. Sighireanu.
TReX: A tool for reachability analysis of complex systems.
In Computer Aided Verification, 13th International Conference, CAV 2001, Paris, France, July 18-22, 2001, Proceedings, volume 2102 of Lecture Notes in Computer Science, pages 368a372.
Springer, 2001.
[4] R. Bagnara, P. M. Hill, and E. Zaffanella.
The Parma Polyhedra Library: Toward a complete set of numerical abstractions for the analysis and verification of hardware and software systems.
Science of Computer Programming, 2008.
To appear.
[5] S. Bardin, A. Finkel, and J. Leroux.
FASTer acceleration of counter automata in practice.
In Tools and Algorithms for the Construction and Analysis of Systems, 10th International Conference, TACAS 2004, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2004, Barcelona, Spain, March 29 - April 2, 2004, Proceedings, volume 2988 of Lecture Notes in Computer Science, pages 576a590.
Springer, 2004.
[6] S. Bardin, A. Finkel, J. Leroux, and L. Petrucci.
FAST: Fast Acceleration of Symbolic Transition systems.
In Computer Aided Verification, 15th International Conference,  Notice that in practice, this canonicity depends on how the sets in Z and D are represented.
Indeed, if any of these representations are not canonical, then we can not guarantee that an IDFZaD will be canonical.
6 Conclusion We have proposed a decomposition of three known classes into finite unions of sums of integers and decimals, providing a new characterization.
This decomposition can be applied to other subsets of real vectors, and possibly yield an interest in the exploration of decidable subclasses of the full arithmetic.
Our main goal is to use this representation of real vectors to verify infinite systems involving counters and clocks.
Indeed, we wish to extend the abilities of the tool FAST [6] to the reals, so that it can compute exact reachability sets using acceleration techniques.
A first step in such an implementation is the framework G ENEPI, allowing to solve mixed integer and real constraints defined in first-order theories.
Thus, our decomposition would allow working separately on integers and reals.
Another advantage of our decomposition is that we can now compute operations that we did not know how to perform on certain logics.
For example, there is currently 8  [7]  [8]  [9]  [10]  [11]  [12]  [13]  [14]  [15]  [16]  [17] P. Bouyer, F. Laroussinie, and P.-A.
Reynier.
Diagonal constraints in timed automata: Forward analysis of timed systems.
In Formal Modeling and Analysis of Timed Systems, Third International Conference, FORMATS 2005, Uppsala, Sweden, September 26-28, 2005, Proceedings, volume 3829 of Lecture Notes in Computer Science, pages 112a 126.
Springer, 2005.
[18] M. Bozga, C. Daws, O. Maler, A. Olivero, S. Tripakis, and S. Yovine.
Kronos: A model-checking tool for real-time systems.
In Computer Aided Verification, 10th International Conference, CAV a98, Vancouver, BC, Canada, June 28 July 2, 1998, Proceedings, volume 1427 of Lecture Notes in Computer Science, pages 546a550.
Springer, 1998.
[19] V. BruyA"re, G. Hansel, C. Michaux, and R. Villemaire.
Logic and p-recognizable sets of integers.
Bulletin of the Belgian Mathematical Society, 1(2):191a238, 1994.
[20] C. Darlot, A. Finkel, and L. van Begin.
About FAST and TReX accelerations.
Electronic Notes in Theoretical Computer Science, 128(6):87a103, 2005.
[21] D. L. Dill.
Timing assumptions and verification of finitestate concurrent systems.
In Automatic Verification Methods for Finite State Systems, International Workshop, Grenoble, France, June 12-14, 1989, Proceedings, volume 407 of Lecture Notes in Computer Science, pages 197a212.
Springer, 1989.
[22] A. Finkel and J. Leroux.
Presburger functions are piecewise linear.
Research Report LSV-08-08, Laboratoire SpAScification et VASrification, ENS Cachan, France, Mar.
2008.
9 pages.
[23] S. Ginsburg and E. H. Spanier.
Semigroups, Presburger formulas, and languages.
Pacific Journal of Mathematics, 16(2):285a296, 1966.
[24] F. Laroussinie and K. G. Larsen.
CMC: A tool for compositional model-checking of real-time systems.
In Formal Description Techniques and Protocol Specification, Testing and Verification, FORTE XI / PSTV XVIIIa98, IFIP TC6 WG6.1 Joint International Conference on Formal Description Techniques for Distributed Systems and Communication Protocols (FORTE XI) and Protocol Specification, Testing and Verification (PSTV XVIII), 3-6 November, 1998, Paris, France, volume 135 of IFIP Conference Proceedings, pages 439a456.
Kluwer, 1998.
[25] K. G. Larsen, P. Pettersson, and W. Yi.
UPPAAL in a nutshell.
International Journal on Software Tools for Technology Transfer (STTT), 1(1-2):134a152, 1997.
[26] J. Leroux and G. Point.
The GENEPI Framework, 2006. http://altarica.labri.fr/wiki/tools:tapas:genepi.
[27] M. Presburger.
On the completeness of a certain system of arithmetic of whole numbers in which addition occurs as the only operation.
Hist.
Philos.
Logic, 12(2):225a233, 1991.
Translated from the German and with commentaries by Dale Jacquette.
[28] A. Tarski.
A problem concerning the notion of definability.
J. Symb.
Log., 13(2):107a111, 1948.
[29] V. Weispfenning.
Mixed real-integer linear quantifier elimination.
In Symbolic and Algebraic Computation, International Symposium, ISSACa99, Vancouver BC, Canada, July 28-31, 1999, Proceedings, pages 129a136.
ACM, 1999.
CAV 2003, Boulder, CO, USA, July 8-12, 2003, Proceedings, volume 2725 of Lecture Notes in Computer Science, pages 118a121.
Springer, 2003.
S. Bardin, J. Leroux, and G. Point.
FAST extended release.
In Computer Aided Verification, 18th International Conference, CAV 2006, Seattle, WA, USA, August 17-20, 2006, Proceedings, volume 4144 of Lecture Notes in Computer Science, pages 63a66.
Springer, 2006.
B. Becker, C. Dax, J. Eisinger, and F. Klaedtke.
LIRA: Handling constraints of linear arithmetics over the integers and the reals.
In Computer Aided Verification, 19th International Conference, CAV 2007, Berlin, Germany, July 3-7, 2007, Proceedings, volume 4590 of Lecture Notes in Computer Science, pages 307a310.
Springer, 2007.
G. Behrmann, P. Bouyer, E. Fleury, and K. G. Larsen.
Static guard analysis in timed automata verification.
In Tools and Algorithms for the Construction and Analysis of Systems, 9th International Conference, TACAS 2003, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2003, Warsaw, Poland, April 7-11, 2003, Proceedings, volume 2619 of Lecture Notes in Computer Science, pages 254a277.
Springer, 2003.
G. Behrmann, P. Bouyer, and K. G. Larsen.
Lower and upper bounds in zone-based abstractions of timed automata.
International Journal on Software Tools for Technology Transfer (STTT), 8(3):204a215, 2006.
J. Bengtsson, K. G. Larsen, F. Larsson, P. Pettersson, and W. Yi.
UPPAAL - a tool suite for automatic verification of real-time systems.
In Hybrid Systems III: Verification and Control, Proceedings of the DIMACS/SYCON Workshop, October 22-25, 1995, Ruttgers University, New Brunswick, NJ, USA, volume 1066 of Lecture Notes in Computer Science, pages 232a243.
Springer, 1995.
B. Berthomieu and M. Menasche.
An enumerative approach for analyzing time Petri nets.
In Information Processing, 9th World Computer Congress, IFIPa83, Paris, France, September 19-23, 1983, Proceedings, pages 41a46.
NorthHolland/IFIP, 1983.
B. Boigelot, L. Bronne, and S. Rassart.
An improved reachability analysis method for strongly linear hybrid systems (extended abstract).
In Computer Aided Verification, 9th International Conference, CAV a97, Haifa, Israel, June 22-25, 1997, Proceedings, volume 1254 of Lecture Notes in Computer Science, pages 167a178.
Springer, 1997.
B. Boigelot, S. Jodogne, and P. Wolper.
On the use of weak automata for deciding linear arithmetic with integer and real variables.
In Automated Reasoning, First International Joint Conference, IJCAR 2001, Siena, Italy, June 18-23, 2001, Proceedings, volume 2083 of Lecture Notes in Computer Science, pages 611a625.
Springer, 2001.
B. Boigelot, S. Jodogne, and P. Wolper.
An effective decision procedure for linear arithmetic over the integers and reals.
ACM Trans.
Comput.
Log., 6(3):614a633, 2005.
B. Boigelot, S. Rassart, and P. Wolper.
On the expressiveness of real and integer arithmetic automata (extended abstract).
In Automata, Languages and Programming, 25th International Colloquium, ICALPa98, Aalborg, Denmark, July 13-17, 1998, Proceedings, volume 1443 of Lecture Notes in Computer Science, pages 152a163.
Springer, 1998.
9