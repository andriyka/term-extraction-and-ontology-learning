A temporal-logic extension of role-based access control covering dynamic separation of duties Till Mossakowski BISS, Dept.
of Computer Science University of Bremen P.O.
Box 330 440, 28334 Bremen, Germany till@tzi.de  Michael Drouineaud BISS, Dept.
of Computer Science University of Bremen P.O.
Box 330 440, 28334 Bremen, Germany mdruid@tzi.de  Karsten Sohr BISS, Dept.
of Computer Science University of Bremen P.O.
Box 330 440, 28334 Bremen, Germany sohr@tzi.de  Abstract Security policies play an important role in todayas computer systems.
We show some severe limitations of the widespread standard role-based access control (RBAC) model, namely that object-based dynamic separation of duty as introduced by Nash and Poland cannot be expressed with it.
We suggest to overcome these limitations by extending the RBAC model with an execution history.
The natural next step is then to add temporal logic for the specification of execution orders.
We show that with this, object-based dynamic separation of duty, as well as other policies, can be adequately specified.
1.
The RBAC model/Separation of duty Role-based access control (RBAC) [18, 1, 2, 9] has received considerable attention as a promising alternative to traditional discretionary and mandatory access control.
Moreover, an extensive field study by the National Institute of Standards and Technology (NIST) pointed out that in practice permissions are assigned to users according to their roles/functions in the organization [8].
The explicit representation of roles greatly simplifies the security management and makes possible to use security principles like separation of duty and least privilege [18].
In the following, we give an overview of RBAC96, a widespread RBAC  model introduced by Sandhu et al.
[18].
In Figures 1 and 2 the entity sets of RBAC96 and the relationships between them are shown.
A further important concept of the advanced RBAC96 models are constraints on the relations assigned to, auth, active in, etc.
With help of these constraints, separation of duty (SOD) can be enforced.
SOD is a well-known principle that prevents fraud and error by requiring that at least two persons are required to complete a task.
SOD is often applied in everyday life, e.g., a paper submitted to a conference typically is required to be reviewed by three referees who must be different from the author.
There are several attempts to express SOD constraints in the computer security world, specifically in the area of banking like the ClarkWilson model [6] or Sandhuas Transaction Control Expressions [17].
Usually, it can be differentiated between static and dynamic SOD.
Static SOD means that a user is not permitted to perform certain steps of a task.
By contrast, in dynamic SOD a user may carry out those steps, but only if he has not done/does not certain other steps of the task.
Thus, dynamic SOD is more flexible than static SOD and hence better satisfies real-world requirements.
Usually, RBAC is expressed in set-theoretic notation.
When using formal methods, one needs to express RBAC in some definite formalism (like the Z formalism used in [5]).
We here formalize RBAC in many-sorted first-order logic, which also is a well-studied and tool-supported formalism [14].
In the specification given in Fig.
3, the axiom states that a session may activate a role only if its user is assigned to the role.
Permissions auth  assigned_to Roles  Users  Operations        user     .
.
active_in Constraints  .
  fi  fi  Sessions  Figure 1.
The components of RBAC96  Our name Users Sessions Roles Operations Objects user auth assigned to active in  [10] Users Subjects Roles Operations Objects subject user auth role members subject roles  [9], [1] Users Sessions Roles Operations Objects user PA UA roles  Meaning human being or an autonomous agent entities through which a user acts job function or job title (permitted or non-permitted) actions on objects passive entities unique user of a session authorization of roles (to execute operations) static assignment between users and roles dynamic activation of roles in sessions  Figure 2.
Table of terminology.
2  Objects  spec RBAC = sorts fifi 	 fi $%fifi'&(	*)+fifi-, op preds .0/-12 3 &4fifi657*- ,  supervisor to handle the verification of the details of a particularly complex invoice.
What never happens is that the same purchasing officer verifies an invoice that he entered into the system, or the same supervisor who verifies an invoice is permitted to authorize payment against it.
!fi"fi#  $(98:&;*<=5>fi?5@ !fi"fi#, "fiBA. B &*-=5C	1 -D, forall '& ,E=&(	 F '" BA. B:*GH$%fifi(I3KJL.0/-12 M'  Now [18, 2, 9, 16] claim that RBAC covers dynamic separation of duties.
[1] cites [15] when formulating his security policies using RBAC, but for the object-based case (which is needed here), he only covers static SOD.
[7] even explicitly introduces an example like the above one, with a formalization using RBAC.
However, the latter is inadequate since too static.
Indeed, an important observation not having been made in the literature so far is the following:  end Figure 3.
RBAC, formalized within first-order logic.
2.
Limitations of the RBAC model Practical applications of RBAC often need dynamic SOD, see Simon and Zurko [19, 20] and Nash and Poland [15].
We cite an example of a purchasing department which processes invoices for received goods from [15]:  Claim For the Nash and Poland example, dynamic separation of duties cannot be expressed in the standard RBAC model.
This is even not possible if the role structure may be refined, as long as the number of roles is smaller than the number of permissions (a practical reasonable assumption).
Let us assume that there are three types of transaction involved in processing an invoice: 1.
Recording the arrival of an invoice and the information recorded on it;  The claim can be seen as follows.
We refer to the above practical example, assuming that there are three operations (enter, verify, authorize) and three roles (clerk, officer, supervisor), such that the clerk role is authorized to execute the enter operation on any object, while the officer (resp.
supervisor) role additionally is authorized to execute the verify (resp.
verify and authorize) operations.
Hence, supervisors are authorized to execute (potentially) any operation on any object.
The intended security policy is: No user should be authorized to execute actually more than one operation on a given object.
Now since authorization is connected to roles, not users, and roles can be activated in sessions, this has to be rephrased as: no user should activate roles NO-PNKQ in sessions R-O.RKQ such that NO and NKQ can execute two distinct operations on some object.
This is formalized as  2.
Verifying that the goods in question have been received and that the details of price etc.
match those agreed with the supplier; 3.
Authorizing the payment of the supplier.
We can also postulate three distinct types of user: 1.
Data entry clerks, who enter the information on invoices into the system; 2.
Purchasing officers, who verify the validity of invoices; 3.
Supervisors, who authorize payments.
S4T N O PN Q &U6VWXR,4R O R Q &;Y4XR.R[Z3V.\R, V]O.V]^Q6&;_`]aXKN.b;c3Z3V.\R,dV-egfh&;_=egf;XKi cPRdj V]1Olm k V]^QonpN.Oob%ic3ZMq;X ZM\rROsnpN[QEb%ic3ZMq;X ZM\rR[Q nrtRKXKN%IRO J m t1RKXKN(I#RKQKJ npb;tacPuIN.OV]1O-V-ePf;Jnvb;tacPuIN[Q-V]^QV-egf%J  If we allocate fixed users to fixed types of transaction, then data entry clerks, and only data entry clerks, can record the arrival of invoices; purchasing officers, and only purchasing officers, can perform verification transactions; and supervisors, and only supervisors, can authorize payments.
(.
.
. )
This is not what usually happens in the real world.
But for the above example, this means that no user could ever activate the supervisor role in a session R , since this role (taken for both NO and N[Q ) would authorize him to execute all three possible operations (taking R m RO m RKQ ).
Now assume that the role structure is refined somehow.
Let t be some supervisor user.
Since t is free to execute (potentially, not actually) any operation on any object, for each object V-egf , there must be three roles Nwx9yz {3|-}{3~ ,  Although some roles are restricted to certain transactions (for example, a data entry clerk is never permitted to authorize payments), it would be normal for an otherwise unoccupied purchasing officer to enter details of invoices if there is a backlog of unprocessed incoming paper, or for a 3  NKwxByz  {3~fi and N.wx9yz 	K} Kw~{ , being assigned to t and authorized to execute the three operations.
Since the number of roles is smaller than the number of permissions, there must be IV-ePf O V] O J m k IV-egf Q V] Q J with N wx9yz w m N wxBy z w .
If V-egf O m V-ePf Q , then V] O m k V] Q , and t may execute two distinct operations on V-egf O m V-egf Q .
If V-egf O m k V-egf Q , choose V] with V] m k V] O .
Now t is free to execute (actually, not only potentially) V]  on V-egfO and V]^Q on V-ePfKQ , and therefore may activate both Nwx9y  z w and NKwx9y  z w  .
But since the latter is equal to Nwx9y  z w  , t may execute both V]  and V]O on V-egfO .
Hence, in both cases, the security policy is violated.
The deeper insight is that the concept of session, while introducing a certain degree of dynamics (opposed to a formulation using the entirely static b(RKR[Z%\ X cgV predicate), is still too weak to express the distinction between the potential to execute an operation and the fact that an operation is actually executed.
Indeed, some further dynamic concept (beyond the notion of session) is needed to model the latter.
In fact, [17] stresses the importance of history.
Gligor et al.
[10] take this point seriously and formalize history via traces of states, but end up with rather complex formulas explicitly talking about states.
[4] also introduce temporal aspects into RBAC.
Their model has considerably complexity, because it talks about various forms of time intervals and about events triggering the activation of roles.
While this is an important topic, our main topic, namely separation of duties, is not treated explicitly.
spec E XTENDED RBAC = RBAC then pred %" &(	1 -D?5> Dfi?5@ !fi" # forall  &>	,  &   -#-D, !H&  F   !fi" # %"IgK .!
;JLG T '&;*<dj '" BA Bp n -$(B8Ig%K .!
;J  end Figure 4.
Extended RBAC, formalized within first-order logic.
3.
Extended RBAC spec R ICH RBAC = RBAC then & ?5 preds "fiBA.  -  We now introduce extended RBAC as a rather simple, first-order based extension of the RBAC model that allows expressing realistic dynamic separation of duties policies.
Surprisingly, this can be done without introducing a notion of state.
We overcome the abovementioned limitations of RBAC by adding, besides the sessions, a further dynamic component tracking the actually executed operations.
Extended RBAC will thus allow a correct specification of dynamic separation of duties while still being as concise as RBAC (and thus avoiding the complexity of the formalization in [10]).
The new component of extended RBAC is the predicate XaX.i tracing the operations performed: X^X.i-I#RV]V-ePf;J means that session R executes (or has executed, or will execute) operation V] on object V-egf .
Of course, since FOL is a static logic, the X^X.i predicate does not depend on time, but it just collects all the executions performed during a session.
(Temporal aspects will be covered in Section 5 below).
The axiom states that a session R may execute an operation (on an object) only if some role N that is authorized to perform the operation is active in R .
Fig.
5 contains definitions of some derived notions that  fi ,  %" &4fifi65> Dfi-#-D?5> !fi" # forall '&%*-,`$:&ofi ,  &   -#-D,*9!r&  9!fi"fi F =" BA  =!
$ T =&(	dj $%fi (I3.J m $ n`'"fi#BA Bv F  %"IP$ K .!
;" J T =&(	dj $%fi (I3.J m $ n  %"I3. .!
;J  end Figure 5.
Derived predicates for extended RBAC.
4  will lead to more succinct formulations of security policies in some cases.
If needed, the derived notions can be eliminated by replacing them with their definitions.
Object-based Dynamic Separation of Duty (ObjDSoD) For a given object, a user may perform at most one operation on it.
Note that while the policies discussed so far can also be formalized in ordinary RBAC, the present policy cannot: it inherently needs the execution predicate (cf.
the discussion in section 2).
4.
Separation of duty in extended RBAC We now specify a bunch of security policies, following the formalizations in [1] and [10].
We overcome the problems of [1] who uses ordinary RBAC and thus fails to specify truly dynamic RBAC (as argued above).
While the formalizations in [10] do not have this problem, they add considerable complexity since they explicitly talk about states and execution history.
We here remain in a stateless world, but still can capture most of the policies of [10] quite adequately.
Still, states may be needed when the order of execution is important.
This will be subject of Section 5.
We follow [10] in relativizing all the security policies w.r.t.
a given set U6VWXY4XKc of roles (regarded as conflicting roles), and given sets _`]aY4XKc and _=egf%Y4XKc of operations and objects, resp.
We freely will use these as sorts for variables.
This can be understood as syntactic sugar for membership in a predicate on the sorts U VW#XR , _`]^XKNb;c3Z3V.\R or _=egf;X.icPR , respectively.
An alternative (though more complicated) way is to use subsorts, e.g.
as in CASL [3].
fi _=egfrY4V 	  t7&=RKXKN-R,dV]V]&_`]1Y4XKc,dV-egfh&_=ePfX.ic1j V] m k V];nrX ^X.i-It V]V-egf%JdG S X aXKiI9t V]#V-ePf;J This also is the policy needed for the invoice example mentioned in section 2.
Operational Dynamic Separation of Duty (OpDSoD) The roles active for (and not just assigned to) a user are not allowed to perform all the operations of _`]aYdX[c (if more than one), regardless of the target object.
Again, we have found a first-order equivalent to the second-order description in [10].
 U6_`]1YdY4V 	 T I   V] O V] Q &_`]aY4XKc1jDV] O m k V] Q JoG t7& ?R[XKN-Roj T V]7&_`]1Y4XKcaj Nl&U6VWXY4XKc,4V-egfh&;_=egf%Y4XKcaj S I9Nb;i c3Zq%X 1V.N t'nvbtacPu I9NV] V-egf%JJ  Static Separation of Duties (SSoD) At most one conflicting role can be assigned to a given user.
fi YdY4V 	  N.OPNKQ=&*- 	1fi,4t 4 & fifi4jDN.Olm k N[Q*G S Ithb%R.R[Z ;\ X  gc V N.O4npt b(RKR[Z%\ X cgV N[Q.J  History-Based Dynamic Separation of Duty (HDSoD) One and the same user cannot perform all the operations in _`]1Y4XKc on the same object of _=ePf;YdX[c .
This is another policy that cannot be expressed in RBAC without the execution predicate.
It is also possible to express this equivalently in a positive way:   YdY4V 	  N.OPN[Q6&%*-	 ,4t &4fifisj t b%R.R[Z ;\ X  cgV N.Odnrthb(RKR[Z%\ X cgV N[QG N.O m N[Q   rY4V 	 T I   V] O V] Q &;_`]aY4XKc1jDV] O m k V] Q JoG t7&=RKXKN-R,4Nl&U6VW#X.YdX[c,sV-egf &_=egf%Y4XKc1j T V]7&_`]1Y4XKcaj S X aXKiI9t V]V-egf%J  Nevertheless, in the sequel we will stick to the negative way, since this conforms with [10].
5.
Temporal-logic RBAC  Simple Dynamic Separation of Duties (SDSoD) Two distinct conflicting roles cannot be activated for one and the same user (although they can be assigned to one and the same user).
The approach of the previous section has two shortcomings.
Firstly, it is not possible to talk about the order of executions.
For example, a supervisor should authorize payment only after the invoice has been entered and verified.
Secondly, separation of duties is only formulated in terms of actual executions, but not in terms of authorization.
That is, actual execution of operations is not only constrained by authorization, but also by the security policy.
The approach   rY4V 	  N.O.N[Q6&%*<	 ,4t & =RKX[N-Roj(N.Olm k N[Q*G S I9NOLb;i c3Zq%X 1 V.N tlnrN[QEb%ic3ZMq;X 1V.N t1J 5  in [10] has the same drawback.
We propose instead to let the policy influence the authorization directly, and the actual execution only indirectly via the authorization.
We now introduce temporal RBAC as a formalism that combines RBAC with states.
This allows for talking about things such as the execution history or order of executions, as in [10], while still being much simpler than [10].
Temporal-logic RBAC is based on temporal first-order logic, a logic that has been intensively studied in the literature [12, 13] and comes with standard tools, e.g.
[11].
A temporal first-order signature consists of a set of sorts, a set of function symbols and a set of predicate symbols (each symbol coming with a string of argument sorts and, for function symbols, a result sort).
Function and predicate symbols are partitioned into rigid and flexible symbols: the former do not change over time, while the latter may vary.
Models live over discrete time, indexed by the natural numbers as time steps.
They interpret the sorts with (time-independent) carrier sets, rigid function and predicate symbols with time-independent functions and predicates of appropriate types, and flexible function and predicate symbols with families of functions and predicates, where the families are indexed by natural numbers.
Sentences are the usual first-order sentences built from equations, predicate applications and logical connectives   and quantifiers , T .
Additionally, we have the modalities (always in the future),  (sometimes in the future) and  (in the next step).
The corresponding past modalities are  - ,  - and - .
Satisfaction is defined inductively for a given time step, where the modalities allow referring to other time steps.
A sentence is satisfied in a model if it is satisfied in the time step zero.
In Fig.
6, we extend the specification of Fig.
3 to the temporal case.
The function t1RKXKN and the static predicate btacPu (applicable to roles) are rigid (i.e.
do not depend on the state), while the dynamic predicate btacPu (applicable to users), as well as the predicates b%ic3ZMq%X ZM\ and XaXKi are flexible (i.e.
do depend on the state).
Hence, XaX.i now traces the operations performed: XaX.i-I#RV] V-egf%J means that session R executes operation V] on object V-egf in the present (implicit) state.
The flexible btacPu for users expresses which operation the user is authorized to perform; indeed, this depends both on the static authorizations of the useras roles as well as on dynamic security policies such as SOD.
The axioms of the specification constrain the user behaviour as expressed by the predicates b%ic3ZMq%X ZM\ and XaXKi : their holding must imply the holding of appropriate role assignment and authorization predicates.
Also, the flexible authorization predicate b;tacPu is constrained, and it is expected that domain-specific security policies like SOD, when added to the specification, constrain b;tacPu even further (cf.
the next section).
Once this is done, it might be useful to add a non-monotonic aclosed world assumptiona stating that  spec T EMPORAL RBAC = sorts fi -fi	1 -D*< Dfi !fi" # rigid op $% fi'&D	1 -D) fifi, rigid pred $(98v& ?5@  D=5> 9!fi"fi flexible preds .0/-12 M &ofifi657*- ,  -$(B87&4fifi65> Dfi-#-D=5@ !fi" #, " BA. B &;*- 65C	1 D,  %"=&(	1 -D=5>fi?5@ !fi"fi# forall '&%*-,L=&(	,  &   -#-D,*9!r&  9!fi"fi F IPIh6" BA B:KJdG $%fifi(I3KJL.0/-12 M'-J F I$(98Ig$ . .!
;JEG T =&(	1 D, '& dj $%fi (IgKJ m $ n`'"fiBA. BvLn $(98 IP;.sK!
;JJ F I ;"I3.sK!
;J`G -$(B8Ig$%fifi(I3KJ KsK9!%JPJ  end spec R ICH T EMPORAL RBAC = T EMPORAL RBAC then flexible preds "fi#BA   & =5  fi, forall  F F   %"=&4fifi65> Dfi-#-D?5> !fi" # '&%*-,`$:&ofi ,  &   -#-D,*9!r&  9!fi"fi Ig?"fi#BA  '$ T  &	1 -Ddj$%fi (IgKJ m $ nC'" BA. BvKJ I ;"Ig$ .sK!
;J T 6&D	1 -Ddj $%fifi%IgKJ m $ n  %"IgK K9!%JPJ  end Figure 6.
Temporal-logic RBAC, formalized within temporal first-order logic.
6  btacPu holds as much as possible without sacrificing the con-  spec I NVOICE = T EMPORAL RBAC then rigid ops fis  "fi% 	a$KDfiA[ fi-  &;*<, fi 3 %[A.fi .$(98D 	K &   D forall $:&d  fi, ^Kr&   -#-D, B^A.-"l&  !fi"  F $(98 I fi <  Kfi3 %fiB^A.-"KJ F $(98 Ifi  " %. ^Mfi%fiBA".J F $(98 Ig	^$K AK fi%Kfi3 %[BA".J F $(98 Ifi  " %[A.fi [BA".J F $(98 Ig	^$K AK fi%fiA  ^fiB^A.-".J F $(98 Ig	^$K AK fi%K-$(B8  	KfiBA".J F I  m k   n  %"Ig$K  [BA".J S $(98Ig$ .  fiB^A.-"KJJ G F I$(98Ig$ [A.fi [BA".J G  T =&(	dj -  -  ;"I3. ^Mfi%fiB^A.-".JJ F I$(98Ig$ .$(98D  	KfiB^A.-"KJ G  T =&(	dj -  -  ;"I3[A.fi [BA".JPJ  straints.
While this in general would go beyond temporal first-order logic, for specific policies, it does not.
6.
Separation of duty in Temporal-logic RBAC We can now reformulate some security policies from Section 4 for the state-based case.
Besides inserting the appropriate temporal modalities, we also have replaced XaX.i with b;t^cPu at several places.
Dynamic Separation of Duties (DSoD)   rY4V 	  NOKPNKQ=&*- 	1fi ,4t7&=RKXKN-RdjDNOlm k NKQG S I9N.Oob%ic3ZMq;X 1V.N tlnpNKQLb%ic3ZMq%X 1V.N tJ  Object-based Dynamic Separation of Duty (ObjDSoD) We now can reformulate Object-based Dynamic Separation of Duty (ObjDSoD) in terms of authorization, not just execution:  end   _=egfrY4V 	  t7&=RKXKN-R,dV] V]  &_`]aYdX[c,dV-ePfh&_=egf;X.ic1j IV] m k V];npXaXKiI9t V]V-egf%J4G S b;tacPuIt V]9V-egf%JPJ  Figure 7.
The invoice example with execution orders specified.
Operational Dynamic Separation of Duty (OpDSoD)  fi U=_`]aYdYdV 	 T I   V]OV]^Q6&_`]1Y4XKcaj^V]1O'm k V]aQKJdG t:&  =RKXKNRoj T V]7&;_`]aY4XKc1j N'&U6VWXY4XKc,4V-egf &%_=egf%Y4XKc1j S I9N*b%ic3ZMq%X 1V.N tlnvb;tacPuINV]V-egf%JPJ  8.
Conclusion  We have argued that the standard formalisms for rolebased access control (RBAC) are not adequate to express realistic dynamic separation of duty (SOD) policies.
The formalisms proposed in the literature [10] that can handle this properly add considerable complexity to the RBAC model.
We have shown how to eat the cake and have it, too: with a rather simple extension, many realistic SOD policies can be expressed.
In a first step, we have added an execution predicate to the RBAC model.
This uses standard many-sorted first-order logic as background formalism, easing the formal verification of systems using standard tools.
However, for realistic practical examples, often the order of executions is crucial.
Here, temporal logic can be used.
We show how to formulate dynamic separation of duties with temporal logic and illustrate this with an example coming from a standard practical application.
We claim that our formalization is the first one that is both adequate to the problem domain and simple in the technical details.
History-Based Dynamic Separation of Duty (HDSoD)    rY4V 	   I t7&?R[XK  N-R,dV-egfh&;_=egf%Y4XKc,sV] &_`]aY4XKc1j IvI V]&_`]1Y4XKcajDV]4m k V]vG - X aX.i-I9t V]9V-ePf;JJ G S b;tacPuIt V]V-egf%JpJ  7.
The Nash and Poland Example in Temporallogic RBAC The invoice example can now be refined such that a certain order of execution of the operations is imposed (cf.
Fig.
7).
The axioms state that a A   operation can only happen after an XK\cgXKN operation, and an b;t^cPu^V.N.Z;X operation can only happen after a A   operation.
Thus we have enforced ObjDSoD and the consecutive execution of the given operations in the desired chronological order (enter, verify, authorize) by the means of our logic.
From this example we see that sometimes the greater expressiveness of temporallogic RBAC is needed.
This simplicity should also ease the use of standard tools, as e.g.
the Stanford Temporal Prover STeP ([11]).
We intend to use this tool for a task that surprisingly has not been tackled so far to our knowledge: the verification of algorithms against dynamic separation of duty security policies.
7  References  [17] R. Sandhu.
Transaction control expressions for separation of duties.
Fourth Aerospace Computer Security Applications Conference, Orlando, pages 282a286, 1988.
[18] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman.
Role-based access control models.
Computer, 29(2):38a47, Feb. 1996.
[19] R. Simon and M. Zurko.
Separation of duty in role-based environments.
In 10th IEEE Computer Security Foundations Workshop (CSFW a97), pages 183a194, Washington - Brussels - Tokyo, June 1997.
IEEE.
[20] M. E. Zurko, R. Simon, and T. Sanfilippo.
A user-centered, modular authorization service built on an RBAC foundation.
In Proceedings of the IEEE Symposium on Research in Security and Privacy, pages 57a71, Oakland, CA, May 1999.
IEEE Computer Society, Technical Committee on Security and Privacy, IEEE Computer Society Press.
[1] G.-J.
Ahn.
The RCL 2000 language for specifying rolebased authorization constraints.
PhD thesis, George Mason University, Fairfax, Virginia, 1999.
[2] G.-J.
Ahn and R. Sandhu.
Role-based authorization constraints specification.
ACM Transactions on Information and System Security, 3(4):207a226, Nov. 2000.
[3] E. Astesiano, M. Bidoit, H. Kirchner, B. Krieg-BruEckner, P. D. Mosses, D. Sannella, and A. Tarlecki.
C ASL: the Common Algebraic Specification Language.
Theoret.
Comput.
Sci., 286:153a196, 2002.
[4] E. Bertino, P. A. Bonatti, and E. Ferrari.
TRBAC: A temporal role-based access control model.
ACM Transactions on Information and System Security, 4(3):191a223, Aug. 2001.
[5] A. D. Brucker, F. Rittinger, and B. Wolff.
The CVSserver case study: A formalized security architecture.
In D. Haneberg, G. Schellhorn, and W. Reif, editors, FMTOOLS 2002, number 2002a11 in Technical Report, pages 47a52.
Augsburg, July 2002.
[6] D. D. Clark and D. R. Wilson.
A comparison of commercial and military computer security policies.
Proceedings of the 1987 IEEE Symposium on Security and Privacy, pages 184a 194, 1987.
[7] C. Eckert.
IT-Sicherheit: Konzepte, Verfahren, Protokolle.
R. Oldenbourg Verlag, 2001.
[8] D. Ferraiolo, D. Gilbert, and N. Lynch.
An examination of federal and commercial access control policy needs.
In Proc.
of the NIST-NCSC Nat.
(U.S.) Comp.
Security Conference, pages 107a116, 1993.
[9] D. F. Ferraiolo, R. Sandhu, S. Gavrila, D. R. Kuhn, and R. Chandramoli.
Proposed NIST standard for role-based access control.
ACM Transactions on Information and System Security, 4(3):224a274, 2001.
[10] V. D. Gligor, S. I. Gavrila, and D. Ferraiolo.
On the formal definition of separation-of-duty policies and their composition.
In 1998 IEEE Symposium on Security and Privacy (SSP a98), pages 172a185, Washington - Brussels - Tokyo, May 1998.
IEEE.
[11] Z.
Manna, N. BjA,rner, A. Browne, E. Chang, M. ColoEn, L. de Alfaro, H. Devarajan, A. Kapur, J. Lee, H. Sipma, and T. E. Uribe.
STeP: The stanford temporal prover.
In P. D. Mosses, M. Nielsen, and M. I. Schwartzbach, editors, TAPSOFT a95: Theory and Practice of Software Development, volume 915 of Lecture Notes in Computer Science, pages 793a794.
Springer-Verlag, 1995.
[12] Z.
Manna and A. Pnueli.
The Temporal Logic of Reactive and Concurrent Systems, Specification.
Springer-Verlag, 1992.
[13] Z.
Manna and A. Pnueli.
Temporal Verification of Reactive Systems: Safety.
Springer-Verlag, New York, 1995.
[14] K. Meinke and J. V. T.
(eds.).
Many-sorted logic and its applications.
Wiley, Chichester, 1993.
[15] M. J. Nash and K. R. Poland.
Some conundrums concerning separation of duty.
In Proc.
IEEE Symposium on Research in Security and Privacy, pages 201a207, 1990.
[16] M. Nyanchama and S. Osborn.
The role graph model and conflict of interest.
ACM Transactions on Information and System Security, 2(1):3a33, Feb. 1999.
8